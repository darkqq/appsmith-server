{"code":"import { parse } from \"acorn\";\r\nimport { ancestor, simple } from \"acorn-walk\";\r\nimport { ECMA_VERSION, NodeTypes } from \"./constants/ast\";\r\nimport { has, isFinite, isString, memoize, toPath } from \"lodash\";\r\nimport { isTrueObject, sanitizeScript } from \"./utils\";\r\nimport { jsObjectDeclaration } from \"./jsObject/index\";\r\n/* We need these functions to typescript casts the nodes with the correct types */\r\nexport const isIdentifierNode = (node) => {\r\n    return node.type === NodeTypes.Identifier;\r\n};\r\nconst isMemberExpressionNode = (node) => {\r\n    return node.type === NodeTypes.MemberExpression;\r\n};\r\nexport const isVariableDeclarator = (node) => {\r\n    return node.type === NodeTypes.VariableDeclarator;\r\n};\r\nconst isFunctionDeclaration = (node) => {\r\n    return node.type === NodeTypes.FunctionDeclaration;\r\n};\r\nconst isFunctionExpression = (node) => {\r\n    return node.type === NodeTypes.FunctionExpression;\r\n};\r\nconst isArrowFunctionExpression = (node) => {\r\n    return node.type === NodeTypes.ArrowFunctionExpression;\r\n};\r\nexport const isObjectExpression = (node) => {\r\n    return node.type === NodeTypes.ObjectExpression;\r\n};\r\nconst isAssignmentPatternNode = (node) => {\r\n    return node.type === NodeTypes.AssignmentPattern;\r\n};\r\nexport const isLiteralNode = (node) => {\r\n    return node.type === NodeTypes.Literal;\r\n};\r\nexport const isPropertyNode = (node) => {\r\n    return node.type === NodeTypes.Property;\r\n};\r\nexport const isPropertyAFunctionNode = (node) => {\r\n    return (node.type === NodeTypes.ArrowFunctionExpression ||\r\n        node.type === NodeTypes.FunctionExpression);\r\n};\r\nconst isArrayAccessorNode = (node) => {\r\n    return (isMemberExpressionNode(node) &&\r\n        node.computed &&\r\n        isLiteralNode(node.property) &&\r\n        isFinite(node.property.value));\r\n};\r\nconst wrapCode = (code) => {\r\n    return `\n    (function() {\n      return ${code}\n    })\n  `;\r\n};\r\n//Tech-debt: should upgrade this to better logic\r\n//Used slice for a quick resolve of critical bug\r\nconst unwrapCode = (code) => {\r\n    let unwrapedCode = code.slice(32);\r\n    return unwrapedCode.slice(0, -10);\r\n};\r\nconst getFunctionalParamNamesFromNode = (node) => {\r\n    return Array.from(getFunctionalParamsFromNode(node)).map((functionalParam) => functionalParam.paramName);\r\n};\r\n// Memoize the ast generation code to improve performance.\r\n// Since this will be used by both the server and the client, we want to prevent regeneration of ast\r\n// for the the same code snippet\r\nexport const getAST = memoize((code, options) => parse(code, Object.assign(Object.assign({}, options), { ecmaVersion: ECMA_VERSION })));\r\nexport const extractIdentifierInfoFromCode = (code, evaluationVersion, invalidIdentifiers) => {\r\n    let ast = { end: 0, start: 0, type: \"\" };\r\n    try {\r\n        const sanitizedScript = sanitizeScript(code, evaluationVersion);\r\n        /* wrapCode - Wrapping code in a function, since all code/script get wrapped with a function during evaluation.\r\n           Some syntax won't be valid unless they're at the RHS of a statement.\r\n           Since we're assigning all code/script to RHS during evaluation, we do the same here.\r\n           So that during ast parse, those errors are neglected.\r\n        */\r\n        /* e.g. IIFE without braces\r\n          function() { return 123; }() -> is invalid\r\n          let result = function() { return 123; }() -> is valid\r\n        */\r\n        const wrappedCode = wrapCode(sanitizedScript);\r\n        ast = getAST(wrappedCode);\r\n        let { references, functionalParams, variableDeclarations } = ancestorWalk(ast);\r\n        const referencesArr = Array.from(references).filter((reference) => {\r\n            // To remove references derived from declared variables and function params,\r\n            // We extract the topLevelIdentifier Eg. Api1.name => Api1\r\n            const topLevelIdentifier = toPath(reference)[0];\r\n            return !(functionalParams.has(topLevelIdentifier) ||\r\n                variableDeclarations.has(topLevelIdentifier) ||\r\n                has(invalidIdentifiers, topLevelIdentifier));\r\n        });\r\n        return {\r\n            references: referencesArr,\r\n            functionalParams: Array.from(functionalParams),\r\n            variables: Array.from(variableDeclarations),\r\n        };\r\n    }\r\n    catch (e) {\r\n        if (e instanceof SyntaxError) {\r\n            // Syntax error. Ignore and return empty list\r\n            return {\r\n                references: [],\r\n                functionalParams: [],\r\n                variables: [],\r\n            };\r\n        }\r\n        throw e;\r\n    }\r\n};\r\nexport const entityRefactorFromCode = (script, oldName, newName, isJSObject, evaluationVersion, invalidIdentifiers) => {\r\n    //Sanitizing leads to removal of special charater.\r\n    //Hence we are not sanatizing the script. Fix(#18492)\r\n    //If script is a JSObject then replace export default to decalartion.\r\n    if (isJSObject)\r\n        script = jsObjectToCode(script);\r\n    else\r\n        script = wrapCode(script);\r\n    let ast = { end: 0, start: 0, type: \"\" };\r\n    //Copy of script to refactor\r\n    let refactorScript = script;\r\n    //Difference in length of oldName and newName\r\n    const nameLengthDiff = newName.length - oldName.length;\r\n    //Offset index used for deciding location of oldName.\r\n    let refactorOffset = 0;\r\n    //Count of refactors on the script\r\n    let refactorCount = 0;\r\n    try {\r\n        ast = getAST(script);\r\n        let { references, functionalParams, variableDeclarations, identifierList, } = ancestorWalk(ast);\r\n        const identifierArray = Array.from(identifierList);\r\n        //To handle if oldName has property (\"JSObject.myfunc\")\r\n        const oldNameArr = oldName.split(\".\");\r\n        const referencesArr = Array.from(references).filter((reference) => {\r\n            // To remove references derived from declared variables and function params,\r\n            // We extract the topLevelIdentifier Eg. Api1.name => Api1\r\n            const topLevelIdentifier = toPath(reference)[0];\r\n            return !(functionalParams.has(topLevelIdentifier) ||\r\n                variableDeclarations.has(topLevelIdentifier) ||\r\n                has(invalidIdentifiers, topLevelIdentifier));\r\n        });\r\n        //Traverse through all identifiers in the script\r\n        identifierArray.forEach((identifier) => {\r\n            if (identifier.name === oldNameArr[0]) {\r\n                let index = 0;\r\n                while (index < referencesArr.length) {\r\n                    if (identifier.name === referencesArr[index].split(\".\")[0]) {\r\n                        //Replace the oldName by newName\r\n                        //Get start index from node and get subarray from index 0 till start\r\n                        //Append above with new name\r\n                        //Append substring from end index from the node till end of string\r\n                        //Offset variable is used to alter the position based on `refactorOffset`\r\n                        //In case of nested JS action get end postion fro the property.\r\n                        ///Default end index\r\n                        let endIndex = identifier.end;\r\n                        const propertyNode = identifier.property;\r\n                        //Flag variable : true if property should be updated\r\n                        //false if property should not be updated\r\n                        let propertyCondFlag = oldNameArr.length > 1 &&\r\n                            propertyNode &&\r\n                            oldNameArr[1] === propertyNode.name;\r\n                        //Condition to validate if Identifier || Property should be updated??\r\n                        if (oldNameArr.length === 1 || propertyCondFlag) {\r\n                            //Condition to extend end index in case of property match\r\n                            if (propertyCondFlag && propertyNode) {\r\n                                endIndex = propertyNode.end;\r\n                            }\r\n                            refactorScript =\r\n                                refactorScript.substring(0, identifier.start + refactorOffset) +\r\n                                    newName +\r\n                                    refactorScript.substring(endIndex + refactorOffset);\r\n                            refactorOffset += nameLengthDiff;\r\n                            ++refactorCount;\r\n                            //We are only looking for one match in refrence for the identifier name.\r\n                            break;\r\n                        }\r\n                    }\r\n                    index++;\r\n                }\r\n            }\r\n        });\r\n        //If script is a JSObject then revert decalartion to export default.\r\n        if (isJSObject)\r\n            refactorScript = jsCodeToObject(refactorScript);\r\n        else\r\n            refactorScript = unwrapCode(refactorScript);\r\n        return {\r\n            isSuccess: true,\r\n            body: { script: refactorScript, refactorCount },\r\n        };\r\n    }\r\n    catch (e) {\r\n        if (e instanceof SyntaxError) {\r\n            // Syntax error. Ignore and return empty list\r\n            return { isSuccess: false, body: { error: \"Syntax Error\" } };\r\n        }\r\n        throw e;\r\n    }\r\n};\r\nexport const getFunctionalParamsFromNode = (node, needValue = false) => {\r\n    const functionalParams = new Set();\r\n    node.params.forEach((paramNode) => {\r\n        if (isIdentifierNode(paramNode)) {\r\n            functionalParams.add({\r\n                paramName: paramNode.name,\r\n                defaultValue: undefined,\r\n            });\r\n        }\r\n        else if (isAssignmentPatternNode(paramNode)) {\r\n            if (isIdentifierNode(paramNode.left)) {\r\n                const paramName = paramNode.left.name;\r\n                if (!needValue) {\r\n                    functionalParams.add({ paramName, defaultValue: undefined });\r\n                }\r\n                else {\r\n                    // figure out how to get value of paramNode.right for each node type\r\n                    // currently we don't use params value, hence skipping it\r\n                    // functionalParams.add({\r\n                    //   defaultValue: paramNode.right.value,\r\n                    // });\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return functionalParams;\r\n};\r\nconst constructFinalMemberExpIdentifier = (node, child = \"\") => {\r\n    const propertyAccessor = getPropertyAccessor(node.property);\r\n    if (isIdentifierNode(node.object)) {\r\n        return `${node.object.name}${propertyAccessor}${child}`;\r\n    }\r\n    else {\r\n        const propertyAccessor = getPropertyAccessor(node.property);\r\n        const nestedChild = `${propertyAccessor}${child}`;\r\n        return constructFinalMemberExpIdentifier(node.object, nestedChild);\r\n    }\r\n};\r\nconst getPropertyAccessor = (propertyNode) => {\r\n    if (isIdentifierNode(propertyNode)) {\r\n        return `.${propertyNode.name}`;\r\n    }\r\n    else if (isLiteralNode(propertyNode) && isString(propertyNode.value)) {\r\n        // is string literal search a['b']\r\n        return `.${propertyNode.value}`;\r\n    }\r\n    else if (isLiteralNode(propertyNode) && isFinite(propertyNode.value)) {\r\n        // is array index search - a[9]\r\n        return `[${propertyNode.value}]`;\r\n    }\r\n};\r\nexport const isTypeOfFunction = (type) => {\r\n    return (type === NodeTypes.ArrowFunctionExpression ||\r\n        type === NodeTypes.FunctionExpression);\r\n};\r\n/** Function returns Invalid top-level member expressions from code\r\n * @param code\r\n * @param data\r\n * @param evaluationVersion\r\n * @returns information about all invalid property/method assessment in code\r\n * @example Given data {\r\n * JSObject1: {\r\n * name:\"JSObject\",\r\n * data:[]\r\n * },\r\n * Api1:{\r\n * name: \"Api1\",\r\n * data: []\r\n * }\r\n * },\r\n * For code {{Api1.name + JSObject.unknownProperty}}, function returns information about \"JSObject.unknownProperty\" node.\r\n */\r\nexport const extractInvalidTopLevelMemberExpressionsFromCode = (code, data, evaluationVersion) => {\r\n    const invalidTopLevelMemberExpressions = new Set();\r\n    const variableDeclarations = new Set();\r\n    let functionalParams = new Set();\r\n    let ast = { end: 0, start: 0, type: \"\" };\r\n    try {\r\n        const sanitizedScript = sanitizeScript(code, evaluationVersion);\r\n        const wrappedCode = wrapCode(sanitizedScript);\r\n        ast = getAST(wrappedCode, { locations: true });\r\n    }\r\n    catch (e) {\r\n        if (e instanceof SyntaxError) {\r\n            // Syntax error. Ignore and return empty list\r\n            return [];\r\n        }\r\n        throw e;\r\n    }\r\n    simple(ast, {\r\n        MemberExpression(node) {\r\n            const { object, property, computed } = node;\r\n            // We are only interested in top-level MemberExpression nodes\r\n            // Eg. for Api1.data.name, we are only interested in Api1.data\r\n            if (!isIdentifierNode(object))\r\n                return;\r\n            if (!(object.name in data) || !isTrueObject(data[object.name]))\r\n                return;\r\n            // For computed member expressions (assessed via [], eg. JSObject1[\"name\"] ),\r\n            // We are only interested in strings\r\n            if (isLiteralNode(property) &&\r\n                isString(property.value) &&\r\n                !(property.value in data[object.name])) {\r\n                invalidTopLevelMemberExpressions.add({\r\n                    object,\r\n                    property,\r\n                });\r\n            }\r\n            // We ignore computed member expressions if property is an identifier (JSObject[name])\r\n            // This is because we can't statically determine what the value of the identifier might be.\r\n            if (isIdentifierNode(property) &&\r\n                !computed &&\r\n                !(property.name in data[object.name])) {\r\n                invalidTopLevelMemberExpressions.add({\r\n                    object,\r\n                    property,\r\n                });\r\n            }\r\n        },\r\n        VariableDeclarator(node) {\r\n            if (isVariableDeclarator(node)) {\r\n                variableDeclarations.add(node.id.name);\r\n            }\r\n        },\r\n        FunctionDeclaration(node) {\r\n            if (!isFunctionDeclaration(node))\r\n                return;\r\n            functionalParams = new Set([\r\n                ...functionalParams,\r\n                ...getFunctionalParamNamesFromNode(node),\r\n            ]);\r\n        },\r\n        FunctionExpression(node) {\r\n            if (!isFunctionExpression(node))\r\n                return;\r\n            functionalParams = new Set([\r\n                ...functionalParams,\r\n                ...getFunctionalParamNamesFromNode(node),\r\n            ]);\r\n        },\r\n        ArrowFunctionExpression(node) {\r\n            if (!isArrowFunctionExpression(node))\r\n                return;\r\n            functionalParams = new Set([\r\n                ...functionalParams,\r\n                ...getFunctionalParamNamesFromNode(node),\r\n            ]);\r\n        },\r\n    });\r\n    const invalidTopLevelMemberExpressionsArray = Array.from(invalidTopLevelMemberExpressions).filter((MemberExpression) => {\r\n        return !(variableDeclarations.has(MemberExpression.object.name) ||\r\n            functionalParams.has(MemberExpression.object.name));\r\n    });\r\n    return invalidTopLevelMemberExpressionsArray;\r\n};\r\nconst ancestorWalk = (ast) => {\r\n    //List of all Identifier nodes with their property(if exists).\r\n    const identifierList = new Array();\r\n    // List of all references found\r\n    const references = new Set();\r\n    // List of variables declared within the script. All identifiers and member expressions derived from declared variables will be removed\r\n    const variableDeclarations = new Set();\r\n    // List of functional params declared within the script. All identifiers and member expressions derived from functional params will be removed\r\n    let functionalParams = new Set();\r\n    /*\r\n     * We do an ancestor walk on the AST in order to extract all references. For example, for member expressions and identifiers, we need to know\r\n     * what surrounds the identifier (its parent and ancestors), ancestor walk will give that information in the callback\r\n     * doc: https://github.com/acornjs/acorn/tree/master/acorn-walk\r\n     */\r\n    ancestor(ast, {\r\n        Identifier(node, ancestors) {\r\n            /*\r\n             * We are interested in identifiers. Due to the nature of AST, Identifier nodes can\r\n             * also be nested inside MemberExpressions. For deeply nested object references, there\r\n             * could be nesting of many MemberExpressions. To find the final reference, we will\r\n             * try to find the top level MemberExpression that does not have a MemberExpression parent.\r\n             * */\r\n            let candidateTopLevelNode = node;\r\n            let depth = ancestors.length - 2; // start \"depth\" with first parent\r\n            while (depth > 0) {\r\n                const parent = ancestors[depth];\r\n                if (isMemberExpressionNode(parent) &&\r\n                    /* Member expressions that are \"computed\" (with [ ] search)\r\n                       and the ones that have optional chaining ( a.b?.c )\r\n                       will be considered top level node.\r\n                       We will stop looking for further parents */\r\n                    /* \"computed\" exception - isArrayAccessorNode\r\n                       Member expressions that are array accessors with static index - [9]\r\n                       will not be considered top level.\r\n                       We will continue looking further. */\r\n                    (!parent.computed || isArrayAccessorNode(parent)) &&\r\n                    !parent.optional) {\r\n                    candidateTopLevelNode = parent;\r\n                    depth = depth - 1;\r\n                }\r\n                else {\r\n                    // Top level found\r\n                    break;\r\n                }\r\n            }\r\n            //If parent is a Member expression then attach property to the Node.\r\n            //else push Identifier Node.\r\n            const parentNode = ancestors[ancestors.length - 2];\r\n            if (isMemberExpressionNode(parentNode)) {\r\n                identifierList.push(Object.assign(Object.assign({}, node), { property: parentNode.property }));\r\n            }\r\n            else\r\n                identifierList.push(node);\r\n            if (isIdentifierNode(candidateTopLevelNode)) {\r\n                // If the node is an Identifier, just save that\r\n                references.add(candidateTopLevelNode.name);\r\n            }\r\n            else {\r\n                // For MemberExpression Nodes, we will construct a final reference string and then add\r\n                // it to the references list\r\n                const memberExpIdentifier = constructFinalMemberExpIdentifier(candidateTopLevelNode);\r\n                references.add(memberExpIdentifier);\r\n            }\r\n        },\r\n        VariableDeclarator(node) {\r\n            // keep a track of declared variables so they can be\r\n            // removed from the final list of references\r\n            if (isVariableDeclarator(node)) {\r\n                variableDeclarations.add(node.id.name);\r\n            }\r\n        },\r\n        FunctionDeclaration(node) {\r\n            // params in function declarations are also counted as references so we keep\r\n            // track of them and remove them from the final list of references\r\n            if (!isFunctionDeclaration(node))\r\n                return;\r\n            functionalParams = new Set([\r\n                ...functionalParams,\r\n                ...getFunctionalParamNamesFromNode(node),\r\n            ]);\r\n        },\r\n        FunctionExpression(node) {\r\n            // params in function expressions are also counted as references so we keep\r\n            // track of them and remove them from the final list of references\r\n            if (!isFunctionExpression(node))\r\n                return;\r\n            functionalParams = new Set([\r\n                ...functionalParams,\r\n                ...getFunctionalParamNamesFromNode(node),\r\n            ]);\r\n        },\r\n        ArrowFunctionExpression(node) {\r\n            // params in arrow function expressions are also counted as references so we keep\r\n            // track of them and remove them from the final list of references\r\n            if (!isArrowFunctionExpression(node))\r\n                return;\r\n            functionalParams = new Set([\r\n                ...functionalParams,\r\n                ...getFunctionalParamNamesFromNode(node),\r\n            ]);\r\n        },\r\n    });\r\n    return {\r\n        references,\r\n        functionalParams,\r\n        variableDeclarations,\r\n        identifierList,\r\n    };\r\n};\r\n//Replace export default by a variable declaration.\r\n//This is required for acorn to parse code into AST.\r\nconst jsObjectToCode = (script) => {\r\n    return script.replace(/export default/g, jsObjectDeclaration);\r\n};\r\n//Revert the string replacement from 'jsObjectToCode'.\r\n//variable declaration is replaced back by export default.\r\nconst jsCodeToObject = (script) => {\r\n    return script.replace(jsObjectDeclaration, \"export default\");\r\n};\r\n//# sourceMappingURL=index.js.map","references":["/home/ykrivoshei/IdeaProjects/appsmith-server/app/shared/ast/node_modules/acorn/dist/acorn.d.ts","/home/ykrivoshei/IdeaProjects/appsmith-server/app/shared/ast/node_modules/acorn-walk/dist/walk.d.ts","/home/ykrivoshei/IdeaProjects/appsmith-server/app/shared/ast/src/constants/ast.ts","/home/ykrivoshei/IdeaProjects/appsmith-server/app/shared/ast/node_modules/@types/lodash/index.d.ts","/home/ykrivoshei/IdeaProjects/appsmith-server/app/shared/ast/src/utils.ts","/home/ykrivoshei/IdeaProjects/appsmith-server/app/shared/ast/src/jsObject/index.ts"],"map":"{\"version\":3,\"file\":\"index.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/index.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/ykrivoshei/IdeaProjects/appsmith-server/app/shared/ast/build/src/index.d.ts","writeByteOrderMark":false,"text":"/// <reference types=\"lodash\" />\r\nimport { Node, SourceLocation, Options } from \"acorn\";\r\nimport { NodeTypes } from \"./constants/ast\";\r\ndeclare type Pattern = IdentifierNode | AssignmentPatternNode;\r\ndeclare type Expression = Node;\r\ninterface IdentifierNode extends Node {\r\n    type: NodeTypes.Identifier;\r\n    name: string;\r\n}\r\ninterface VariableDeclaratorNode extends Node {\r\n    type: NodeTypes.VariableDeclarator;\r\n    id: IdentifierNode;\r\n    init: Expression | null;\r\n}\r\ninterface Function extends Node {\r\n    id: IdentifierNode | null;\r\n    params: Pattern[];\r\n}\r\ninterface FunctionDeclarationNode extends Node, Function {\r\n    type: NodeTypes.FunctionDeclaration;\r\n}\r\ninterface FunctionExpressionNode extends Expression, Function {\r\n    type: NodeTypes.FunctionExpression;\r\n}\r\ninterface ArrowFunctionExpressionNode extends Expression, Function {\r\n    type: NodeTypes.ArrowFunctionExpression;\r\n}\r\nexport interface ObjectExpression extends Expression {\r\n    type: NodeTypes.ObjectExpression;\r\n    properties: Array<PropertyNode>;\r\n}\r\ninterface AssignmentPatternNode extends Node {\r\n    type: NodeTypes.AssignmentPattern;\r\n    left: Pattern;\r\n}\r\ninterface LiteralNode extends Node {\r\n    type: NodeTypes.Literal;\r\n    value: string | boolean | null | number | RegExp;\r\n}\r\nexport interface PropertyNode extends Node {\r\n    type: NodeTypes.Property;\r\n    key: LiteralNode | IdentifierNode;\r\n    value: Node;\r\n    kind: \"init\" | \"get\" | \"set\";\r\n}\r\ndeclare type NodeWithLocation<NodeType> = NodeType & {\r\n    loc: SourceLocation;\r\n};\r\ndeclare type AstOptions = Omit<Options, \"ecmaVersion\">;\r\ndeclare type EntityRefactorResponse = {\r\n    isSuccess: boolean;\r\n    body: {\r\n        script: string;\r\n        refactorCount: number;\r\n    } | {\r\n        error: string;\r\n    };\r\n};\r\nexport declare const isIdentifierNode: (node: Node) => node is IdentifierNode;\r\nexport declare const isVariableDeclarator: (node: Node) => node is VariableDeclaratorNode;\r\nexport declare const isObjectExpression: (node: Node) => node is ObjectExpression;\r\nexport declare const isLiteralNode: (node: Node) => node is LiteralNode;\r\nexport declare const isPropertyNode: (node: Node) => node is PropertyNode;\r\nexport declare const isPropertyAFunctionNode: (node: Node) => node is FunctionExpressionNode | ArrowFunctionExpressionNode;\r\nexport declare const getAST: ((code: string, options?: AstOptions | undefined) => Node) & import(\"lodash\").MemoizedFunction;\r\n/**\r\n * An AST based extractor that fetches all possible references in a given\r\n * piece of code. We use this to get any references to the global entities in Appsmith\r\n * and create dependencies on them. If the reference was updated, the given piece of code\r\n * should run again.\r\n * @param code: The piece of script where references need to be extracted from\r\n */\r\nexport interface IdentifierInfo {\r\n    references: string[];\r\n    functionalParams: string[];\r\n    variables: string[];\r\n}\r\nexport declare const extractIdentifierInfoFromCode: (code: string, evaluationVersion: number, invalidIdentifiers?: Record<string, unknown> | undefined) => IdentifierInfo;\r\nexport declare const entityRefactorFromCode: (script: string, oldName: string, newName: string, isJSObject: boolean, evaluationVersion: number, invalidIdentifiers?: Record<string, unknown> | undefined) => EntityRefactorResponse;\r\nexport declare type functionParam = {\r\n    paramName: string;\r\n    defaultValue: unknown;\r\n};\r\nexport declare const getFunctionalParamsFromNode: (node: FunctionDeclarationNode | FunctionExpressionNode | ArrowFunctionExpressionNode, needValue?: boolean) => Set<functionParam>;\r\nexport declare const isTypeOfFunction: (type: string) => boolean;\r\nexport interface MemberExpressionData {\r\n    property: NodeWithLocation<IdentifierNode | LiteralNode>;\r\n    object: NodeWithLocation<IdentifierNode>;\r\n}\r\n/** Function returns Invalid top-level member expressions from code\r\n * @param code\r\n * @param data\r\n * @param evaluationVersion\r\n * @returns information about all invalid property/method assessment in code\r\n * @example Given data {\r\n * JSObject1: {\r\n * name:\"JSObject\",\r\n * data:[]\r\n * },\r\n * Api1:{\r\n * name: \"Api1\",\r\n * data: []\r\n * }\r\n * },\r\n * For code {{Api1.name + JSObject.unknownProperty}}, function returns information about \"JSObject.unknownProperty\" node.\r\n */\r\nexport declare const extractInvalidTopLevelMemberExpressionsFromCode: (code: string, data: Record<string, any>, evaluationVersion: number) => MemberExpressionData[];\r\nexport {};\r\n"}}
