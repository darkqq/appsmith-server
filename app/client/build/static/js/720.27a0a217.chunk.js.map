{"version":3,"file":"static/js/720.27a0a217.chunk.js","mappings":"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EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,EAAE,IAAI,GAAG,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,IAAI,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,KAAK,GAAG,IAAI,KAAK,EAAE,KAAK,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,KAAK,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,KAAK,IAAI,GAAG,GAAG,KAAK,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,KAAK,MAAM,GAAG,KAAK,GAAG,IAAI,EAAE,KAAK,MAAM,KAClhCC,EAAwB,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,KAAK,GAAG,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,KAAK,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE,EAAE,OAAO,KAK/d,SAASC,EAAcC,EAAMC,GAE3B,IADA,IAAIj1B,EAAM,MACDe,EAAI,EAAGA,EAAIk0B,EAAIj0B,OAAQD,GAAK,EAAG,CAEtC,IADAf,GAAOi1B,EAAIl0B,IACDi0B,EAAM,OAAO,EAEvB,IADAh1B,GAAOi1B,EAAIl0B,EAAI,KACJi0B,EAAM,OAAO,CAC1B,CACF,CAIA,SAASE,EAAkBF,EAAMvI,GAC/B,OAAIuI,EAAO,GAAoB,KAATA,EAClBA,EAAO,KACPA,EAAO,GAAoB,KAATA,EAClBA,EAAO,MACPA,GAAQ,MAAeA,GAAQ,KAAQL,EAAwBhyB,KAAKyS,OAAO+f,aAAaH,KAC7E,IAAXvI,GACGsI,EAAcC,EAAMH,IAC7B,CAIA,SAASzM,EAAiB4M,EAAMvI,GAC9B,OAAIuI,EAAO,GAAoB,KAATA,EAClBA,EAAO,MACPA,EAAO,MACPA,EAAO,KACPA,EAAO,GAAoB,KAATA,EAClBA,EAAO,MACPA,GAAQ,MAAeA,GAAQ,KAAQJ,EAAmBjyB,KAAKyS,OAAO+f,aAAaH,KACxE,IAAXvI,IACGsI,EAAcC,EAAMH,IAA+BE,EAAcC,EAAMF,MAChF,CAyBA,IAAIM,EAAY,SAAmBC,EAAOC,QAC1B,IAATA,IAAkBA,EAAO,CAAC,GAE/Bv1B,KAAKs1B,MAAQA,EACbt1B,KAAKw1B,QAAUD,EAAKC,QACpBx1B,KAAKy1B,aAAeF,EAAKE,WACzBz1B,KAAK01B,aAAeH,EAAKG,WACzB11B,KAAK21B,SAAWJ,EAAKI,OACrB31B,KAAK41B,WAAaL,EAAKK,SACvB51B,KAAKkqB,SAAWqL,EAAKrL,OACrBlqB,KAAK61B,UAAYN,EAAKM,QACtB71B,KAAK81B,MAAQP,EAAKO,OAAS,KAC3B91B,KAAK+1B,cAAgB,IACvB,EAEA,SAASD,EAAMp0B,EAAMs0B,GACnB,OAAO,IAAIX,EAAU3zB,EAAM,CAAC+zB,YAAY,EAAMK,MAAOE,GACvD,CACA,IAAIP,EAAa,CAACA,YAAY,GAC1BC,EAAa,CAACA,YAAY,GAG1BO,EAAe,CAAC,EAGpB,SAASrM,EAAGloB,EAAM2Q,GAIhB,YAHiB,IAAZA,IAAqBA,EAAU,CAAC,GAErCA,EAAQmjB,QAAU9zB,EACXu0B,EAAav0B,GAAQ,IAAI2zB,EAAU3zB,EAAM2Q,EAClD,CAEA,IAAI6jB,EAAK,CACP5vB,IAAK,IAAI+uB,EAAU,MAAOK,GAC1BS,OAAQ,IAAId,EAAU,SAAUK,GAChCU,OAAQ,IAAIf,EAAU,SAAUK,GAChCh0B,KAAM,IAAI2zB,EAAU,OAAQK,GAC5BW,IAAK,IAAIhB,EAAU,OAGnBiB,SAAU,IAAIjB,EAAU,IAAK,CAACI,YAAY,EAAMC,YAAY,IAC5Da,SAAU,IAAIlB,EAAU,KACxBmB,OAAQ,IAAInB,EAAU,IAAK,CAACI,YAAY,EAAMC,YAAY,IAC1De,OAAQ,IAAIpB,EAAU,KACtBqB,OAAQ,IAAIrB,EAAU,IAAK,CAACI,YAAY,EAAMC,YAAY,IAC1DiB,OAAQ,IAAItB,EAAU,KACtBuB,MAAO,IAAIvB,EAAU,IAAKI,GAC1BoB,KAAM,IAAIxB,EAAU,IAAKI,GACzBjyB,MAAO,IAAI6xB,EAAU,IAAKI,GAC1BqB,IAAK,IAAIzB,EAAU,KACnB0B,SAAU,IAAI1B,EAAU,IAAKI,GAC7Ble,MAAO,IAAI8d,EAAU,KAAMI,GAC3BuB,SAAU,IAAI3B,EAAU,YACxB4B,SAAU,IAAI5B,EAAU,MAAOI,GAC/ByB,UAAW,IAAI7B,EAAU,IAAKK,GAC9ByB,aAAc,IAAI9B,EAAU,KAAM,CAACI,YAAY,EAAMC,YAAY,IAgBjE0B,GAAI,IAAI/B,EAAU,IAAK,CAACI,YAAY,EAAMG,UAAU,IACpDyB,OAAQ,IAAIhC,EAAU,KAAM,CAACI,YAAY,EAAMG,UAAU,IACzD0B,OAAQ,IAAIjC,EAAU,QAAS,CAACnL,QAAQ,EAAM2L,SAAS,EAAMH,YAAY,IACzExL,OAAQ,IAAImL,EAAU,SAAU,CAACI,YAAY,EAAMvL,QAAQ,EAAMwL,YAAY,IAC7E6B,UAAWzB,EAAM,KAAM,GACvB0B,WAAY1B,EAAM,KAAM,GACxB2B,UAAW3B,EAAM,IAAK,GACtB4B,WAAY5B,EAAM,IAAK,GACvB6B,WAAY7B,EAAM,IAAK,GACvB8B,SAAU9B,EAAM,QAAS,GACzB+B,WAAY/B,EAAM,MAAO,GACzBgC,SAAUhC,EAAM,QAAS,GACzBiC,QAAS,IAAI1C,EAAU,MAAO,CAACI,YAAY,EAAMK,MAAO,EAAG5L,QAAQ,EAAMwL,YAAY,IACrFsC,OAAQlC,EAAM,IAAK,IACnBmC,KAAMnC,EAAM,IAAK,IACjBoC,MAAOpC,EAAM,IAAK,IAClBqC,SAAU,IAAI9C,EAAU,KAAM,CAACI,YAAY,IAG3C2C,OAAQxO,EAAG,SACXyO,MAAOzO,EAAG,OAAQ6L,GAClB6C,OAAQ1O,EAAG,SACX2O,UAAW3O,EAAG,YACd4O,UAAW5O,EAAG,YACd6O,SAAU7O,EAAG,UAAW6L,GACxBiD,IAAK9O,EAAG,KAAM,CAAC+L,QAAQ,EAAMF,YAAY,IACzCkD,MAAO/O,EAAG,OAAQ6L,GAClBmD,SAAUhP,EAAG,WACbiP,KAAMjP,EAAG,MAAO,CAAC+L,QAAQ,IACzBmD,UAAWlP,EAAG,WAAY8L,GAC1BqD,IAAKnP,EAAG,MACRoP,QAASpP,EAAG,SAAU6L,GACtBwD,QAASrP,EAAG,UACZsP,OAAQtP,EAAG,QAAS6L,GACpB0D,KAAMvP,EAAG,OACTwP,KAAMxP,EAAG,OACTyP,OAAQzP,EAAG,SACX0P,OAAQ1P,EAAG,QAAS,CAAC+L,QAAQ,IAC7B4D,MAAO3P,EAAG,QACV4P,KAAM5P,EAAG,MAAO,CAAC6L,YAAY,EAAMC,YAAY,IAC/C+D,MAAO7P,EAAG,OAAQ8L,GAClBgE,OAAQ9P,EAAG,QAAS8L,GACpBiE,OAAQ/P,EAAG,SACXgQ,SAAUhQ,EAAG,UAAW6L,GACxBoE,QAASjQ,EAAG,UACZkQ,QAASlQ,EAAG,UACZmQ,MAAOnQ,EAAG,OAAQ8L,GAClBsE,MAAOpQ,EAAG,OAAQ8L,GAClBuE,OAAQrQ,EAAG,QAAS8L,GACpBwE,IAAKtQ,EAAG,KAAM,CAAC6L,YAAY,EAAMK,MAAO,IACxCqE,YAAavQ,EAAG,aAAc,CAAC6L,YAAY,EAAMK,MAAO,IACxDsE,QAASxQ,EAAG,SAAU,CAAC6L,YAAY,EAAMvL,QAAQ,EAAMwL,YAAY,IACnE2E,MAAOzQ,EAAG,OAAQ,CAAC6L,YAAY,EAAMvL,QAAQ,EAAMwL,YAAY,IAC/D4E,QAAS1Q,EAAG,SAAU,CAAC6L,YAAY,EAAMvL,QAAQ,EAAMwL,YAAY,KAMjE6E,EAAY,yBACZC,EAAa,IAAItkB,OAAOqkB,EAAUtd,OAAQ,KAE9C,SAASwd,EAAUxF,GACjB,OAAgB,KAATA,GAAwB,KAATA,GAAwB,OAATA,GAA4B,OAATA,CAC1D,CAEA,IAAIyF,EAAqB,sDAErBC,EAAiB,gCAErB,SAASxlB,EAAQ9V,GACf,MAA+C,mBAAxCE,OAAOC,UAAUyN,SAASvN,KAAKL,EACxC,CAIA,SAASu7B,EAAIv7B,EAAKqF,GAChB,OAAOnF,OAAOC,UAAUC,eAAeC,KAAKL,EAAKqF,EACnD,CAKA,IAAIm2B,EAAW,SAAkBpM,EAAMqM,GACrC96B,KAAKyuB,KAAOA,EACZzuB,KAAK+6B,OAASD,CAChB,EAEAD,EAASr7B,UAAUgwB,OAAS,SAAiBxX,GAC3C,OAAO,IAAI6iB,EAAS76B,KAAKyuB,KAAMzuB,KAAK+6B,OAAS/iB,EAC/C,EAEA,IAAIgjB,EAAiB,SAAwBh0B,EAAGnH,EAAOqX,GACrDlX,KAAKH,MAAQA,EACbG,KAAKkX,IAAMA,EACU,OAAjBlQ,EAAE2d,aAAqB3kB,KAAKid,OAASjW,EAAE2d,WAC7C,EAQA,SAASsW,EAAY9Y,EAAOqN,GAC1B,IAAK,IAAIf,EAAO,EAAGrjB,EAAM,IAAK,CAC5BovB,EAAW5L,UAAYxjB,EACvB,IAAI5E,EAAQg0B,EAAWpuB,KAAK+V,GAC5B,KAAI3b,GAASA,EAAMqoB,MAAQW,GAIzB,OAAO,IAAIqL,EAASpM,EAAMe,EAASpkB,KAHjCqjB,EACFrjB,EAAM5E,EAAMqoB,MAAQroB,EAAM,GAAGvF,MAIjC,CACF,CAKA,IAAI6lB,EAAiB,CAKnBS,YAAa,EAIb2T,WAAY,SAMZC,oBAAqB,KAGrBC,gBAAiB,KAKjBC,cAAe,KAGfjP,4BAA4B,EAG5BC,6BAA6B,EAG7BC,eAAe,EAKfgP,WAAW,EAMXC,QAAS,KAWTC,UAAW,KASXC,QAAQ,EAMRC,QAAS,KAGT/W,WAAY,KAGZwH,iBAAkB,KAGlBwP,gBAAgB,EAChB/U,QAAS,CAAC,GAKZ,SAASgV,EAAWC,GAClB,IAAIxpB,EAAU,CAAC,EAEf,IAAK,IAAIypB,KAAOhV,EACdzU,EAAQypB,GAAOD,GAAQjB,EAAIiB,EAAMC,GAAOD,EAAKC,GAAOhV,EAAegV,GAQrE,GANIzpB,EAAQkV,aAAe,OACzBlV,EAAQkV,aAAe,MAEI,MAAzBlV,EAAQgpB,gBACVhpB,EAAQgpB,cAAgBhpB,EAAQkV,YAAc,GAE5CpS,EAAQ9C,EAAQkpB,SAAU,CAC5B,IAAIQ,EAAS1pB,EAAQkpB,QACrBlpB,EAAQkpB,QAAU,SAAUS,GAAS,OAAOD,EAAOr4B,KAAKs4B,EAAQ,CAClE,CAIA,OAHI7mB,EAAQ9C,EAAQmpB,aAClBnpB,EAAQmpB,UAAYS,EAAY5pB,EAASA,EAAQmpB,YAE5CnpB,CACT,CAEA,SAAS4pB,EAAY5pB,EAAS6pB,GAC5B,OAAO,SAAUC,EAAOpa,EAAMliB,EAAOqX,EAAKklB,EAAUC,GAClD,IAAIC,EAAU,CACZn8B,KAAMg8B,EAAQ,QAAU,OACxB11B,MAAOsb,EACPliB,MAAOA,EACPqX,IAAKA,GAEH7E,EAAQipB,YACVgB,EAAQC,IAAM,IAAIvB,EAAeh7B,KAAMo8B,EAAUC,IAC/ChqB,EAAQopB,SACVa,EAAQE,MAAQ,CAAC38B,EAAOqX,IAC1BglB,EAAMx4B,KAAK44B,EACb,CACF,CAGA,IAAI1V,EAAU,CAAC,EAEf,SAAS6V,EAAcC,GACrB,OAAO,IAAIxmB,OAAO,KAAOwmB,EAAMhnB,QAAQ,KAAM,KAAO,KACtD,CAEA,IAAIinB,EAAS,SAAgBtqB,EAAS8P,EAAOya,GAC3C58B,KAAKqS,QAAUA,EAAUupB,EAAWvpB,GACpCrS,KAAK2kB,WAAatS,EAAQsS,WAC1B3kB,KAAKy0B,SAAWgI,EAAchI,EAASpiB,EAAQkV,aAAe,EAAI,EAAI,IACtE,IAAIsV,EAAW,GACf,IAAKxqB,EAAQgpB,cAAe,CAC1B,IAAK,IAAI5iB,EAAIpG,EAAQkV,cACfsV,EAAWxI,EAAc5b,IADIA,KAET,UAAtBpG,EAAQ6oB,aAAwB2B,GAAY,SAClD,CACA78B,KAAKq0B,cAAgBoI,EAAcI,GACnC,IAAIC,GAAkBD,EAAWA,EAAW,IAAM,IAAMxI,EAAcC,OACtEt0B,KAAK+8B,oBAAsBN,EAAcK,GACzC98B,KAAKg9B,wBAA0BP,EAAcK,EAAiB,IAAMzI,EAAcE,YAClFv0B,KAAKmiB,MAAQ9M,OAAO8M,GAKpBniB,KAAKi9B,aAAc,EAGnBj9B,KAAKk9B,YAAY7qB,EAAQuU,SAKrBgW,GACF58B,KAAKC,IAAM28B,EACX58B,KAAK8xB,UAAY9xB,KAAKmiB,MAAMqO,YAAY,KAAMoM,EAAW,GAAK,EAC9D58B,KAAKgyB,QAAUhyB,KAAKmiB,MAAM1e,MAAM,EAAGzD,KAAK8xB,WAAWxpB,MAAMiyB,GAAWt5B,SAEpEjB,KAAKC,IAAMD,KAAK8xB,UAAY,EAC5B9xB,KAAKgyB,QAAU,GAKjBhyB,KAAKG,KAAO+1B,EAAGG,IAEfr2B,KAAKyG,MAAQ,KAEbzG,KAAKH,MAAQG,KAAKkX,IAAMlX,KAAKC,IAG7BD,KAAKo8B,SAAWp8B,KAAKq8B,OAASr8B,KAAKm9B,cAGnCn9B,KAAKo9B,cAAgBp9B,KAAKq9B,gBAAkB,KAC5Cr9B,KAAKs9B,aAAet9B,KAAKu9B,WAAav9B,KAAKC,IAK3CD,KAAK6W,QAAU7W,KAAKw9B,iBACpBx9B,KAAKy9B,aAAc,EAGnBz9B,KAAK09B,SAAkC,WAAvBrrB,EAAQ6oB,WACxBl7B,KAAKs0B,OAASt0B,KAAK09B,UAAY19B,KAAK29B,gBAAgB39B,KAAKC,KAGzDD,KAAK49B,kBAAoB,EAGzB59B,KAAK69B,WAAa79B,KAAK89B,YAAc99B,KAAK+9B,SAAU,EAEpD/9B,KAAKg+B,SAAWh+B,KAAKi+B,SAAW,EAEhCj+B,KAAKk+B,OAAS,GAGG,IAAbl+B,KAAKC,KAAaoS,EAAQia,eAA4C,OAA3BtsB,KAAKmiB,MAAM1e,MAAM,EAAG,IACjEzD,KAAKm+B,gBAAgB,EACzB,EAGAxB,EAAOn9B,UAAUsqB,UAAY,SAAoBrnB,GAAQ,OAAOzC,KAAKy0B,SAAS7xB,KAAKH,EAAM,EACzFk6B,EAAOn9B,UAAU4+B,eAAiB,SAAyB37B,GAAQ,OAAOzC,KAAKq0B,cAAczxB,KAAKH,EAAM,EAExGk6B,EAAOn9B,UAAUiO,OAAS,SAAiB/L,EAAMoJ,GAC/C9K,KAAK0B,GAAQoJ,EAAE9K,KAAK0B,GACtB,EAEAi7B,EAAOn9B,UAAU09B,YAAc,SAAsBmB,GACjD,IAAIC,EAASt+B,KAEf,IAAK,IAAI0B,KAAQ28B,EAAe,CAC9B,IAAItP,EAASnI,EAAQllB,GACrB,IAAKqtB,EAAQ,MAAM,IAAIjsB,MAAM,WAAapB,EAAO,eACjDqtB,EAAOuP,EAAQD,EAAc38B,GAC/B,CACF,EAEAi7B,EAAOn9B,UAAUoL,MAAQ,WACvB,IAAImN,EAAO/X,KAAKqS,QAAQqpB,SAAW17B,KAAKu+B,YAExC,OADAv+B,KAAKw+B,YACEx+B,KAAKy+B,cAAc1mB,EAC5B,EAEA,IAAI2mB,EAAK/B,EAAOn9B,UAIZm/B,EAAU,6CACdD,EAAGf,gBAAkB,SAAS99B,GAG5B,IAFA,IAAIy+B,EAASt+B,OAEJ,CACP26B,EAAe/L,UAAY/uB,EAC3BA,GAAS86B,EAAevuB,KAAKkyB,EAAOnc,OAAO,GAAGlhB,OAC9C,IAAIuF,EAAQm4B,EAAQvyB,KAAKkyB,EAAOnc,MAAM1e,MAAM5D,IAC5C,IAAK2G,EAAO,OAAO,EACnB,GAA8B,eAAzBA,EAAM,IAAMA,EAAM,IAAqB,OAAO,EACnD3G,GAAS2G,EAAM,GAAGvF,MACpB,CACF,EAKAy9B,EAAGr8B,IAAM,SAASlC,GAChB,OAAIH,KAAKG,OAASA,IAChBH,KAAKmE,QACE,EAIX,EAIAu6B,EAAGE,aAAe,SAASl9B,GACzB,OAAO1B,KAAKG,OAAS+1B,EAAGx0B,MAAQ1B,KAAKyG,QAAU/E,CACjD,EAIAg9B,EAAGG,cAAgB,SAASn9B,GAC1B,OAAO1B,KAAKyG,QAAU/E,GAAQ1B,KAAKqC,IAAI6zB,EAAGx0B,KAC5C,EAIAg9B,EAAGI,iBAAmB,SAASp9B,GACxB1B,KAAK6+B,cAAcn9B,IAAO1B,KAAK++B,YACtC,EAIAL,EAAGM,mBAAqB,WACtB,OAAOh/B,KAAKG,OAAS+1B,EAAGG,KACtBr2B,KAAKG,OAAS+1B,EAAGO,QACjB8D,EAAU33B,KAAK5C,KAAKmiB,MAAM1e,MAAMzD,KAAKu9B,WAAYv9B,KAAKH,OAC1D,EAEA6+B,EAAGO,gBAAkB,WACnB,GAAIj/B,KAAKg/B,qBAGP,OAFIh/B,KAAKqS,QAAQ8oB,qBACfn7B,KAAKqS,QAAQ8oB,oBAAoBn7B,KAAKu9B,WAAYv9B,KAAKo9B,gBAClD,CAEX,EAKAsB,EAAGQ,UAAY,WACRl/B,KAAKqC,IAAI6zB,EAAGW,OAAU72B,KAAKi/B,mBAAmBj/B,KAAK++B,YAC1D,EAEAL,EAAGS,mBAAqB,SAASC,EAASC,GACxC,GAAIr/B,KAAKG,MAAQi/B,EAKf,OAJIp/B,KAAKqS,QAAQ+oB,iBACfp7B,KAAKqS,QAAQ+oB,gBAAgBp7B,KAAKs9B,aAAct9B,KAAKq9B,iBAClDgC,GACHr/B,KAAKmE,QACA,CAEX,EAKAu6B,EAAGY,OAAS,SAASn/B,GACnBH,KAAKqC,IAAIlC,IAASH,KAAK++B,YACzB,EAIAL,EAAGK,WAAa,SAAS9+B,GACvBD,KAAKu/B,MAAa,MAAPt/B,EAAcA,EAAMD,KAAKH,MAAO,mBAC7C,EAEA,IAAI2/B,EAAsB,WACxBx/B,KAAKy/B,gBAAkBz/B,KAAK0/B,cAAgB1/B,KAAK2/B,oBAAsB3/B,KAAK4/B,mBAAqB,CACnG,EAEAlB,EAAGmB,mBAAqB,SAASC,EAAwBlK,GACvD,GAAKkK,EAAL,CACIA,EAAuBJ,eAAiB,GAC1C1/B,KAAK+/B,iBAAiBD,EAAuBJ,cAAe,iDAC9D,IAAIM,EAASpK,EAAWkK,EAAuBH,oBAAsBG,EAAuBF,kBACxFI,GAAU,GAAGhgC,KAAK+/B,iBAAiBC,EAAQ,wBAJZ,CAKrC,EAEAtB,EAAGuB,sBAAwB,SAASH,EAAwBI,GAC1D,IAAIjgC,EAAM6/B,EAAyBA,EAAuBL,iBAAmB,EAC7E,IAAKS,EAAU,OAAOjgC,GAAO,EACzBA,GAAO,GAAGD,KAAKu/B,MAAMt/B,EAAK,0EAChC,EAEAy+B,EAAGyB,+BAAiC,WAC9BngC,KAAKg+B,YAAch+B,KAAKi+B,UAAYj+B,KAAKg+B,SAAWh+B,KAAKi+B,WAC3Dj+B,KAAKu/B,MAAMv/B,KAAKg+B,SAAU,8CACxBh+B,KAAKi+B,UACPj+B,KAAKu/B,MAAMv/B,KAAKi+B,SAAU,6CAC9B,EAEAS,EAAG0B,qBAAuB,SAAShW,GACjC,MAAkB,4BAAdA,EAAKjqB,KACAH,KAAKogC,qBAAqBhW,EAAKvP,YACnB,eAAduP,EAAKjqB,MAAuC,qBAAdiqB,EAAKjqB,IAC5C,EAEA,IAAIkgC,EAAO1D,EAAOn9B,UASlB6gC,EAAK5B,cAAgB,SAAS1mB,GAC5B,IAAIumB,EAASt+B,KAETd,EAAU,CAAC,EAEf,IADK6Y,EAAKM,OAAMN,EAAKM,KAAO,IACrBrY,KAAKG,OAAS+1B,EAAGG,KAAK,CAC3B,IAAIiK,EAAOhC,EAAOiC,gBAAe,GAAM,EAAMrhC,GAC7C6Y,EAAKM,KAAK3U,KAAK48B,EACjB,CAKA,OAJAtgC,KAAKmE,OACDnE,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAKmjB,WAAal7B,KAAKqS,QAAQ6oB,YAE1Bl7B,KAAKwgC,WAAWzoB,EAAM,UAC/B,EAEA,IAAI0oB,EAAY,CAACzmB,KAAM,QACnB0mB,EAAc,CAAC1mB,KAAM,UACzBqmB,EAAKM,MAAQ,WACX,GAAI3gC,KAAKG,OAAS+1B,EAAGx0B,MAAQ1B,KAAKqS,QAAQkV,YAAc,GAAmB,OAAdvnB,KAAKyG,MAAgB,OAAO,EACzFk0B,EAAe/L,UAAY5uB,KAAKC,IAChC,IAAI2gC,EAAOjG,EAAevuB,KAAKpM,KAAKmiB,OAChChe,EAAOnE,KAAKC,IAAM2gC,EAAK,GAAG3/B,OAAQ4/B,EAAS7gC,KAAKmiB,MAAM7Y,WAAWnF,GACrE,GAAe,KAAX08B,GAA2B,KAAVA,EAAe,OAAO,EAC3C,GAAI1L,EAAkB0L,GAAQ,GAAO,CACnC,IAAK,IAAI5gC,EAAMkE,EAAO,EAAGkkB,EAAiBroB,KAAKmiB,MAAM7Y,WAAWrJ,IAAM,KAASA,GAC/E,IAAI6gC,EAAQ9gC,KAAKmiB,MAAM1e,MAAMU,EAAMlE,GACnC,IAAKD,KAAK8pB,UAAUgX,GAAQ,OAAO,CACrC,CACA,OAAO,CACT,EAKAT,EAAKU,gBAAkB,WACrB,GAAI/gC,KAAKG,OAAS+1B,EAAGx0B,MAAQ1B,KAAKqS,QAAQkV,YAAc,GAAmB,SAAdvnB,KAAKyG,MAChE,OAAO,EAETk0B,EAAe/L,UAAY5uB,KAAKC,IAChC,IAAI2gC,EAAOjG,EAAevuB,KAAKpM,KAAKmiB,OAChChe,EAAOnE,KAAKC,IAAM2gC,EAAK,GAAG3/B,OAC9B,OAAQs5B,EAAU33B,KAAK5C,KAAKmiB,MAAM1e,MAAMzD,KAAKC,IAAKkE,KACX,aAArCnE,KAAKmiB,MAAM1e,MAAMU,EAAMA,EAAO,KAC7BA,EAAO,GAAKnE,KAAKmiB,MAAMlhB,SAAWonB,EAAiBroB,KAAKmiB,MAAM5f,OAAO4B,EAAO,IACjF,EASAk8B,EAAKE,eAAiB,SAASS,EAAaC,EAAU/hC,GACpD,IAAoD8a,EAAhDknB,EAAYlhC,KAAKG,KAAM4X,EAAO/X,KAAKu+B,YAWvC,OATIv+B,KAAK2gC,UACPO,EAAYhL,EAAGkD,KACfpf,EAAO,OAODknB,GACR,KAAKhL,EAAGkC,OAAQ,KAAKlC,EAAGqC,UAAW,OAAOv4B,KAAKmhC,4BAA4BppB,EAAMmpB,EAAU1L,SAC3F,KAAKU,EAAGsC,UAAW,OAAOx4B,KAAKohC,uBAAuBrpB,GACtD,KAAKme,EAAGwC,IAAK,OAAO14B,KAAKqhC,iBAAiBtpB,GAC1C,KAAKme,EAAG2C,KAAM,OAAO74B,KAAKshC,kBAAkBvpB,GAC5C,KAAKme,EAAG4C,UAEN,OADKkI,GAAehhC,KAAKqS,QAAQkV,aAAe,GAAGvnB,KAAK++B,aACjD/+B,KAAKuhC,uBAAuBxpB,GAAM,GAC3C,KAAKme,EAAGyD,OAEN,OADKqH,GAAahhC,KAAK++B,aAChB/+B,KAAKwhC,WAAWzpB,GAAM,GAC/B,KAAKme,EAAG6C,IAAK,OAAO/4B,KAAKyhC,iBAAiB1pB,GAC1C,KAAKme,EAAG8C,QAAS,OAAOh5B,KAAK0hC,qBAAqB3pB,GAClD,KAAKme,EAAG+C,QAAS,OAAOj5B,KAAK2hC,qBAAqB5pB,GAClD,KAAKme,EAAGgD,OAAQ,OAAOl5B,KAAK4hC,oBAAoB7pB,GAChD,KAAKme,EAAGiD,KAAM,OAAOn5B,KAAK6hC,kBAAkB9pB,GAC5C,KAAKme,EAAGmD,OAAQ,KAAKnD,EAAGkD,KAGtB,OAFApf,EAAOA,GAAQha,KAAKyG,MACfu6B,GAAuB,OAARhnB,GAAeha,KAAK++B,aACjC/+B,KAAK8hC,kBAAkB/pB,EAAMiC,GACtC,KAAKkc,EAAGoD,OAAQ,OAAOt5B,KAAK+hC,oBAAoBhqB,GAChD,KAAKme,EAAGqD,MAAO,OAAOv5B,KAAKgiC,mBAAmBjqB,GAC9C,KAAKme,EAAGM,OAAQ,OAAOx2B,KAAKiiC,aAC5B,KAAK/L,EAAGW,KAAM,OAAO72B,KAAKkiC,oBAAoBnqB,GAC9C,KAAKme,EAAG2D,QACR,KAAK3D,EAAG4D,QAON,OANK95B,KAAKqS,QAAQga,8BACX4U,GACHjhC,KAAKu/B,MAAMv/B,KAAKH,MAAO,0DACpBG,KAAK09B,UACR19B,KAAKu/B,MAAMv/B,KAAKH,MAAO,oEAEpBqhC,IAAchL,EAAG4D,QAAU95B,KAAKmiC,YAAYpqB,GAAQ/X,KAAKoiC,YAAYrqB,EAAM7Y,GAOpF,QACE,GAAIc,KAAK+gC,mBAAqBC,EAE5B,OADAhhC,KAAKmE,OACEnE,KAAKuhC,uBAAuBxpB,GAAM,GAG3C,IAAIsqB,EAAYriC,KAAKyG,MAAO2jB,EAAOpqB,KAAKsiC,kBACxC,OAAIpB,IAAchL,EAAGx0B,MAAsB,eAAd0oB,EAAKjqB,MAAyBH,KAAKqC,IAAI6zB,EAAG1yB,OAC9DxD,KAAKuiC,sBAAsBxqB,EAAMsqB,EAAWjY,GACzCpqB,KAAKwiC,yBAAyBzqB,EAAMqS,GAEpD,EAEAiW,EAAKc,4BAA8B,SAASppB,EAAMyd,GAChD,IAAI8I,EAASt+B,KAETyiC,EAAqB,SAAXjN,EACdx1B,KAAKmE,OACDnE,KAAKqC,IAAI6zB,EAAGW,OAAS72B,KAAKi/B,kBAAmBlnB,EAAKud,MAAQ,KACrDt1B,KAAKG,OAAS+1B,EAAGx0B,KAAM1B,KAAK++B,cAEnChnB,EAAKud,MAAQt1B,KAAK0iC,aAClB1iC,KAAKk/B,aAKP,IAAK,IAAIl+B,EAAI,EAAGA,EAAIhB,KAAKk+B,OAAOj9B,SAAUD,EAAG,CAC3C,IAAI2hC,EAAMrE,EAAOJ,OAAOl9B,GACxB,GAAkB,MAAd+W,EAAKud,OAAiBqN,EAAIjhC,OAASqW,EAAKud,MAAM5zB,KAAM,CACtD,GAAgB,MAAZihC,EAAI3oB,OAAiByoB,GAAwB,SAAbE,EAAI3oB,MAAkB,MAC1D,GAAIjC,EAAKud,OAASmN,EAAS,KAC7B,CACF,CAEA,OADIzhC,IAAMhB,KAAKk+B,OAAOj9B,QAAQjB,KAAKu/B,MAAMxnB,EAAKlY,MAAO,eAAiB21B,GAC/Dx1B,KAAKwgC,WAAWzoB,EAAM0qB,EAAU,iBAAmB,oBAC5D,EAEApC,EAAKe,uBAAyB,SAASrpB,GAGrC,OAFA/X,KAAKmE,OACLnE,KAAKk/B,YACEl/B,KAAKwgC,WAAWzoB,EAAM,oBAC/B,EAEAsoB,EAAKgB,iBAAmB,SAAStpB,GAW/B,OAVA/X,KAAKmE,OACLnE,KAAKk+B,OAAOx6B,KAAK+8B,GACjB1oB,EAAKM,KAAOrY,KAAKugC,gBAAe,GAChCvgC,KAAKk+B,OAAO7Z,MACZrkB,KAAKs/B,OAAOpJ,EAAGoD,QACfvhB,EAAKnV,KAAO5C,KAAK4iC,uBACb5iC,KAAKqS,QAAQkV,aAAe,EAC9BvnB,KAAKqC,IAAI6zB,EAAGW,MAEZ72B,KAAKk/B,YACAl/B,KAAKwgC,WAAWzoB,EAAM,mBAC/B,EAUAsoB,EAAKiB,kBAAoB,SAASvpB,GAIhC,GAHA/X,KAAKmE,OACLnE,KAAKk+B,OAAOx6B,KAAK+8B,GACjBzgC,KAAKs/B,OAAOpJ,EAAGQ,QACX12B,KAAKG,OAAS+1B,EAAGW,KAAM,OAAO72B,KAAK6iC,SAAS9qB,EAAM,MACtD,IAAI4oB,EAAQ3gC,KAAK2gC,QACjB,GAAI3gC,KAAKG,OAAS+1B,EAAGkD,MAAQp5B,KAAKG,OAAS+1B,EAAGmD,QAAUsH,EAAO,CAC7D,IAAImC,EAAS9iC,KAAKu+B,YAAavkB,EAAO2mB,EAAQ,MAAQ3gC,KAAKyG,MAI3D,OAHAzG,KAAKmE,OACLnE,KAAK+iC,SAASD,GAAQ,EAAM9oB,GAC5Bha,KAAKwgC,WAAWsC,EAAQ,yBACnB9iC,KAAKG,OAAS+1B,EAAGgE,KAAQl6B,KAAKqS,QAAQkV,aAAe,GAAKvnB,KAAK4+B,aAAa,QAA0C,IAA/BkE,EAAO1nB,aAAana,QACjG,QAAT+Y,GAAkB8oB,EAAO1nB,aAAa,GAAGvO,KAExC7M,KAAK6iC,SAAS9qB,EAAM+qB,GADlB9iC,KAAKgjC,WAAWjrB,EAAM+qB,EAEjC,CACA,IAAIhD,EAAyB,IAAIN,EAC7B3yB,EAAO7M,KAAKsiC,iBAAgB,EAAMxC,GACtC,OAAI9/B,KAAKG,OAAS+1B,EAAGgE,KAAQl6B,KAAKqS,QAAQkV,aAAe,GAAKvnB,KAAK4+B,aAAa,OAC9E5+B,KAAKijC,aAAap2B,GAClB7M,KAAKkjC,UAAUr2B,GACf7M,KAAK6/B,mBAAmBC,GAAwB,GACzC9/B,KAAKgjC,WAAWjrB,EAAMlL,KAE7B7M,KAAKigC,sBAAsBH,GAAwB,GAE9C9/B,KAAK6iC,SAAS9qB,EAAMlL,GAC7B,EAEAwzB,EAAKkB,uBAAyB,SAASxpB,EAAMorB,GAE3C,OADAnjC,KAAKmE,OACEnE,KAAKojC,cAAcrrB,GAAM,GAAM,EAAOorB,EAC/C,EAEA9C,EAAKgD,WAAa,WAChB,OAAOrjC,KAAKG,OAAS+1B,EAAG4C,WAAa94B,KAAK+gC,iBAC5C,EAEAV,EAAKoB,iBAAmB,SAAS1pB,GAM/B,OALA/X,KAAKmE,OACL4T,EAAKnV,KAAO5C,KAAK4iC,uBAEjB7qB,EAAKuI,WAAatgB,KAAKugC,gBAAgBvgC,KAAKs0B,QAAUt0B,KAAKqjC,cAC3DtrB,EAAKwI,UAAYvgB,KAAKqC,IAAI6zB,EAAGyC,OAAS34B,KAAKugC,gBAAgBvgC,KAAKs0B,QAAUt0B,KAAKqjC,cAAgB,KACxFrjC,KAAKwgC,WAAWzoB,EAAM,cAC/B,EAEAsoB,EAAKqB,qBAAuB,SAAS3pB,GAWnC,OAVK/X,KAAK69B,YAAe79B,KAAKqS,QAAQ+Z,4BACpCpsB,KAAKu/B,MAAMv/B,KAAKH,MAAO,gCACzBG,KAAKmE,OAMDnE,KAAKqC,IAAI6zB,EAAGW,OAAS72B,KAAKi/B,kBAAmBlnB,EAAK+B,SAAW,MAC1D/B,EAAK+B,SAAW9Z,KAAKsiC,kBAAmBtiC,KAAKk/B,aAC7Cl/B,KAAKwgC,WAAWzoB,EAAM,kBAC/B,EAEAsoB,EAAKsB,qBAAuB,SAAS5pB,GACnC,IAAIumB,EAASt+B,KAEbA,KAAKmE,OACL4T,EAAKurB,aAAetjC,KAAK4iC,uBACzB7qB,EAAKwrB,MAAQ,GACbvjC,KAAKs/B,OAAOpJ,EAAGM,QACfx2B,KAAKk+B,OAAOx6B,KAAKg9B,GAMjB,IAAK,IAAIt1B,EAAKo4B,GAAa,EAAOxjC,KAAKG,MAAQ+1B,EAAGO,QAChD,GAAI6H,EAAOn+B,OAAS+1B,EAAGmC,OAASiG,EAAOn+B,OAAS+1B,EAAGuC,SAAU,CAC3D,IAAIgL,EAASnF,EAAOn+B,OAAS+1B,EAAGmC,MAC5BjtB,GAAKkzB,EAAOkC,WAAWp1B,EAAK,cAChC2M,EAAKwrB,MAAM7/B,KAAK0H,EAAMkzB,EAAOC,aAC7BnzB,EAAIkV,WAAa,GACjBge,EAAOn6B,OACHs/B,EACFr4B,EAAIxI,KAAO07B,EAAOgE,mBAEdkB,GAAYlF,EAAOyB,iBAAiBzB,EAAOhB,aAAc,4BAC7DkG,GAAa,EACbp4B,EAAIxI,KAAO,MAEb07B,EAAOgB,OAAOpJ,EAAG1yB,MACnB,MACO4H,GAAKkzB,EAAOS,aACjB3zB,EAAIkV,WAAW5c,KAAK46B,EAAOiC,gBAAe,IAM9C,OAHIn1B,GAAKpL,KAAKwgC,WAAWp1B,EAAK,cAC9BpL,KAAKmE,OACLnE,KAAKk+B,OAAO7Z,MACLrkB,KAAKwgC,WAAWzoB,EAAM,kBAC/B,EAEAsoB,EAAKuB,oBAAsB,SAAS7pB,GAMlC,OALA/X,KAAKmE,OACDo2B,EAAU33B,KAAK5C,KAAKmiB,MAAM1e,MAAMzD,KAAKu9B,WAAYv9B,KAAKH,SACxDG,KAAKu/B,MAAMv/B,KAAKu9B,WAAY,+BAC9BxlB,EAAK+B,SAAW9Z,KAAKsiC,kBACrBtiC,KAAKk/B,YACEl/B,KAAKwgC,WAAWzoB,EAAM,iBAC/B,EAIA,IAAIhP,EAAQ,GAEZs3B,EAAKwB,kBAAoB,SAAS9pB,GAIhC,GAHA/X,KAAKmE,OACL4T,EAAKokB,MAAQn8B,KAAKiiC,aAClBlqB,EAAKjW,QAAU,KACX9B,KAAKG,OAAS+1B,EAAGoC,OAAQ,CAC3B,IAAIoL,EAAS1jC,KAAKu+B,YAClBv+B,KAAKmE,OACLnE,KAAKs/B,OAAOpJ,EAAGQ,QACfgN,EAAO/oB,MAAQ3a,KAAK2jC,mBACpB3jC,KAAKkjC,UAAUQ,EAAO/oB,OAAO,GAC7B3a,KAAKs/B,OAAOpJ,EAAGS,QACf+M,EAAOrrB,KAAOrY,KAAKiiC,aACnBlqB,EAAKjW,QAAU9B,KAAKwgC,WAAWkD,EAAQ,cACzC,CAIA,OAHA3rB,EAAK6rB,UAAY5jC,KAAKqC,IAAI6zB,EAAG0C,UAAY54B,KAAKiiC,aAAe,KACxDlqB,EAAKjW,SAAYiW,EAAK6rB,WACzB5jC,KAAKu/B,MAAMxnB,EAAKlY,MAAO,mCAClBG,KAAKwgC,WAAWzoB,EAAM,eAC/B,EAEAsoB,EAAKyB,kBAAoB,SAAS/pB,EAAMiC,GAItC,OAHAha,KAAKmE,OACLnE,KAAK+iC,SAAShrB,GAAM,EAAOiC,GAC3Bha,KAAKk/B,YACEl/B,KAAKwgC,WAAWzoB,EAAM,sBAC/B,EAEAsoB,EAAK0B,oBAAsB,SAAShqB,GAMlC,OALA/X,KAAKmE,OACL4T,EAAKnV,KAAO5C,KAAK4iC,uBACjB5iC,KAAKk+B,OAAOx6B,KAAK+8B,GACjB1oB,EAAKM,KAAOrY,KAAKugC,gBAAe,GAChCvgC,KAAKk+B,OAAO7Z,MACLrkB,KAAKwgC,WAAWzoB,EAAM,iBAC/B,EAEAsoB,EAAK2B,mBAAqB,SAASjqB,GAKjC,OAJI/X,KAAKs0B,QAAQt0B,KAAKu/B,MAAMv/B,KAAKH,MAAO,yBACxCG,KAAKmE,OACL4T,EAAKoF,OAASnd,KAAK4iC,uBACnB7qB,EAAKM,KAAOrY,KAAKugC,gBAAe,GACzBvgC,KAAKwgC,WAAWzoB,EAAM,gBAC/B,EAEAsoB,EAAK6B,oBAAsB,SAASnqB,GAElC,OADA/X,KAAKmE,OACEnE,KAAKwgC,WAAWzoB,EAAM,iBAC/B,EAEAsoB,EAAKkC,sBAAwB,SAASxqB,EAAMsqB,EAAWjY,GAGrD,IAFA,IAAIkU,EAASt+B,KAEJgB,EAAI,EAAGA,EAAIhB,KAAKk+B,OAAOj9B,SAAUD,EACpCs9B,EAAOJ,OAAOl9B,GAAGU,OAAS2gC,GAAW/D,EAAOiB,MAAMnV,EAAKvqB,MAAO,UAAYwiC,EAAY,yBAE5F,IADA,IAAIroB,EAAOha,KAAKG,KAAKw1B,OAAS,OAAS31B,KAAKG,OAAS+1B,EAAG+C,QAAU,SAAW,KACpE4K,EAAM7jC,KAAKk+B,OAAOj9B,OAAS,EAAG4iC,GAAO,EAAGA,IAAO,CACtD,IAAIvO,EAAQgJ,EAAOJ,OAAO2F,GAC1B,GAAIvO,EAAMwO,gBAAkB/rB,EAAKlY,MAG1B,MAFLy1B,EAAMwO,eAAiBxF,EAAOz+B,MAC9By1B,EAAMtb,KAAOA,CAEjB,CASA,OARAha,KAAKk+B,OAAOx6B,KAAK,CAAChC,KAAM2gC,EAAWroB,KAAMA,EAAM8pB,eAAgB9jC,KAAKH,QACpEkY,EAAKM,KAAOrY,KAAKugC,gBAAe,IACV,oBAAlBxoB,EAAKM,KAAKlY,MACQ,uBAAlB4X,EAAKM,KAAKlY,OAAkCH,KAAKs0B,QAA4B,OAAlBvc,EAAKM,KAAK2B,OACnD,uBAAlBjC,EAAKM,KAAKlY,OAAkCH,KAAKs0B,QAAUvc,EAAKM,KAAKnV,aACvElD,KAAK+/B,iBAAiBhoB,EAAKM,KAAKxY,MAAO,+BACzCG,KAAKk+B,OAAO7Z,MACZtM,EAAKud,MAAQlL,EACNpqB,KAAKwgC,WAAWzoB,EAAM,mBAC/B,EAEAsoB,EAAKmC,yBAA2B,SAASzqB,EAAMqS,GAG7C,OAFArS,EAAK8C,WAAauP,EAClBpqB,KAAKk/B,YACEl/B,KAAKwgC,WAAWzoB,EAAM,sBAC/B,EAMAsoB,EAAK4B,WAAa,WAChB,IAAI3D,EAASt+B,KAET+X,EAAO/X,KAAKu+B,YAGhB,IAFAxmB,EAAKM,KAAO,GACZrY,KAAKs/B,OAAOpJ,EAAGM,SACPx2B,KAAKqC,IAAI6zB,EAAGO,SAAS,CAC3B,IAAI6J,EAAOhC,EAAOiC,gBAAe,GACjCxoB,EAAKM,KAAK3U,KAAK48B,EACjB,CACA,OAAOtgC,KAAKwgC,WAAWzoB,EAAM,iBAC/B,EAMAsoB,EAAKwC,SAAW,SAAS9qB,EAAMlL,GAS7B,OARAkL,EAAKlL,KAAOA,EACZ7M,KAAKs/B,OAAOpJ,EAAGW,MACf9e,EAAKnV,KAAO5C,KAAKG,OAAS+1B,EAAGW,KAAO,KAAO72B,KAAKsiC,kBAChDtiC,KAAKs/B,OAAOpJ,EAAGW,MACf9e,EAAKgsB,OAAS/jC,KAAKG,OAAS+1B,EAAGS,OAAS,KAAO32B,KAAKsiC,kBACpDtiC,KAAKs/B,OAAOpJ,EAAGS,QACf5e,EAAKM,KAAOrY,KAAKugC,gBAAe,GAChCvgC,KAAKk+B,OAAO7Z,MACLrkB,KAAKwgC,WAAWzoB,EAAM,eAC/B,EAKAsoB,EAAK2C,WAAa,SAASjrB,EAAMlL,GAC/B,IAAI1M,EAAOH,KAAKG,OAAS+1B,EAAGgE,IAAM,iBAAmB,iBAOrD,OANAl6B,KAAKmE,OACL4T,EAAK4B,KAAO9M,EACZkL,EAAKuC,MAAQta,KAAKsiC,kBAClBtiC,KAAKs/B,OAAOpJ,EAAGS,QACf5e,EAAKM,KAAOrY,KAAKugC,gBAAe,GAChCvgC,KAAKk+B,OAAO7Z,MACLrkB,KAAKwgC,WAAWzoB,EAAM5X,EAC/B,EAIAkgC,EAAK0C,SAAW,SAAShrB,EAAMisB,EAAOhqB,GACpC,IAAIskB,EAASt+B,KAIb,IAFA+X,EAAKqD,aAAe,GACpBrD,EAAKiC,KAAOA,IACH,CACP,IAAIqB,EAAOijB,EAAOC,YAYlB,GAXAD,EAAO2F,WAAW5oB,GACdijB,EAAOj8B,IAAI6zB,EAAGkB,IAChB/b,EAAKxO,KAAOyxB,EAAO4F,iBAAiBF,GAClB,UAAThqB,GAAsBskB,EAAOn+B,OAAS+1B,EAAGgE,KAAQoE,EAAOjsB,QAAQkV,aAAe,GAAK+W,EAAOM,aAAa,MAExF,cAAhBvjB,EAAKT,GAAGza,MAA0B6jC,IAAU1F,EAAOn+B,OAAS+1B,EAAGgE,KAAOoE,EAAOM,aAAa,OAGnGvjB,EAAKxO,KAAO,KAFZyxB,EAAOiB,MAAMjB,EAAOf,WAAY,4DAFhCe,EAAOS,aAMThnB,EAAKqD,aAAa1X,KAAK46B,EAAOkC,WAAWnlB,EAAM,wBAC1CijB,EAAOj8B,IAAI6zB,EAAGU,OAAQ,KAC7B,CACA,OAAO7e,CACT,EAEAsoB,EAAK4D,WAAa,SAAS5oB,GACzBA,EAAKT,GAAK5a,KAAK2jC,mBACf3jC,KAAKkjC,UAAU7nB,EAAKT,IAAI,EAC1B,EAKAylB,EAAK+C,cAAgB,SAASrrB,EAAMosB,EAAaC,EAAqBjB,GACpEnjC,KAAKqkC,aAAatsB,GACd/X,KAAKqS,QAAQkV,aAAe,IAAM4b,IACpCprB,EAAK7U,UAAYlD,KAAKqC,IAAI6zB,EAAG+B,OAC3Bj4B,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAKiP,QAAUmc,GAEE,MAAfgB,IACFA,EAAcnkC,KAAKG,MAAQ+1B,EAAGx0B,MAC5ByiC,IACFpsB,EAAK6C,GAAK5a,KAAK0iC,cAEjB,IAAI4B,EAAWtkC,KAAK89B,YAAayG,EAAavkC,KAAK+9B,QAC/CyG,EAAcxkC,KAAKg+B,SAAUyG,EAAczkC,KAAKi+B,SAAUyG,EAAY1kC,KAAK69B,WAiB/E,OAhBA79B,KAAK89B,YAAc/lB,EAAK7U,UACxBlD,KAAK+9B,QAAUhmB,EAAKiP,MACpBhnB,KAAKg+B,SAAW,EAChBh+B,KAAKi+B,SAAW,EAChBj+B,KAAK69B,YAAa,EAEbsG,GAAenkC,KAAKG,OAAS+1B,EAAGx0B,OACnCqW,EAAK6C,GAAK5a,KAAK0iC,cACjB1iC,KAAK2kC,oBAAoB5sB,GACzB/X,KAAK4kC,kBAAkB7sB,EAAMqsB,GAE7BpkC,KAAK89B,YAAcwG,EACnBtkC,KAAK+9B,QAAUwG,EACfvkC,KAAKg+B,SAAWwG,EAChBxkC,KAAKi+B,SAAWwG,EAChBzkC,KAAK69B,WAAa6G,EACX1kC,KAAKwgC,WAAWzoB,EAAMosB,EAAc,sBAAwB,qBACrE,EAEA9D,EAAKsE,oBAAsB,SAAS5sB,GAClC/X,KAAKs/B,OAAOpJ,EAAGQ,QACf3e,EAAK2C,OAAS1a,KAAK6kC,iBAAiB3O,EAAGS,QAAQ,EAAO32B,KAAKqS,QAAQkV,aAAe,GAAG,GACrFvnB,KAAKmgC,gCACP,EAKAE,EAAKmB,WAAa,SAASzpB,EAAMosB,GAC/B,IAAI7F,EAASt+B,KAEbA,KAAKmE,OACc,MAAfggC,IAAqBA,EAAcnkC,KAAKG,OAAS+1B,EAAGx0B,MACxD1B,KAAK8kC,aAAa/sB,EAAMosB,GACxBnkC,KAAK+kC,gBAAgBhtB,GACrB,IAAIitB,EAAYhlC,KAAKu+B,YACjB0G,GAAiB,EAGrB,IAFAD,EAAU3sB,KAAO,GACjBrY,KAAKs/B,OAAOpJ,EAAGM,SACPx2B,KAAKqC,IAAI6zB,EAAGO,SAClB,IAAI6H,EAAOj8B,IAAI6zB,EAAGW,MAAlB,CACA,IAAIxY,EAASigB,EAAOC,YAChB2G,EAAc5G,EAAOj8B,IAAI6zB,EAAG+B,MAC5BkL,GAAU,EACVgC,EAAgB7G,EAAOn+B,OAAS+1B,EAAGx0B,MAAyB,WAAjB48B,EAAO73B,MACtD63B,EAAO8G,kBAAkB/mB,GACzBA,EAAOC,OAAS6mB,GAAiB7G,EAAOn+B,OAAS+1B,EAAGQ,OAChDrY,EAAOC,SACL4mB,GAAa5G,EAAOS,aACxBmG,EAAc5G,EAAOj8B,IAAI6zB,EAAG+B,MAC5BqG,EAAO8G,kBAAkB/mB,IAEvBigB,EAAOjsB,QAAQkV,aAAe,IAAM2d,IAAgB7mB,EAAO/a,UACvC,eAApB+a,EAAOlC,IAAIhc,MAA6C,UAApBke,EAAOlC,IAAIza,MAAoB48B,EAAOn+B,OAAS+1B,EAAGQ,SACrF4H,EAAOU,uBACVmE,GAAU,EACV7E,EAAO8G,kBAAkB/mB,IAE3BA,EAAOrE,KAAO,SACd,IAAIqrB,GAAW,EACf,IAAKhnB,EAAO/a,SAAU,CACpB,IAAI6Y,EAAMkC,EAAOlC,IACZ+oB,GAAgB/B,GAAwB,eAAbhnB,EAAIhc,MAAyBm+B,EAAOn+B,OAAS+1B,EAAGQ,QAAwB,QAAbva,EAAIza,MAA+B,QAAbya,EAAIza,OACnH2jC,GAAW,EACXhnB,EAAOrE,KAAOmC,EAAIza,KAClBya,EAAMmiB,EAAO8G,kBAAkB/mB,KAE5BA,EAAOC,SAAwB,eAAbnC,EAAIhc,MAAsC,gBAAbgc,EAAIza,MACvC,YAAbya,EAAIhc,MAAoC,gBAAdgc,EAAI1V,SAC5Bw+B,GAAgB3G,EAAOiB,MAAMpjB,EAAItc,MAAO,2CACxCwlC,GAAU/G,EAAOiB,MAAMpjB,EAAItc,MAAO,2CAClCqlC,GAAa5G,EAAOiB,MAAMpjB,EAAItc,MAAO,oCACrCsjC,GAAS7E,EAAOiB,MAAMpjB,EAAItc,MAAO,wCACrCwe,EAAOrE,KAAO,cACdirB,GAAiB,EAErB,CAEA,GADA3G,EAAOgH,iBAAiBN,EAAW3mB,EAAQ6mB,EAAa/B,GACpDkC,EAAU,CACZ,IAAIE,EAA6B,QAAhBlnB,EAAOrE,KAAiB,EAAI,EAC7C,GAAIqE,EAAO5X,MAAMiU,OAAOzZ,SAAWskC,EAAY,CAC7C,IAAI1lC,EAAQwe,EAAO5X,MAAM5G,MACL,QAAhBwe,EAAOrE,KACTskB,EAAOyB,iBAAiBlgC,EAAO,gCAE/By+B,EAAOyB,iBAAiBlgC,EAAO,uCACnC,KACsB,QAAhBwe,EAAOrE,MAAkD,gBAAhCqE,EAAO5X,MAAMiU,OAAO,GAAGva,MAClDm+B,EAAOyB,iBAAiB1hB,EAAO5X,MAAMiU,OAAO,GAAG7a,MAAO,gCAE5D,CAlDiC,CAqDnC,OADAkY,EAAKM,KAAOrY,KAAKwgC,WAAWwE,EAAW,aAChChlC,KAAKwgC,WAAWzoB,EAAMosB,EAAc,mBAAqB,kBAClE,EAEA9D,EAAKiF,iBAAmB,SAASN,EAAW3mB,EAAQ6mB,EAAa/B,GAC/D9kB,EAAO5X,MAAQzG,KAAKwlC,YAAYN,EAAa/B,GAC7C6B,EAAU3sB,KAAK3U,KAAK1D,KAAKwgC,WAAWniB,EAAQ,oBAC9C,EAEAgiB,EAAKyE,aAAe,SAAS/sB,EAAMosB,GACjCpsB,EAAK6C,GAAK5a,KAAKG,OAAS+1B,EAAGx0B,KAAO1B,KAAK0iC,aAAeyB,EAAcnkC,KAAK++B,aAAe,IAC1F,EAEAsB,EAAK0E,gBAAkB,SAAShtB,GAC9BA,EAAKwD,WAAavb,KAAKqC,IAAI6zB,EAAG0D,UAAY55B,KAAKylC,sBAAwB,IACzE,EAIApF,EAAK+B,YAAc,SAASrqB,EAAM7Y,GAChC,IAAIo/B,EAASt+B,KAIb,GAFAA,KAAKmE,OAEDnE,KAAKqC,IAAI6zB,EAAG+B,MAId,OAHAj4B,KAAK8+B,iBAAiB,QACtB/mB,EAAKkF,OAASjd,KAAKG,OAAS+1B,EAAGE,OAASp2B,KAAK0lC,gBAAkB1lC,KAAK++B,aACpE/+B,KAAKk/B,YACEl/B,KAAKwgC,WAAWzoB,EAAM,wBAE/B,GAAI/X,KAAKqC,IAAI6zB,EAAGuC,UAAW,CAEzB,IAAI0K,EACJ,GAFAnjC,KAAK2lC,YAAYzmC,EAAS,UAAWc,KAAKs9B,cAEtCt9B,KAAKG,OAAS+1B,EAAG4C,YAAcqK,EAAUnjC,KAAK+gC,mBAAoB,CACpE,IAAI6E,EAAQ5lC,KAAKu+B,YACjBv+B,KAAKmE,OACDg/B,GAASnjC,KAAKmE,OAClB4T,EAAKipB,YAAchhC,KAAKojC,cAAcwC,EAAO,MAAM,EAAOzC,EAC5D,MAAO,GAAInjC,KAAKG,OAAS+1B,EAAGyD,OAAQ,CAClC,IAAIkM,EAAQ7lC,KAAKu+B,YACjBxmB,EAAKipB,YAAchhC,KAAKwhC,WAAWqE,EAAO,KAC5C,MACE9tB,EAAKipB,YAAchhC,KAAKkkC,mBACxBlkC,KAAKk/B,YAEP,OAAOl/B,KAAKwgC,WAAWzoB,EAAM,2BAC/B,CAEA,GAAI/X,KAAK8lC,6BACP/tB,EAAKipB,YAAchhC,KAAKugC,gBAAe,GACT,wBAA1BxoB,EAAKipB,YAAY7gC,KACnBH,KAAK+lC,oBAAoB7mC,EAAS6Y,EAAKipB,YAAY5lB,cAEnDpb,KAAK2lC,YAAYzmC,EAAS6Y,EAAKipB,YAAYpmB,GAAGlZ,KAAMqW,EAAKipB,YAAYpmB,GAAG/a,OAC1EkY,EAAK4D,WAAa,GAClB5D,EAAKkF,OAAS,SACT,CAGL,GAFAlF,EAAKipB,YAAc,KACnBjpB,EAAK4D,WAAa3b,KAAKgmC,sBAAsB9mC,GACzCc,KAAK6+B,cAAc,QACrB9mB,EAAKkF,OAASjd,KAAKG,OAAS+1B,EAAGE,OAASp2B,KAAK0lC,gBAAkB1lC,KAAK++B,iBAC/D,CAEL,IAAK,IAAI/9B,EAAI,EAAGA,EAAI+W,EAAK4D,WAAW1a,OAAQD,KACtCs9B,EAAO7J,SAAS7xB,KAAKmV,EAAK4D,WAAW3a,GAAGgH,MAAMtG,OAAS48B,EAAOjK,cAAczxB,KAAKmV,EAAK4D,WAAW3a,GAAGgH,MAAMtG,QAC5G48B,EAAOS,WAAWhnB,EAAK4D,WAAW3a,GAAGgH,MAAMnI,OAI/CkY,EAAKkF,OAAS,IAChB,CACAjd,KAAKk/B,WACP,CACA,OAAOl/B,KAAKwgC,WAAWzoB,EAAM,yBAC/B,EAEAsoB,EAAKsF,YAAc,SAASzmC,EAASwC,EAAMzB,GACpCf,IACDK,OAAOC,UAAUC,eAAeC,KAAKR,EAASwC,IAChD1B,KAAK+/B,iBAAiB9/B,EAAK,qBAAuByB,EAAO,KAC3DxC,EAAQwC,IAAQ,EAClB,EAEA2+B,EAAK4F,mBAAqB,SAAS/mC,EAASgnC,GAC1C,IAAI5H,EAASt+B,KAETG,EAAO+lC,EAAI/lC,KACf,GAAY,cAARA,EACFH,KAAK2lC,YAAYzmC,EAASgnC,EAAIxkC,KAAMwkC,EAAIrmC,YACrC,GAAY,iBAARM,EACP,IAAK,IAAIa,EAAI,EAAGA,EAAIklC,EAAItsB,WAAW3Y,SAAUD,EAC3Cs9B,EAAO2H,mBAAmB/mC,EAASgnC,EAAItsB,WAAW5Y,GAAGyF,YACpD,GAAY,gBAARtG,EACP,IAAK,IAAI0jC,EAAM,EAAGA,EAAMqC,EAAIrsB,SAAS5Y,SAAU4iC,EAAK,CAClD,IAAIjlB,EAAMsnB,EAAIrsB,SAASgqB,GACnBjlB,GAAK0f,EAAO2H,mBAAmB/mC,EAAS0f,EAC9C,KACe,qBAARze,EACPH,KAAKimC,mBAAmB/mC,EAASgnC,EAAIvsB,MACtB,2BAARxZ,GACPH,KAAKimC,mBAAmB/mC,EAASgnC,EAAIrrB,WACzC,EAEAwlB,EAAK0F,oBAAsB,SAAS7mC,EAASinC,GAC3C,IAAI7H,EAASt+B,KAEb,GAAKd,EACL,IAAK,IAAI8B,EAAI,EAAGA,EAAImlC,EAAMllC,OAAQD,IAChCs9B,EAAO2H,mBAAmB/mC,EAASinC,EAAMnlC,GAAG4Z,GAChD,EAEAylB,EAAKyF,2BAA6B,WAChC,MAA6B,QAAtB9lC,KAAKG,KAAKq1B,SACU,UAAtBx1B,KAAKG,KAAKq1B,SACY,UAAtBx1B,KAAKG,KAAKq1B,SACY,aAAtBx1B,KAAKG,KAAKq1B,SACVx1B,KAAK2gC,SACL3gC,KAAK+gC,iBACZ,EAIAV,EAAK2F,sBAAwB,SAAS9mC,GACpC,IAAIo/B,EAASt+B,KAETomC,EAAQ,GAAIC,GAAQ,EAGxB,IADArmC,KAAKs/B,OAAOpJ,EAAGM,SACPx2B,KAAKqC,IAAI6zB,EAAGO,SAAS,CAC3B,GAAK4P,EAGEA,GAAQ,OADb,GADA/H,EAAOgB,OAAOpJ,EAAGU,OACb0H,EAAOa,mBAAmBjJ,EAAGO,QAAS,MAG5C,IAAI1e,EAAOumB,EAAOC,YAClBxmB,EAAK/P,MAAQs2B,EAAOoE,YAAW,GAC/B3qB,EAAKuuB,SAAWhI,EAAOO,cAAc,MAAQP,EAAOoE,YAAW,GAAQ3qB,EAAK/P,MAC5Es2B,EAAOqH,YAAYzmC,EAAS6Y,EAAKuuB,SAAS5kC,KAAMqW,EAAKuuB,SAASzmC,OAC9DumC,EAAM1iC,KAAK46B,EAAOkC,WAAWzoB,EAAM,mBACrC,CACA,OAAOquB,CACT,EAIA/F,EAAK8B,YAAc,SAASpqB,GAY1B,OAXA/X,KAAKmE,OAEDnE,KAAKG,OAAS+1B,EAAGE,QACnBre,EAAK4D,WAAa5S,EAClBgP,EAAKkF,OAASjd,KAAK0lC,kBAEnB3tB,EAAK4D,WAAa3b,KAAKumC,wBACvBvmC,KAAK8+B,iBAAiB,QACtB/mB,EAAKkF,OAASjd,KAAKG,OAAS+1B,EAAGE,OAASp2B,KAAK0lC,gBAAkB1lC,KAAK++B,cAEtE/+B,KAAKk/B,YACEl/B,KAAKwgC,WAAWzoB,EAAM,oBAC/B,EAIAsoB,EAAKkG,sBAAwB,WAC3B,IAAIjI,EAASt+B,KAETomC,EAAQ,GAAIC,GAAQ,EACxB,GAAIrmC,KAAKG,OAAS+1B,EAAGx0B,KAAM,CAEzB,IAAIqW,EAAO/X,KAAKu+B,YAIhB,GAHAxmB,EAAK/P,MAAQhI,KAAK0iC,aAClB1iC,KAAKkjC,UAAUnrB,EAAK/P,OAAO,GAC3Bo+B,EAAM1iC,KAAK1D,KAAKwgC,WAAWzoB,EAAM,4BAC5B/X,KAAKqC,IAAI6zB,EAAGU,OAAQ,OAAOwP,CAClC,CACA,GAAIpmC,KAAKG,OAAS+1B,EAAG+B,KAAM,CACzB,IAAIuO,EAASxmC,KAAKu+B,YAMlB,OALAv+B,KAAKmE,OACLnE,KAAK8+B,iBAAiB,MACtB0H,EAAOx+B,MAAQhI,KAAK0iC,aACpB1iC,KAAKkjC,UAAUsD,EAAOx+B,OAAO,GAC7Bo+B,EAAM1iC,KAAK1D,KAAKwgC,WAAWgG,EAAQ,6BAC5BJ,CACT,CAEA,IADApmC,KAAKs/B,OAAOpJ,EAAGM,SACPx2B,KAAKqC,IAAI6zB,EAAGO,SAAS,CAC3B,GAAK4P,EAGEA,GAAQ,OADb,GADA/H,EAAOgB,OAAOpJ,EAAGU,OACb0H,EAAOa,mBAAmBjJ,EAAGO,QAAS,MAG5C,IAAIgQ,EAASnI,EAAOC,YACpBkI,EAAOC,SAAWpI,EAAOoE,YAAW,GAChCpE,EAAOO,cAAc,MACvB4H,EAAOz+B,MAAQs2B,EAAOoE,cAEtB+D,EAAOz+B,MAAQy+B,EAAOC,SAClBpI,EAAOxU,UAAU2c,EAAOz+B,MAAMtG,OAAO48B,EAAOS,WAAW0H,EAAOz+B,MAAMnI,OACpEy+B,EAAOvB,oBAAoBn6B,KAAK6jC,EAAOz+B,MAAMtG,OAAO48B,EAAOyB,iBAAiB0G,EAAOz+B,MAAMnI,MAAO,gBAAkB4mC,EAAOz+B,MAAMtG,KAAO,kBAE5I48B,EAAO4E,UAAUuD,EAAOz+B,OAAO,GAC/Bo+B,EAAM1iC,KAAK46B,EAAOkC,WAAWiG,EAAQ,mBACvC,CACA,OAAOL,CACT,EAEA,IAAIO,EAAOhK,EAAOn9B,UAKlBmnC,EAAK1D,aAAe,SAASlrB,EAAM6uB,GACjC,IAAItI,EAASt+B,KAEb,GAAIA,KAAKqS,QAAQkV,aAAe,GAAKxP,EACnC,OAAQA,EAAK5X,MACX,IAAK,aACDH,KAAK+9B,SAAyB,UAAdhmB,EAAKrW,MACvB1B,KAAKu/B,MAAMxnB,EAAKlY,MAAO,8DACzB,MAEF,IAAK,gBACL,IAAK,eACH,MAEF,IAAK,mBACHkY,EAAK5X,KAAO,gBACZ,IAAK,IAAIa,EAAI,EAAGA,EAAI+W,EAAK6B,WAAW3Y,OAAQD,IAAK,CAC/C,IAAI1B,EAAOyY,EAAK6B,WAAW5Y,GACT,SAAd1B,EAAK0a,MAAiBskB,EAAOiB,MAAMjgC,EAAK6c,IAAItc,MAAO,iDACvDy+B,EAAO2E,aAAa3jC,EAAKmH,MAAOmgC,EAClC,CACA,MAEF,IAAK,kBACH7uB,EAAK5X,KAAO,eACZH,KAAK6mC,iBAAiB9uB,EAAK8B,SAAU+sB,GACrC,MAEF,IAAK,uBACH,GAAsB,MAAlB7uB,EAAK6H,SAKF,CACL5f,KAAKu/B,MAAMxnB,EAAK4B,KAAKzC,IAAK,+DAC1B,KACF,CAPEa,EAAK5X,KAAO,2BACL4X,EAAK6H,SACZ5f,KAAKijC,aAAalrB,EAAK4B,KAAMitB,GAOjC,IAAK,oBACH,MAEF,IAAK,0BACH7uB,EAAK8C,WAAa7a,KAAKijC,aAAalrB,EAAK8C,WAAY+rB,GACrD,MAEF,IAAK,mBACH,IAAKA,EAAW,MAElB,QACE5mC,KAAKu/B,MAAMxnB,EAAKlY,MAAO,uBAG3B,OAAOkY,CACT,EAIA4uB,EAAKE,iBAAmB,SAASC,EAAUF,GACzC,IAAItI,EAASt+B,KAETkX,EAAM4vB,EAAS7lC,OACnB,GAAIiW,EAAK,CACP,IAAI6vB,EAAOD,EAAS5vB,EAAM,GAC1B,GAAI6vB,GAAqB,eAAbA,EAAK5mC,OACb+W,OACG,GAAI6vB,GAAqB,iBAAbA,EAAK5mC,KAAyB,CAC/C4mC,EAAK5mC,KAAO,cACZ,IAAIe,EAAM6lC,EAAKjtB,SACf9Z,KAAKijC,aAAa/hC,EAAK0lC,GACN,eAAb1lC,EAAIf,MAAsC,qBAAbe,EAAIf,MAA4C,iBAAbe,EAAIf,MACtEH,KAAK++B,WAAW79B,EAAIrB,SACpBqX,CACJ,CAEI0vB,GAAaG,GAAsB,gBAAdA,EAAK5mC,MAAiD,eAAvB4mC,EAAKjtB,SAAS3Z,MACpEH,KAAK++B,WAAWgI,EAAKjtB,SAASja,MAClC,CACA,IAAK,IAAImB,EAAI,EAAGA,EAAIkW,EAAKlW,IAAK,CAC5B,IAAI4d,EAAMkoB,EAAS9lC,GACf4d,GAAK0f,EAAO2E,aAAarkB,EAAKgoB,EACpC,CACA,OAAOE,CACT,EAIAH,EAAKK,YAAc,SAASlH,GAC1B,IAAI/nB,EAAO/X,KAAKu+B,YAGhB,OAFAv+B,KAAKmE,OACL4T,EAAK+B,SAAW9Z,KAAKkkC,kBAAiB,EAAOpE,GACtC9/B,KAAKwgC,WAAWzoB,EAAM,gBAC/B,EAEA4uB,EAAKM,UAAY,SAASC,GACxB,IAAInvB,EAAO/X,KAAKu+B,YAOhB,OANAv+B,KAAKmE,OAGc4T,EAAK+B,SAApBotB,EAA+BlnC,KAAKG,OAAS+1B,EAAGx0B,KAAO1B,KAAK0iC,aAAe1iC,KAAK++B,aAC/D/+B,KAAKG,OAAS+1B,EAAGx0B,MAAQ1B,KAAKG,OAAS+1B,EAAGI,SAAWt2B,KAAK2jC,mBAAqB3jC,KAAK++B,aAElG/+B,KAAKwgC,WAAWzoB,EAAM,cAC/B,EAIA4uB,EAAKhD,iBAAmB,WACtB,GAAI3jC,KAAKqS,QAAQkV,YAAc,EAAG,OAAOvnB,KAAK0iC,aAC9C,OAAQ1iC,KAAKG,MACb,KAAK+1B,EAAGx0B,KACN,OAAO1B,KAAK0iC,aAEd,KAAKxM,EAAGI,SACN,IAAIve,EAAO/X,KAAKu+B,YAGhB,OAFAv+B,KAAKmE,OACL4T,EAAK8B,SAAW7Z,KAAK6kC,iBAAiB3O,EAAGK,UAAU,GAAM,GAClDv2B,KAAKwgC,WAAWzoB,EAAM,gBAE/B,KAAKme,EAAGM,OACN,OAAOx2B,KAAKmnC,UAAS,GAEvB,QACEnnC,KAAK++B,aAET,EAEA4H,EAAK9B,iBAAmB,SAASuC,EAAOC,EAAYC,EAAoBJ,GAItE,IAHA,IAAI5I,EAASt+B,KAETunC,EAAO,GAAIlB,GAAQ,GACfrmC,KAAKqC,IAAI+kC,IAGf,GAFIf,EAAOA,GAAQ,EACd/H,EAAOgB,OAAOpJ,EAAGU,OAClByQ,GAAc/I,EAAOn+B,OAAS+1B,EAAGU,MACnC2Q,EAAK7jC,KAAK,UACL,IAAI4jC,GAAsBhJ,EAAOa,mBAAmBiI,GACzD,MACK,GAAI9I,EAAOn+B,OAAS+1B,EAAGe,SAAU,CACtC,IAAIuQ,EAAOlJ,EAAO2I,UAAUC,GAC5B5I,EAAOmJ,qBAAqBD,GAC5BD,EAAK7jC,KAAK8jC,GACNlJ,EAAOn+B,OAAS+1B,EAAGU,OAAO0H,EAAOiB,MAAMjB,EAAOz+B,MAAO,iDACzDy+B,EAAOgB,OAAO8H,GACd,KACF,CACE,IAAIM,EAAOpJ,EAAOqJ,kBAAkBrJ,EAAOz+B,MAAOy+B,EAAOlC,UACzDkC,EAAOmJ,qBAAqBC,GAC5BH,EAAK7jC,KAAKgkC,EACZ,CAEF,OAAOH,CACT,EAEAZ,EAAKc,qBAAuB,SAAS9sB,GACnC,OAAOA,CACT,EAIAgsB,EAAKgB,kBAAoB,SAAS/K,EAAUR,EAAUziB,GAEpD,GADAA,EAAOA,GAAQ3Z,KAAK2jC,mBAChB3jC,KAAKqS,QAAQkV,YAAc,IAAMvnB,KAAKqC,IAAI6zB,EAAGkB,IAAK,OAAOzd,EAC7D,IAAI5B,EAAO/X,KAAK4nC,YAAYhL,EAAUR,GAGtC,OAFArkB,EAAK4B,KAAOA,EACZ5B,EAAKuC,MAAQta,KAAKkkC,mBACXlkC,KAAKwgC,WAAWzoB,EAAM,oBAC/B,EAKA4uB,EAAKzD,UAAY,SAAS9Y,EAAMwc,EAAWiB,GACzC,IAAIvJ,EAASt+B,KAEb,OAAQoqB,EAAKjqB,MACb,IAAK,aACCH,KAAKs0B,QAAUt0B,KAAKg9B,wBAAwBp6B,KAAKwnB,EAAK1oB,OACxD1B,KAAK+/B,iBAAiB3V,EAAKvqB,OAAQ+mC,EAAY,WAAa,iBAAmBxc,EAAK1oB,KAAO,mBACzFmmC,IACEjN,EAAIiN,EAAczd,EAAK1oB,OACzB1B,KAAK+/B,iBAAiB3V,EAAKvqB,MAAO,uBACpCgoC,EAAazd,EAAK1oB,OAAQ,GAE5B,MAEF,IAAK,mBACCklC,GAAW5mC,KAAK+/B,iBAAiB3V,EAAKvqB,OAAQ+mC,EAAY,UAAY,gBAAkB,sBAC5F,MAEF,IAAK,gBACH,IAAK,IAAI5lC,EAAI,EAAGA,EAAIopB,EAAKxQ,WAAW3Y,OAAQD,IAC1Cs9B,EAAO4E,UAAU9Y,EAAKxQ,WAAW5Y,GAAGyF,MAAOmgC,EAAWiB,GACxD,MAEF,IAAK,eACH,IAAK,IAAIhE,EAAM,EAAGA,EAAMzZ,EAAKvQ,SAAS5Y,OAAQ4iC,IAAO,CACnD,IAAI6D,EAAOtd,EAAKvQ,SAASgqB,GACrB6D,GAAMpJ,EAAO4E,UAAUwE,EAAMd,EAAWiB,EAC9C,CACA,MAEF,IAAK,oBACH7nC,KAAKkjC,UAAU9Y,EAAKzQ,KAAMitB,EAAWiB,GACrC,MAEF,IAAK,cACH7nC,KAAKkjC,UAAU9Y,EAAKtQ,SAAU8sB,EAAWiB,GACzC,MAEF,IAAK,0BACH7nC,KAAKkjC,UAAU9Y,EAAKvP,WAAY+rB,EAAWiB,GAC3C,MAEF,QACE7nC,KAAKu/B,MAAMnV,EAAKvqB,OAAQ+mC,EAAY,UAAY,gBAAkB,WAEtE,EAoBA,IAAIkB,EAAOnL,EAAOn9B,UAOlBsoC,EAAKC,eAAiB,SAASzoC,EAAM0oC,GACnC,KAAIhoC,KAAKqS,QAAQkV,aAAe,IAAMjoB,EAAKgE,UAAYhE,EAAK+e,QAAU/e,EAAK2oC,YAA3E,CAEA,IACIvmC,EADAya,EAAM7c,EAAK6c,IAEf,OAAQA,EAAIhc,MACZ,IAAK,aAAcuB,EAAOya,EAAIza,KAAM,MACpC,IAAK,UAAWA,EAAO2T,OAAO8G,EAAI1V,OAAQ,MAC1C,QAAS,OAET,IAAIuT,EAAO1a,EAAK0a,KAChB,GAAIha,KAAKqS,QAAQkV,aAAe,EACjB,cAAT7lB,GAAiC,SAATsY,IACtBguB,EAASriC,OAAO3F,KAAK+/B,iBAAiB5jB,EAAItc,MAAO,sCACrDmoC,EAASriC,OAAQ,OAHrB,CAQA,IAAIuN,EAAQ80B,EADZtmC,EAAO,IAAMA,GAEb,GAAIwR,EAAO,CACT,IAAImyB,EAAoB,SAATrrB,IACVha,KAAKs0B,SAAU+Q,IAAanyB,EAAM8G,KAAWqrB,EAAWnyB,EAAMrG,MACjE7M,KAAK+/B,iBAAiB5jB,EAAItc,MAAO,2BACrC,MACEqT,EAAQ80B,EAAStmC,GAAQ,CACvBmL,MAAM,EACN0X,KAAK,EACL2Q,KAAK,GAGThiB,EAAM8G,IAAQ,CAdd,CAfQ,CA8BV,EAiBA8tB,EAAKxF,gBAAkB,SAAS4F,EAAMpI,GACpC,IAAIxB,EAASt+B,KAET48B,EAAW58B,KAAKH,MAAOu8B,EAAWp8B,KAAKo8B,SACvChS,EAAOpqB,KAAKkkC,iBAAiBgE,EAAMpI,GACvC,GAAI9/B,KAAKG,OAAS+1B,EAAGU,MAAO,CAC1B,IAAI7e,EAAO/X,KAAK4nC,YAAYhL,EAAUR,GAEtC,IADArkB,EAAK2H,YAAc,CAAC0K,GACbpqB,KAAKqC,IAAI6zB,EAAGU,QAAQ7e,EAAK2H,YAAYhc,KAAK46B,EAAO4F,iBAAiBgE,EAAMpI,IAC/E,OAAO9/B,KAAKwgC,WAAWzoB,EAAM,qBAC/B,CACA,OAAOqS,CACT,EAKA0d,EAAK5D,iBAAmB,SAASgE,EAAMpI,EAAwBqI,GAC7D,GAAInoC,KAAK89B,aAAe99B,KAAK4+B,aAAa,SAAU,OAAO5+B,KAAKooC,aAEhE,IAAIC,GAAyB,EAAOC,GAAkB,EAClDxI,GACFwI,EAAiBxI,EAAuBH,oBACxCG,EAAuBH,qBAAuB,IAE9CG,EAAyB,IAAIN,EAC7B6I,GAAyB,GAG3B,IAAIzL,EAAW58B,KAAKH,MAAOu8B,EAAWp8B,KAAKo8B,SACvCp8B,KAAKG,MAAQ+1B,EAAGQ,QAAU12B,KAAKG,MAAQ+1B,EAAGx0B,OAC5C1B,KAAK49B,iBAAmB59B,KAAKH,OAC/B,IAAI8Z,EAAO3Z,KAAKuoC,sBAAsBL,EAAMpI,GAE5C,GADIqI,IAAgBxuB,EAAOwuB,EAAezoC,KAAKM,KAAM2Z,EAAMijB,EAAUR,IACjEp8B,KAAKG,KAAKy1B,SAAU,CACtB51B,KAAK6/B,mBAAmBC,GAAwB,GAC3CuI,GAAwB7I,EAAoB9/B,KAAKogC,GACtD,IAAI/nB,EAAO/X,KAAK4nC,YAAYhL,EAAUR,GAOtC,OANArkB,EAAK6H,SAAW5f,KAAKyG,MACrBsR,EAAK4B,KAAO3Z,KAAKG,OAAS+1B,EAAGkB,GAAKp3B,KAAKijC,aAAatpB,GAAQA,EAC5DmmB,EAAuBL,iBAAmB,EAC1Cz/B,KAAKkjC,UAAUvpB,GACf3Z,KAAKmE,OACL4T,EAAKuC,MAAQta,KAAKkkC,iBAAiBgE,GAC5BloC,KAAKwgC,WAAWzoB,EAAM,uBAC/B,CAIA,OAHMswB,GAAwBroC,KAAKigC,sBAAsBH,GAAwB,GAE7EwI,GAAkB,IAAGxI,EAAuBH,oBAAsB2I,GAC/D3uB,CACT,EAIAmuB,EAAKS,sBAAwB,SAASL,EAAMpI,GAC1C,IAAIlD,EAAW58B,KAAKH,MAAOu8B,EAAWp8B,KAAKo8B,SACvChS,EAAOpqB,KAAKwoC,aAAaN,EAAMpI,GACnC,GAAI9/B,KAAKigC,sBAAsBH,GAAyB,OAAO1V,EAC/D,GAAIpqB,KAAKqC,IAAI6zB,EAAGa,UAAW,CACzB,IAAIhf,EAAO/X,KAAK4nC,YAAYhL,EAAUR,GAKtC,OAJArkB,EAAKnV,KAAOwnB,EACZrS,EAAKuI,WAAatgB,KAAKkkC,mBACvBlkC,KAAKs/B,OAAOpJ,EAAG1yB,OACfuU,EAAKwI,UAAYvgB,KAAKkkC,iBAAiBgE,GAChCloC,KAAKwgC,WAAWzoB,EAAM,wBAC/B,CACA,OAAOqS,CACT,EAIA0d,EAAKU,aAAe,SAASN,EAAMpI,GACjC,IAAIlD,EAAW58B,KAAKH,MAAOu8B,EAAWp8B,KAAKo8B,SACvChS,EAAOpqB,KAAKyoC,gBAAgB3I,GAAwB,GACxD,OAAI9/B,KAAKigC,sBAAsBH,GAAgC1V,EACxDpqB,KAAK0oC,YAAYte,EAAMwS,EAAUR,GAAW,EAAG8L,EACxD,EAQAJ,EAAKY,YAAc,SAAS/uB,EAAMgvB,EAAcC,EAAcC,EAASX,GACrE,IAAIlS,EAAOh2B,KAAKG,KAAK21B,MACrB,GAAY,MAARE,KAAkBkS,GAAQloC,KAAKG,OAAS+1B,EAAGgE,MACzClE,EAAO6S,EAAS,CAClB,IAAIC,EAAU9oC,KAAKG,OAAS+1B,EAAGqB,WAAav3B,KAAKG,OAAS+1B,EAAGsB,WACzDhb,EAAKxc,KAAKyG,MACdzG,KAAKmE,OACL,IAAIy4B,EAAW58B,KAAKH,MAAOu8B,EAAWp8B,KAAKo8B,SACvC9hB,EAAQta,KAAK0oC,YAAY1oC,KAAKyoC,gBAAgB,MAAM,GAAQ7L,EAAUR,EAAUpG,EAAMkS,GACtFnwB,EAAO/X,KAAK+oC,YAAYJ,EAAcC,EAAcjvB,EAAMW,EAAOkC,EAAIssB,GACzE,OAAO9oC,KAAK0oC,YAAY3wB,EAAM4wB,EAAcC,EAAcC,EAASX,EACrE,CAEF,OAAOvuB,CACT,EAEAmuB,EAAKiB,YAAc,SAASnM,EAAUR,EAAUziB,EAAMW,EAAOkC,EAAIssB,GAC/D,IAAI/wB,EAAO/X,KAAK4nC,YAAYhL,EAAUR,GAItC,OAHArkB,EAAK4B,KAAOA,EACZ5B,EAAK6H,SAAWpD,EAChBzE,EAAKuC,MAAQA,EACNta,KAAKwgC,WAAWzoB,EAAM+wB,EAAU,oBAAsB,mBAC/D,EAIAhB,EAAKW,gBAAkB,SAAS3I,EAAwBkJ,GACtD,IAEqD5e,EAFjDkU,EAASt+B,KAET48B,EAAW58B,KAAKH,MAAOu8B,EAAWp8B,KAAKo8B,SAC3C,GAAIp8B,KAAK+9B,SAAW/9B,KAAK4+B,aAAa,SACpCxU,EAAOpqB,KAAKipC,WAAWnJ,GACvBkJ,GAAW,OACN,GAAIhpC,KAAKG,KAAK+pB,OAAQ,CAC3B,IAAInS,EAAO/X,KAAKu+B,YAAawF,EAAS/jC,KAAKG,OAAS+1B,EAAGoB,OACvDvf,EAAK6H,SAAW5f,KAAKyG,MACrBsR,EAAKmS,QAAS,EACdlqB,KAAKmE,OACL4T,EAAK+B,SAAW9Z,KAAKyoC,gBAAgB,MAAM,GAC3CzoC,KAAKigC,sBAAsBH,GAAwB,GAC/CiE,EAAQ/jC,KAAKkjC,UAAUnrB,EAAK+B,UACvB9Z,KAAKs0B,QAA4B,WAAlBvc,EAAK6H,UACG,eAAvB7H,EAAK+B,SAAS3Z,KACrBH,KAAK+/B,iBAAiBhoB,EAAKlY,MAAO,0CAC/BmpC,GAAW,EAChB5e,EAAOpqB,KAAKwgC,WAAWzoB,EAAMgsB,EAAS,mBAAqB,kBAC7D,KAAO,CAEL,GADA3Z,EAAOpqB,KAAKylC,oBAAoB3F,GAC5B9/B,KAAKigC,sBAAsBH,GAAyB,OAAO1V,EAC/D,KAAOpqB,KAAKG,KAAK01B,UAAY71B,KAAKg/B,sBAAsB,CACtD,IAAIwH,EAASlI,EAAOsJ,YAAYhL,EAAUR,GAC1CoK,EAAO5mB,SAAW0e,EAAO73B,MACzB+/B,EAAOtc,QAAS,EAChBsc,EAAO1sB,SAAWsQ,EAClBkU,EAAO4E,UAAU9Y,GACjBkU,EAAOn6B,OACPimB,EAAOkU,EAAOkC,WAAWgG,EAAQ,mBACnC,CACF,CAEA,OAAKwC,GAAYhpC,KAAKqC,IAAI6zB,EAAGiC,UACpBn4B,KAAK+oC,YAAYnM,EAAUR,EAAUhS,EAAMpqB,KAAKyoC,gBAAgB,MAAM,GAAQ,MAAM,GAEpFre,CACX,EAIA0d,EAAKrC,oBAAsB,SAAS3F,GAClC,IAAIlD,EAAW58B,KAAKH,MAAOu8B,EAAWp8B,KAAKo8B,SACvChS,EAAOpqB,KAAK0lC,cAAc5F,GAC1BoJ,EAAoC,4BAAd9e,EAAKjqB,MAA+F,MAAzDH,KAAKmiB,MAAM1e,MAAMzD,KAAKs9B,aAAct9B,KAAKu9B,YAC9G,GAAIv9B,KAAKigC,sBAAsBH,IAA2BoJ,EAAqB,OAAO9e,EACtF,IAAI7lB,EAASvE,KAAKmpC,gBAAgB/e,EAAMwS,EAAUR,GAKlD,OAJI0D,GAA0C,qBAAhBv7B,EAAOpE,OAC/B2/B,EAAuBH,qBAAuBp7B,EAAO1E,QAAOigC,EAAuBH,qBAAuB,GAC1GG,EAAuBF,mBAAqBr7B,EAAO1E,QAAOigC,EAAuBF,mBAAqB,IAErGr7B,CACT,EAEAujC,EAAKqB,gBAAkB,SAASrpC,EAAM88B,EAAUR,EAAUgN,GAKxD,IAJA,IAIS9lC,EAJLg7B,EAASt+B,KAETqpC,EAAkBrpC,KAAKqS,QAAQkV,aAAe,GAAmB,eAAdznB,EAAKK,MAAuC,UAAdL,EAAK4B,MACtF1B,KAAKu9B,YAAcz9B,EAAKoX,MAAQlX,KAAKg/B,uBAEvC,IAAK17B,EAAWg7B,EAAOj8B,IAAI6zB,EAAGI,YAAcgI,EAAOj8B,IAAI6zB,EAAGY,KAAM,CAC9D,IAAI/e,EAAOumB,EAAOsJ,YAAYhL,EAAUR,GACxCrkB,EAAKoF,OAASrd,EACdiY,EAAKqE,SAAW9Y,EAAWg7B,EAAOgE,kBAAoBhE,EAAOoE,YAAW,GACxE3qB,EAAKzU,WAAaA,EACdA,GAAUg7B,EAAOgB,OAAOpJ,EAAGK,UAC/Bz2B,EAAOw+B,EAAOkC,WAAWzoB,EAAM,mBACjC,MAAO,IAAKqxB,GAAW9K,EAAOj8B,IAAI6zB,EAAGQ,QAAS,CAC5C,IAAIoJ,EAAyB,IAAIN,EAAqBgF,EAAclG,EAAON,SAAUyG,EAAcnG,EAAOL,SAC1GK,EAAON,SAAW,EAClBM,EAAOL,SAAW,EAClB,IAAI6I,EAAWxI,EAAOgL,cAAcpT,EAAGS,OAAQ2H,EAAOjsB,QAAQkV,aAAe,GAAG,EAAOuY,GACvF,GAAIuJ,IAAoB/K,EAAOU,sBAAwBV,EAAOj8B,IAAI6zB,EAAG3e,OAKnE,OAJA+mB,EAAOuB,mBAAmBC,GAAwB,GAClDxB,EAAO6B,iCACP7B,EAAON,SAAWwG,EAClBlG,EAAOL,SAAWwG,EACXnG,EAAOiL,qBAAqBjL,EAAOsJ,YAAYhL,EAAUR,GAAW0K,GAAU,GAEvFxI,EAAO2B,sBAAsBH,GAAwB,GACrDxB,EAAON,SAAWwG,GAAelG,EAAON,SACxCM,EAAOL,SAAWwG,GAAenG,EAAOL,SACxC,IAAIuI,EAASlI,EAAOsJ,YAAYhL,EAAUR,GAC1CoK,EAAOl/B,OAASxH,EAChB0mC,EAAOj1B,UAAYu1B,EACnBhnC,EAAOw+B,EAAOkC,WAAWgG,EAAQ,iBACnC,KAAO,IAAIlI,EAAOn+B,OAAS+1B,EAAGgB,UAM5B,OAAOp3B,EALP,IAAI2mC,EAASnI,EAAOsJ,YAAYhL,EAAUR,GAC1CqK,EAAOplB,IAAMvhB,EACb2mC,EAAOrlB,MAAQkd,EAAOkL,gBACtB1pC,EAAOw+B,EAAOkC,WAAWiG,EAAQ,2BAGnC,CAEJ,EAOAqB,EAAKpC,cAAgB,SAAS5F,GAC5B,IAAI/nB,EAAM0xB,EAAazpC,KAAK49B,kBAAoB59B,KAAKH,MACrD,OAAQG,KAAKG,MACb,KAAK+1B,EAAGwD,OACD15B,KAAK69B,YACR79B,KAAKu/B,MAAMv/B,KAAKH,MAAO,wCAE3B,KAAKq2B,EAAGuD,MACN,IAAIt5B,EAAOH,KAAKG,OAAS+1B,EAAGuD,MAAQ,iBAAmB,QAGvD,OAFA1hB,EAAO/X,KAAKu+B,YACZv+B,KAAKmE,OACEnE,KAAKwgC,WAAWzoB,EAAM5X,GAE/B,KAAK+1B,EAAGx0B,KACN,IAAIk7B,EAAW58B,KAAKH,MAAOu8B,EAAWp8B,KAAKo8B,SACvCxhB,EAAK5a,KAAK0iC,WAAW1iC,KAAKG,OAAS+1B,EAAGx0B,MAC1C,GAAI1B,KAAKqS,QAAQkV,aAAe,GAAiB,UAAZ3M,EAAGlZ,OAAqB1B,KAAKg/B,sBAAwBh/B,KAAKqC,IAAI6zB,EAAG4C,WACpG,OAAO94B,KAAKojC,cAAcpjC,KAAK4nC,YAAYhL,EAAUR,IAAW,GAAO,GAAO,GAChF,GAAIqN,IAAezpC,KAAKg/B,qBAAsB,CAC5C,GAAIh/B,KAAKqC,IAAI6zB,EAAG3e,OACd,OAAOvX,KAAKupC,qBAAqBvpC,KAAK4nC,YAAYhL,EAAUR,GAAW,CAACxhB,IAAK,GAC/E,GAAI5a,KAAKqS,QAAQkV,aAAe,GAAiB,UAAZ3M,EAAGlZ,MAAoB1B,KAAKG,OAAS+1B,EAAGx0B,KAI3E,OAHAkZ,EAAK5a,KAAK0iC,cACN1iC,KAAKg/B,sBAAyBh/B,KAAKqC,IAAI6zB,EAAG3e,QAC5CvX,KAAK++B,aACA/+B,KAAKupC,qBAAqBvpC,KAAK4nC,YAAYhL,EAAUR,GAAW,CAACxhB,IAAK,EAEjF,CACA,OAAOA,EAET,KAAKsb,EAAGC,OACN,IAAI1vB,EAAQzG,KAAKyG,MAGjB,OAFAsR,EAAO/X,KAAK0pC,aAAajjC,EAAMA,QAC1BkW,MAAQ,CAACmF,QAASrb,EAAMqb,QAAS6nB,MAAOljC,EAAMkjC,OAC5C5xB,EAET,KAAKme,EAAG5vB,IAAK,KAAK4vB,EAAGE,OACnB,OAAOp2B,KAAK0pC,aAAa1pC,KAAKyG,OAEhC,KAAKyvB,EAAG6D,MAAO,KAAK7D,EAAG8D,MAAO,KAAK9D,EAAG+D,OAKpC,OAJAliB,EAAO/X,KAAKu+B,aACP93B,MAAQzG,KAAKG,OAAS+1B,EAAG6D,MAAQ,KAAO/5B,KAAKG,OAAS+1B,EAAG8D,MAC9DjiB,EAAK6xB,IAAM5pC,KAAKG,KAAKq1B,QACrBx1B,KAAKmE,OACEnE,KAAKwgC,WAAWzoB,EAAM,WAE/B,KAAKme,EAAGQ,OACN,IAAI72B,EAAQG,KAAKH,MAAOuqB,EAAOpqB,KAAK6pC,mCAAmCJ,GAOvE,OANI3J,IACEA,EAAuBH,oBAAsB,IAAM3/B,KAAKogC,qBAAqBhW,KAC/E0V,EAAuBH,oBAAsB9/B,GAC3CigC,EAAuBF,kBAAoB,IAC7CE,EAAuBF,kBAAoB//B,IAExCuqB,EAET,KAAK8L,EAAGI,SAIN,OAHAve,EAAO/X,KAAKu+B,YACZv+B,KAAKmE,OACL4T,EAAK8B,SAAW7Z,KAAKspC,cAAcpT,EAAGK,UAAU,GAAM,EAAMuJ,GACrD9/B,KAAKwgC,WAAWzoB,EAAM,mBAE/B,KAAKme,EAAGM,OACN,OAAOx2B,KAAKmnC,UAAS,EAAOrH,GAE9B,KAAK5J,EAAG4C,UAGN,OAFA/gB,EAAO/X,KAAKu+B,YACZv+B,KAAKmE,OACEnE,KAAKojC,cAAcrrB,GAAM,GAElC,KAAKme,EAAGyD,OACN,OAAO35B,KAAKwhC,WAAWxhC,KAAKu+B,aAAa,GAE3C,KAAKrI,EAAGsD,KACN,OAAOx5B,KAAK8pC,WAEd,KAAK5T,EAAGgB,UACN,OAAOl3B,KAAKwpC,gBAEd,QACExpC,KAAK++B,aAET,EAEA+I,EAAK4B,aAAe,SAASjjC,GAC3B,IAAIsR,EAAO/X,KAAKu+B,YAIhB,OAHAxmB,EAAKtR,MAAQA,EACbsR,EAAK6xB,IAAM5pC,KAAKmiB,MAAM1e,MAAMzD,KAAKH,MAAOG,KAAKkX,KAC7ClX,KAAKmE,OACEnE,KAAKwgC,WAAWzoB,EAAM,UAC/B,EAEA+vB,EAAKlF,qBAAuB,WAC1B5iC,KAAKs/B,OAAOpJ,EAAGQ,QACf,IAAI3uB,EAAM/H,KAAKsiC,kBAEf,OADAtiC,KAAKs/B,OAAOpJ,EAAGS,QACR5uB,CACT,EAEA+/B,EAAK+B,mCAAqC,SAASJ,GACjD,IAEqD1hC,EAFjDu2B,EAASt+B,KAET48B,EAAW58B,KAAKH,MAAOu8B,EAAWp8B,KAAKo8B,SAAekL,EAAqBtnC,KAAKqS,QAAQkV,aAAe,EAC3G,GAAIvnB,KAAKqS,QAAQkV,aAAe,EAAG,CACjCvnB,KAAKmE,OAEL,IAEgH4lC,EAAaC,EAFzHC,EAAgBjqC,KAAKH,MAAOqqC,EAAgBlqC,KAAKo8B,SACjD0K,EAAW,GAAIT,GAAQ,EAAM8D,GAAc,EAC3CrK,EAAyB,IAAIN,EAAqBgF,EAAcxkC,KAAKg+B,SAAUyG,EAAczkC,KAAKi+B,SAGtG,IAFAj+B,KAAKg+B,SAAW,EAChBh+B,KAAKi+B,SAAW,EACTj+B,KAAKG,OAAS+1B,EAAGS,QAAQ,CAE9B,GADA0P,EAAQA,GAAQ,EAAQ/H,EAAOgB,OAAOpJ,EAAGU,OACrC0Q,GAAsBhJ,EAAOa,mBAAmBjJ,EAAGS,QAAQ,GAAO,CACpEwT,GAAc,EACd,KACF,CAAO,GAAI7L,EAAOn+B,OAAS+1B,EAAGe,SAAU,CACtC8S,EAAczL,EAAOz+B,MACrBinC,EAASpjC,KAAK46B,EAAO8L,eAAe9L,EAAO2I,cACvC3I,EAAOn+B,OAAS+1B,EAAGU,OAAO0H,EAAOiB,MAAMjB,EAAOz+B,MAAO,iDACzD,KACF,CACMy+B,EAAOn+B,OAAS+1B,EAAGQ,QAAWsT,IAChCA,EAAkB1L,EAAOz+B,OAE3BinC,EAASpjC,KAAK46B,EAAO4F,kBAAiB,EAAOpE,EAAwBxB,EAAO8L,gBAEhF,CACA,IAAIC,EAAcrqC,KAAKH,MAAOyqC,EAActqC,KAAKo8B,SAGjD,GAFAp8B,KAAKs/B,OAAOpJ,EAAGS,QAEX8S,IAAezpC,KAAKg/B,sBAAwBh/B,KAAKqC,IAAI6zB,EAAG3e,OAM1D,OALAvX,KAAK6/B,mBAAmBC,GAAwB,GAChD9/B,KAAKmgC,iCACD6J,GAAiBhqC,KAAK++B,WAAWiL,GACrChqC,KAAKg+B,SAAWwG,EAChBxkC,KAAKi+B,SAAWwG,EACTzkC,KAAKuqC,oBAAoB3N,EAAUR,EAAU0K,GAGjDA,EAAS7lC,SAAUkpC,GAAanqC,KAAK++B,WAAW/+B,KAAKs9B,cACtDyM,GAAa/pC,KAAK++B,WAAWgL,GACjC/pC,KAAKigC,sBAAsBH,GAAwB,GACnD9/B,KAAKg+B,SAAWwG,GAAexkC,KAAKg+B,SACpCh+B,KAAKi+B,SAAWwG,GAAezkC,KAAKi+B,SAEhC6I,EAAS7lC,OAAS,IACpB8G,EAAM/H,KAAK4nC,YAAYqC,EAAeC,IAClCxqB,YAAconB,EAClB9mC,KAAKwqC,aAAaziC,EAAK,qBAAsBsiC,EAAaC,IAE1DviC,EAAM++B,EAAS,EAEnB,MACE/+B,EAAM/H,KAAK4iC,uBAGb,GAAI5iC,KAAKqS,QAAQspB,eAAgB,CAC/B,IAAI8O,EAAMzqC,KAAK4nC,YAAYhL,EAAUR,GAErC,OADAqO,EAAI5vB,WAAa9S,EACV/H,KAAKwgC,WAAWiK,EAAK,0BAC9B,CACE,OAAO1iC,CAEX,EAEA+/B,EAAKsC,eAAiB,SAASM,GAC7B,OAAOA,CACT,EAEA5C,EAAKyC,oBAAsB,SAAS3N,EAAUR,EAAU0K,GACtD,OAAO9mC,KAAKupC,qBAAqBvpC,KAAK4nC,YAAYhL,EAAUR,GAAW0K,EACzE,EAQA,IAAI6D,EAAU,GAEd7C,EAAKgC,SAAW,WACd,IAAI/xB,EAAO/X,KAAKu+B,YACZqM,EAAO5qC,KAAK0iC,YAAW,GAC3B,GAAI1iC,KAAKqS,QAAQkV,aAAe,GAAKvnB,KAAKqC,IAAI6zB,EAAGY,KAO/C,OANA/e,EAAK6yB,KAAOA,EACZ7yB,EAAKqE,SAAWpc,KAAK0iC,YAAW,GACL,WAAvB3qB,EAAKqE,SAAS1a,MAChB1B,KAAK+/B,iBAAiBhoB,EAAKqE,SAASvc,MAAO,sDACxCG,KAAK69B,YACR79B,KAAK+/B,iBAAiBhoB,EAAKlY,MAAO,4CAC7BG,KAAKwgC,WAAWzoB,EAAM,gBAE/B,IAAI6kB,EAAW58B,KAAKH,MAAOu8B,EAAWp8B,KAAKo8B,SAI3C,OAHArkB,EAAKzQ,OAAStH,KAAKmpC,gBAAgBnpC,KAAK0lC,gBAAiB9I,EAAUR,GAAU,GACzEp8B,KAAKqC,IAAI6zB,EAAGQ,QAAS3e,EAAKxG,UAAYvR,KAAKspC,cAAcpT,EAAGS,OAAQ32B,KAAKqS,QAAQkV,aAAe,GAAG,GAClGxP,EAAKxG,UAAYo5B,EACf3qC,KAAKwgC,WAAWzoB,EAAM,gBAC/B,EAIA+vB,EAAK+C,qBAAuB,WAC1B,IAAInD,EAAO1nC,KAAKu+B,YAOhB,OANAmJ,EAAKjhC,MAAQ,CACXmjC,IAAK5pC,KAAKmiB,MAAM1e,MAAMzD,KAAKH,MAAOG,KAAKkX,KAAKxB,QAAQ,SAAU,MAC9Do1B,OAAQ9qC,KAAKyG,OAEfzG,KAAKmE,OACLujC,EAAKqD,KAAO/qC,KAAKG,OAAS+1B,EAAGgB,UACtBl3B,KAAKwgC,WAAWkH,EAAM,kBAC/B,EAEAI,EAAK0B,cAAgB,WACnB,IAAIlL,EAASt+B,KAET+X,EAAO/X,KAAKu+B,YAChBv+B,KAAKmE,OACL4T,EAAK2H,YAAc,GACnB,IAAIsrB,EAAShrC,KAAK6qC,uBAElB,IADA9yB,EAAKkzB,OAAS,CAACD,IACPA,EAAOD,MACbzM,EAAOgB,OAAOpJ,EAAGiB,cACjBpf,EAAK2H,YAAYhc,KAAK46B,EAAOgE,mBAC7BhE,EAAOgB,OAAOpJ,EAAGO,QACjB1e,EAAKkzB,OAAOvnC,KAAKsnC,EAAS1M,EAAOuM,wBAGnC,OADA7qC,KAAKmE,OACEnE,KAAKwgC,WAAWzoB,EAAM,kBAC/B,EAIA+vB,EAAKX,SAAW,SAAS+D,EAAWpL,GAClC,IAAIxB,EAASt+B,KAET+X,EAAO/X,KAAKu+B,YAAa8H,GAAQ,EAAM2B,EAAW,CAAC,EAGvD,IAFAjwB,EAAK6B,WAAa,GAClB5Z,KAAKmE,QACGnE,KAAKqC,IAAI6zB,EAAGO,SAAS,CAC3B,GAAK4P,EAGEA,GAAQ,OADb,GADA/H,EAAOgB,OAAOpJ,EAAGU,OACb0H,EAAOa,mBAAmBjJ,EAAGO,QAAS,MAG5C,IAA+ByO,EAAa/B,EAASvG,EAAUR,EAA3D98B,EAAOg/B,EAAOC,YACdD,EAAOjsB,QAAQkV,aAAe,IAChCjoB,EAAK+e,QAAS,EACd/e,EAAK2oC,WAAY,GACbiD,GAAapL,KACflD,EAAW0B,EAAOz+B,MAClBu8B,EAAWkC,EAAOlC,UAEf8O,IACHhG,EAAc5G,EAAOj8B,IAAI6zB,EAAG+B,QAEhCqG,EAAO8G,kBAAkB9lC,GACpB4rC,KAAa5M,EAAOjsB,QAAQkV,aAAe,IAAM2d,GAAgB5lC,EAAKgE,UACrD,eAAlBhE,EAAK6c,IAAIhc,MAA2C,UAAlBb,EAAK6c,IAAIza,MAAoB48B,EAAOn+B,OAAS+1B,EAAGQ,QAClF4H,EAAOn+B,OAAS+1B,EAAG1yB,OAAU86B,EAAOU,qBAItCmE,GAAU,GAHVA,GAAU,EACV7E,EAAO8G,kBAAkB9lC,EAAMwgC,IAIjCxB,EAAO6M,mBAAmB7rC,EAAM4rC,EAAWhG,EAAa/B,EAASvG,EAAUR,EAAU0D,GACrFxB,EAAOyJ,eAAezoC,EAAM0oC,GAC5BjwB,EAAK6B,WAAWlW,KAAK46B,EAAOkC,WAAWlhC,EAAM,YAC/C,CACA,OAAOU,KAAKwgC,WAAWzoB,EAAMmzB,EAAY,gBAAkB,mBAC7D,EAEApD,EAAKqD,mBAAqB,SAAS7rC,EAAM4rC,EAAWhG,EAAa/B,EAASvG,EAAUR,EAAU0D,GAI5F,IAHKoF,GAAe/B,IAAYnjC,KAAKG,OAAS+1B,EAAG1yB,OAC/CxD,KAAK++B,aAEH/+B,KAAKqC,IAAI6zB,EAAG1yB,OACdlE,EAAKmH,MAAQykC,EAAYlrC,KAAK2nC,kBAAkB3nC,KAAKH,MAAOG,KAAKo8B,UAAYp8B,KAAKkkC,kBAAiB,EAAOpE,GAC1GxgC,EAAK0a,KAAO,YACP,GAAIha,KAAKqS,QAAQkV,aAAe,GAAKvnB,KAAKG,OAAS+1B,EAAGQ,OACvDwU,GAAWlrC,KAAK++B,aACpBz/B,EAAK0a,KAAO,OACZ1a,EAAK+e,QAAS,EACd/e,EAAKmH,MAAQzG,KAAKwlC,YAAYN,EAAa/B,QACtC,GAAInjC,KAAKqS,QAAQkV,aAAe,IAAMjoB,EAAKgE,UAA8B,eAAlBhE,EAAK6c,IAAIhc,OACzC,QAAlBb,EAAK6c,IAAIza,MAAoC,QAAlBpC,EAAK6c,IAAIza,OACpC1B,KAAKG,MAAQ+1B,EAAGU,OAAS52B,KAAKG,MAAQ+1B,EAAGO,OAAS,EACxDyO,GAAe/B,GAAW+H,IAAWlrC,KAAK++B,aAC9Cz/B,EAAK0a,KAAO1a,EAAK6c,IAAIza,KACrB1B,KAAKolC,kBAAkB9lC,GACvBA,EAAKmH,MAAQzG,KAAKwlC,aAAY,GAC9B,IAAID,EAA2B,QAAdjmC,EAAK0a,KAAiB,EAAI,EAC3C,GAAI1a,EAAKmH,MAAMiU,OAAOzZ,SAAWskC,EAAY,CAC3C,IAAI1lC,EAAQP,EAAKmH,MAAM5G,MACL,QAAdP,EAAK0a,KACPha,KAAK+/B,iBAAiBlgC,EAAO,gCAE7BG,KAAK+/B,iBAAiBlgC,EAAO,uCACjC,KACoB,QAAdP,EAAK0a,MAAgD,gBAA9B1a,EAAKmH,MAAMiU,OAAO,GAAGva,MAC9CH,KAAK+/B,iBAAiBzgC,EAAKmH,MAAMiU,OAAO,GAAG7a,MAAO,gCAExD,MAAWG,KAAKqS,QAAQkV,aAAe,IAAMjoB,EAAKgE,UAA8B,eAAlBhE,EAAK6c,IAAIhc,OACjEH,KAAKy0B,SAAS7xB,KAAKtD,EAAK6c,IAAIza,QAC3B1B,KAAKs0B,OAASt0B,KAAK+8B,oBAAsB/8B,KAAKq0B,eAAezxB,KAAKtD,EAAK6c,IAAIza,OAC3E1B,KAAK89B,aAAgC,SAAjBx+B,EAAK6c,IAAIza,MAC7B1B,KAAK+9B,SAA4B,SAAjBz+B,EAAK6c,IAAIza,OAC5B1B,KAAK+/B,iBAAiBzgC,EAAK6c,IAAItc,MAAO,IAAMP,EAAK6c,IAAIza,KAAO,2CAC9DpC,EAAK0a,KAAO,OACRkxB,EACF5rC,EAAKmH,MAAQzG,KAAK2nC,kBAAkB/K,EAAUR,EAAU98B,EAAK6c,KACpDnc,KAAKG,OAAS+1B,EAAGkB,IAAM0I,GAC5BA,EAAuBL,gBAAkB,IAC3CK,EAAuBL,gBAAkBz/B,KAAKH,OAChDP,EAAKmH,MAAQzG,KAAK2nC,kBAAkB/K,EAAUR,EAAU98B,EAAK6c,MAE7D7c,EAAKmH,MAAQnH,EAAK6c,IAEpB7c,EAAK2oC,WAAY,GACZjoC,KAAK++B,YACd,EAEA+I,EAAK1C,kBAAoB,SAAS9lC,GAChC,GAAIU,KAAKqS,QAAQkV,aAAe,EAAG,CACjC,GAAIvnB,KAAKqC,IAAI6zB,EAAGI,UAId,OAHAh3B,EAAKgE,UAAW,EAChBhE,EAAK6c,IAAMnc,KAAKkkC,mBAChBlkC,KAAKs/B,OAAOpJ,EAAGK,UACRj3B,EAAK6c,IAEZ7c,EAAKgE,UAAW,CAEpB,CACA,OAAOhE,EAAK6c,IAAMnc,KAAKG,OAAS+1B,EAAG5vB,KAAOtG,KAAKG,OAAS+1B,EAAGE,OAASp2B,KAAK0lC,gBAAkB1lC,KAAK0iC,YAAW,EAC7G,EAIAoF,EAAKzD,aAAe,SAAStsB,GAC3BA,EAAK6C,GAAK,KACN5a,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAK7U,WAAY,EACjB6U,EAAK8C,YAAa,GAEhB7a,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAKiP,OAAQ,EACjB,EAIA8gB,EAAKtC,YAAc,SAASN,EAAa/B,GACvC,IAAIprB,EAAO/X,KAAKu+B,YAAa+F,EAAWtkC,KAAK89B,YAAayG,EAAavkC,KAAK+9B,QACxEyG,EAAcxkC,KAAKg+B,SAAUyG,EAAczkC,KAAKi+B,SAAUyG,EAAY1kC,KAAK69B,WAwB/E,OAtBA79B,KAAKqkC,aAAatsB,GACd/X,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAK7U,UAAYgiC,GACfllC,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAKiP,QAAUmc,GAEjBnjC,KAAK89B,YAAc/lB,EAAK7U,UACxBlD,KAAK+9B,QAAUhmB,EAAKiP,MACpBhnB,KAAKg+B,SAAW,EAChBh+B,KAAKi+B,SAAW,EAChBj+B,KAAK69B,YAAa,EAElB79B,KAAKs/B,OAAOpJ,EAAGQ,QACf3e,EAAK2C,OAAS1a,KAAK6kC,iBAAiB3O,EAAGS,QAAQ,EAAO32B,KAAKqS,QAAQkV,aAAe,GAClFvnB,KAAKmgC,iCACLngC,KAAK4kC,kBAAkB7sB,GAAM,GAE7B/X,KAAK89B,YAAcwG,EACnBtkC,KAAK+9B,QAAUwG,EACfvkC,KAAKg+B,SAAWwG,EAChBxkC,KAAKi+B,SAAWwG,EAChBzkC,KAAK69B,WAAa6G,EACX1kC,KAAKwgC,WAAWzoB,EAAM,qBAC/B,EAIA+vB,EAAKyB,qBAAuB,SAASxxB,EAAM2C,EAAQyoB,GACjD,IAAImB,EAAWtkC,KAAK89B,YAAayG,EAAavkC,KAAK+9B,QAC/CyG,EAAcxkC,KAAKg+B,SAAUyG,EAAczkC,KAAKi+B,SAAUyG,EAAY1kC,KAAK69B,WAoB/E,OAlBA79B,KAAKqkC,aAAatsB,GACd/X,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAKiP,QAAUmc,GAEjBnjC,KAAK89B,aAAc,EACnB99B,KAAK+9B,QAAUhmB,EAAKiP,MACpBhnB,KAAKg+B,SAAW,EAChBh+B,KAAKi+B,SAAW,EAChBj+B,KAAK69B,YAAa,EAElB9lB,EAAK2C,OAAS1a,KAAK6mC,iBAAiBnsB,GAAQ,GAC5C1a,KAAK4kC,kBAAkB7sB,GAAM,GAE7B/X,KAAK89B,YAAcwG,EACnBtkC,KAAK+9B,QAAUwG,EACfvkC,KAAKg+B,SAAWwG,EAChBxkC,KAAKi+B,SAAWwG,EAChBzkC,KAAK69B,WAAa6G,EACX1kC,KAAKwgC,WAAWzoB,EAAM,0BAC/B,EAIA+vB,EAAKlD,kBAAoB,SAAS7sB,EAAMqzB,GACtC,IAAIC,EAAeD,GAAmBprC,KAAKG,OAAS+1B,EAAGM,OACnD8U,EAAYtrC,KAAKs0B,OAAQiX,GAAY,EAEzC,GAAIF,EACFtzB,EAAKM,KAAOrY,KAAKkkC,mBACjBnsB,EAAK8C,YAAa,MACb,CACL,IAAI2wB,EAAYxrC,KAAKqS,QAAQkV,aAAe,IAAMvnB,KAAKyrC,kBAAkB1zB,EAAK2C,QACzE4wB,IAAaE,IAChBD,EAAYvrC,KAAK29B,gBAAgB39B,KAAKkX,OAIrBs0B,GACfxrC,KAAK+/B,iBAAiBhoB,EAAKlY,MAAO,6EAItC,IAAI6rC,EAAY1rC,KAAKk+B,OACrBl+B,KAAKk+B,OAAS,GACVqN,IAAWvrC,KAAKs0B,QAAS,GAC7Bvc,EAAKM,KAAOrY,KAAKiiC,YAAW,GAC5BlqB,EAAK8C,YAAa,EAClB7a,KAAKk+B,OAASwN,CAChB,CAEIJ,GAAaC,GACfvrC,KAAKs0B,QAAS,EACVvc,EAAK6C,IACP5a,KAAKkjC,UAAUnrB,EAAK6C,IAAI,GAC1B5a,KAAK2rC,YAAY5zB,GACjB/X,KAAKs0B,OAASgX,IACLF,GAAoBprC,KAAKyrC,kBAAkB1zB,EAAK2C,SACzD1a,KAAK2rC,YAAY5zB,EAErB,EAEA+vB,EAAK2D,kBAAoB,SAAS/wB,GAChC,IAAK,IAAI1Z,EAAI,EAAGA,EAAI0Z,EAAOzZ,OAAQD,IACjC,GAAuB,eAAnB0Z,EAAO1Z,GAAGb,KAAuB,OAAO,EAC9C,OAAO,CACT,EAKA2nC,EAAK6D,YAAc,SAAS5zB,GAI1B,IAHA,IAAIumB,EAASt+B,KAET4rC,EAAW,CAAC,EACP5qC,EAAI,EAAGA,EAAI+W,EAAK2C,OAAOzZ,OAAQD,IAAKs9B,EAAO4E,UAAUnrB,EAAK2C,OAAO1Z,IAAI,EAAM4qC,EACtF,EAQA9D,EAAKwB,cAAgB,SAASlC,EAAOE,EAAoBD,EAAYvH,GAInE,IAHA,IAAIxB,EAASt+B,KAETunC,EAAO,GAAIlB,GAAQ,GACfrmC,KAAKqC,IAAI+kC,IAAQ,CACvB,GAAKf,EAGEA,GAAQ,OADb,GADA/H,EAAOgB,OAAOpJ,EAAGU,OACb0Q,GAAsBhJ,EAAOa,mBAAmBiI,GAAQ,MAG9D,IAAIxoB,EACAyoB,GAAc/I,EAAOn+B,OAAS+1B,EAAGU,MACnChY,EAAM,KACC0f,EAAOn+B,OAAS+1B,EAAGe,UAC1BrY,EAAM0f,EAAO0I,YAAYlH,GACrBA,GAA0BxB,EAAOn+B,OAAS+1B,EAAGU,OAASkJ,EAAuBJ,cAAgB,IAC/FI,EAAuBJ,cAAgBpB,EAAOz+B,QAEhD+e,EAAM0f,EAAO4F,kBAAiB,EAAOpE,GAEvCyH,EAAK7jC,KAAKkb,EACZ,CACA,OAAO2oB,CACT,EAMAO,EAAKpF,WAAa,SAASmJ,GACzB,IAAI9zB,EAAO/X,KAAKu+B,YAkBhB,OAjBIsN,GAAyC,SAA9B7rC,KAAKqS,QAAQgpB,gBAA0BwQ,GAAU,GAC5D7rC,KAAKG,OAAS+1B,EAAGx0B,OACdmqC,IAAY7rC,KAAKs0B,OAASt0B,KAAK+8B,oBAAsB/8B,KAAKq0B,eAAezxB,KAAK5C,KAAKyG,SACnFzG,KAAKqS,QAAQkV,aAAe,IAC6B,GAAzDvnB,KAAKmiB,MAAM1e,MAAMzD,KAAKH,MAAOG,KAAKkX,KAAK1U,QAAQ,QAClDxC,KAAK+/B,iBAAiB//B,KAAKH,MAAO,gBAAkBG,KAAKyG,MAAQ,iBAC/DzG,KAAK89B,aAA8B,UAAf99B,KAAKyG,OAC3BzG,KAAK+/B,iBAAiB//B,KAAKH,MAAO,wDAChCG,KAAK+9B,SAA0B,UAAf/9B,KAAKyG,OACvBzG,KAAK+/B,iBAAiB//B,KAAKH,MAAO,8DACpCkY,EAAKrW,KAAO1B,KAAKyG,OACRolC,GAAW7rC,KAAKG,KAAKq1B,QAC9Bzd,EAAKrW,KAAO1B,KAAKG,KAAKq1B,QAEtBx1B,KAAK++B,aAEP/+B,KAAKmE,OACEnE,KAAKwgC,WAAWzoB,EAAM,aAC/B,EAIA+vB,EAAKM,WAAa,WACXpoC,KAAKg+B,WAAUh+B,KAAKg+B,SAAWh+B,KAAKH,OAEzC,IAAIkY,EAAO/X,KAAKu+B,YAShB,OARAv+B,KAAKmE,OACDnE,KAAKG,MAAQ+1B,EAAGW,MAAQ72B,KAAKg/B,sBAAyBh/B,KAAKG,MAAQ+1B,EAAG+B,OAASj4B,KAAKG,KAAKu1B,YAC3F3d,EAAKyJ,UAAW,EAChBzJ,EAAK+B,SAAW,OAEhB/B,EAAKyJ,SAAWxhB,KAAKqC,IAAI6zB,EAAG+B,MAC5BlgB,EAAK+B,SAAW9Z,KAAKkkC,oBAEhBlkC,KAAKwgC,WAAWzoB,EAAM,kBAC/B,EAEA+vB,EAAKmB,WAAa,WACXjpC,KAAKi+B,WAAUj+B,KAAKi+B,SAAWj+B,KAAKH,OAEzC,IAAIkY,EAAO/X,KAAKu+B,YAGhB,OAFAv+B,KAAKmE,OACL4T,EAAK+B,SAAW9Z,KAAKyoC,gBAAgB,MAAM,GACpCzoC,KAAKwgC,WAAWzoB,EAAM,kBAC/B,EAEA,IAAI+zB,EAAOnP,EAAOn9B,UAQlBssC,EAAKvM,MAAQ,SAASt/B,EAAK6W,GACzB,IAAIylB,EAAMtB,EAAYj7B,KAAKmiB,MAAOliB,GAClC6W,GAAW,KAAOylB,EAAI9N,KAAO,IAAM8N,EAAIxB,OAAS,IAChD,IAAI3N,EAAM,IAAI2e,YAAYj1B,GAE1B,MADAsW,EAAIntB,IAAMA,EAAKmtB,EAAImP,IAAMA,EAAKnP,EAAI4e,SAAWhsC,KAAKC,IAC5CmtB,CACR,EAEA0e,EAAK/L,iBAAmB+L,EAAKvM,MAE7BuM,EAAK3O,YAAc,WACjB,GAAIn9B,KAAKqS,QAAQipB,UACf,OAAO,IAAIT,EAAS76B,KAAKgyB,QAAShyB,KAAKC,IAAMD,KAAK8xB,UAEtD,EAEA,IAAIma,EAAO,SAAcC,EAAQjsC,EAAKs8B,GACpCv8B,KAAKG,KAAO,GACZH,KAAKH,MAAQI,EACbD,KAAKkX,IAAM,EACPg1B,EAAO75B,QAAQipB,YACjBt7B,KAAKu8B,IAAM,IAAIvB,EAAekR,EAAQ3P,IACpC2P,EAAO75B,QAAQ8Z,mBACjBnsB,KAAK2kB,WAAaunB,EAAO75B,QAAQ8Z,kBAC/B+f,EAAO75B,QAAQopB,SACjBz7B,KAAKw8B,MAAQ,CAACv8B,EAAK,GACvB,EAIIksC,EAAOxP,EAAOn9B,UAYlB,SAASgrC,EAAazyB,EAAM5X,EAAMF,EAAKs8B,GAOrC,OANAxkB,EAAK5X,KAAOA,EACZ4X,EAAKb,IAAMjX,EACPD,KAAKqS,QAAQipB,YACfvjB,EAAKwkB,IAAIrlB,IAAMqlB,GACbv8B,KAAKqS,QAAQopB,SACf1jB,EAAKykB,MAAM,GAAKv8B,GACX8X,CACT,CAlBAo0B,EAAK5N,UAAY,WACf,OAAO,IAAI0N,EAAKjsC,KAAMA,KAAKH,MAAOG,KAAKo8B,SACzC,EAEA+P,EAAKvE,YAAc,SAAS3nC,EAAKs8B,GAC/B,OAAO,IAAI0P,EAAKjsC,KAAMC,EAAKs8B,EAC7B,EAcA4P,EAAK3L,WAAa,SAASzoB,EAAM5X,GAC/B,OAAOqqC,EAAa9qC,KAAKM,KAAM+X,EAAM5X,EAAMH,KAAKu9B,WAAYv9B,KAAKo9B,cACnE,EAIA+O,EAAK3B,aAAe,SAASzyB,EAAM5X,EAAMF,EAAKs8B,GAC5C,OAAOiO,EAAa9qC,KAAKM,KAAM+X,EAAM5X,EAAMF,EAAKs8B,EAClD,EAMA,IAAI6P,EAAa,SAAoBpQ,EAAOqQ,EAAQC,EAAeloB,GACjEpkB,KAAKg8B,MAAQA,EACbh8B,KAAKqsC,SAAWA,EAChBrsC,KAAKssC,gBAAkBA,EACvBtsC,KAAKokB,SAAWA,CAClB,EAEIziB,EAAQ,CACV4qC,OAAQ,IAAIH,EAAW,KAAK,GAC5BI,OAAQ,IAAIJ,EAAW,KAAK,GAC5BK,OAAQ,IAAIL,EAAW,MAAM,GAC7BM,OAAQ,IAAIN,EAAW,KAAK,GAC5BO,OAAQ,IAAIP,EAAW,KAAK,GAC5BQ,OAAQ,IAAIR,EAAW,KAAK,GAAM,GAAM,SAAUplC,GAAK,OAAOA,EAAE6lC,eAAiB,IACjFC,OAAQ,IAAIV,EAAW,YAAY,IAGjCW,EAAOpQ,EAAOn9B,UAElButC,EAAKvP,eAAiB,WACpB,MAAO,CAAC77B,EAAM4qC,OAChB,EAEAQ,EAAKC,aAAe,SAASC,GAC3B,GAAIA,IAAa/W,EAAG1yB,MAAO,CACzB,IAAI4G,EAASpK,KAAKktC,aAClB,GAAI9iC,IAAWzI,EAAM4qC,QAAUniC,IAAWzI,EAAM6qC,OAC9C,OAAQpiC,EAAOiiC,MACnB,CACA,OAAIY,IAAa/W,EAAG8C,QACXuB,EAAU33B,KAAK5C,KAAKmiB,MAAM1e,MAAMzD,KAAKu9B,WAAYv9B,KAAKH,QAC3DotC,IAAa/W,EAAGyC,OAASsU,IAAa/W,EAAGW,MAAQoW,IAAa/W,EAAGG,KAAO4W,IAAa/W,EAAGS,SAExFsW,GAAY/W,EAAGM,OACVx2B,KAAKktC,eAAiBvrC,EAAM4qC,QAC7BvsC,KAAKy9B,YACf,EAEAsP,EAAKhX,cAAgB,SAASkX,GAC5B,IAAIlJ,EAAQ5jC,EAAOH,KAAKG,KACpBA,EAAKq1B,SAAWyX,GAAY/W,EAAGY,IACjC92B,KAAKy9B,aAAc,GACZsG,EAAS5jC,EAAK41B,eACrBgO,EAAOrkC,KAAKM,KAAMitC,GAElBjtC,KAAKy9B,YAAct9B,EAAKs1B,UAC5B,EAIAS,EAAGS,OAAOZ,cAAgBG,EAAGO,OAAOV,cAAgB,WAClD,GAA2B,GAAvB/1B,KAAK6W,QAAQ5V,OAAjB,CAIA,IAAI6d,EAAM9e,KAAK6W,QAAQwN,MACnBvF,IAAQnd,EAAM4qC,QAAUvsC,KAAKktC,eAAiBvrC,EAAMmrC,QACtD9sC,KAAK6W,QAAQwN,MACbrkB,KAAKy9B,aAAc,GACV3e,IAAQnd,EAAM8qC,OACvBzsC,KAAKy9B,aAAc,EAEnBz9B,KAAKy9B,aAAe3e,EAAIutB,MAR1B,MAFErsC,KAAKy9B,aAAc,CAYvB,EAEAvH,EAAGM,OAAOT,cAAgB,SAASkX,GACjCjtC,KAAK6W,QAAQnT,KAAK1D,KAAKgtC,aAAaC,GAAYtrC,EAAM4qC,OAAS5qC,EAAM6qC,QACrExsC,KAAKy9B,aAAc,CACrB,EAEAvH,EAAGiB,aAAapB,cAAgB,WAC9B/1B,KAAK6W,QAAQnT,KAAK/B,EAAM8qC,QACxBzsC,KAAKy9B,aAAc,CACrB,EAEAvH,EAAGQ,OAAOX,cAAgB,SAASkX,GACjC,IAAIE,EAAkBF,IAAa/W,EAAG6C,KAAOkU,IAAa/W,EAAG2C,MAAQoU,IAAa/W,EAAGqD,OAAS0T,IAAa/W,EAAGoD,OAC9Gt5B,KAAK6W,QAAQnT,KAAKypC,EAAkBxrC,EAAM+qC,OAAS/qC,EAAMgrC,QACzD3sC,KAAKy9B,aAAc,CACrB,EAEAvH,EAAGoB,OAAOvB,cAAgB,WACxB,EAGFG,EAAG4C,UAAU/C,cAAgB,SAASkX,GAChCA,EAASxX,YAAcwX,IAAa/W,EAAGW,MAAQoW,IAAa/W,EAAGyC,QAC5DsU,IAAa/W,EAAG1yB,OAASypC,IAAa/W,EAAGM,QAAWx2B,KAAKktC,eAAiBvrC,EAAM4qC,SACrFvsC,KAAK6W,QAAQnT,KAAK/B,EAAMmrC,QAC1B9sC,KAAKy9B,aAAc,CACrB,EAEAvH,EAAGgB,UAAUnB,cAAgB,WACvB/1B,KAAKktC,eAAiBvrC,EAAMirC,OAC9B5sC,KAAK6W,QAAQwN,MAEbrkB,KAAK6W,QAAQnT,KAAK/B,EAAMirC,QAC1B5sC,KAAKy9B,aAAc,CACrB,EAMA,IAAI2P,EAAQ,SAAepmC,GACzBhH,KAAKG,KAAO6G,EAAE7G,KACdH,KAAKyG,MAAQO,EAAEP,MACfzG,KAAKH,MAAQmH,EAAEnH,MACfG,KAAKkX,IAAMlQ,EAAEkQ,IACTlQ,EAAEqL,QAAQipB,YACZt7B,KAAKu8B,IAAM,IAAIvB,EAAeh0B,EAAGA,EAAEo1B,SAAUp1B,EAAEq1B,SAC7Cr1B,EAAEqL,QAAQopB,SACZz7B,KAAKw8B,MAAQ,CAACx1B,EAAEnH,MAAOmH,EAAEkQ,KAC7B,EAIIm2B,GAAO1Q,EAAOn9B,UAGd8tC,GAA6B,iBAAZC,UAAoE,wBAA5ChuC,OAAOC,UAAUyN,SAASvN,KAAK6tC,UAgW5E,SAASC,GAAgBC,EAAK9D,EAAO+D,EAAcxB,GACjD,IACE,OAAO,IAAIh2B,OAAOu3B,EAAK9D,EAMzB,CALE,MAAOxxB,GACP,QAAqBw1B,IAAjBD,EAEF,MADIv1B,aAAa4zB,aAAaG,EAAO3M,MAAMmO,EAAc,qCAAuCv1B,EAAErB,SAC5FqB,CAEV,CACF,CArWAk1B,GAAKlpC,KAAO,WACNnE,KAAKqS,QAAQkpB,SACfv7B,KAAKqS,QAAQkpB,QAAQ,IAAI6R,EAAMptC,OAEjCA,KAAKu9B,WAAav9B,KAAKkX,IACvBlX,KAAKs9B,aAAet9B,KAAKH,MACzBG,KAAKo9B,cAAgBp9B,KAAKq8B,OAC1Br8B,KAAKq9B,gBAAkBr9B,KAAKo8B,SAC5Bp8B,KAAKw+B,WACP,EAEA6O,GAAKO,SAAW,WAEd,OADA5tC,KAAKmE,OACE,IAAIipC,EAAMptC,KACnB,EAGsB,qBAAXsV,SACT+3B,GAAK/3B,OAAOu4B,UAAY,WACtB,IAAIztC,EAAOJ,KACX,MAAO,CAACmE,KAAM,WACZ,IAAI63B,EAAQ57B,EAAKwtC,WACjB,MAAO,CACLpgB,KAAMwO,EAAM77B,OAAS+1B,EAAGG,IACxB5vB,MAAOu1B,EAEX,EACF,GAKFqR,GAAKH,WAAa,WAChB,OAAOltC,KAAK6W,QAAQ7W,KAAK6W,QAAQ5V,OAAS,EAC5C,EAKAosC,GAAK7O,UAAY,WACf,IAAI0O,EAAaltC,KAAKktC,aAKtB,OAJKA,GAAeA,EAAWZ,eAAetsC,KAAK8tC,YAEnD9tC,KAAKH,MAAQG,KAAKC,IACdD,KAAKqS,QAAQipB,YAAWt7B,KAAKo8B,SAAWp8B,KAAKm9B,eAC7Cn9B,KAAKC,KAAOD,KAAKmiB,MAAMlhB,OAAejB,KAAK+tC,YAAY7X,EAAGG,KAE1D6W,EAAW9oB,SAAiB8oB,EAAW9oB,SAASpkB,WAC/CA,KAAKguC,UAAUhuC,KAAKiuC,oBAC3B,EAEAZ,GAAKW,UAAY,SAAS/Y,GAGxB,OAAIE,EAAkBF,EAAMj1B,KAAKqS,QAAQkV,aAAe,IAAe,KAAT0N,EACrDj1B,KAAKkuC,WAEPluC,KAAKmuC,iBAAiBlZ,EAC/B,EAEAoY,GAAKY,kBAAoB,WACvB,IAAIhZ,EAAOj1B,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,KACtC,OAAIg1B,GAAQ,OAAUA,GAAQ,MAAeA,GAErCA,GAAQ,IADLj1B,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,GACf,QAC/B,EAEAotC,GAAKe,iBAAmB,WACtB,IAQM5nC,EARF83B,EAASt+B,KAETo8B,EAAWp8B,KAAKqS,QAAQmpB,WAAax7B,KAAKm9B,cAC1Ct9B,EAAQG,KAAKC,IAAKiX,EAAMlX,KAAKmiB,MAAM3f,QAAQ,KAAMxC,KAAKC,KAAO,GAGjE,IAFa,IAATiX,GAAYlX,KAAKu/B,MAAMv/B,KAAKC,IAAM,EAAG,wBACzCD,KAAKC,IAAMiX,EAAM,EACblX,KAAKqS,QAAQipB,UAGf,IAFAd,EAAW5L,UAAY/uB,GAEf2G,EAAQg0B,EAAWpuB,KAAKpM,KAAKmiB,SAAW3b,EAAMqoB,MAAQ7uB,KAAKC,OAC/Dq+B,EAAOtM,QACTsM,EAAOxM,UAAYtrB,EAAMqoB,MAAQroB,EAAM,GAAGvF,OAG1CjB,KAAKqS,QAAQmpB,WACfx7B,KAAKqS,QAAQmpB,WAAU,EAAMx7B,KAAKmiB,MAAM1e,MAAM5D,EAAQ,EAAGqX,GAAMrX,EAAOG,KAAKC,IACpDm8B,EAAUp8B,KAAKm9B,cAC1C,EAEAkQ,GAAKlP,gBAAkB,SAASkQ,GAM9B,IALA,IAAI/P,EAASt+B,KAETH,EAAQG,KAAKC,IACbm8B,EAAWp8B,KAAKqS,QAAQmpB,WAAax7B,KAAKm9B,cAC1Cx6B,EAAK3C,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,KAAKouC,GAClCruC,KAAKC,IAAMD,KAAKmiB,MAAMlhB,QAAiB,KAAP0B,GAAoB,KAAPA,GAAoB,OAAPA,GAAsB,OAAPA,KAC5E27B,EAAOr+B,IACT0C,EAAK27B,EAAOnc,MAAM7Y,WAAWg1B,EAAOr+B,KAElCD,KAAKqS,QAAQmpB,WACfx7B,KAAKqS,QAAQmpB,WAAU,EAAOx7B,KAAKmiB,MAAM1e,MAAM5D,EAAQwuC,EAAWruC,KAAKC,KAAMJ,EAAOG,KAAKC,IAClEm8B,EAAUp8B,KAAKm9B,cAC1C,EAKAkQ,GAAKS,UAAY,WACf,IAAIxP,EAASt+B,KAEbsuC,EAAM,KAAOtuC,KAAKC,IAAMD,KAAKmiB,MAAMlhB,QAAQ,CACzC,IAAI0B,EAAK27B,EAAOnc,MAAM7Y,WAAWg1B,EAAOr+B,KACxC,OAAQ0C,GACN,KAAK,GAAI,KAAK,MACV27B,EAAOr+B,IACT,MACF,KAAK,GAC6C,KAA5Cq+B,EAAOnc,MAAM7Y,WAAWg1B,EAAOr+B,IAAM,MACrCq+B,EAAOr+B,IAEb,KAAK,GAAI,KAAK,KAAM,KAAK,OACrBq+B,EAAOr+B,IACLq+B,EAAOjsB,QAAQipB,cACfgD,EAAOtM,QACTsM,EAAOxM,UAAYwM,EAAOr+B,KAE5B,MACF,KAAK,GACH,OAAQq+B,EAAOnc,MAAM7Y,WAAWg1B,EAAOr+B,IAAM,IAC3C,KAAK,GACHq+B,EAAO8P,mBACP,MACF,KAAK,GACH9P,EAAOH,gBAAgB,GACvB,MACF,QACE,MAAMmQ,EAEV,MACF,QACE,KAAI3rC,EAAK,GAAKA,EAAK,IAAMA,GAAM,MAAQ+3B,EAAmB93B,KAAKyS,OAAO+f,aAAazyB,KAGjF,MAAM2rC,IAFJhQ,EAAOr+B,IAKjB,CACF,EAOAotC,GAAKU,YAAc,SAAS5tC,EAAM4H,GAChC/H,KAAKkX,IAAMlX,KAAKC,IACZD,KAAKqS,QAAQipB,YAAWt7B,KAAKq8B,OAASr8B,KAAKm9B,eAC/C,IAAI8P,EAAWjtC,KAAKG,KACpBH,KAAKG,KAAOA,EACZH,KAAKyG,MAAQsB,EAEb/H,KAAK+1B,cAAckX,EACrB,EAWAI,GAAKkB,cAAgB,WACnB,IAAIpqC,EAAOnE,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,GAC5C,GAAIkE,GAAQ,IAAMA,GAAQ,GAAI,OAAOnE,KAAKwuC,YAAW,GACrD,IAAIC,EAAQzuC,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,GAC7C,OAAID,KAAKqS,QAAQkV,aAAe,GAAc,KAATpjB,GAAyB,KAAVsqC,GAClDzuC,KAAKC,KAAO,EACLD,KAAK+tC,YAAY7X,EAAGe,cAEzBj3B,KAAKC,IACAD,KAAK+tC,YAAY7X,EAAGY,KAE/B,EAEAuW,GAAKqB,gBAAkB,WACrB,IAAIvqC,EAAOnE,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,GAC5C,OAAID,KAAKy9B,eAAgBz9B,KAAKC,IAAYD,KAAK2uC,cAClC,KAATxqC,EAAoBnE,KAAK4uC,SAAS1Y,EAAGmB,OAAQ,GAC1Cr3B,KAAK4uC,SAAS1Y,EAAGgC,MAAO,EACjC,EAEAmV,GAAKwB,0BAA4B,SAAS5Z,GACxC,IAAI9wB,EAAOnE,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,GACxCouB,EAAO,EACPygB,EAAqB,KAAT7Z,EAAciB,EAAG+B,KAAO/B,EAAG8B,OAS3C,OANIh4B,KAAKqS,QAAQkV,aAAe,GAAc,KAATpjB,MACjCkqB,EACFygB,EAAY5Y,EAAGiC,SACfh0B,EAAOnE,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,IAG7B,KAATkE,EAAoBnE,KAAK4uC,SAAS1Y,EAAGmB,OAAQhJ,EAAO,GACjDruB,KAAK4uC,SAASE,EAAWzgB,EAClC,EAEAgf,GAAK0B,mBAAqB,SAAS9Z,GACjC,IAAI9wB,EAAOnE,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,GAC5C,OAAIkE,IAAS8wB,EAAaj1B,KAAK4uC,SAAkB,MAAT3Z,EAAeiB,EAAGqB,UAAYrB,EAAGsB,WAAY,GACxE,KAATrzB,EAAoBnE,KAAK4uC,SAAS1Y,EAAGmB,OAAQ,GAC1Cr3B,KAAK4uC,SAAkB,MAAT3Z,EAAeiB,EAAGuB,UAAYvB,EAAGyB,WAAY,EACpE,EAEA0V,GAAK2B,gBAAkB,WAErB,OAAa,KADFhvC,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,GACpBD,KAAK4uC,SAAS1Y,EAAGmB,OAAQ,GAC1Cr3B,KAAK4uC,SAAS1Y,EAAGwB,WAAY,EACtC,EAEA2V,GAAK4B,mBAAqB,SAASha,GACjC,IAAI9wB,EAAOnE,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,GAC5C,OAAIkE,IAAS8wB,EACC,IAAR9wB,GAAqD,IAAvCnE,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,IAC/Cs6B,EAAU33B,KAAK5C,KAAKmiB,MAAM1e,MAAMzD,KAAKu9B,WAAYv9B,KAAKC,OAExDD,KAAKm+B,gBAAgB,GACrBn+B,KAAK8tC,YACE9tC,KAAKw+B,aAEPx+B,KAAK4uC,SAAS1Y,EAAGoB,OAAQ,GAErB,KAATnzB,EAAoBnE,KAAK4uC,SAAS1Y,EAAGmB,OAAQ,GAC1Cr3B,KAAK4uC,SAAS1Y,EAAG6B,QAAS,EACnC,EAEAsV,GAAK6B,gBAAkB,SAASja,GAC9B,IAAI9wB,EAAOnE,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,GACxCouB,EAAO,EACX,OAAIlqB,IAAS8wB,GACX5G,EAAgB,KAAT4G,GAAuD,KAAxCj1B,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,GAAY,EAAI,EACxB,KAA3CD,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAMouB,GAAqBruB,KAAK4uC,SAAS1Y,EAAGmB,OAAQhJ,EAAO,GACnFruB,KAAK4uC,SAAS1Y,EAAG4B,SAAUzJ,IAExB,IAARlqB,GAAsB,IAAR8wB,GAAqD,IAAvCj1B,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,IACtB,IAAvCD,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,IAC/BD,KAAK09B,UAAU19B,KAAK++B,aAExB/+B,KAAKm+B,gBAAgB,GACrBn+B,KAAK8tC,YACE9tC,KAAKw+B,cAED,KAATr6B,IAAakqB,EAAO,GACjBruB,KAAK4uC,SAAS1Y,EAAG2B,WAAYxJ,GACtC,EAEAgf,GAAK8B,kBAAoB,SAASla,GAChC,IAAI9wB,EAAOnE,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,GAC5C,OAAa,KAATkE,EAAoBnE,KAAK4uC,SAAS1Y,EAAG0B,SAAkD,KAAxC53B,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,GAAY,EAAI,GACvF,KAATg1B,GAAwB,KAAT9wB,GAAenE,KAAKqS,QAAQkV,aAAe,GAC5DvnB,KAAKC,KAAO,EACLD,KAAK+tC,YAAY7X,EAAG3e,QAEtBvX,KAAK4uC,SAAkB,KAAT3Z,EAAciB,EAAGkB,GAAKlB,EAAGhM,OAAQ,EACxD,EAEAmjB,GAAKc,iBAAmB,SAASlZ,GAC/B,OAAQA,GAGR,KAAK,GACH,OAAOj1B,KAAKuuC,gBAGd,KAAK,GAAgB,QAAVvuC,KAAKC,IAAYD,KAAK+tC,YAAY7X,EAAGQ,QAChD,KAAK,GAAgB,QAAV12B,KAAKC,IAAYD,KAAK+tC,YAAY7X,EAAGS,QAChD,KAAK,GAAgB,QAAV32B,KAAKC,IAAYD,KAAK+tC,YAAY7X,EAAGW,MAChD,KAAK,GAAgB,QAAV72B,KAAKC,IAAYD,KAAK+tC,YAAY7X,EAAGU,OAChD,KAAK,GAAgB,QAAV52B,KAAKC,IAAYD,KAAK+tC,YAAY7X,EAAGI,UAChD,KAAK,GAAgB,QAAVt2B,KAAKC,IAAYD,KAAK+tC,YAAY7X,EAAGK,UAChD,KAAK,IAAiB,QAAVv2B,KAAKC,IAAYD,KAAK+tC,YAAY7X,EAAGM,QACjD,KAAK,IAAiB,QAAVx2B,KAAKC,IAAYD,KAAK+tC,YAAY7X,EAAGO,QACjD,KAAK,GAAgB,QAAVz2B,KAAKC,IAAYD,KAAK+tC,YAAY7X,EAAG1yB,OAChD,KAAK,GAAgB,QAAVxD,KAAKC,IAAYD,KAAK+tC,YAAY7X,EAAGa,UAEhD,KAAK,GACH,GAAI/2B,KAAKqS,QAAQkV,YAAc,EAAG,MAElC,QADEvnB,KAAKC,IACAD,KAAK+tC,YAAY7X,EAAGgB,WAE7B,KAAK,GACH,IAAI/yB,EAAOnE,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,IAAM,GAC5C,GAAa,MAATkE,GAAyB,KAATA,EAAa,OAAOnE,KAAKovC,gBAAgB,IAC7D,GAAIpvC,KAAKqS,QAAQkV,aAAe,EAAG,CACjC,GAAa,MAATpjB,GAAyB,KAATA,EAAa,OAAOnE,KAAKovC,gBAAgB,GAC7D,GAAa,KAATjrC,GAAwB,KAATA,EAAa,OAAOnE,KAAKovC,gBAAgB,EAC9D,CAGF,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAAI,KAAK,GAC3E,OAAOpvC,KAAKwuC,YAAW,GAGzB,KAAK,GAAI,KAAK,GACZ,OAAOxuC,KAAKqvC,WAAWpa,GAOzB,KAAK,GACH,OAAOj1B,KAAK0uC,kBAEd,KAAK,GAAI,KAAK,GACZ,OAAO1uC,KAAK6uC,0BAA0B5Z,GAExC,KAAK,IAAK,KAAK,GACb,OAAOj1B,KAAK+uC,mBAAmB9Z,GAEjC,KAAK,GACH,OAAOj1B,KAAKgvC,kBAEd,KAAK,GAAI,KAAK,GACZ,OAAOhvC,KAAKivC,mBAAmBha,GAEjC,KAAK,GAAI,KAAK,GACZ,OAAOj1B,KAAKkvC,gBAAgBja,GAE9B,KAAK,GAAI,KAAK,GACZ,OAAOj1B,KAAKmvC,kBAAkBla,GAEhC,KAAK,IACH,OAAOj1B,KAAK4uC,SAAS1Y,EAAGhM,OAAQ,GAGlClqB,KAAKu/B,MAAMv/B,KAAKC,IAAK,yBAA2BqvC,GAAkBra,GAAQ,IAC5E,EAEAoY,GAAKuB,SAAW,SAASzuC,EAAMkuB,GAC7B,IAAI/rB,EAAMtC,KAAKmiB,MAAM1e,MAAMzD,KAAKC,IAAKD,KAAKC,IAAMouB,GAEhD,OADAruB,KAAKC,KAAOouB,EACLruB,KAAK+tC,YAAY5tC,EAAMmC,EAChC,EAgBA,IAAIitC,KAAyB/B,GAAgB,SAAU,KA4IvD,SAAS8B,GAAkBra,GAEzB,OAAIA,GAAQ,MAAe5f,OAAO+f,aAAaH,IAC/CA,GAAQ,MACD5f,OAAO+f,aAA4B,OAAdH,GAAQ,IAA8B,OAAR,KAAPA,IACrD,CA/IAoY,GAAKsB,WAAa,WAIhB,IAHA,IAEIa,EAASC,EAFTnR,EAASt+B,KAESH,EAAQG,KAAKC,MAC1B,CACHq+B,EAAOr+B,KAAOq+B,EAAOnc,MAAMlhB,QAAQq9B,EAAOiB,MAAM1/B,EAAO,mCAC3D,IAAI8C,EAAK27B,EAAOnc,MAAM5f,OAAO+7B,EAAOr+B,KAEpC,GADIs6B,EAAU33B,KAAKD,IAAK27B,EAAOiB,MAAM1/B,EAAO,mCACvC2vC,EAKEA,GAAU,MALH,CACZ,GAAW,MAAP7sC,EAAY8sC,GAAU,OACrB,GAAW,MAAP9sC,GAAc8sC,EAASA,GAAU,OACrC,GAAW,MAAP9sC,IAAe8sC,EAAS,MACjCD,EAAiB,OAAP7sC,CACZ,GACE27B,EAAOr+B,GACX,CACA,IAAIgM,EAAUjM,KAAKmiB,MAAM1e,MAAM5D,EAAOG,KAAKC,OACzCD,KAAKC,IAGP,IAAIyvC,EAAO1vC,KAAK2vC,YACZC,EAAM3jC,EAAS4jC,EAAW,GAC9B,GAAIH,EAAM,CACR,IAAII,EAAa,WACb9vC,KAAKqS,QAAQkV,aAAe,IAAGuoB,EAAa,cAC3CA,EAAWltC,KAAK8sC,IAAO1vC,KAAKu/B,MAAM1/B,EAAO,mCAC1C6vC,EAAKltC,QAAQ,MAAQ,IACnB+sC,GACFM,EAAW,KAeXD,GALAA,EAAMA,EAAIl6B,QAAQ,0BAA0B,SAAUq6B,EAAQ9a,EAAMzF,GAGlE,OAFAyF,EAAO/uB,OAAO,KAAO+uB,IACV,SAAUqJ,EAAOiB,MAAM1/B,EAAQ2vB,EAAS,EAAG,4BAC/C,GACT,KACU9Z,QAAQ,sDAAuD,KACzEm6B,EAAWA,EAASn6B,QAAQ,IAAK,KAGvC,CAEA,IAAIjP,EAAQ,KASZ,OANK6mC,KACHE,GAAgBoC,EAAKC,EAAUhwC,EAAOG,MAGtCyG,EAAQ+mC,GAAgBvhC,EAASyjC,IAE5B1vC,KAAK+tC,YAAY7X,EAAGC,OAAQ,CAACrU,QAAS7V,EAAS09B,MAAO+F,EAAMjpC,MAAOA,GAC5E,EAMA4mC,GAAK2C,QAAU,SAASC,EAAOC,GAI7B,IAHA,IAAI5R,EAASt+B,KAETH,EAAQG,KAAKC,IAAKkwC,EAAQ,EACrBnvC,EAAI,EAAGmX,EAAW,MAAP+3B,EAAcE,IAAWF,EAAKlvC,EAAImX,IAAKnX,EAAG,CAC5D,IAAgD+G,EAA5CktB,EAAOqJ,EAAOnc,MAAM7Y,WAAWg1B,EAAOr+B,KAK1C,IAJgB8H,EAAZktB,GAAQ,GAAUA,EAAO,GAAK,GACzBA,GAAQ,GAAUA,EAAO,GAAK,GAC9BA,GAAQ,IAAMA,GAAQ,GAAUA,EAAO,GACrCmb,MACAH,EAAO,QAChB3R,EAAOr+B,IACTkwC,EAAQA,EAAQF,EAAQloC,CAC1B,CACA,OAAI/H,KAAKC,MAAQJ,GAAgB,MAAPqwC,GAAelwC,KAAKC,IAAMJ,IAAUqwC,EAAY,KAEnEC,CACT,EAEA9C,GAAK+B,gBAAkB,SAASa,GAC9BjwC,KAAKC,KAAO,EACZ,IAAI8H,EAAM/H,KAAKgwC,QAAQC,GAGvB,OAFW,MAAPloC,GAAa/H,KAAKu/B,MAAMv/B,KAAKH,MAAQ,EAAG,4BAA8BowC,GACtE9a,EAAkBn1B,KAAKiuC,sBAAsBjuC,KAAKu/B,MAAMv/B,KAAKC,IAAK,oCAC/DD,KAAK+tC,YAAY7X,EAAG5vB,IAAKyB,EAClC,EAIAslC,GAAKmB,WAAa,SAAS6B,GACzB,IAAIxwC,EAAQG,KAAKC,IAAKqwC,GAAU,EAAOC,EAA4C,KAApCvwC,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,KACrEowC,GAAsC,OAArBrwC,KAAKgwC,QAAQ,KAAchwC,KAAKu/B,MAAM1/B,EAAO,kBAC/D0wC,GAASvwC,KAAKC,KAAOJ,EAAQ,IAAG0wC,GAAQ,GAC5C,IAAIpsC,EAAOnE,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,KACzB,KAATkE,GAAgBosC,MAChBvwC,KAAKC,IACPD,KAAKgwC,QAAQ,IACbM,GAAU,EACVnsC,EAAOnE,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,MAEtB,KAATkE,GAAwB,MAATA,GAAkBosC,IAEvB,MADbpsC,EAAOnE,KAAKmiB,MAAM7Y,aAAatJ,KAAKC,OACR,KAATkE,KAAenE,KAAKC,IACd,OAArBD,KAAKgwC,QAAQ,KAAchwC,KAAKu/B,MAAM1/B,EAAO,kBACjDywC,GAAU,GAERnb,EAAkBn1B,KAAKiuC,sBAAsBjuC,KAAKu/B,MAAMv/B,KAAKC,IAAK,oCAEtE,IAA6C8H,EAAzCzF,EAAMtC,KAAKmiB,MAAM1e,MAAM5D,EAAOG,KAAKC,KAKvC,OAJIqwC,EAASvoC,EAAMyoC,WAAWluC,GACpBiuC,GAAwB,IAAfjuC,EAAIrB,OACd,OAAO2B,KAAKN,IAAQtC,KAAKs0B,OAAQt0B,KAAKu/B,MAAM1/B,EAAO,kBACvDkI,EAAM0oC,SAASnuC,EAAK,GAFYyF,EAAM0oC,SAASnuC,EAAK,IAGlDtC,KAAK+tC,YAAY7X,EAAG5vB,IAAKyB,EAClC,EAIAslC,GAAKqD,cAAgB,WACnB,IAA0Czb,EAE1C,GAAW,MAFFj1B,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,KAEpB,CACVD,KAAKqS,QAAQkV,YAAc,GAAGvnB,KAAK++B,aACvC,IAAI4R,IAAY3wC,KAAKC,IACrBg1B,EAAOj1B,KAAK4wC,YAAY5wC,KAAKmiB,MAAM3f,QAAQ,IAAKxC,KAAKC,KAAOD,KAAKC,OAC/DD,KAAKC,IACHg1B,EAAO,SAAUj1B,KAAKu/B,MAAMoR,EAAS,2BAC3C,MACE1b,EAAOj1B,KAAK4wC,YAAY,GAE1B,OAAO3b,CACT,EASAoY,GAAKgC,WAAa,SAASwB,GAIzB,IAHA,IAAIvS,EAASt+B,KAET8e,EAAM,GAAIgyB,IAAe9wC,KAAKC,MACzB,CACHq+B,EAAOr+B,KAAOq+B,EAAOnc,MAAMlhB,QAAQq9B,EAAOiB,MAAMjB,EAAOz+B,MAAO,gCAClE,IAAI8C,EAAK27B,EAAOnc,MAAM7Y,WAAWg1B,EAAOr+B,KACxC,GAAI0C,IAAOkuC,EAAO,MACP,KAAPluC,GACFmc,GAAOwf,EAAOnc,MAAM1e,MAAMqtC,EAAYxS,EAAOr+B,KAC7C6e,GAAOwf,EAAOyS,iBAAgB,GAC9BD,EAAaxS,EAAOr+B,MAEhBw6B,EAAU93B,IAAK27B,EAAOiB,MAAMjB,EAAOz+B,MAAO,kCAC5Cy+B,EAAOr+B,IAEb,CAEA,OADA6e,GAAO9e,KAAKmiB,MAAM1e,MAAMqtC,EAAY9wC,KAAKC,OAClCD,KAAK+tC,YAAY7X,EAAGE,OAAQtX,EACrC,EAIAuuB,GAAKR,cAAgB,WAInB,IAHA,IAAIvO,EAASt+B,KAET8e,EAAM,GAAIgyB,EAAa9wC,KAAKC,MACvB,CACHq+B,EAAOr+B,KAAOq+B,EAAOnc,MAAMlhB,QAAQq9B,EAAOiB,MAAMjB,EAAOz+B,MAAO,yBAClE,IAAI8C,EAAK27B,EAAOnc,MAAM7Y,WAAWg1B,EAAOr+B,KACxC,GAAW,KAAP0C,GAAoB,KAAPA,GAAyD,MAA5C27B,EAAOnc,MAAM7Y,WAAWg1B,EAAOr+B,IAAM,GACjE,OAAIq+B,EAAOr+B,MAAQq+B,EAAOz+B,OAASy+B,EAAOn+B,OAAS+1B,EAAGc,SACzC,KAAPr0B,GACF27B,EAAOr+B,KAAO,EACPq+B,EAAOyP,YAAY7X,EAAGiB,kBAE3BmH,EAAOr+B,IACFq+B,EAAOyP,YAAY7X,EAAGgB,aAGjCpY,GAAOwf,EAAOnc,MAAM1e,MAAMqtC,EAAYxS,EAAOr+B,KACtCq+B,EAAOyP,YAAY7X,EAAGc,SAAUlY,IAEzC,GAAW,KAAPnc,EACFmc,GAAOwf,EAAOnc,MAAM1e,MAAMqtC,EAAYxS,EAAOr+B,KAC7C6e,GAAOwf,EAAOyS,iBAAgB,GAC9BD,EAAaxS,EAAOr+B,SACf,GAAIw6B,EAAU93B,GAAK,CAGxB,OAFAmc,GAAOwf,EAAOnc,MAAM1e,MAAMqtC,EAAYxS,EAAOr+B,OAC3Cq+B,EAAOr+B,IACD0C,GACN,KAAK,GACyC,KAAxC27B,EAAOnc,MAAM7Y,WAAWg1B,EAAOr+B,QAAeq+B,EAAOr+B,IAC3D,KAAK,GACH6e,GAAO,KACP,MACF,QACEA,GAAOzJ,OAAO+f,aAAazyB,GAG3B27B,EAAOjsB,QAAQipB,cACfgD,EAAOtM,QACTsM,EAAOxM,UAAYwM,EAAOr+B,KAE5B6wC,EAAaxS,EAAOr+B,GACtB,OACIq+B,EAAOr+B,GAEb,CACF,EAIAotC,GAAK0D,gBAAkB,SAASC,GAC9B,IAAIruC,EAAK3C,KAAKmiB,MAAM7Y,aAAatJ,KAAKC,KAEtC,SADED,KAAKC,IACC0C,GACR,KAAK,IAAK,MAAO,KACjB,KAAK,IAAK,MAAO,KACjB,KAAK,IAAK,OAAO0S,OAAO+f,aAAap1B,KAAK4wC,YAAY,IACtD,KAAK,IAAK,OAAOtB,GAAkBtvC,KAAK0wC,iBACxC,KAAK,IAAK,MAAO,KACjB,KAAK,GAAI,MAAO,KAChB,KAAK,IAAK,MAAO,KACjB,KAAK,IAAK,MAAO,KACjB,KAAK,GAA4C,KAApC1wC,KAAKmiB,MAAM7Y,WAAWtJ,KAAKC,QAAeD,KAAKC,IAC5D,KAAK,GAEH,OADID,KAAKqS,QAAQipB,YAAat7B,KAAK8xB,UAAY9xB,KAAKC,MAAOD,KAAKgyB,SACzD,GACT,QACE,GAAIrvB,GAAM,IAAMA,GAAM,GAAI,CACxB,IAAIsuC,EAAWjxC,KAAKmiB,MAAM+uB,OAAOlxC,KAAKC,IAAM,EAAG,GAAGuG,MAAM,WAAW,GAC/D+pC,EAAQE,SAASQ,EAAU,GAS/B,OARIV,EAAQ,MACVU,EAAWA,EAASxtC,MAAM,GAAI,GAC9B8sC,EAAQE,SAASQ,EAAU,IAEZ,MAAbA,IAAqBjxC,KAAKs0B,QAAU0c,IACtChxC,KAAKu/B,MAAMv/B,KAAKC,IAAM,EAAG,gCAE3BD,KAAKC,KAAOgxC,EAAShwC,OAAS,EACvBoU,OAAO+f,aAAamb,EAC7B,CACA,OAAOl7B,OAAO+f,aAAazyB,GAE/B,EAIA0qC,GAAKuD,YAAc,SAASV,GAC1B,IAAIS,EAAU3wC,KAAKC,IACf+X,EAAIhY,KAAKgwC,QAAQ,GAAIE,GAEzB,OADU,OAANl4B,GAAYhY,KAAKu/B,MAAMoR,EAAS,iCAC7B34B,CACT,EAQAq1B,GAAKsC,UAAY,WACf,IAAIrR,EAASt+B,KAEbA,KAAKi9B,aAAc,EAGnB,IAFA,IAAIx6B,EAAO,GAAI4jC,GAAQ,EAAMyK,EAAa9wC,KAAKC,IAC3CysB,EAAS1sB,KAAKqS,QAAQkV,aAAe,EAClCvnB,KAAKC,IAAMD,KAAKmiB,MAAMlhB,QAAQ,CACnC,IAAI0B,EAAK27B,EAAO2P,oBAChB,GAAI5lB,EAAiB1lB,EAAI+pB,GACvB4R,EAAOr+B,KAAO0C,GAAM,MAAS,EAAI,MAC5B,IAAW,KAAPA,EAaT,MAZA27B,EAAOrB,aAAc,EACrBx6B,GAAQ67B,EAAOnc,MAAM1e,MAAMqtC,EAAYxS,EAAOr+B,KAC9C,IAAIkxC,EAAW7S,EAAOr+B,IACuB,KAAzCq+B,EAAOnc,MAAM7Y,aAAag1B,EAAOr+B,MACnCq+B,EAAOiB,MAAMjB,EAAOr+B,IAAK,+CACzBq+B,EAAOr+B,IACT,IAAImxC,EAAM9S,EAAOoS,iBACXrK,EAAQlR,EAAoB9M,GAAkB+oB,EAAK1kB,IACvD4R,EAAOiB,MAAM4R,EAAU,0BACzB1uC,GAAQ6sC,GAAkB8B,GAC1BN,EAAaxS,EAAOr+B,GAGtB,CACAomC,GAAQ,CACV,CACA,OAAO5jC,EAAOzC,KAAKmiB,MAAM1e,MAAMqtC,EAAY9wC,KAAKC,IAClD,EAKAotC,GAAKa,SAAW,WACd,IAAIzrC,EAAOzC,KAAK2vC,YACZxvC,EAAO+1B,EAAGx0B,KAKd,OAJI1B,KAAKy0B,SAAS7xB,KAAKH,KACjBzC,KAAKi9B,aAAaj9B,KAAK+/B,iBAAiB//B,KAAKH,MAAO,8BAAgC4C,GACxFtC,EAAO81B,EAAaxzB,IAEfzC,KAAK+tC,YAAY5tC,EAAMsC,EAChC,EAuBA,IAAI2xB,GAAU,SASd,SAASxpB,GAAMuX,EAAO9P,GACpB,OAAO,IAAIsqB,EAAOtqB,EAAS8P,GAAOvX,OACpC,CAMA,SAASymC,GAAkBlvB,EAAOliB,EAAKoS,GACrC,IAAIrL,EAAI,IAAI21B,EAAOtqB,EAAS8P,EAAOliB,GAEnC,OADA+G,EAAEw3B,YACKx3B,EAAEs7B,iBACX,CAKA,SAASgP,GAAUnvB,EAAO9P,GACxB,OAAO,IAAIsqB,EAAOtqB,EAAS8P,EAC7B,CAKA,SAASovB,GAAgB3mC,EAAO+xB,EAAQ/V,GACtC1nB,EAAQ+iB,aAAerX,EACvB1L,EAAQsyC,YAAc7U,EACtBz9B,EAAQuyC,aAAe7qB,CACzB,CAEA1nB,EAAQk1B,QAAUA,GAClBl1B,EAAQ0L,MAAQA,GAChB1L,EAAQmyC,kBAAoBA,GAC5BnyC,EAAQoyC,UAAYA,GACpBpyC,EAAQqyC,gBAAkBA,GAC1BryC,EAAQy9B,OAASA,EACjBz9B,EAAQ0nB,QAAUA,EAClB1nB,EAAQ4nB,eAAiBA,EACzB5nB,EAAQ27B,SAAWA,EACnB37B,EAAQ87B,eAAiBA,EACzB97B,EAAQ+7B,YAAcA,EACtB/7B,EAAQ+sC,KAAOA,EACf/sC,EAAQm2B,UAAYA,EACpBn2B,EAAQwyC,SAAWxb,EACnBh3B,EAAQ+2B,aAAeA,EACvB/2B,EAAQktC,WAAaA,EACrBltC,EAAQyyC,YAAchwC,EACtBzC,EAAQmpB,iBAAmBA,EAC3BnpB,EAAQi2B,kBAAoBA,EAC5Bj2B,EAAQkuC,MAAQA,EAChBluC,EAAQu7B,UAAYA,EACpBv7B,EAAQq7B,UAAYA,EACpBr7B,EAAQs7B,WAAaA,EAErBj7B,OAAOqyC,eAAe1yC,EAAS,aAAc,CAAEuH,OAAO,GAEtD,CAv2GiEorC,CAAQ3yC,E,yBCGhE,SAAUA,EAAQ4yC,GAAW,aAGtC,IAAIL,EAAe,CAAC,EAEhBD,EAAc,SAAqBrvB,EAAO9P,GAO5C,QANiB,IAAZA,IAAqBA,EAAU,CAAC,GAErCrS,KAAK+xC,KAAOD,EAAQR,UAAUnvB,EAAO9P,GACrCrS,KAAKqS,QAAUrS,KAAK+xC,KAAK1/B,QACzBrS,KAAKmiB,MAAQniB,KAAK+xC,KAAK5vB,MACvBniB,KAAKgyC,IAAMhyC,KAAK+mC,KAAO,CAAC5mC,KAAM2xC,EAAQJ,SAASrb,IAAKx2B,MAAO,EAAGqX,IAAK,GAC/DlX,KAAKqS,QAAQipB,UAAW,CAC1B,IAAI2W,EAAOjyC,KAAK+xC,KAAK5U,cACrBn9B,KAAKgyC,IAAIzV,IAAM,IAAIuV,EAAQ9W,eAAeh7B,KAAK+xC,KAAME,EAAMA,EAC7D,CACAjyC,KAAKkyC,MAAQ,GACblyC,KAAK6W,QAAU,GACf7W,KAAKmyC,UAAY,EACjBnyC,KAAKoyC,aAAe,EACpBpyC,KAAKqyC,cAAgBryC,KAAKsyC,QAAQtyC,KAAKoyC,cAAgB,EACvDpyC,KAAK+9B,SAAU,EAEf/9B,KAAKqS,QAAQo/B,aAAep/B,EAAQo/B,cAAgB,CAAC,EACrDzxC,KAAKk9B,YAAYl9B,KAAKqS,QAAQo/B,aAChC,EAEAD,EAAYhyC,UAAU++B,UAAY,WAChC,OAAO,IAAIuT,EAAQ7F,KAAKjsC,KAAK+xC,KAAM/xC,KAAKgyC,IAAInyC,MAAOG,KAAKqS,QAAQipB,UAAYt7B,KAAKgyC,IAAIzV,IAAI18B,MAAQ,KACnG,EAEA2xC,EAAYhyC,UAAU+yC,gBAAkB,WACtC,OAAOvyC,KAAKqS,QAAQipB,UAAY,CAACt7B,KAAKgyC,IAAInyC,MAAOG,KAAKgyC,IAAIzV,IAAI18B,OAASG,KAAKgyC,IAAInyC,KAClF,EAEA2xC,EAAYhyC,UAAUooC,YAAc,SAAsB3nC,GACxD,OAAID,KAAKqS,QAAQipB,UACR,IAAIwW,EAAQ7F,KAAKjsC,KAAK+xC,KAAM9xC,EAAI,GAAIA,EAAI,IAExC,IAAI6xC,EAAQ7F,KAAKjsC,KAAK+xC,KAAM9xC,EAEvC,EAEAuxC,EAAYhyC,UAAUghC,WAAa,SAAqBzoB,EAAM5X,GAO5D,OANA4X,EAAK5X,KAAOA,EACZ4X,EAAKb,IAAMlX,KAAK+mC,KAAK7vB,IACjBlX,KAAKqS,QAAQipB,YACfvjB,EAAKwkB,IAAIrlB,IAAMlX,KAAK+mC,KAAKxK,IAAIrlB,KAC3BlX,KAAKqS,QAAQopB,SACf1jB,EAAKykB,MAAM,GAAKx8B,KAAK+mC,KAAK7vB,KACrBa,CACT,EAEAy5B,EAAYhyC,UAAUgzC,UAAY,SAAoBryC,GACpD,IAAIsyC,EAAQzyC,KAAKu+B,YAQjB,OAPAkU,EAAMtyC,KAAOA,EACbsyC,EAAMv7B,IAAMu7B,EAAM5yC,MACdG,KAAKqS,QAAQipB,YACfmX,EAAMlW,IAAIrlB,IAAMu7B,EAAMlW,IAAI18B,OACxBG,KAAKqS,QAAQopB,SACfgX,EAAMjW,MAAM,GAAKiW,EAAM5yC,OACzBG,KAAK+mC,KAAO,CAAC5mC,KAAM2xC,EAAQJ,SAAShwC,KAAM7B,MAAO4yC,EAAM5yC,MAAOqX,IAAKu7B,EAAM5yC,MAAO08B,IAAKkW,EAAMlW,KACpFkW,CACT,EAEAjB,EAAYhyC,UAAUkzC,WAAa,WACjC,IAAID,EAAQzyC,KAAKwyC,UAAU,cAE3B,OADAC,EAAM/wC,KAAO,SACN+wC,CACT,EAEAjB,EAAYhyC,UAAUmzC,YAAc,WAClC,IAAIF,EAAQzyC,KAAKwyC,UAAU,WAE3B,OADAC,EAAMhsC,MAAQgsC,EAAM7I,IAAM,SACnB6I,CACT,EAEAjB,EAAYhyC,UAAU6C,IAAM,SAAclC,GACxC,OAAIH,KAAKgyC,IAAI7xC,OAASA,IACpBH,KAAKmE,QACE,EAIX,EAEAqtC,EAAYhyC,UAAUo/B,aAAe,SAAuBl9B,GAC1D,OAAO1B,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAShwC,MAAQ1B,KAAKgyC,IAAIvrC,QAAU/E,CACvE,EAEA8vC,EAAYhyC,UAAUq/B,cAAgB,SAAwBn9B,GAC5D,OAAO1B,KAAKgyC,IAAIvrC,QAAU/E,GAAQ1B,KAAKqC,IAAIyvC,EAAQJ,SAAShwC,KAC9D,EAEA8vC,EAAYhyC,UAAUw/B,mBAAqB,WACzC,OAAOh/B,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASrb,KAAOr2B,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASjb,QAClFqb,EAAQvX,UAAU33B,KAAK5C,KAAKmiB,MAAM1e,MAAMzD,KAAK+mC,KAAK7vB,IAAKlX,KAAKgyC,IAAInyC,OACpE,EAEA2xC,EAAYhyC,UAAU0/B,UAAY,WAChC,OAAOl/B,KAAKqC,IAAIyvC,EAAQJ,SAAS7a,KACnC,EAEA2a,EAAYhyC,UAAU8/B,OAAS,SAAiBn/B,GAC5C,IAAIm+B,EAASt+B,KAEf,GAAIA,KAAKqC,IAAIlC,GAAO,OAAO,EAC3B,IAAK,IAAIa,EAAI,EAAGA,GAAK,EAAGA,IACtB,GAAIs9B,EAAOsU,UAAU5xC,GAAGb,MAAQA,EAAM,CACpC,IAAK,IAAI0Q,EAAI,EAAGA,EAAI7P,EAAG6P,IAAKytB,EAAOn6B,OACnC,OAAO,CACT,CAEJ,EAEAqtC,EAAYhyC,UAAUqzC,OAAS,WAC7B7yC,KAAK6W,QAAQnT,KAAK1D,KAAKmyC,UACzB,EAEAX,EAAYhyC,UAAUszC,MAAQ,WAC5B9yC,KAAKmyC,UAAYnyC,KAAK6W,QAAQwN,KAChC,EAEAmtB,EAAYhyC,UAAU8yC,QAAU,SAAkBryC,GAChD,KAAOA,EAAMD,KAAKmiB,MAAMlhB,SAAW6wC,EAAQrX,UAAUz6B,KAAKmiB,MAAM7Y,WAAWrJ,OAASA,EACpF,OAAOA,CACT,EAEAuxC,EAAYhyC,UAAUuzC,iBAAmB,SAA2B9yC,GAGlE,IAFE,IAAIq+B,EAASt+B,KAEN2S,EAAQ,KAAM1S,EAAK,CAC1B,IAAI0C,EAAK27B,EAAOnc,MAAM7Y,WAAWrJ,GACjC,GAAW,KAAP0C,IAAagQ,MACZ,IAAW,IAAPhQ,EACJ,OAAOgQ,EADOA,GAAS2rB,EAAOjsB,QAAQ2gC,OAC1B,CACnB,CACF,EAEAxB,EAAYhyC,UAAUyzC,OAAS,SAAiBC,EAAUC,EAAQ1kB,EAAM2kB,GACtE,OAAIpzC,KAAKgyC,IAAI7xC,OAAS+yC,GAAYlzC,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASrb,KAC9D5H,GAAQzuB,KAAKoyC,cAAgBpyC,KAAKmyC,UAAYgB,GAAUnzC,KAAKqzC,qBAChED,GAAkBpzC,KAAKqyC,eAAiBryC,KAAKmiB,MAAMlhB,QACpDjB,KAAK+yC,iBAAiB/yC,KAAKqyC,eAAiBc,EACjD,EAEA3B,EAAYhyC,UAAU6zC,gBAAkB,WAGtC,IAFE,IAAI/U,EAASt+B,KAENgH,EAAIhH,KAAKgyC,IAAInyC,MAAQ,EAAGmH,GAAKhH,KAAKoyC,eAAgBprC,EAAG,CAC5D,IAAIrE,EAAK27B,EAAOnc,MAAM7Y,WAAWtC,GACjC,GAAW,IAAPrE,GAAmB,KAAPA,EAAW,OAAO,CACpC,CACA,OAAO,CACT,EAEA6uC,EAAYhyC,UAAUiO,OAAS,SAAiB/L,EAAMoJ,GACpD9K,KAAK0B,GAAQoJ,EAAE9K,KAAK0B,GACtB,EAEA8vC,EAAYhyC,UAAU09B,YAAc,SAAsBmB,GACtD,IAAIC,EAASt+B,KAEf,IAAK,IAAI0B,KAAQ28B,EAAe,CAC9B,IAAItP,EAAS0iB,EAAa/vC,GAC1B,IAAKqtB,EAAQ,MAAM,IAAIjsB,MAAM,WAAapB,EAAO,eACjDqtB,EAAOuP,EAAQD,EAAc38B,GAC/B,CACF,EAEA,IAAI4xC,EAAK9B,EAAYhyC,UAErB,SAAS+zC,EAAQ5wC,GACf,OAAQA,EAAK,IAAMA,EAAK,GAAa,KAAPA,GAAoB,MAAPA,GAAcmvC,EAAQrX,UAAU93B,EAC7E,CA8GA,SAAS6wC,EAAQz7B,GAAQ,MAAoB,UAAbA,EAAKrW,IAAY,CA5GjD4xC,EAAGnvC,KAAO,WACR,IAAIm6B,EAASt+B,KAQb,GANAA,KAAK+mC,KAAO/mC,KAAKgyC,IACbhyC,KAAKkyC,MAAMjxC,OACbjB,KAAKgyC,IAAMhyC,KAAKkyC,MAAMuB,QAEtBzzC,KAAKgyC,IAAMhyC,KAAKguC,YAEdhuC,KAAKgyC,IAAInyC,OAASG,KAAKqyC,cAAe,CACxC,KAAOryC,KAAKgyC,IAAInyC,OAASG,KAAKqyC,eAC5B/T,EAAO8T,aAAe9T,EAAO+T,cAC7B/T,EAAO+T,cAAgB/T,EAAOgU,QAAQhU,EAAO8T,cAAgB,EAE/DpyC,KAAKmyC,UAAYnyC,KAAK+yC,iBAAiB/yC,KAAKoyC,aAC9C,CACF,EAEAkB,EAAGtF,UAAY,WAGb,IAFA,IAAI1P,EAASt+B,OAGX,IAQE,OAPAs+B,EAAOyT,KAAK5tC,OACRm6B,EAAOyT,KAAK5xC,OAAS2xC,EAAQJ,SAAS5a,KACM,MAA5CwH,EAAOnc,MAAM+uB,OAAO5S,EAAOyT,KAAK76B,IAAK,IACrConB,EAAOjsB,QAAQkV,aAAe,IAChC+W,EAAOyT,KAAK76B,MACZonB,EAAOyT,KAAK5xC,KAAO2xC,EAAQJ,SAASza,UAE/B,IAAI6a,EAAQ1E,MAAM9O,EAAOyT,KA8ClC,CA7CE,MAAM55B,GACN,KAAMA,aAAa4zB,aAAc,MAAM5zB,EAGvC,IAAI+V,EAAM/V,EAAErB,QAAS7W,EAAMkY,EAAE6zB,SAAUt2B,GAAU,EACjD,GAAI,gBAAgB9S,KAAKsrB,GAEvB,GADAjuB,EAAMq+B,EAAOgU,QAAQn6B,EAAElY,IAAM,GACzB,SAAS2C,KAAKsrB,GAChBxY,EAAU,CAAC7V,MAAOsY,EAAElY,IAAKiX,IAAKjX,EAAKE,KAAM2xC,EAAQJ,SAAStb,OAAQ3vB,MAAO63B,EAAOnc,MAAM1e,MAAM0U,EAAElY,IAAM,EAAGA,SAClG,GAAI,gBAAgB2C,KAAKsrB,GAAM,CACpC,IAAIxrB,EAAK47B,EAAOnc,MAAM1e,MAAM0U,EAAElY,IAAKA,GACnC,IAAMyC,EAAK,IAAIwT,OAAOxT,EAAgB,CAAV,MAAMyV,GAAI,CACtCzC,EAAU,CAAC7V,MAAOsY,EAAElY,IAAKiX,IAAKjX,EAAKE,KAAM2xC,EAAQJ,SAASvb,OAAQ1vB,MAAO/D,EAC3E,MACEgT,IADS,WAAW9S,KAAKsrB,IACf,CAACruB,MAAOsY,EAAElY,IAAKiX,IAAKjX,EACnBE,KAAM2xC,EAAQJ,SAAS1a,SACvBvwB,MAAO63B,EAAOnc,MAAM1e,MAAM0U,EAAElY,IAAKA,SAIzC,GAAI,8HAA8H2C,KAAKsrB,GAC5I,KAAOjuB,EAAMD,KAAKmiB,MAAMlhB,SAAWsyC,EAAQvzC,KAAKmiB,MAAM7Y,WAAWrJ,OAASA,OACrE,GAAI,yCAAyC2C,KAAKsrB,GACvD,KAAOjuB,EAAMD,KAAKmiB,MAAMlhB,QAAQ,CAC9B,IAAI0B,EAAK27B,EAAOnc,MAAM7Y,WAAWrJ,KACjC,GAAW,KAAP0C,GAAoB,KAAPA,GAAamvC,EAAQrX,UAAU93B,GAAK,KACvD,MACK,GAAI,wBAAwBC,KAAKsrB,GACtCjuB,IACAyV,GAAU,MACL,KAAI,sBAAsB9S,KAAKsrB,GAGpC,MAAM/V,EAFNzC,GAAU,CAGZ,CAGA,GAFA4oB,EAAOoV,QAAQzzC,IACC,IAAZyV,IAAkBA,EAAU,CAAC7V,MAAOI,EAAKiX,IAAKjX,EAAKE,KAAM2xC,EAAQJ,SAAShwC,KAAM+E,MAAO,WACvFiP,EAMF,OALI4oB,EAAOjsB,QAAQipB,YACjB5lB,EAAQ6mB,IAAM,IAAIuV,EAAQ9W,eACxBsD,EAAOyT,KACPD,EAAQ7W,YAAYqD,EAAOnc,MAAOzM,EAAQ7V,OAC1CiyC,EAAQ7W,YAAYqD,EAAOnc,MAAOzM,EAAQwB,OACvCxB,CAEX,CAEJ,EAEA49B,EAAGI,QAAU,SAASzzC,GACpB,IAAIq+B,EAASt+B,KAEbA,KAAK+xC,KAAK9xC,IAAMA,EAChB,IAQMuG,EARF7D,EAAK3C,KAAKmiB,MAAM5f,OAAOtC,EAAM,GAKjC,GAJAD,KAAK+xC,KAAKtU,aAAe96B,GAAM,8BAA8BC,KAAKD,IAChE,UAAUC,KAAKD,IACf,4EAA4EC,KAAK5C,KAAKmiB,MAAM1e,MAAMxD,EAAM,GAAIA,IAE1GD,KAAKqS,QAAQipB,UAIf,IAHAt7B,KAAK+xC,KAAK/f,QAAU,EACpBhyB,KAAK+xC,KAAKjgB,UAAYggB,EAAQtX,WAAW5L,UAAY,GAE7CpoB,EAAQsrC,EAAQtX,WAAWpuB,KAAKpM,KAAKmiB,SAAW3b,EAAMqoB,MAAQ5uB,KAClEq+B,EAAOyT,KAAK/f,QACdsM,EAAOyT,KAAKjgB,UAAYtrB,EAAMqoB,MAAQroB,EAAM,GAAGvF,MAGrD,EAEAqyC,EAAGV,UAAY,SAAS56B,GAGtB,IAFA,IAAIsmB,EAASt+B,KAENgY,EAAIhY,KAAKkyC,MAAMjxC,QACpBq9B,EAAO4T,MAAMxuC,KAAK46B,EAAO0P,aAC3B,OAAOhuC,KAAKkyC,MAAMl6B,EAAI,EACxB,EAIA,IAAI27B,EAAOnC,EAAYhyC,UAEvBm0C,EAAKlV,cAAgB,WACnB,IAAIH,EAASt+B,KAET+X,EAAO/X,KAAK4nC,YAAY5nC,KAAKqS,QAAQipB,UAAY,CAAC,EAAGwW,EAAQ7W,YAAYj7B,KAAKmiB,MAAO,IAAM,GAE/F,IADApK,EAAKM,KAAO,GACLrY,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASrb,KAAKte,EAAKM,KAAK3U,KAAK46B,EAAOiC,kBAKrE,OAJAvgC,KAAK+mC,KAAO/mC,KAAKgyC,IACbhyC,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAKmjB,WAAal7B,KAAKqS,QAAQ6oB,YAE1Bl7B,KAAKwgC,WAAWzoB,EAAM,UAC/B,EAEA47B,EAAKpT,eAAiB,WACpB,IAEwDvmB,EAFpDskB,EAASt+B,KAETkhC,EAAYlhC,KAAKgyC,IAAI7xC,KAAM4X,EAAO/X,KAAKu+B,YAO3C,OALIv+B,KAAK+xC,KAAKpR,UACZO,EAAY4Q,EAAQJ,SAAStY,KAC7Bpf,EAAO,OAGDknB,GACR,KAAK4Q,EAAQJ,SAAStZ,OAAQ,KAAK0Z,EAAQJ,SAASnZ,UAClDv4B,KAAKmE,OACL,IAAIs+B,EAAUvB,IAAc4Q,EAAQJ,SAAStZ,OAO7C,OANIp4B,KAAKk/B,aAAel/B,KAAKg/B,qBAC3BjnB,EAAKud,MAAQ,MAEbvd,EAAKud,MAAQt1B,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAShwC,KAAO1B,KAAK0iC,aAAe,KAC3E1iC,KAAKk/B,aAEAl/B,KAAKwgC,WAAWzoB,EAAM0qB,EAAU,iBAAmB,qBAE5D,KAAKqP,EAAQJ,SAASlZ,UAGpB,OAFAx4B,KAAKmE,OACLnE,KAAKk/B,YACEl/B,KAAKwgC,WAAWzoB,EAAM,qBAE/B,KAAK+5B,EAAQJ,SAAShZ,IAKpB,OAJA14B,KAAKmE,OACL4T,EAAKM,KAAOrY,KAAKugC,iBACjBxoB,EAAKnV,KAAO5C,KAAKqC,IAAIyvC,EAAQJ,SAASpY,QAAUt5B,KAAK4iC,uBAAyB5iC,KAAK0yC,aACnF1yC,KAAKk/B,YACEl/B,KAAKwgC,WAAWzoB,EAAM,oBAE/B,KAAK+5B,EAAQJ,SAAS7Y,KAIpB,GAHA74B,KAAKmE,OACLnE,KAAK6yC,SACL7yC,KAAKs/B,OAAOwS,EAAQJ,SAAShb,QACzB12B,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAS7a,KAAM,OAAO72B,KAAK6iC,SAAS9qB,EAAM,MACxE,IAAI4oB,EAAQ3gC,KAAK+xC,KAAKpR,QACtB,GAAIA,GAAS3gC,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAStY,MAAQp5B,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASrY,OAAQ,CACjG,IAAIyJ,EAAS9iC,KAAK+iC,UAAS,EAAMpC,EAAQ,MAAQ3gC,KAAKgyC,IAAIvrC,OAC1D,OAAmC,IAA/Bq8B,EAAO1nB,aAAana,QAAiBjB,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASxX,MAAOl6B,KAAK4+B,aAAa,MAG9F5+B,KAAK6iC,SAAS9qB,EAAM+qB,GAFlB9iC,KAAKgjC,WAAWjrB,EAAM+qB,EAGjC,CACA,IAAIj2B,EAAO7M,KAAKsiC,iBAAgB,GAChC,OAAItiC,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASxX,KAAOl6B,KAAK4+B,aAAa,MACvD5+B,KAAKgjC,WAAWjrB,EAAM/X,KAAKijC,aAAap2B,IAC1C7M,KAAK6iC,SAAS9qB,EAAMlL,GAE7B,KAAKilC,EAAQJ,SAAS5Y,UAEpB,OADA94B,KAAKmE,OACEnE,KAAKojC,cAAcrrB,GAAM,GAElC,KAAK+5B,EAAQJ,SAAS3Y,IAKpB,OAJA/4B,KAAKmE,OACL4T,EAAKnV,KAAO5C,KAAK4iC,uBACjB7qB,EAAKuI,WAAatgB,KAAKugC,iBACvBxoB,EAAKwI,UAAYvgB,KAAKqC,IAAIyvC,EAAQJ,SAAS/Y,OAAS34B,KAAKugC,iBAAmB,KACrEvgC,KAAKwgC,WAAWzoB,EAAM,eAE/B,KAAK+5B,EAAQJ,SAAS1Y,QAIpB,OAHAh5B,KAAKmE,OACDnE,KAAKqC,IAAIyvC,EAAQJ,SAAS7a,OAAS72B,KAAKg/B,qBAAsBjnB,EAAK+B,SAAW,MAC3E/B,EAAK+B,SAAW9Z,KAAKsiC,kBAAmBtiC,KAAKk/B,aAC7Cl/B,KAAKwgC,WAAWzoB,EAAM,mBAE/B,KAAK+5B,EAAQJ,SAASzY,QACpB,IAOI7tB,EAPAwoC,EAAc5zC,KAAKmyC,UAAW1jB,EAAOzuB,KAAKoyC,aAQ9C,IAPApyC,KAAKmE,OACL4T,EAAKurB,aAAetjC,KAAK4iC,uBACzB7qB,EAAKwrB,MAAQ,GACbvjC,KAAK6yC,SACL7yC,KAAKs/B,OAAOwS,EAAQJ,SAASlb,SAGrBx2B,KAAKizC,OAAOnB,EAAQJ,SAASjb,OAAQmd,EAAanlB,GAAM,IAC9D,GAAI6P,EAAO0T,IAAI7xC,OAAS2xC,EAAQJ,SAASrZ,OAASiG,EAAO0T,IAAI7xC,OAAS2xC,EAAQJ,SAASjZ,SAAU,CAC/F,IAAIgL,EAASnF,EAAO0T,IAAI7xC,OAAS2xC,EAAQJ,SAASrZ,MAC9CjtB,GAAKkzB,EAAOkC,WAAWp1B,EAAK,cAChC2M,EAAKwrB,MAAM7/B,KAAK0H,EAAMkzB,EAAOC,aAC7BnzB,EAAIkV,WAAa,GACjBge,EAAOn6B,OACKiH,EAAIxI,KAAZ6gC,EAAmBnF,EAAOgE,kBACd,KAChBhE,EAAOgB,OAAOwS,EAAQJ,SAASluC,MACjC,MACO4H,IACH2M,EAAKwrB,MAAM7/B,KAAK0H,EAAMkzB,EAAOC,aAC7BnzB,EAAIkV,WAAa,GACjBlV,EAAIxI,KAAO,MAEbwI,EAAIkV,WAAW5c,KAAK46B,EAAOiC,kBAM/B,OAHIn1B,GAAKpL,KAAKwgC,WAAWp1B,EAAK,cAC9BpL,KAAK8yC,QACL9yC,KAAKqC,IAAIyvC,EAAQJ,SAASjb,QACnBz2B,KAAKwgC,WAAWzoB,EAAM,mBAE/B,KAAK+5B,EAAQJ,SAASxY,OAIpB,OAHAl5B,KAAKmE,OACL4T,EAAK+B,SAAW9Z,KAAKsiC,kBACrBtiC,KAAKk/B,YACEl/B,KAAKwgC,WAAWzoB,EAAM,kBAE/B,KAAK+5B,EAAQJ,SAASvY,KAIpB,GAHAn5B,KAAKmE,OACL4T,EAAKokB,MAAQn8B,KAAKiiC,aAClBlqB,EAAKjW,QAAU,KACX9B,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASpZ,OAAQ,CAC7C,IAAIoL,EAAS1jC,KAAKu+B,YAClBv+B,KAAKmE,OACLnE,KAAKs/B,OAAOwS,EAAQJ,SAAShb,QAC7BgN,EAAO/oB,MAAQ3a,KAAKijC,aAAajjC,KAAK0lC,iBAAiB,GACvD1lC,KAAKs/B,OAAOwS,EAAQJ,SAAS/a,QAC7B+M,EAAOrrB,KAAOrY,KAAKiiC,aACnBlqB,EAAKjW,QAAU9B,KAAKwgC,WAAWkD,EAAQ,cACzC,CAEA,OADA3rB,EAAK6rB,UAAY5jC,KAAKqC,IAAIyvC,EAAQJ,SAAS9Y,UAAY54B,KAAKiiC,aAAe,KACtElqB,EAAKjW,SAAYiW,EAAK6rB,UACpB5jC,KAAKwgC,WAAWzoB,EAAM,gBADgBA,EAAKokB,MAGpD,KAAK2V,EAAQJ,SAAStY,KACtB,KAAK0Y,EAAQJ,SAASrY,OACpB,OAAOr5B,KAAK+iC,UAAS,EAAO/oB,GAAQha,KAAKgyC,IAAIvrC,OAE/C,KAAKqrC,EAAQJ,SAASpY,OAIpB,OAHAt5B,KAAKmE,OACL4T,EAAKnV,KAAO5C,KAAK4iC,uBACjB7qB,EAAKM,KAAOrY,KAAKugC,iBACVvgC,KAAKwgC,WAAWzoB,EAAM,kBAE/B,KAAK+5B,EAAQJ,SAASnY,MAIpB,OAHAv5B,KAAKmE,OACL4T,EAAKoF,OAASnd,KAAK4iC,uBACnB7qB,EAAKM,KAAOrY,KAAKugC,iBACVvgC,KAAKwgC,WAAWzoB,EAAM,iBAE/B,KAAK+5B,EAAQJ,SAASlb,OACpB,OAAOx2B,KAAKiiC,aAEd,KAAK6P,EAAQJ,SAAS7a,KAEpB,OADA72B,KAAKmE,OACEnE,KAAKwgC,WAAWzoB,EAAM,kBAE/B,KAAK+5B,EAAQJ,SAAS/X,OACpB,OAAO35B,KAAKwhC,YAAW,GAEzB,KAAKsQ,EAAQJ,SAAS5X,QACpB,OAAO95B,KAAKmiC,cAEd,KAAK2P,EAAQJ,SAAS7X,QACpB,OAAO75B,KAAKoiC,cAEd,QACE,GAAIpiC,KAAK+xC,KAAKhR,kBAGZ,OAFA/gC,KAAKmE,OACLnE,KAAKmE,OACEnE,KAAKojC,cAAcrrB,GAAM,GAAM,GAExC,IAAIqS,EAAOpqB,KAAKsiC,kBAChB,OAAIkR,EAAQppB,IACVpqB,KAAKmE,OACDnE,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASrb,IAAYr2B,KAAKwgC,WAAWzoB,EAAM,kBAClE/X,KAAKugC,kBACHW,IAAc4Q,EAAQJ,SAAShwC,MAAsB,eAAd0oB,EAAKjqB,MAAyBH,KAAKqC,IAAIyvC,EAAQJ,SAASluC,QACxGuU,EAAKM,KAAOrY,KAAKugC,iBACjBxoB,EAAKud,MAAQlL,EACNpqB,KAAKwgC,WAAWzoB,EAAM,sBAE7BA,EAAK8C,WAAauP,EAClBpqB,KAAKk/B,YACEl/B,KAAKwgC,WAAWzoB,EAAM,wBAGnC,EAEA47B,EAAK1R,WAAa,WAChB,IAAI3D,EAASt+B,KAET+X,EAAO/X,KAAKu+B,YAChBv+B,KAAK6yC,SACL7yC,KAAKs/B,OAAOwS,EAAQJ,SAASlb,QAC7B,IAAIod,EAAc5zC,KAAKmyC,UAAW1jB,EAAOzuB,KAAKoyC,aAE9C,IADAr6B,EAAKM,KAAO,IACJrY,KAAKizC,OAAOnB,EAAQJ,SAASjb,OAAQmd,EAAanlB,GAAM,IAC9D1W,EAAKM,KAAK3U,KAAK46B,EAAOiC,kBAGxB,OAFAvgC,KAAK8yC,QACL9yC,KAAKqC,IAAIyvC,EAAQJ,SAASjb,QACnBz2B,KAAKwgC,WAAWzoB,EAAM,iBAC/B,EAEA47B,EAAK9Q,SAAW,SAAS9qB,EAAMlL,GAQ7B,OAPAkL,EAAKlL,KAAOA,EACZkL,EAAKnV,KAAOmV,EAAKgsB,OAAS,KACtB/jC,KAAKqC,IAAIyvC,EAAQJ,SAAS7a,OAAS72B,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAS7a,OAAM9e,EAAKnV,KAAO5C,KAAKsiC,mBAC7FtiC,KAAKqC,IAAIyvC,EAAQJ,SAAS7a,OAAS72B,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAS/a,SAAQ5e,EAAKgsB,OAAS/jC,KAAKsiC,mBACrGtiC,KAAK8yC,QACL9yC,KAAKs/B,OAAOwS,EAAQJ,SAAS/a,QAC7B5e,EAAKM,KAAOrY,KAAKugC,iBACVvgC,KAAKwgC,WAAWzoB,EAAM,eAC/B,EAEA47B,EAAK3Q,WAAa,SAASjrB,EAAMlL,GAC/B,IAAI1M,EAAOH,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASxX,IAAM,iBAAmB,iBAOvE,OANAl6B,KAAKmE,OACL4T,EAAK4B,KAAO9M,EACZkL,EAAKuC,MAAQta,KAAKsiC,kBAClBtiC,KAAK8yC,QACL9yC,KAAKs/B,OAAOwS,EAAQJ,SAAS/a,QAC7B5e,EAAKM,KAAOrY,KAAKugC,iBACVvgC,KAAKwgC,WAAWzoB,EAAM5X,EAC/B,EAEAwzC,EAAK5Q,SAAW,SAASmF,EAAMluB,GAC7B,IAAIskB,EAASt+B,KAET+X,EAAO/X,KAAKu+B,YAChBxmB,EAAKiC,KAAOA,EACZha,KAAKmE,OACL4T,EAAKqD,aAAe,GACpB,EAAG,CACD,IAAIC,EAAOijB,EAAOC,YAClBljB,EAAKT,GAAK0jB,EAAOjsB,QAAQkV,aAAe,EAAI+W,EAAO2E,aAAa3E,EAAOoH,iBAAiB,GAAQpH,EAAOoE,aACvGrnB,EAAKxO,KAAOyxB,EAAOj8B,IAAIyvC,EAAQJ,SAASta,IAAMkH,EAAO4F,iBAAiBgE,GAAQ,KAC9EnwB,EAAKqD,aAAa1X,KAAK46B,EAAOkC,WAAWnlB,EAAM,sBACjD,OAASrb,KAAKqC,IAAIyvC,EAAQJ,SAAS9a,QACnC,IAAK7e,EAAKqD,aAAana,OAAQ,CAC7B,IAAI4yC,EAAS7zC,KAAKu+B,YAClBsV,EAAOj5B,GAAK5a,KAAK0yC,aACjB36B,EAAKqD,aAAa1X,KAAK1D,KAAKwgC,WAAWqT,EAAQ,sBACjD,CAEA,OADK3L,GAAMloC,KAAKk/B,YACTl/B,KAAKwgC,WAAWzoB,EAAM,sBAC/B,EAEA47B,EAAKnS,WAAa,SAAS2C,GACzB,IAAI7F,EAASt+B,KAET+X,EAAO/X,KAAKu+B,YAChBv+B,KAAKmE,OACc,MAAfggC,IAAqBA,EAAcnkC,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAShwC,MACtE1B,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAShwC,KAAMqW,EAAK6C,GAAK5a,KAAK0iC,aACtC3qB,EAAK6C,GAAlBupB,EAAuBnkC,KAAK0yC,aACtB,KACf36B,EAAKwD,WAAavb,KAAKqC,IAAIyvC,EAAQJ,SAAS9X,UAAY55B,KAAKsiC,kBAAoB,KACjFvqB,EAAKM,KAAOrY,KAAKu+B,YACjBxmB,EAAKM,KAAKA,KAAO,GACjBrY,KAAK6yC,SACL,IAAIM,EAASnzC,KAAKmyC,UAAY,EAAG1jB,EAAOzuB,KAAKoyC,aAG7C,IAFApyC,KAAKqC,IAAIyvC,EAAQJ,SAASlb,QACtBx2B,KAAKmyC,UAAY,EAAIgB,IAAUA,EAASnzC,KAAKmyC,UAAW1jB,EAAOzuB,KAAKoyC,eAChEpyC,KAAKizC,OAAOnB,EAAQJ,SAASjb,OAAQ0c,EAAQ1kB,IACnD,IAAI6P,EAAOY,YAAX,CACA,IAAiCgG,EAAa/B,EAA1C9kB,EAASigB,EAAOC,YAChBD,EAAOjsB,QAAQkV,aAAe,IAChClJ,EAAOC,QAAS,EAChB4mB,EAAc5G,EAAOj8B,IAAIyvC,EAAQJ,SAASzZ,OAE5CqG,EAAO8G,kBAAkB/mB,GACrBm1B,EAAQn1B,EAAOlC,MAAYq3B,EAAQlV,EAAO4F,qBAAqB5F,EAAOn6B,OAAQm6B,EAAOj8B,IAAIyvC,EAAQJ,SAAS9a,SACtF,eAApBvY,EAAOlC,IAAIhc,MAA0Bke,EAAO/a,UAAgC,WAApB+a,EAAOlC,IAAIza,MAClE48B,EAAO0T,IAAI7xC,MAAQ2xC,EAAQJ,SAAShb,QAAU4H,EAAO0T,IAAI7xC,MAAQ2xC,EAAQJ,SAASlb,OAKrFnY,EAAOC,QAAS,GAJhBD,EAAOC,QAAS,EAChB4mB,EAAc5G,EAAOj8B,IAAIyvC,EAAQJ,SAASzZ,MAC1CqG,EAAO8G,kBAAkB/mB,IAItBA,EAAO/a,UACY,eAApB+a,EAAOlC,IAAIhc,MAA6C,UAApBke,EAAOlC,IAAIza,MAAoB48B,EAAO0T,IAAI7xC,OAAS2xC,EAAQJ,SAAShb,QACvG4H,EAAOU,qBAIVmE,GAAU,GAHV7E,EAAO8G,kBAAkB/mB,GACzB8kB,GAAU,GAIR7E,EAAOjsB,QAAQkV,aAAe,GAAyB,eAApBlJ,EAAOlC,IAAIhc,OAC7Cke,EAAO/a,WAAiC,QAApB+a,EAAOlC,IAAIza,MAAsC,QAApB2c,EAAOlC,IAAIza,OAC7D48B,EAAO0T,IAAI7xC,OAAS2xC,EAAQJ,SAAShb,QAAU4H,EAAO0T,IAAI7xC,OAAS2xC,EAAQJ,SAASlb,QACtFnY,EAAOrE,KAAOqE,EAAOlC,IAAIza,KACzB48B,EAAO8G,kBAAkB/mB,GACzBA,EAAO5X,MAAQ63B,EAAOkH,aAAY,KAE7BnnB,EAAO/a,UAAa+a,EAAOC,QAAW4mB,GAAgB/B,KACrC,eAApB9kB,EAAOlC,IAAIhc,MAA6C,gBAApBke,EAAOlC,IAAIza,MACzB,YAApB2c,EAAOlC,IAAIhc,MAA2C,gBAArBke,EAAOlC,IAAI1V,OAG9C4X,EAAOrE,KAAQ,SAFfqE,EAAOrE,KAAO,cAIhBqE,EAAO5X,MAAQ63B,EAAOkH,YAAYN,EAAa/B,IAEjDprB,EAAKM,KAAKA,KAAK3U,KAAK46B,EAAOkC,WAAWniB,EAAQ,qBAxCd,CAmDlC,OATAre,KAAK8yC,QACA9yC,KAAKqC,IAAIyvC,EAAQJ,SAASjb,UAG7Bz2B,KAAK+mC,KAAK7vB,IAAMlX,KAAKgyC,IAAInyC,MACrBG,KAAKqS,QAAQipB,YAAWt7B,KAAK+mC,KAAKxK,IAAIrlB,IAAMlX,KAAKgyC,IAAIzV,IAAI18B,QAE/DG,KAAKk/B,YACLl/B,KAAKwgC,WAAWzoB,EAAKM,KAAM,aACpBrY,KAAKwgC,WAAWzoB,EAAMosB,EAAc,mBAAqB,kBAClE,EAEAwP,EAAKvQ,cAAgB,SAASrrB,EAAMosB,EAAahB,GAC/C,IAAIoB,EAAavkC,KAAK+9B,QAetB,OAdA/9B,KAAKqkC,aAAatsB,GACd/X,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAK7U,UAAYlD,KAAKqC,IAAIyvC,EAAQJ,SAASzZ,OAEzCj4B,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAKiP,QAAUmc,GAEE,MAAfgB,IAAqBA,EAAcnkC,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAShwC,MACtE1B,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAShwC,KAAMqW,EAAK6C,GAAK5a,KAAK0iC,aACnDyB,IAAapsB,EAAK6C,GAAK5a,KAAK0yC,cACrC1yC,KAAK+9B,QAAUhmB,EAAKiP,MACpBjP,EAAK2C,OAAS1a,KAAK2kC,sBACnB5sB,EAAKM,KAAOrY,KAAKiiC,aACjBjiC,KAAK+9B,QAAUwG,EACRvkC,KAAKwgC,WAAWzoB,EAAMosB,EAAc,sBAAwB,qBACrE,EAEAwP,EAAKvR,YAAc,WACjB,IAAIrqB,EAAO/X,KAAKu+B,YAEhB,GADAv+B,KAAKmE,OACDnE,KAAKqC,IAAIyvC,EAAQJ,SAASzZ,MAE5B,OADAlgB,EAAKkF,OAASjd,KAAK6+B,cAAc,QAAU7+B,KAAK0lC,gBAAkB1lC,KAAK2yC,cAChE3yC,KAAKwgC,WAAWzoB,EAAM,wBAE/B,GAAI/X,KAAKqC,IAAIyvC,EAAQJ,SAASjZ,UAAW,CAEvC,IAAI0K,EACJ,GAAInjC,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAS5Y,YAAcqK,EAAUnjC,KAAK+xC,KAAKhR,mBAAoB,CAC3F,IAAI6E,EAAQ5lC,KAAKu+B,YACjBv+B,KAAKmE,OACDg/B,GAASnjC,KAAKmE,OAClB4T,EAAKipB,YAAchhC,KAAKojC,cAAcwC,EAAO,KAAMzC,EACrD,MAAWnjC,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAS/X,OAC5C5hB,EAAKipB,YAAchhC,KAAKwhC,WAAW,OAEnCzpB,EAAKipB,YAAchhC,KAAKkkC,mBACxBlkC,KAAKk/B,aAEP,OAAOl/B,KAAKwgC,WAAWzoB,EAAM,2BAC/B,CAWA,OAVI/X,KAAKgyC,IAAI7xC,KAAKq1B,SAAWx1B,KAAK+xC,KAAKpR,SAAW3gC,KAAK+xC,KAAKhR,mBAC1DhpB,EAAKipB,YAAchhC,KAAKugC,iBACxBxoB,EAAK4D,WAAa,GAClB5D,EAAKkF,OAAS,OAEdlF,EAAKipB,YAAc,KACnBjpB,EAAK4D,WAAa3b,KAAK8zC,2BACvB/7B,EAAKkF,OAASjd,KAAK6+B,cAAc,QAAU7+B,KAAK0lC,gBAAkB,KAClE1lC,KAAKk/B,aAEAl/B,KAAKwgC,WAAWzoB,EAAM,yBAC/B,EAEA47B,EAAKxR,YAAc,WACjB,IAOMvjB,EAPF7G,EAAO/X,KAAKu+B,YAmBhB,OAlBAv+B,KAAKmE,OACDnE,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAStb,QACrCre,EAAK4D,WAAa,GAClB5D,EAAKkF,OAASjd,KAAK0lC,gBACnB3tB,EAAKiC,KAAO,KAGRha,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAShwC,MAA2B,SAAnB1B,KAAKgyC,IAAIvrC,SACtDmY,EAAM5e,KAAKu+B,aACPv2B,MAAQhI,KAAK0iC,aACjB1iC,KAAKwgC,WAAW5hB,EAAK,0BACrB5e,KAAKqC,IAAIyvC,EAAQJ,SAAS9a,QAE5B7e,EAAK4D,WAAa3b,KAAK+zC,2BACvBh8B,EAAKkF,OAASjd,KAAK6+B,cAAc,SAAW7+B,KAAKgyC,IAAI7xC,MAAQ2xC,EAAQJ,SAAStb,OAASp2B,KAAK0lC,gBAAkB1lC,KAAK2yC,cAC/G/zB,GAAK7G,EAAK4D,WAAW6V,QAAQ5S,IAEnC5e,KAAKk/B,YACEl/B,KAAKwgC,WAAWzoB,EAAM,oBAC/B,EAEA47B,EAAKI,yBAA2B,WAC9B,IAAIzV,EAASt+B,KAETunC,EAAO,GACX,GAAIvnC,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASzZ,KAAM,CAC3C,IAAIrZ,EAAM5e,KAAKu+B,YACfv+B,KAAKmE,OACLya,EAAI5W,MAAQhI,KAAK6+B,cAAc,MAAQ7+B,KAAK0iC,aAAe1iC,KAAK0yC,aAChEnL,EAAK7jC,KAAK1D,KAAKwgC,WAAW5hB,EAAK,4BACjC,KAAO,CACL,IAAIu0B,EAASnzC,KAAKmyC,UAAW1jB,EAAOzuB,KAAKoyC,aAAc4B,EAAgBh0C,KAAKqyC,cAI5E,IAHAryC,KAAK6yC,SACL7yC,KAAKqC,IAAIyvC,EAAQJ,SAASlb,QACtBx2B,KAAKoyC,aAAe4B,IAAeA,EAAgBh0C,KAAKoyC,eACpDpyC,KAAKizC,OAAOnB,EAAQJ,SAASjb,OAAQ0c,GAAUnzC,KAAKoyC,cAAgB4B,EAAgB,EAAI,GAAIvlB,IAAO,CACzG,IAAIwlB,EAAQ3V,EAAOC,YACnB,GAAID,EAAOj8B,IAAIyvC,EAAQJ,SAASzZ,MAC9Bgc,EAAMjsC,MAAQs2B,EAAOO,cAAc,MAAQP,EAAOoE,aAAepE,EAAOoU,aACxEpU,EAAOkC,WAAWyT,EAAO,gCACpB,CACL,GAAI3V,EAAOM,aAAa,QAAS,MAEjC,GADAqV,EAAMvN,SAAWpI,EAAOoE,aACpB8Q,EAAQS,EAAMvN,UAAW,MAC7BuN,EAAMjsC,MAAQs2B,EAAOO,cAAc,MAAQP,EAAOoE,aAAeuR,EAAMvN,SACvEpI,EAAOkC,WAAWyT,EAAO,kBAC3B,CACA1M,EAAK7jC,KAAKuwC,GACV3V,EAAOj8B,IAAIyvC,EAAQJ,SAAS9a,MAC9B,CACA52B,KAAKqC,IAAIyvC,EAAQJ,SAASjb,QAC1Bz2B,KAAK8yC,OACP,CACA,OAAOvL,CACT,EAEAoM,EAAKG,yBAA2B,WAC9B,IAAIxV,EAASt+B,KAETunC,EAAO,GACP4L,EAASnzC,KAAKmyC,UAAW1jB,EAAOzuB,KAAKoyC,aAAc4B,EAAgBh0C,KAAKqyC,cAI5E,IAHAryC,KAAK6yC,SACL7yC,KAAKqC,IAAIyvC,EAAQJ,SAASlb,QACtBx2B,KAAKoyC,aAAe4B,IAAeA,EAAgBh0C,KAAKoyC,eACpDpyC,KAAKizC,OAAOnB,EAAQJ,SAASjb,OAAQ0c,GAAUnzC,KAAKoyC,cAAgB4B,EAAgB,EAAI,GAAIvlB,KAC9F6P,EAAOM,aAAa,SADiF,CAEzG,IAAIhgB,EAAM0f,EAAOC,YAEjB,GADA3f,EAAI5W,MAAQs2B,EAAOoE,aACf8Q,EAAQ50B,EAAI5W,OAAQ,MACxB4W,EAAI0nB,SAAWhI,EAAOO,cAAc,MAAQP,EAAOoE,aAAe9jB,EAAI5W,MACtEs2B,EAAOkC,WAAW5hB,EAAK,mBACvB2oB,EAAK7jC,KAAKkb,GACV0f,EAAOj8B,IAAIyvC,EAAQJ,SAAS9a,MAC9B,CAGA,OAFA52B,KAAKqC,IAAIyvC,EAAQJ,SAASjb,QAC1Bz2B,KAAK8yC,QACEvL,CACT,EAEA,IAAI2M,EAAO1C,EAAYhyC,UAgmBvB,SAASyiB,EAAaE,EAAO9P,GAC3B,IAAIrL,EAAI,IAAIwqC,EAAYrvB,EAAO9P,GAE/B,OADArL,EAAE7C,OACK6C,EAAEy3B,eACX,CAlmBAyV,EAAKhR,UAAY,SAAS9Y,GACxB,IAAKA,EAAM,OAAOA,EAClB,OAAQA,EAAKjqB,MACb,IAAK,aACL,IAAK,mBACH,OAAOiqB,EAET,IAAK,0BAEH,OADAA,EAAKvP,WAAa7a,KAAKkjC,UAAU9Y,EAAKvP,YAC/BuP,EAET,QACE,OAAOpqB,KAAK0yC,aAEhB,EAEAwB,EAAK5R,gBAAkB,SAAS4F,GAC9B,IAAI5J,EAASt+B,KAETH,EAAQG,KAAKuyC,kBACbnoB,EAAOpqB,KAAKkkC,iBAAiBgE,GACjC,GAAIloC,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAS9a,MAAO,CAC5C,IAAI7e,EAAO/X,KAAK4nC,YAAY/nC,GAE5B,IADAkY,EAAK2H,YAAc,CAAC0K,GACbpqB,KAAKqC,IAAIyvC,EAAQJ,SAAS9a,QAAQ7e,EAAK2H,YAAYhc,KAAK46B,EAAO4F,iBAAiBgE,IACvF,OAAOloC,KAAKwgC,WAAWzoB,EAAM,qBAC/B,CACA,OAAOqS,CACT,EAEA8pB,EAAKtR,qBAAuB,WAC1B5iC,KAAK6yC,SACL7yC,KAAKs/B,OAAOwS,EAAQJ,SAAShb,QAC7B,IAAI3uB,EAAM/H,KAAKsiC,kBAGf,OAFAtiC,KAAK8yC,QACL9yC,KAAKs/B,OAAOwS,EAAQJ,SAAS/a,QACtB5uB,CACT,EAEAmsC,EAAKhQ,iBAAmB,SAASgE,GAC/B,GAAIloC,KAAK+xC,KAAKnT,aAAa,SAAU,CACnC,IAAI7mB,EAAO/X,KAAKu+B,YAShB,OARAv+B,KAAKmE,OACDnE,KAAKk/B,aAAel/B,KAAKg/B,sBAAyBh/B,KAAKgyC,IAAI7xC,MAAQ2xC,EAAQJ,SAASzZ,OAASj4B,KAAKgyC,IAAI7xC,KAAKu1B,YAC7G3d,EAAKyJ,UAAW,EAChBzJ,EAAK+B,SAAW,OAEhB/B,EAAKyJ,SAAWxhB,KAAKqC,IAAIyvC,EAAQJ,SAASzZ,MAC1ClgB,EAAK+B,SAAW9Z,KAAKkkC,oBAEhBlkC,KAAKwgC,WAAWzoB,EAAM,kBAC/B,CAEA,IAAIlY,EAAQG,KAAKuyC,kBACb54B,EAAO3Z,KAAKuoC,sBAAsBL,GACtC,GAAIloC,KAAKgyC,IAAI7xC,KAAKy1B,SAAU,CAC1B,IAAI4Q,EAASxmC,KAAK4nC,YAAY/nC,GAK9B,OAJA2mC,EAAO5mB,SAAW5f,KAAKgyC,IAAIvrC,MAC3B+/B,EAAO7sB,KAAO3Z,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASta,GAAKp3B,KAAKijC,aAAatpB,GAAQ3Z,KAAKkjC,UAAUvpB,GAC/F3Z,KAAKmE,OACLqiC,EAAOlsB,MAAQta,KAAKkkC,iBAAiBgE,GAC9BloC,KAAKwgC,WAAWgG,EAAQ,uBACjC,CACA,OAAO7sB,CACT,EAEAu6B,EAAK3L,sBAAwB,SAASL,GACpC,IAAIroC,EAAQG,KAAKuyC,kBACbnoB,EAAOpqB,KAAKwoC,aAAaN,GAC7B,GAAIloC,KAAKqC,IAAIyvC,EAAQJ,SAAS3a,UAAW,CACvC,IAAIhf,EAAO/X,KAAK4nC,YAAY/nC,GAI5B,OAHAkY,EAAKnV,KAAOwnB,EACZrS,EAAKuI,WAAatgB,KAAKkkC,mBACvBnsB,EAAKwI,UAAYvgB,KAAKs/B,OAAOwS,EAAQJ,SAASluC,OAASxD,KAAKkkC,iBAAiBgE,GAAQloC,KAAK0yC,aACnF1yC,KAAKwgC,WAAWzoB,EAAM,wBAC/B,CACA,OAAOqS,CACT,EAEA8pB,EAAK1L,aAAe,SAASN,GAC3B,IAAIroC,EAAQG,KAAKuyC,kBACbY,EAASnzC,KAAKmyC,UAAW1jB,EAAOzuB,KAAKoyC,aACzC,OAAOpyC,KAAK0oC,YAAY1oC,KAAKyoC,iBAAgB,GAAQ5oC,GAAQ,EAAGqoC,EAAMiL,EAAQ1kB,EAChF,EAEAylB,EAAKxL,YAAc,SAAS/uB,EAAM9Z,EAAOgpC,EAASX,EAAMiL,EAAQ1kB,GAC9D,GAAIzuB,KAAKoyC,cAAgB3jB,GAAQzuB,KAAKmyC,UAAYgB,GAAUnzC,KAAKqzC,kBAAmB,OAAO15B,EAC3F,IAAIqc,EAAOh2B,KAAKgyC,IAAI7xC,KAAK21B,MACzB,GAAY,MAARE,KAAkBkS,GAAQloC,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASxX,MAC3DlE,EAAO6S,EAAS,CAClB,IAAI9wB,EAAO/X,KAAK4nC,YAAY/nC,GAI5B,GAHAkY,EAAK4B,KAAOA,EACZ5B,EAAK6H,SAAW5f,KAAKgyC,IAAIvrC,MACzBzG,KAAKmE,OACDnE,KAAKoyC,cAAgB3jB,GAAQzuB,KAAKmyC,UAAYgB,GAAUnzC,KAAKqzC,kBAC/Dt7B,EAAKuC,MAAQta,KAAK0yC,iBACb,CACL,IAAIyB,EAAan0C,KAAKuyC,kBACtBx6B,EAAKuC,MAAQta,KAAK0oC,YAAY1oC,KAAKyoC,iBAAgB,GAAQ0L,EAAYne,EAAMkS,EAAMiL,EAAQ1kB,EAC7F,CAEA,OADAzuB,KAAKwgC,WAAWzoB,EAAM,UAAUnV,KAAKmV,EAAK6H,UAAY,oBAAsB,oBACrE5f,KAAK0oC,YAAY3wB,EAAMlY,EAAOgpC,EAASX,EAAMiL,EAAQ1kB,EAC9D,CAEF,OAAO9U,CACT,EAEAu6B,EAAKzL,gBAAkB,SAASO,GAC9B,IAEoC5e,EAFhCkU,EAASt+B,KAETH,EAAQG,KAAKuyC,kBACjB,GAAIvyC,KAAKqS,QAAQkV,aAAe,GAAKvnB,KAAK+9B,SAAW/9B,KAAK+xC,KAAKnT,aAAa,SAC1ExU,EAAOpqB,KAAKipC,aACZD,GAAW,OACN,GAAIhpC,KAAKgyC,IAAI7xC,KAAK+pB,OAAQ,CAC/B,IAAInS,EAAO/X,KAAKu+B,YAAawF,EAAS/jC,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASpa,OACpEyM,IAAQiF,GAAW,GACxBjxB,EAAK6H,SAAW5f,KAAKgyC,IAAIvrC,MACzBsR,EAAKmS,QAAS,EACdlqB,KAAKmE,OACL4T,EAAK+B,SAAW9Z,KAAKyoC,iBAAgB,GACjC1E,IAAQhsB,EAAK+B,SAAW9Z,KAAKkjC,UAAUnrB,EAAK+B,WAChDsQ,EAAOpqB,KAAKwgC,WAAWzoB,EAAMgsB,EAAS,mBAAqB,kBAC7D,MAAO,GAAI/jC,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASza,SAAU,CACtD,IAAIuP,EAASxmC,KAAKu+B,YAClBv+B,KAAKmE,OACLqiC,EAAO1sB,SAAW9Z,KAAKyoC,gBAAgBO,GACvC5e,EAAOpqB,KAAKwgC,WAAWgG,EAAQ,gBACjC,MAEE,IADApc,EAAOpqB,KAAKylC,sBACLzlC,KAAKgyC,IAAI7xC,KAAK01B,UAAY71B,KAAKg/B,sBAAsB,CAC1D,IAAIyH,EAASnI,EAAOsJ,YAAY/nC,GAChC4mC,EAAO7mB,SAAW0e,EAAO0T,IAAIvrC,MAC7BggC,EAAOvc,QAAS,EAChBuc,EAAO3sB,SAAWwkB,EAAO4E,UAAU9Y,GACnCkU,EAAOn6B,OACPimB,EAAOkU,EAAOkC,WAAWiG,EAAQ,mBACnC,CAGF,IAAKuC,GAAYhpC,KAAKqC,IAAIyvC,EAAQJ,SAASvZ,UAAW,CACpD,IAAIic,EAASp0C,KAAK4nC,YAAY/nC,GAI9B,OAHAu0C,EAAOx0B,SAAW,KAClBw0B,EAAOz6B,KAAOyQ,EACdgqB,EAAO95B,MAAQta,KAAKyoC,iBAAgB,GAC7BzoC,KAAKwgC,WAAW4T,EAAQ,mBACjC,CAEA,OAAOhqB,CACT,EAEA8pB,EAAKzO,oBAAsB,WACzB,IAAI5lC,EAAQG,KAAKuyC,kBACjB,OAAOvyC,KAAKmpC,gBAAgBnpC,KAAK0lC,gBAAiB7lC,GAAO,EAAOG,KAAKmyC,UAAWnyC,KAAKoyC,aACvF,EAEA8B,EAAK/K,gBAAkB,SAASrpC,EAAMD,EAAOupC,EAASiL,EAAa5lB,GAGjE,IAFA,IAAI6P,EAASt+B,OAEJ,CACP,GAAIs+B,EAAO8T,cAAgB3jB,GAAQ6P,EAAO6T,WAAakC,GAAe/V,EAAO+U,kBAAmB,CAC9F,GAAI/U,EAAO0T,IAAI7xC,MAAQ2xC,EAAQJ,SAAS5a,KAAOwH,EAAO6T,WAAakC,EAGjE,OAAOv0C,IAFLu0C,CAGN,CAEA,IAAIhL,EAAgC,eAAdvpC,EAAKK,MAAuC,UAAdL,EAAK4B,OAAqB48B,EAAOU,qBAErF,GAAIV,EAAOj8B,IAAIyvC,EAAQJ,SAAS5a,KAAM,CACpC,IAAI/e,EAAOumB,EAAOsJ,YAAY/nC,GAC9BkY,EAAKoF,OAASrd,EACVw+B,EAAO8T,cAAgB3jB,GAAQ6P,EAAO6T,WAAakC,GAAe/V,EAAO+U,kBAC3Et7B,EAAKqE,SAAWkiB,EAAOoU,aAEvB36B,EAAKqE,SAAWkiB,EAAOgW,yBAA2BhW,EAAOoU,aAC3D36B,EAAKzU,UAAW,EAChBxD,EAAOw+B,EAAOkC,WAAWzoB,EAAM,mBACjC,MAAO,GAAIumB,EAAO0T,IAAI7xC,MAAQ2xC,EAAQJ,SAASpb,SAAU,CACvDgI,EAAOuU,SACPvU,EAAOn6B,OACP,IAAIqiC,EAASlI,EAAOsJ,YAAY/nC,GAChC2mC,EAAOrpB,OAASrd,EAChB0mC,EAAOpqB,SAAWkiB,EAAOgE,kBACzBkE,EAAOljC,UAAW,EAClBg7B,EAAOwU,QACPxU,EAAOgB,OAAOwS,EAAQJ,SAASnb,UAC/Bz2B,EAAOw+B,EAAOkC,WAAWgG,EAAQ,mBACnC,MAAO,GAAK4C,GAAW9K,EAAO0T,IAAI7xC,MAAQ2xC,EAAQJ,SAAShb,OAQpD,IAAI4H,EAAO0T,IAAI7xC,MAAQ2xC,EAAQJ,SAASxa,UAM7C,OAAOp3B,EALP,IAAIs0C,EAAS9V,EAAOsJ,YAAY/nC,GAChCu0C,EAAO/yB,IAAMvhB,EACbs0C,EAAOhzB,MAAQkd,EAAOkL,gBACtB1pC,EAAOw+B,EAAOkC,WAAW4T,EAAQ,2BAGnC,KAfmE,CACjE,IAAItN,EAAWxI,EAAOgL,cAAcwI,EAAQJ,SAAS/a,QACrD,GAAI0S,GAAmB/K,EAAOj8B,IAAIyvC,EAAQJ,SAASn6B,OACjD,OAAO+mB,EAAOiL,qBAAqBjL,EAAOsJ,YAAY/nC,GAAQinC,GAAU,GAC1E,IAAIL,EAASnI,EAAOsJ,YAAY/nC,GAChC4mC,EAAOn/B,OAASxH,EAChB2mC,EAAOl1B,UAAYu1B,EACnBhnC,EAAOw+B,EAAOkC,WAAWiG,EAAQ,iBACnC,CAQF,CACF,EAEAyN,EAAKxO,cAAgB,WACnB,IAAI3tB,EACJ,OAAQ/X,KAAKgyC,IAAI7xC,MACjB,KAAK2xC,EAAQJ,SAASjY,MACtB,KAAKqY,EAAQJ,SAAShY,OACpB,IAAIv5B,EAAOH,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASjY,MAAQ,iBAAmB,QAGzE,OAFA1hB,EAAO/X,KAAKu+B,YACZv+B,KAAKmE,OACEnE,KAAKwgC,WAAWzoB,EAAM5X,GAE/B,KAAK2xC,EAAQJ,SAAShwC,KACpB,IAAI7B,EAAQG,KAAKuyC,kBACb33B,EAAK5a,KAAK0iC,aACVS,GAAU,EACd,GAAgB,UAAZvoB,EAAGlZ,OAAqB1B,KAAKg/B,qBAAsB,CACrD,GAAIh/B,KAAKqC,IAAIyvC,EAAQJ,SAAS5Y,WAC5B,OAAO94B,KAAKojC,cAAcpjC,KAAK4nC,YAAY/nC,IAAQ,GAAO,GACxDG,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAShwC,OACrCkZ,EAAK5a,KAAK0iC,aACVS,GAAU,EAEd,CACA,OAAOnjC,KAAKqC,IAAIyvC,EAAQJ,SAASn6B,OAASvX,KAAKupC,qBAAqBvpC,KAAK4nC,YAAY/nC,GAAQ,CAAC+a,GAAKuoB,GAAWvoB,EAEhH,KAAKk3B,EAAQJ,SAASvb,OACpBpe,EAAO/X,KAAKu+B,YACZ,IAAIx2B,EAAM/H,KAAKgyC,IAAIvrC,MAKnB,OAJAsR,EAAK4E,MAAQ,CAACmF,QAAS/Z,EAAI+Z,QAAS6nB,MAAO5hC,EAAI4hC,OAC/C5xB,EAAKtR,MAAQsB,EAAItB,MACjBsR,EAAK6xB,IAAM5pC,KAAKmiB,MAAM1e,MAAMzD,KAAKgyC,IAAInyC,MAAOG,KAAKgyC,IAAI96B,KACrDlX,KAAKmE,OACEnE,KAAKwgC,WAAWzoB,EAAM,WAE/B,KAAK+5B,EAAQJ,SAASprC,IAAK,KAAKwrC,EAAQJ,SAAStb,OAK/C,OAJAre,EAAO/X,KAAKu+B,aACP93B,MAAQzG,KAAKgyC,IAAIvrC,MACtBsR,EAAK6xB,IAAM5pC,KAAKmiB,MAAM1e,MAAMzD,KAAKgyC,IAAInyC,MAAOG,KAAKgyC,IAAI96B,KACrDlX,KAAKmE,OACEnE,KAAKwgC,WAAWzoB,EAAM,WAE/B,KAAK+5B,EAAQJ,SAAS3X,MAAO,KAAK+X,EAAQJ,SAAS1X,MAAO,KAAK8X,EAAQJ,SAASzX,OAK9E,OAJAliB,EAAO/X,KAAKu+B,aACP93B,MAAQzG,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAS3X,MAAQ,KAAO/5B,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAS1X,MAClGjiB,EAAK6xB,IAAM5pC,KAAKgyC,IAAI7xC,KAAKq1B,QACzBx1B,KAAKmE,OACEnE,KAAKwgC,WAAWzoB,EAAM,WAE/B,KAAK+5B,EAAQJ,SAAShb,OACpB,IAAI6d,EAAav0C,KAAKuyC,kBACtBvyC,KAAKmE,OACL,IAAIU,EAAQ7E,KAAKsiC,kBAEjB,GADAtiC,KAAKs/B,OAAOwS,EAAQJ,SAAS/a,QACzB32B,KAAKqC,IAAIyvC,EAAQJ,SAASn6B,OAAQ,CAEpC,IAAImD,EAAS7V,EAAM6a,aAAe,CAAC7a,GAGnC,OAFI6V,EAAOzZ,QAAUuyC,EAAQ94B,EAAOA,EAAOzZ,OAAS,KAClDyZ,EAAO2J,MACFrkB,KAAKupC,qBAAqBvpC,KAAK4nC,YAAY2M,GAAa75B,EACjE,CACA,GAAI1a,KAAKqS,QAAQspB,eAAgB,CAC/B,IAAI8O,EAAMzqC,KAAK4nC,YAAY2M,GAC3B9J,EAAI5vB,WAAahW,EACjBA,EAAQ7E,KAAKwgC,WAAWiK,EAAK,0BAC/B,CACA,OAAO5lC,EAET,KAAKitC,EAAQJ,SAASpb,SAGpB,OAFAve,EAAO/X,KAAKu+B,aACP1kB,SAAW7Z,KAAKspC,cAAcwI,EAAQJ,SAASnb,UAAU,GACvDv2B,KAAKwgC,WAAWzoB,EAAM,mBAE/B,KAAK+5B,EAAQJ,SAASlb,OACpB,OAAOx2B,KAAKmnC,WAEd,KAAK2K,EAAQJ,SAAS/X,OACpB,OAAO35B,KAAKwhC,YAAW,GAEzB,KAAKsQ,EAAQJ,SAAS5Y,UAGpB,OAFA/gB,EAAO/X,KAAKu+B,YACZv+B,KAAKmE,OACEnE,KAAKojC,cAAcrrB,GAAM,GAElC,KAAK+5B,EAAQJ,SAASlY,KACpB,OAAOx5B,KAAK8pC,WAEd,KAAKgI,EAAQJ,SAASxa,UACpB,OAAOl3B,KAAKwpC,gBAEd,QACE,OAAOxpC,KAAK0yC,aAEhB,EAEAwB,EAAKpK,SAAW,WACd,IAAI/xB,EAAO/X,KAAKu+B,YAAa8V,EAAcr0C,KAAKmyC,UAAW1jB,EAAOzuB,KAAKoyC,aACnExH,EAAO5qC,KAAK0iC,YAAW,GAC3B,GAAI1iC,KAAKqS,QAAQkV,aAAe,GAAKvnB,KAAKqC,IAAIyvC,EAAQJ,SAAS5a,KAG7D,OAFA/e,EAAK6yB,KAAOA,EACZ7yB,EAAKqE,SAAWpc,KAAK0iC,YAAW,GACzB1iC,KAAKwgC,WAAWzoB,EAAM,gBAE/B,IAAIlY,EAAQG,KAAKuyC,kBAOjB,OANAx6B,EAAKzQ,OAAStH,KAAKmpC,gBAAgBnpC,KAAK0lC,gBAAiB7lC,GAAO,EAAMw0C,EAAa5lB,GAC/EzuB,KAAKgyC,IAAI7xC,MAAQ2xC,EAAQJ,SAAShb,OACpC3e,EAAKxG,UAAYvR,KAAKspC,cAAcwI,EAAQJ,SAAS/a,QAErD5e,EAAKxG,UAAY,GAEZvR,KAAKwgC,WAAWzoB,EAAM,gBAC/B,EAEAm8B,EAAKrJ,qBAAuB,WAC1B,IAAInD,EAAO1nC,KAAKu+B,YAOhB,OANAmJ,EAAKjhC,MAAQ,CACXmjC,IAAK5pC,KAAKmiB,MAAM1e,MAAMzD,KAAKgyC,IAAInyC,MAAOG,KAAKgyC,IAAI96B,KAAKxB,QAAQ,SAAU,MACtEo1B,OAAQ9qC,KAAKgyC,IAAIvrC,OAEnBzG,KAAKmE,OACLujC,EAAKqD,KAAO/qC,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASxa,UACxCl3B,KAAKwgC,WAAWkH,EAAM,kBAC/B,EAEAwM,EAAK1K,cAAgB,WACnB,IAAIlL,EAASt+B,KAET+X,EAAO/X,KAAKu+B,YAChBv+B,KAAKmE,OACL4T,EAAK2H,YAAc,GACnB,IAAIsrB,EAAShrC,KAAK6qC,uBAElB,IADA9yB,EAAKkzB,OAAS,CAACD,IACPA,EAAOD,MACbzM,EAAOn6B,OACP4T,EAAK2H,YAAYhc,KAAK46B,EAAOgE,mBACzBhE,EAAOgB,OAAOwS,EAAQJ,SAASjb,QACjCuU,EAAS1M,EAAOuM,yBAEhBG,EAAS1M,EAAOC,aACT93B,MAAQ,CAACqkC,OAAQ,GAAIlB,IAAK,IACjCoB,EAAOD,MAAO,EACdzM,EAAOkC,WAAWwK,EAAQ,oBAE5BjzB,EAAKkzB,OAAOvnC,KAAKsnC,GAGnB,OADAhrC,KAAKs/B,OAAOwS,EAAQJ,SAASxa,WACtBl3B,KAAKwgC,WAAWzoB,EAAM,kBAC/B,EAEAm8B,EAAK/M,SAAW,WACd,IAAI7I,EAASt+B,KAET+X,EAAO/X,KAAKu+B,YAChBxmB,EAAK6B,WAAa,GAClB5Z,KAAK6yC,SACL,IAAIM,EAASnzC,KAAKmyC,UAAY,EAAG1jB,EAAOzuB,KAAKoyC,aAG7C,IAFApyC,KAAKqC,IAAIyvC,EAAQJ,SAASlb,QACtBx2B,KAAKmyC,UAAY,EAAIgB,IAAUA,EAASnzC,KAAKmyC,UAAW1jB,EAAOzuB,KAAKoyC,eAChEpyC,KAAKizC,OAAOnB,EAAQJ,SAASjb,OAAQ0c,EAAQ1kB,IAAO,CAC1D,IAA+ByW,EAAa/B,EAAStjC,EAAjDP,EAAOg/B,EAAOC,YAgBlB,GAfID,EAAOjsB,QAAQkV,aAAe,IAChC1nB,EAAQy+B,EAAOiU,kBACfjzC,EAAK+e,QAAS,EACd/e,EAAK2oC,WAAY,EACjB/C,EAAc5G,EAAOj8B,IAAIyvC,EAAQJ,SAASzZ,OAE5CqG,EAAO8G,kBAAkB9lC,GACpBA,EAAKgE,UACY,eAAlBhE,EAAK6c,IAAIhc,MAA2C,UAAlBb,EAAK6c,IAAIza,MAAoB48B,EAAO0T,IAAI7xC,OAAS2xC,EAAQJ,SAAShb,QACpG4H,EAAO0T,IAAI7xC,OAAS2xC,EAAQJ,SAASluC,OAAU86B,EAAOU,qBAIxDmE,GAAU,GAHV7E,EAAO8G,kBAAkB9lC,GACzB6jC,GAAU,GAIRqQ,EAAQl0C,EAAK6c,KAAYq3B,EAAQlV,EAAO4F,qBAAqB5F,EAAOn6B,OAAQm6B,EAAOj8B,IAAIyvC,EAAQJ,SAAS9a,WAA5G,CACA,GAAI0H,EAAOj8B,IAAIyvC,EAAQJ,SAASluC,OAC9BlE,EAAK0a,KAAO,OACZ1a,EAAKmH,MAAQ63B,EAAO4F,wBACf,GAAI5F,EAAOjsB,QAAQkV,aAAe,IAAM+W,EAAO0T,IAAI7xC,OAAS2xC,EAAQJ,SAAShb,QAAU4H,EAAO0T,IAAI7xC,OAAS2xC,EAAQJ,SAASlb,QACjIl3B,EAAK0a,KAAO,OACZ1a,EAAK+e,QAAS,EACd/e,EAAKmH,MAAQ63B,EAAOkH,YAAYN,EAAa/B,QACxC,GAAI7E,EAAOjsB,QAAQkV,aAAe,GAAuB,eAAlBjoB,EAAK6c,IAAIhc,OAC3Cb,EAAKgE,WAA+B,QAAlBhE,EAAK6c,IAAIza,MAAoC,QAAlBpC,EAAK6c,IAAIza,OACtD48B,EAAO0T,IAAI7xC,MAAQ2xC,EAAQJ,SAAS9a,OAAS0H,EAAO0T,IAAI7xC,MAAQ2xC,EAAQJ,SAASjb,OAC3Fn3B,EAAK0a,KAAO1a,EAAK6c,IAAIza,KACrB48B,EAAO8G,kBAAkB9lC,GACzBA,EAAKmH,MAAQ63B,EAAOkH,aAAY,OAC3B,CAEL,GADAlmC,EAAK0a,KAAO,OACRskB,EAAOjsB,QAAQkV,aAAe,EAChC,GAAI+W,EAAOj8B,IAAIyvC,EAAQJ,SAASta,IAAK,CACnC,IAAIC,EAASiH,EAAOsJ,YAAY/nC,GAChCw3B,EAAOzX,SAAW,IAClByX,EAAO1d,KAAOra,EAAK6c,IACnBkb,EAAO/c,MAAQgkB,EAAO4F,mBACtB5kC,EAAKmH,MAAQ63B,EAAOkC,WAAWnJ,EAAQ,uBACzC,MACE/3B,EAAKmH,MAAQnH,EAAK6c,SAGpB7c,EAAKmH,MAAQ63B,EAAOoU,aAEtBpzC,EAAK2oC,WAAY,CACnB,CACAlwB,EAAK6B,WAAWlW,KAAK46B,EAAOkC,WAAWlhC,EAAM,aAC7Cg/B,EAAOj8B,IAAIyvC,EAAQJ,SAAS9a,MAhCiG,CAiC/H,CAQA,OAPA52B,KAAK8yC,QACA9yC,KAAKqC,IAAIyvC,EAAQJ,SAASjb,UAG7Bz2B,KAAK+mC,KAAK7vB,IAAMlX,KAAKgyC,IAAInyC,MACrBG,KAAKqS,QAAQipB,YAAWt7B,KAAK+mC,KAAKxK,IAAIrlB,IAAMlX,KAAKgyC,IAAIzV,IAAI18B,QAExDG,KAAKwgC,WAAWzoB,EAAM,mBAC/B,EAEAm8B,EAAK9O,kBAAoB,SAAS9lC,GAChC,GAAIU,KAAKqS,QAAQkV,aAAe,EAAG,CACjC,GAAIvnB,KAAKqC,IAAIyvC,EAAQJ,SAASpb,UAI5B,OAHAh3B,EAAKgE,UAAW,EAChBhE,EAAK6c,IAAMnc,KAAKsiC,uBAChBtiC,KAAKs/B,OAAOwS,EAAQJ,SAASnb,UAG7Bj3B,EAAKgE,UAAW,CAEpB,CACA,IAAI6Y,EAAOnc,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASprC,KAAOtG,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAStb,OAAUp2B,KAAK0lC,gBAAkB1lC,KAAK0iC,aAC9HpjC,EAAK6c,IAAMA,GAAOnc,KAAK0yC,YACzB,EAEAwB,EAAKI,sBAAwB,WAC3B,GAAIt0C,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAShwC,MAAQ1B,KAAKgyC,IAAI7xC,KAAKq1B,QAAS,OAAOx1B,KAAK0iC,YACpF,EAEAwR,EAAKxR,WAAa,WAChB,IAAIhhC,EAAO1B,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAAShwC,KAAO1B,KAAKgyC,IAAIvrC,MAAQzG,KAAKgyC,IAAI7xC,KAAKq1B,QACpF,IAAK9zB,EAAM,OAAO1B,KAAK0yC,aACvB,IAAI36B,EAAO/X,KAAKu+B,YAGhB,OAFAv+B,KAAKmE,OACL4T,EAAKrW,KAAOA,EACL1B,KAAKwgC,WAAWzoB,EAAM,aAC/B,EAEAm8B,EAAK7P,aAAe,SAAStsB,GAC3BA,EAAK6C,GAAK,KACV7C,EAAK2C,OAAS,GACV1a,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAK7U,WAAY,EACjB6U,EAAK8C,YAAa,GAEhB7a,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAKiP,OAAQ,EACjB,EAKAktB,EAAKjR,aAAe,SAASlrB,EAAMy8B,GACjC,IAAIlW,EAASt+B,KAEb,IAAK+X,GAAqB,cAAbA,EAAK5X,MAAsC,oBAAb4X,EAAK5X,OAA+Bq0C,QAExE,GAAiB,2BAAbz8B,EAAK5X,KACd4X,EAAK8C,WAAa7a,KAAKijC,aAAalrB,EAAK8C,WAAY25B,OAChD,IAAIx0C,KAAKqS,QAAQkV,YAAc,EACpC,OAAOvnB,KAAK0yC,aACP,GAAiB,oBAAb36B,EAAK5X,KAA4B,CAC1C4X,EAAK5X,KAAO,gBAEZ,IADA,IAAI8I,EAAQ8O,EAAK6B,WACR5Y,EAAI,EAAGA,EAAIiI,EAAMhI,OAAQD,IAChCiI,EAAMjI,GAAGyF,MAAQ63B,EAAO2E,aAAah6B,EAAMjI,GAAGyF,MAAO+tC,EACzD,MAAO,GAAiB,mBAAbz8B,EAAK5X,KACd4X,EAAK5X,KAAO,eACZH,KAAK6mC,iBAAiB9uB,EAAK8B,SAAU26B,QAChC,GAAiB,iBAAbz8B,EAAK5X,KACd4X,EAAK5X,KAAO,cACZ4X,EAAK+B,SAAW9Z,KAAKijC,aAAalrB,EAAK+B,SAAU06B,OAC5C,IAAiB,wBAAbz8B,EAAK5X,KAId,OAAOH,KAAK0yC,aAHZ36B,EAAK5X,KAAO,2BACL4X,EAAK6H,QAGd,EACA,OAAO7H,CACT,EAEAm8B,EAAKrN,iBAAmB,SAASC,EAAU0N,GAGzC,IAFA,IAAIlW,EAASt+B,KAEJgB,EAAI,EAAGA,EAAI8lC,EAAS7lC,OAAQD,IACnC8lC,EAAS9lC,GAAKs9B,EAAO2E,aAAa6D,EAAS9lC,GAAIwzC,GACjD,OAAO1N,CACT,EAEAoN,EAAKvP,oBAAsB,SAASjqB,GAElC,OADAA,EAAS1a,KAAKspC,cAAcwI,EAAQJ,SAAS/a,QACtC32B,KAAK6mC,iBAAiBnsB,GAAQ,EACvC,EAEAw5B,EAAK1O,YAAc,SAASN,EAAa/B,GACvC,IAAIprB,EAAO/X,KAAKu+B,YAAagG,EAAavkC,KAAK+9B,QAW/C,OAVA/9B,KAAKqkC,aAAatsB,GACd/X,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAK7U,YAAcgiC,GACjBllC,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAKiP,QAAUmc,GACjBnjC,KAAK+9B,QAAUhmB,EAAKiP,MACpBjP,EAAK2C,OAAS1a,KAAK2kC,sBACnB5sB,EAAK8C,WAAa7a,KAAKqS,QAAQkV,aAAe,GAAKvnB,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASlb,OACtFze,EAAKM,KAAON,EAAK8C,WAAa7a,KAAKkkC,mBAAqBlkC,KAAKiiC,aAC7DjiC,KAAK+9B,QAAUwG,EACRvkC,KAAKwgC,WAAWzoB,EAAM,qBAC/B,EAEAm8B,EAAK3K,qBAAuB,SAASxxB,EAAM2C,EAAQyoB,GACjD,IAAIoB,EAAavkC,KAAK+9B,QAStB,OARA/9B,KAAKqkC,aAAatsB,GACd/X,KAAKqS,QAAQkV,aAAe,IAC9BxP,EAAKiP,QAAUmc,GACjBnjC,KAAK+9B,QAAUhmB,EAAKiP,MACpBjP,EAAK2C,OAAS1a,KAAK6mC,iBAAiBnsB,GAAQ,GAC5C3C,EAAK8C,WAAa7a,KAAKgyC,IAAI7xC,OAAS2xC,EAAQJ,SAASlb,OACrDze,EAAKM,KAAON,EAAK8C,WAAa7a,KAAKkkC,mBAAqBlkC,KAAKiiC,aAC7DjiC,KAAK+9B,QAAUwG,EACRvkC,KAAKwgC,WAAWzoB,EAAM,0BAC/B,EAEAm8B,EAAK5K,cAAgB,SAASlC,EAAOC,GACnC,IAAI/I,EAASt+B,KAEbA,KAAK6yC,SACL,IAAIM,EAASnzC,KAAKmyC,UAAW1jB,EAAOzuB,KAAKoyC,aAAc7K,EAAO,GAE9D,IADAvnC,KAAKmE,QACGnE,KAAKizC,OAAO7L,EAAO+L,EAAS,EAAG1kB,IACrC,GAAI6P,EAAOj8B,IAAIyvC,EAAQJ,SAAS9a,OAC9B2Q,EAAK7jC,KAAK2jC,EAAa,KAAO/I,EAAOoU,kBADvC,CAIA,IAAI9zB,EAAM0f,EAAO4F,mBACjB,GAAIsP,EAAQ50B,GAAM,CAChB,GAAI0f,EAAO2U,OAAO7L,EAAO+L,EAAQ1kB,GAAO,MACxC6P,EAAOn6B,MACT,MACEojC,EAAK7jC,KAAKkb,GAEZ0f,EAAOj8B,IAAIyvC,EAAQJ,SAAS9a,MAR5B,CAiBF,OAPA52B,KAAK8yC,QACA9yC,KAAKqC,IAAI+kC,KAGZpnC,KAAK+mC,KAAK7vB,IAAMlX,KAAKgyC,IAAInyC,MACrBG,KAAKqS,QAAQipB,YAAWt7B,KAAK+mC,KAAKxK,IAAIrlB,IAAMlX,KAAKgyC,IAAIzV,IAAI18B,QAExD0nC,CACT,EAEA2M,EAAKjL,WAAa,WAChB,IAAIlxB,EAAO/X,KAAKu+B,YAGhB,OAFAv+B,KAAKmE,OACL4T,EAAK+B,SAAW9Z,KAAKyoC,kBACdzoC,KAAKwgC,WAAWzoB,EAAM,kBAC/B,EAiCA+5B,EAAQhrB,eAAeksB,QAAU,EAQjClB,EAAQP,gBAAgBtvB,EAAcuvB,EAAaC,GAEnDvyC,EAAQ+iB,aAAeA,EACvB/iB,EAAQsyC,YAAcA,EACtBtyC,EAAQuyC,aAAeA,EAEvBlyC,OAAOqyC,eAAe1yC,EAAS,aAAc,CAAEuH,OAAO,GAEtD,CA51CiEorC,CAAQ3yC,EAAS4mB,EAAQ,O,sBCGjF,SAAU5mB,GAAW,aAoB9B,SAAS+Y,EAAOF,EAAM08B,EAAU30C,EAAMmkB,EAAOG,GACtCtkB,IAAMA,EAAOZ,EAAQY,MACzB,SAAUmP,EAAE8I,EAAMqL,EAAIgB,GACrB,IAAIjkB,EAAOikB,GAAYrM,EAAK5X,KAAM4O,EAAQ0lC,EAASt0C,GACnDL,EAAKK,GAAM4X,EAAMqL,EAAInU,GACjBF,GAAOA,EAAMgJ,EAAMqL,EACxB,CAJA,CAIErL,EAAMkM,EAAOG,EAClB,CAKA,SAASmB,EAASxN,EAAM08B,EAAU30C,EAAMmkB,GACjCnkB,IAAMA,EAAOZ,EAAQY,MAC1B,IAAIwlB,EAAY,IACf,SAAUrW,EAAE8I,EAAMqL,EAAIgB,GACrB,IAAIjkB,EAAOikB,GAAYrM,EAAK5X,KAAM4O,EAAQ0lC,EAASt0C,GAC/Cu0C,EAAQ38B,GAAQuN,EAAUA,EAAUrkB,OAAS,GAC7CyzC,GAAOpvB,EAAU5hB,KAAKqU,GAC1BjY,EAAKK,GAAM4X,EAAMqL,EAAInU,GACjBF,GAAOA,EAAMgJ,EAAMqL,GAAMkC,EAAWA,GACpCovB,GAAOpvB,EAAUjB,KACtB,CAPA,CAOEtM,EAAMkM,EACX,CAOA,SAAStL,EAAUZ,EAAMkM,EAAO0wB,EAAO70C,EAAMskB,GAC3C,IAAIwwB,EAAUD,EAAQz1C,EAAQgb,KAAKy6B,EAAO70C,GAAQA,GACjD,SAAUmP,EAAE8I,EAAMqL,EAAIgB,GACrBwwB,EAAQxwB,GAAYrM,EAAK5X,MAAM4X,EAAMqL,EAAInU,EAC1C,CAFA,CAEE8I,EAAMkM,EAAOG,EAClB,CAEA,SAASywB,EAASjyC,GAChB,MAAmB,iBAARA,EACF,SAAUzC,GAAQ,OAAOA,GAAQyC,CAAM,EACtCA,GACD,WAAc,OAAO,CAAM,CAGtC,CAEA,IAAIkyC,EAAQ,SAAe/8B,EAAMkM,GAASjkB,KAAK+X,KAAOA,EAAM/X,KAAKikB,MAAQA,CAAM,EAK/E,SAASJ,EAAW9L,EAAMlY,EAAOqX,EAAKtU,EAAM9C,EAAMmkB,GAChDrhB,EAAOiyC,EAASjyC,GACX9C,IAAMA,EAAOZ,EAAQY,MAC1B,KACG,SAAUmP,EAAE8I,EAAMqL,EAAIgB,GACrB,IAAIjkB,EAAOikB,GAAYrM,EAAK5X,KAI5B,IAHc,MAATN,GAAiBkY,EAAKlY,OAASA,KACxB,MAAPqX,GAAea,EAAKb,KAAOA,IAC9BpX,EAAKK,GAAM4X,EAAMqL,EAAInU,IACT,MAATpP,GAAiBkY,EAAKlY,OAASA,KACxB,MAAPqX,GAAea,EAAKb,KAAOA,IAC5BtU,EAAKzC,EAAM4X,GACb,MAAM,IAAI+8B,EAAM/8B,EAAMqL,EACzB,CATA,CASErL,EAAMkM,EAIX,CAHE,MAAO9L,GACP,GAAIA,aAAa28B,EAAO,OAAO38B,EAC/B,MAAMA,CACR,CACF,CAIA,SAAS4L,EAAehM,EAAM9X,EAAK2C,EAAM9C,EAAMmkB,GAC7CrhB,EAAOiyC,EAASjyC,GACX9C,IAAMA,EAAOZ,EAAQY,MAC1B,KACG,SAAUmP,EAAE8I,EAAMqL,EAAIgB,GACrB,IAAIjkB,EAAOikB,GAAYrM,EAAK5X,KAC5B,KAAI4X,EAAKlY,MAAQI,GAAO8X,EAAKb,IAAMjX,KACnCH,EAAKK,GAAM4X,EAAMqL,EAAInU,GACjBrM,EAAKzC,EAAM4X,IAAO,MAAM,IAAI+8B,EAAM/8B,EAAMqL,EAC7C,CALA,CAKErL,EAAMkM,EAIX,CAHE,MAAO9L,GACP,GAAIA,aAAa28B,EAAO,OAAO38B,EAC/B,MAAMA,CACR,CACF,CAGA,SAAS48B,EAAch9B,EAAM9X,EAAK2C,EAAM9C,EAAMmkB,GAC5CrhB,EAAOiyC,EAASjyC,GACX9C,IAAMA,EAAOZ,EAAQY,MAC1B,KACG,SAAUmP,EAAE8I,EAAMqL,EAAIgB,GACrB,KAAIrM,EAAKb,IAAMjX,GAAf,CACA,IAAIE,EAAOikB,GAAYrM,EAAK5X,KAC5B,GAAI4X,EAAKlY,OAASI,GAAO2C,EAAKzC,EAAM4X,GAAO,MAAM,IAAI+8B,EAAM/8B,EAAMqL,GACjEtjB,EAAKK,GAAM4X,EAAMqL,EAAInU,EAHK,CAI3B,CALA,CAKE8I,EAAMkM,EAIX,CAHE,MAAO9L,GACP,GAAIA,aAAa28B,EAAO,OAAO38B,EAC/B,MAAMA,CACR,CACF,CAGA,SAAS68B,EAAej9B,EAAM9X,EAAK2C,EAAM9C,EAAMmkB,GAG7C,IAAI5V,EAQJ,OAVAzL,EAAOiyC,EAASjyC,GACX9C,IAAMA,EAAOZ,EAAQY,MAEzB,SAAUmP,EAAE8I,EAAMqL,EAAIgB,GACrB,KAAIrM,EAAKlY,MAAQI,GAAjB,CACA,IAAIE,EAAOikB,GAAYrM,EAAK5X,KACxB4X,EAAKb,KAAOjX,KAASoO,GAAOA,EAAI0J,KAAKb,IAAMa,EAAKb,MAAQtU,EAAKzC,EAAM4X,KACrE1J,EAAM,IAAIymC,EAAM/8B,EAAMqL,IACxBtjB,EAAKK,GAAM4X,EAAMqL,EAAInU,EAJO,CAK7B,CANA,CAME8I,EAAMkM,GACF5V,CACT,CAGA,IAAIrF,EAASzJ,OAAOyJ,QAAU,SAASrD,GACrC,SAASsvC,IAAQ,CAEjB,OADAA,EAAKz1C,UAAYmG,EACV,IAAIsvC,CACb,EAIA,SAAS/6B,EAAKy6B,EAAO70C,GACdA,IAAMA,EAAOZ,EAAQY,MAC1B,IAAI80C,EAAU5rC,EAAOlJ,GACrB,IAAK,IAAIK,KAAQw0C,EAAOC,EAAQz0C,GAAQw0C,EAAMx0C,GAC9C,OAAOy0C,CACT,CAEA,SAASM,EAAYn9B,EAAMqL,EAAInU,GAAKA,EAAE8I,EAAMqL,EAAI,CAChD,SAAS+xB,EAAOp0B,EAAOmC,EAAKkyB,GAAK,CAIjC,IAAIt1C,EAAO,CAAC,EAEZA,EAAKu1C,QAAUv1C,EAAKgb,eAAiB,SAAU/C,EAAMqL,EAAInU,GACvD,IAAK,IAAIjO,EAAI,EAAGA,EAAI+W,EAAKM,KAAKpX,SAAUD,EACtCiO,EAAE8I,EAAKM,KAAKrX,GAAIoiB,EAAI,YACxB,EACAtjB,EAAK8hB,UAAYszB,EACjBp1C,EAAKw1C,eAAiBH,EACtBr1C,EAAKy1C,oBAAsBz1C,EAAK01C,wBAC9B,SAAUz9B,EAAMqL,EAAInU,GAAK,OAAOA,EAAE8I,EAAK8C,WAAYuI,EAAI,aAAe,EACxEtjB,EAAK21C,YAAc,SAAU19B,EAAMqL,EAAInU,GACrCA,EAAE8I,EAAKnV,KAAMwgB,EAAI,cACjBnU,EAAE8I,EAAKuI,WAAY8C,EAAI,aACnBrL,EAAKwI,WAAWtR,EAAE8I,EAAKwI,UAAW6C,EAAI,YAC5C,EACAtjB,EAAK41C,iBAAmB,SAAU39B,EAAMqL,EAAInU,GAAK,OAAOA,EAAE8I,EAAKM,KAAM+K,EAAI,YAAc,EACvFtjB,EAAK61C,eAAiB71C,EAAK81C,kBAAoBT,EAC/Cr1C,EAAK+1C,cAAgB,SAAU99B,EAAMqL,EAAInU,GACvCA,EAAE8I,EAAKoF,OAAQiG,EAAI,cACnBnU,EAAE8I,EAAKM,KAAM+K,EAAI,YACnB,EACAtjB,EAAKg2C,gBAAkB,SAAU/9B,EAAMqL,EAAInU,GACzCA,EAAE8I,EAAKurB,aAAclgB,EAAI,cACzB,IAAK,IAAIpiB,EAAI,EAAGA,EAAI+W,EAAKwrB,MAAMtiC,SAAUD,EAAG,CAC1C,IAAI+0C,EAAKh+B,EAAKwrB,MAAMviC,GAChB+0C,EAAGnzC,MAAMqM,EAAE8mC,EAAGnzC,KAAMwgB,EAAI,cAC5B,IAAK,IAAIvS,EAAI,EAAGA,EAAIklC,EAAGz1B,WAAWrf,SAAU4P,EAC1C5B,EAAE8mC,EAAGz1B,WAAWzP,GAAIuS,EAAI,YAC5B,CACF,EACAtjB,EAAK+hB,gBAAkB/hB,EAAKwhB,gBAAkBxhB,EAAKk2C,gBAAkB,SAAUj+B,EAAMqL,EAAInU,GACnF8I,EAAK+B,UAAU7K,EAAE8I,EAAK+B,SAAUsJ,EAAI,aAC1C,EACAtjB,EAAKm2C,eAAiBn2C,EAAKo2C,cACzB,SAAUn+B,EAAMqL,EAAInU,GAAK,OAAOA,EAAE8I,EAAK+B,SAAUsJ,EAAI,aAAe,EACtEtjB,EAAKq2C,aAAe,SAAUp+B,EAAMqL,EAAInU,GACtCA,EAAE8I,EAAKokB,MAAO/Y,EAAI,aACdrL,EAAKjW,SAASmN,EAAE8I,EAAKjW,QAASshB,GAC9BrL,EAAK6rB,WAAW30B,EAAE8I,EAAK6rB,UAAWxgB,EAAI,YAC5C,EACAtjB,EAAKkb,YAAc,SAAUjD,EAAMqL,EAAInU,GACrCA,EAAE8I,EAAK4C,MAAOyI,EAAI,WAClBnU,EAAE8I,EAAKM,KAAM+K,EAAI,YACnB,EACAtjB,EAAKs2C,eAAiBt2C,EAAKu2C,iBAAmB,SAAUt+B,EAAMqL,EAAInU,GAChEA,EAAE8I,EAAKnV,KAAMwgB,EAAI,cACjBnU,EAAE8I,EAAKM,KAAM+K,EAAI,YACnB,EACAtjB,EAAK2b,aAAe,SAAU1D,EAAMqL,EAAInU,GAClC8I,EAAKlL,MAAMoC,EAAE8I,EAAKlL,KAAMuW,EAAI,WAC5BrL,EAAKnV,MAAMqM,EAAE8I,EAAKnV,KAAMwgB,EAAI,cAC5BrL,EAAKgsB,QAAQ90B,EAAE8I,EAAKgsB,OAAQ3gB,EAAI,cACpCnU,EAAE8I,EAAKM,KAAM+K,EAAI,YACnB,EACAtjB,EAAK0b,eAAiB1b,EAAK+b,eAAiB,SAAU9D,EAAMqL,EAAInU,GAC9DA,EAAE8I,EAAK4B,KAAMyJ,EAAI,WACjBnU,EAAE8I,EAAKuC,MAAO8I,EAAI,cAClBnU,EAAE8I,EAAKM,KAAM+K,EAAI,YACnB,EACAtjB,EAAKw2C,QAAU,SAAUv+B,EAAMqL,EAAInU,GAChB,uBAAb8I,EAAK5X,KAA+B8O,EAAE8I,EAAMqL,GAC3CnU,EAAE8I,EAAMqL,EAAI,aACnB,EACAtjB,EAAKy2C,kBAAoBpB,EAEzBr1C,EAAK6hB,oBAAsB,SAAU5J,EAAMqL,EAAInU,GAAK,OAAOA,EAAE8I,EAAMqL,EAAI,WAAa,EACpFtjB,EAAKob,oBAAsB,SAAUnD,EAAMqL,EAAInU,GAC7C,IAAK,IAAIjO,EAAI,EAAGA,EAAI+W,EAAKqD,aAAana,SAAUD,EAC9CiO,EAAE8I,EAAKqD,aAAapa,GAAIoiB,EAC5B,EACAtjB,EAAK8kB,mBAAqB,SAAU7M,EAAMqL,EAAInU,GAC5CA,EAAE8I,EAAK6C,GAAIwI,EAAI,WACXrL,EAAKlL,MAAMoC,EAAE8I,EAAKlL,KAAMuW,EAAI,aAClC,EAEAtjB,EAAKmV,SAAW,SAAU8C,EAAMqL,EAAInU,GAC9B8I,EAAK6C,IAAI3L,EAAE8I,EAAK6C,GAAIwI,EAAI,WAC5B,IAAK,IAAIpiB,EAAI,EAAGA,EAAI+W,EAAK2C,OAAOzZ,OAAQD,IACtCiO,EAAE8I,EAAK2C,OAAO1Z,GAAIoiB,EAAI,WACxBnU,EAAE8I,EAAKM,KAAM+K,EAAIrL,EAAK8C,WAAa,kBAAoB,YACzD,EAGA/a,EAAK02C,UAAY,SAAUz+B,EAAMqL,EAAInU,GAAK,OAAOA,EAAE8I,EAAMqL,EAAI,YAAc,EAC3EtjB,EAAK22C,gBAAkB,SAAU1+B,EAAMqL,EAAInU,GAAK,OAAOA,EAAE8I,EAAMqL,EAAI,aAAe,EAElFtjB,EAAK42C,QAAU,SAAU3+B,EAAMqL,EAAInU,GAChB,cAAb8I,EAAK5X,KACP8O,EAAE8I,EAAMqL,EAAI,mBACQ,oBAAbrL,EAAK5X,KACZ8O,EAAE8I,EAAMqL,EAAI,iBAEZnU,EAAE8I,EAAMqL,EACZ,EACAtjB,EAAKqa,gBAAkBg7B,EACvBr1C,EAAK0a,cAAgB06B,EACrBp1C,EAAKud,YAAc,SAAUtF,EAAMqL,EAAInU,GAAK,OAAOA,EAAE8I,EAAK+B,SAAUsJ,EAAI,UAAY,EACpFtjB,EAAKyd,aAAgB,SAAUxF,EAAMqL,EAAInU,GACvC,IAAK,IAAIjO,EAAI,EAAGA,EAAI+W,EAAK8B,SAAS5Y,SAAUD,EAAG,CAC7C,IAAI4d,EAAM7G,EAAK8B,SAAS7Y,GACpB4d,GAAK3P,EAAE2P,EAAKwE,EAAI,UACtB,CACF,EACAtjB,EAAKwd,cAAgB,SAAUvF,EAAMqL,EAAInU,GACvC,IAAK,IAAIjO,EAAI,EAAGA,EAAI+W,EAAK6B,WAAW3Y,SAAUD,EAC5CiO,EAAE8I,EAAK6B,WAAW5Y,GAAGyF,MAAO2c,EAAI,UACpC,EAEAtjB,EAAKoY,WAAag9B,EAClBp1C,EAAKghB,eAAiBhhB,EAAKkhB,MAAQlhB,EAAK62C,aAAexB,EACvDr1C,EAAKof,gBAAkB,SAAUnH,EAAMqL,EAAInU,GACzC,IAAK,IAAIjO,EAAI,EAAGA,EAAI+W,EAAK8B,SAAS5Y,SAAUD,EAAG,CAC7C,IAAI4d,EAAM7G,EAAK8B,SAAS7Y,GACpB4d,GAAK3P,EAAE2P,EAAKwE,EAAI,aACtB,CACF,EACAtjB,EAAKqf,iBAAmB,SAAUpH,EAAMqL,EAAInU,GAC1C,IAAK,IAAIjO,EAAI,EAAGA,EAAI+W,EAAK6B,WAAW3Y,SAAUD,EAC5CiO,EAAE8I,EAAK6B,WAAW5Y,GAAIoiB,EAC1B,EACAtjB,EAAKwf,mBAAqBxf,EAAK4hB,wBAA0B5hB,EAAK6hB,oBAC9D7hB,EAAK0f,mBAAqB1f,EAAKohB,gBAAkB,SAAUnJ,EAAMqL,EAAInU,GACnE,IAAK,IAAIjO,EAAI,EAAGA,EAAI+W,EAAK2H,YAAYze,SAAUD,EAC7CiO,EAAE8I,EAAK2H,YAAY1e,GAAIoiB,EAAI,aAC/B,EACAtjB,EAAK6f,gBAAkB7f,EAAK+f,iBAAmB,SAAU9H,EAAMqL,EAAInU,GACjEA,EAAE8I,EAAK+B,SAAUsJ,EAAI,aACvB,EACAtjB,EAAKggB,iBAAmBhgB,EAAKsgB,kBAAoB,SAAUrI,EAAMqL,EAAInU,GACnEA,EAAE8I,EAAK4B,KAAMyJ,EAAI,cACjBnU,EAAE8I,EAAKuC,MAAO8I,EAAI,aACpB,EACAtjB,EAAKya,qBAAuBza,EAAKua,kBAAoB,SAAUtC,EAAMqL,EAAInU,GACvEA,EAAE8I,EAAK4B,KAAMyJ,EAAI,WACjBnU,EAAE8I,EAAKuC,MAAO8I,EAAI,aACpB,EACAtjB,EAAKugB,sBAAwB,SAAUtI,EAAMqL,EAAInU,GAC/CA,EAAE8I,EAAKnV,KAAMwgB,EAAI,cACjBnU,EAAE8I,EAAKuI,WAAY8C,EAAI,cACvBnU,EAAE8I,EAAKwI,UAAW6C,EAAI,aACxB,EACAtjB,EAAK0gB,cAAgB1gB,EAAK2gB,eAAiB,SAAU1I,EAAMqL,EAAInU,GAE7D,GADAA,EAAE8I,EAAKzQ,OAAQ8b,EAAI,cACfrL,EAAKxG,UAAW,IAAK,IAAIvQ,EAAI,EAAGA,EAAI+W,EAAKxG,UAAUtQ,SAAUD,EAC/DiO,EAAE8I,EAAKxG,UAAUvQ,GAAIoiB,EAAI,aAC7B,EACAtjB,EAAKod,iBAAmB,SAAUnF,EAAMqL,EAAInU,GAC1CA,EAAE8I,EAAKoF,OAAQiG,EAAI,cACfrL,EAAKzU,UAAU2L,EAAE8I,EAAKqE,SAAUgH,EAAI,aAC1C,EACAtjB,EAAK82C,uBAAyB92C,EAAK+2C,yBAA2B,SAAU9+B,EAAMqL,EAAInU,GAC5E8I,EAAKipB,aACP/xB,EAAE8I,EAAKipB,YAAa5d,EAAiB,0BAAbrL,EAAK5X,MAAoC4X,EAAKipB,YAAYpmB,GAAK,YAAc,cACnG7C,EAAKkF,QAAQhO,EAAE8I,EAAKkF,OAAQmG,EAAI,aACtC,EACAtjB,EAAKg3C,qBAAuB,SAAU/+B,EAAMqL,EAAInU,GAC9CA,EAAE8I,EAAKkF,OAAQmG,EAAI,aACrB,EACAtjB,EAAK4b,kBAAoB,SAAU3D,EAAMqL,EAAInU,GAC3C,IAAK,IAAIjO,EAAI,EAAGA,EAAI+W,EAAK4D,WAAW1a,OAAQD,IAC1CiO,EAAE8I,EAAK4D,WAAW3a,GAAIoiB,GACxBnU,EAAE8I,EAAKkF,OAAQmG,EAAI,aACrB,EACAtjB,EAAKujB,gBAAkBvjB,EAAKwjB,uBAAyBxjB,EAAKyjB,yBAA2BzjB,EAAKkd,WAAald,EAAKmhB,QAAUk0B,EAEtHr1C,EAAKqhB,yBAA2B,SAAUpJ,EAAMqL,EAAInU,GAClDA,EAAE8I,EAAKsJ,IAAK+B,EAAI,cAChBnU,EAAE8I,EAAKqJ,MAAOgC,EAChB,EACAtjB,EAAKwb,iBAAmBxb,EAAKyf,gBAAkB,SAAUxH,EAAMqL,EAAInU,GAAK,OAAOA,EAAE8I,EAAMqL,EAAI,QAAU,EACrGtjB,EAAKi3C,MAAQ,SAAUh/B,EAAMqL,EAAInU,GAC3B8I,EAAK6C,IAAI3L,EAAE8I,EAAK6C,GAAIwI,EAAI,WACxBrL,EAAKwD,YAAYtM,EAAE8I,EAAKwD,WAAY6H,EAAI,cAC5C,IAAK,IAAIpiB,EAAI,EAAGA,EAAI+W,EAAKM,KAAKA,KAAKpX,OAAQD,IACzCiO,EAAE8I,EAAKM,KAAKA,KAAKrX,GAAIoiB,EACzB,EACAtjB,EAAKijB,iBAAmBjjB,EAAKqjB,SAAW,SAAUpL,EAAMqL,EAAInU,GACtD8I,EAAKzU,UAAU2L,EAAE8I,EAAKoE,IAAKiH,EAAI,cACnCnU,EAAE8I,EAAKtR,MAAO2c,EAAI,aACpB,EAEAlkB,EAAQ+Y,OAASA,EACjB/Y,EAAQqmB,SAAWA,EACnBrmB,EAAQyZ,UAAYA,EACpBzZ,EAAQ2kB,WAAaA,EACrB3kB,EAAQ6kB,eAAiBA,EACzB7kB,EAAQ61C,cAAgBA,EACxB71C,EAAQ81C,eAAiBA,EACzB91C,EAAQgb,KAAOA,EACfhb,EAAQY,KAAOA,EAEfP,OAAOqyC,eAAe1yC,EAAS,aAAc,CAAEuH,OAAO,GAEtD,CAtWiEorC,CAAQ3yC,E,mFCA1D,SAAS83C,EAAgB33C,EAAK8c,EAAK1V,GAYhD,OAXA0V,GAAM,OAAcA,MACT9c,EACTE,OAAOqyC,eAAevyC,EAAK8c,EAAK,CAC9B1V,MAAOA,EACPwwC,YAAY,EACZC,cAAc,EACdC,UAAU,IAGZ93C,EAAI8c,GAAO1V,EAENpH,CACT,C,kFCbA,SAAS+3C,EAAQj6B,EAAQk6B,GACvB,IAAIC,EAAO/3C,OAAO+3C,KAAKn6B,GACvB,GAAI5d,OAAOg4C,sBAAuB,CAChC,IAAI5hC,EAAUpW,OAAOg4C,sBAAsBp6B,GAC3Ck6B,IAAmB1hC,EAAUA,EAAQgO,QAAO,SAAUrH,GACpD,OAAO/c,OAAOi4C,yBAAyBr6B,EAAQb,GAAK26B,UACtD,KAAKK,EAAK5zC,KAAKiB,MAAM2yC,EAAM3hC,EAC7B,CACA,OAAO2hC,CACT,CACe,SAASG,EAAexwC,GACrC,IAAK,IAAIjG,EAAI,EAAGA,EAAIuQ,UAAUtQ,OAAQD,IAAK,CACzC,IAAIic,EAAS,MAAQ1L,UAAUvQ,GAAKuQ,UAAUvQ,GAAK,CAAC,EACpDA,EAAI,EAAIo2C,EAAQ73C,OAAO0d,IAAS,GAAIrb,SAAQ,SAAUua,IACpD,OAAelV,EAAQkV,EAAKc,EAAOd,GACrC,IAAK5c,OAAOm4C,0BAA4Bn4C,OAAOo4C,iBAAiB1wC,EAAQ1H,OAAOm4C,0BAA0Bz6B,IAAWm6B,EAAQ73C,OAAO0d,IAASrb,SAAQ,SAAUua,GAC5J5c,OAAOqyC,eAAe3qC,EAAQkV,EAAK5c,OAAOi4C,yBAAyBv6B,EAAQd,GAC7E,GACF,CACA,OAAOlV,CACT,C,oFCnBe,SAAS2wC,EAAe12C,GACrC,IAAIib,ECFS,SAAsBgG,EAAOlS,GAC1C,GAAuB,YAAnB,OAAQkS,IAAiC,OAAVA,EAAgB,OAAOA,EAC1D,IAAIlR,EAAOkR,EAAM7M,OAAOuiC,aACxB,QAAalK,IAAT18B,EAAoB,CACtB,IAAI6mC,EAAM7mC,EAAKvR,KAAKyiB,EAAOlS,GAAQ,WACnC,GAAqB,YAAjB,OAAQ6nC,GAAmB,OAAOA,EACtC,MAAM,IAAIC,UAAU,+CACtB,CACA,OAAiB,WAAT9nC,EAAoBoF,OAASnP,QAAQic,EAC/C,CDPY,CAAYjhB,EAAK,UAC3B,MAAwB,YAAjB,OAAQib,GAAoBA,EAAM9G,OAAO8G,EAClD,C,qCELe,SAASie,EAAQ/6B,GAG9B,OAAO+6B,EAAU,mBAAqB9kB,QAAU,iBAAmBA,OAAOu4B,SAAW,SAAUxuC,GAC7F,cAAcA,CAChB,EAAI,SAAUA,GACZ,OAAOA,GAAO,mBAAqBiW,QAAUjW,EAAIoN,cAAgB6I,QAAUjW,IAAQiW,OAAO9V,UAAY,gBAAkBH,CAC1H,EAAG+6B,EAAQ/6B,EACb,C","sources":["../node_modules/tern/lib/def.js","../node_modules/tern/lib/infer.js","../node_modules/tern/lib/signal.js","../node_modules/tern/lib/tern.js","../node_modules/tern/node_modules/acorn/dist/acorn.js","../node_modules/tern/node_modules/acorn/dist/acorn_loose.js","../node_modules/tern/node_modules/acorn/dist/walk.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/typeof.js"],"sourcesContent":["// Type description parser\n//\n// Type description JSON files (such as ecmascript.json and browser.json)\n// are used to\n//\n// A) describe types that come from native code\n//\n// B) to cheaply load the types for big libraries, or libraries that\n//    can't be inferred well\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    return exports.init = mod;\n  if (typeof define == \"function\" && define.amd) // AMD\n    return define({init: mod});\n  tern.def = {init: mod};\n})(function(exports, infer) {\n  \"use strict\";\n\n  function hop(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  var TypeParser = exports.TypeParser = function(spec, start, base, forceNew) {\n    this.pos = start || 0;\n    this.spec = spec;\n    this.base = base;\n    this.forceNew = forceNew;\n  };\n\n  function unwrapType(type, self, args) {\n    return type.call ? type(self, args) : type;\n  }\n\n  function extractProp(type, prop) {\n    if (prop == \"!ret\") {\n      if (type.retval) return type.retval;\n      var rv = new infer.AVal;\n      type.propagate(new infer.IsCallee(infer.ANull, [], null, rv));\n      return rv;\n    } else {\n      return type.getProp(prop);\n    }\n  }\n\n  function computedFunc(name, args, retType, generator) {\n    return function(self, cArgs) {\n      var realArgs = [];\n      for (var i = 0; i < args.length; i++) realArgs.push(unwrapType(args[i], self, cArgs));\n      return new infer.Fn(name, infer.ANull, realArgs, unwrapType(retType, self, cArgs), generator);\n    };\n  }\n  function computedUnion(types) {\n    return function(self, args) {\n      var union = new infer.AVal;\n      for (var i = 0; i < types.length; i++) unwrapType(types[i], self, args).propagate(union);\n      union.maxWeight = 1e5;\n      return union;\n    };\n  }\n  function computedArray(inner) {\n    return function(self, args) {\n      return new infer.Arr(inner(self, args));\n    };\n  }\n  function computedTuple(types) {\n    return function(self, args) {\n      return new infer.Arr(types.map(function(tp) { return unwrapType(tp, self, args) }))\n    }\n  }\n  function computedObject(names, types) {\n    return function(self, args) {\n      var obj = new infer.Obj;\n      names.forEach(function (prop, i) {\n        obj.defProp(prop).addType(unwrapType(types[i], self, args));\n      });\n      return obj;\n    };\n  }\n\n  TypeParser.prototype = {\n    eat: function(str) {\n      if (str.length == 1 ? this.spec.charAt(this.pos) == str : this.spec.indexOf(str, this.pos) == this.pos) {\n        this.pos += str.length;\n        return true;\n      }\n    },\n    word: function(re) {\n      var word = \"\", ch, re = re || /[\\w$]/;\n      while ((ch = this.spec.charAt(this.pos)) && re.test(ch)) { word += ch; ++this.pos; }\n      return word;\n    },\n    error: function() {\n      throw new Error(\"Unrecognized type spec: \" + this.spec + \" (at \" + this.pos + \")\");\n    },\n    parseFnType: function(comp, name, top, generator) {\n      var args = [], names = [], computed = false;\n      if (!this.eat(\")\")) for (var i = 0; ; ++i) {\n        var colon = this.spec.indexOf(\": \", this.pos), argname;\n        if (colon != -1) {\n          argname = this.spec.slice(this.pos, colon);\n          if (/^(\\.\\.\\.)?[$\\w?]+$/.test(argname))\n            this.pos = colon + 2;\n          else\n            argname = null;\n        }\n        names.push(argname);\n        var argType = this.parseType(comp);\n        if (argType.call) computed = true;\n        args.push(argType);\n        if (!this.eat(\", \")) {\n          this.eat(\")\") || this.error();\n          break;\n        }\n      }\n      var retType, computeRet, computeRetStart, fn;\n      if (this.eat(\" -> \")) {\n        var retStart = this.pos;\n        retType = this.parseType(true);\n        if (retType.call && !computed) {\n          computeRet = retType;\n          retType = infer.ANull;\n          computeRetStart = retStart;\n        }\n      } else {\n        retType = infer.ANull;\n      }\n      if (computed) return computedFunc(name, args, retType, generator);\n\n      if (top && (fn = this.base))\n        infer.Fn.call(this.base, name, infer.ANull, args, names, retType, generator);\n      else\n        fn = new infer.Fn(name, infer.ANull, args, names, retType, generator);\n      if (computeRet) fn.computeRet = computeRet;\n      if (computeRetStart != null) fn.computeRetSource = this.spec.slice(computeRetStart, this.pos);\n      return fn;\n    },\n    parseType: function(comp, name, top) {\n      var main = this.parseTypeMaybeProp(comp, name, top);\n      if (!this.eat(\"|\")) return main;\n      var types = [main], computed = main.call;\n      for (;;) {\n        var next = this.parseTypeMaybeProp(comp, name, top);\n        types.push(next);\n        if (next.call) computed = true;\n        if (!this.eat(\"|\")) break;\n      }\n      if (computed) return computedUnion(types);\n      var union = new infer.AVal;\n      for (var i = 0; i < types.length; i++) types[i].propagate(union);\n      union.maxWeight = 1e5;\n      return union;\n    },\n    parseTypeMaybeProp: function(comp, name, top) {\n      var result = this.parseTypeInner(comp, name, top);\n      while (comp && this.eat(\".\")) result = this.extendWithProp(result);\n      return result;\n    },\n    extendWithProp: function(base) {\n      var propName = this.word(/[\\w<>$!:]/) || this.error();\n      if (base.apply) return function(self, args) {\n        return extractProp(base(self, args), propName);\n      };\n      return extractProp(base, propName);\n    },\n    parseTypeInner: function(comp, name, top) {\n      var gen\n      if (this.eat(\"fn(\") || (gen = this.eat(\"fn*(\"))) {\n        return this.parseFnType(comp, name, top, gen);\n      } else if (this.eat(\"[\")) {\n        var inner = this.parseType(comp), types, computed = inner.call\n        while (this.eat(\", \")) {\n          if (!types) types = [inner]\n          var next = this.parseType(comp)\n          types.push(next)\n          computed = computed || next.call\n        }\n        this.eat(\"]\") || this.error()\n        if (computed) return types ? computedTuple(types) : computedArray(inner)\n        if (top && this.base) {\n          infer.Arr.call(this.base, types || inner)\n          return this.base\n        }\n        return new infer.Arr(types || inner)\n      } else if (this.eat(\"{\")) {\n        var types = [], names = [], computed = false\n        if (!this.eat(\"}\")) {\n          for (var i = 0; ; ++i) {\n            var colon = this.spec.indexOf(\": \", this.pos), propName;\n            if (colon != -1) {\n              propName = this.spec.slice(this.pos, colon);\n              if (/^[$\\w?]+$/.test(propName))\n                this.pos = colon + 2;\n              else\n                propName = null;\n            }\n            var propType = this.parseType(comp);\n            if (propType.call) computed = true;\n            names.push(propName);\n            types.push(propType);\n            if (!this.eat(\", \")) {\n              this.eat(\"}\") || this.error();\n              break;\n            }\n          }\n        }\n        if (computed) return computedObject(names, types);\n        var obj = new infer.Obj;\n        names.forEach(function (prop, i) {\n          obj.defProp(prop).addType(types[i]);\n        });\n        return obj;\n      } else if (this.eat(\"+\")) {\n        var path = this.word(/[\\w$<>\\.:!]/)\n        var base = infer.cx().localDefs[path + \".prototype\"]\n        if (!base) {\n          var base = parsePath(path);\n          if (!(base instanceof infer.Obj)) return base;\n          var proto = descendProps(base, [\"prototype\"])\n          if (proto && (proto = proto.getObjType()))\n            base = proto\n        }\n        if (comp && this.eat(\"[\")) return this.parsePoly(base);\n        if (top && this.base) {\n          this.base.proto = base\n          var name = base.hasCtor && base.hasCtor.name || base.name\n          if (name) this.base.name = name\n          return this.base\n        }\n        if (top && this.forceNew) return new infer.Obj(base);\n        return infer.getInstance(base);\n      } else if (this.eat(\":\")) {\n        var name = this.word(/[\\w$\\.]/)\n        return infer.getSymbol(name)\n      } else if (comp && this.eat(\"!\")) {\n        var arg = this.word(/\\d/);\n        if (arg) {\n          arg = Number(arg);\n          return function(_self, args) {return args[arg] || infer.ANull;};\n        } else if (this.eat(\"this\")) {\n          return function(self) {return self;};\n        } else if (this.eat(\"custom:\")) {\n          var fname = this.word(/[\\w$]/);\n          return customFunctions[fname] || function() { return infer.ANull; };\n        } else {\n          return this.fromWord(\"!\" + this.word(/[\\w$<>\\.!:]/));\n        }\n      } else if (this.eat(\"?\")) {\n        return infer.ANull;\n      } else {\n        return this.fromWord(this.word(/[\\w$<>\\.!:`]/));\n      }\n    },\n    fromWord: function(spec) {\n      var cx = infer.cx();\n      switch (spec) {\n      case \"number\": return cx.num;\n      case \"string\": return cx.str;\n      case \"bool\": return cx.bool;\n      case \"<top>\": return cx.topScope;\n      }\n      if (cx.localDefs && spec in cx.localDefs) return cx.localDefs[spec];\n      return parsePath(spec);\n    },\n    parsePoly: function(base) {\n      var propName = \"<i>\", match;\n      if (match = this.spec.slice(this.pos).match(/^\\s*([\\w$:]+)\\s*=\\s*/)) {\n        propName = match[1];\n        this.pos += match[0].length;\n      }\n      var value = this.parseType(true);\n      if (!this.eat(\"]\")) this.error();\n      if (value.call) return function(self, args) {\n        var instance = new infer.Obj(base);\n        value(self, args).propagate(instance.defProp(propName));\n        return instance;\n      };\n      var instance = new infer.Obj(base);\n      value.propagate(instance.defProp(propName));\n      return instance;\n    }\n  };\n\n  function addArgCallEffects(type) {\n    if (type instanceof infer.Fn && type.args) for (var i = 0; i < type.args.length; ++i) {\n      var arg = type.args[i]\n      if (arg instanceof infer.Fn && arg.args && arg.args.length) addArgCallEffect(type, i)\n    }\n  }\n\n  function addArgCallEffect(type, argNum) {\n    addEffect(type, function(_self, args) {\n      if (args[argNum]) args[argNum].propagate(\n        new infer.IsCallee(infer.cx().topScope, type.args[argNum].args, null, infer.ANull))\n    })\n  }\n\n  function parseType(spec, name, base, forceNew) {\n    var type = new TypeParser(spec, null, base, forceNew).parseType(false, name, true);\n    if (type instanceof infer.AVal) type.types.forEach(addArgCallEffects)\n    else addArgCallEffects(type)\n    return type;\n  }\n\n  function addEffect(fn, handler, replaceRet) {\n    var oldCmp = fn.computeRet, rv = fn.retval;\n    fn.computeRet = function(self, args, argNodes) {\n      var handled = handler(self, args, argNodes);\n      var old = oldCmp ? oldCmp(self, args, argNodes) : rv;\n      return replaceRet ? handled : old;\n    };\n  }\n\n  var parseEffect = exports.parseEffect = function(effect, fn) {\n    var m;\n    if (effect.indexOf(\"propagate \") == 0) {\n      var p = new TypeParser(effect, 10);\n      var origin = p.parseType(true);\n      if (!p.eat(\" \")) p.error();\n      var target = p.parseType(true);\n      addEffect(fn, function(self, args) {\n        unwrapType(origin, self, args).propagate(unwrapType(target, self, args));\n      });\n    } else if (effect.indexOf(\"call \") == 0) {\n      var andRet = effect.indexOf(\"and return \", 5) == 5;\n      var p = new TypeParser(effect, andRet ? 16 : 5);\n      var getCallee = p.parseType(true), getSelf = null, getArgs = [];\n      if (p.eat(\" this=\")) getSelf = p.parseType(true);\n      while (p.eat(\" \")) getArgs.push(p.parseType(true));\n      addEffect(fn, function(self, args) {\n        var callee = unwrapType(getCallee, self, args);\n        var slf = getSelf ? unwrapType(getSelf, self, args) : infer.ANull, as = [];\n        for (var i = 0; i < getArgs.length; ++i) as.push(unwrapType(getArgs[i], self, args));\n        var result = andRet ? new infer.AVal : infer.ANull;\n        callee.propagate(new infer.IsCallee(slf, as, null, result));\n        return result;\n      }, andRet);\n    } else if (m = effect.match(/^custom (\\S+)\\s*(.*)/)) {\n      var customFunc = customFunctions[m[1]];\n      if (customFunc) addEffect(fn, m[2] ? customFunc(m[2]) : customFunc);\n    } else if (effect.indexOf(\"copy \") == 0) {\n      var p = new TypeParser(effect, 5);\n      var getFrom = p.parseType(true);\n      p.eat(\" \");\n      var getTo = p.parseType(true);\n      addEffect(fn, function(self, args) {\n        var from = unwrapType(getFrom, self, args), to = unwrapType(getTo, self, args);\n        from.forAllProps(function(prop, val, local) {\n          if (local && prop != \"<i>\")\n            to.propagate(new infer.DefProp(prop, val));\n        });\n      });\n    } else {\n      throw new Error(\"Unknown effect type: \" + effect);\n    }\n  };\n\n  var currentTopScope;\n\n  var parsePath = exports.parsePath = function(path, scope) {\n    var cx = infer.cx(), cached = cx.paths[path], origPath = path;\n    if (cached != null) return cached;\n    cx.paths[path] = infer.ANull;\n\n    var base = scope || currentTopScope || cx.topScope;\n\n    if (cx.localDefs) for (var name in cx.localDefs) {\n      if (path.indexOf(name) == 0) {\n        if (path == name) return cx.paths[path] = cx.localDefs[path];\n        if (path.charAt(name.length) == \".\") {\n          base = cx.localDefs[name];\n          path = path.slice(name.length + 1);\n          break;\n        }\n      }\n    }\n\n    var result = descendProps(base, path.split(\".\"))\n    // Uncomment this to get feedback on your poorly written .json files\n    // if (result == infer.ANull) console.error(\"bad path: \" + origPath + \" (\" + cx.curOrigin + \")\")\n    cx.paths[origPath] = result == infer.ANull ? null : result\n    return result\n  }\n\n  function descendProps(base, parts) {\n    for (var i = 0; i < parts.length && base != infer.ANull; ++i) {\n      var prop = parts[i];\n      if (prop.charAt(0) == \"!\") {\n        if (prop == \"!proto\") {\n          base = (base instanceof infer.Obj && base.proto) || infer.ANull;\n        } else {\n          var fn = base.getFunctionType();\n          if (!fn) {\n            base = infer.ANull;\n          } else if (prop == \"!ret\") {\n            base = fn.retval && fn.retval.getType(false) || infer.ANull;\n          } else {\n            var arg = fn.args && fn.args[Number(prop.slice(1))];\n            base = (arg && arg.getType(false)) || infer.ANull;\n          }\n        }\n      } else if (base instanceof infer.Obj &&\n                 (prop == \"prototype\" && base instanceof infer.Fn || base.hasProp(prop))) {\n        var propVal = base.getProp(prop);\n        if (!propVal || propVal.isEmpty())\n          base = infer.ANull;\n        else\n          base = propVal.types[0];\n      } else {\n        base = infer.ANull;\n      }\n    }\n    return base;\n  }\n\n  function emptyObj(ctor) {\n    var empty = Object.create(ctor.prototype);\n    empty.props = Object.create(null);\n    empty.isShell = true;\n    return empty;\n  }\n\n  function isSimpleAnnotation(spec) {\n    if (!spec[\"!type\"] || /^(fn\\(|\\[|\\+)/.test(spec[\"!type\"])) return false;\n    for (var prop in spec)\n      if (prop != \"!type\" && prop != \"!doc\" && prop != \"!url\" && prop != \"!span\" && prop != \"!data\")\n        return false;\n    return true;\n  }\n\n  function passOne(base, spec, path) {\n    if (!base) {\n      var tp = spec[\"!type\"];\n      if (tp) {\n        if (/^fn\\(/.test(tp)) base = emptyObj(infer.Fn);\n        else if (tp.charAt(0) == \"[\") base = emptyObj(infer.Arr);\n        else if (tp.charAt(0) == \"+\") base = emptyObj(infer.Obj)\n        else throw new Error(\"Invalid !type spec: \" + tp);\n      } else if (spec[\"!stdProto\"]) {\n        base = infer.cx().protos[spec[\"!stdProto\"]];\n      } else {\n        base = emptyObj(infer.Obj);\n      }\n      base.name = path;\n    }\n\n    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {\n      var inner = spec[name];\n      if (typeof inner == \"string\" || isSimpleAnnotation(inner)) continue;\n      var prop = base.defProp(name);\n      passOne(prop.getObjType(), inner, path ? path + \".\" + name : name).propagate(prop);\n    }\n    return base;\n  }\n\n  function passTwo(base, spec, path) {\n    if (base.isShell) {\n      delete base.isShell;\n      var tp = spec[\"!type\"];\n      if (tp) {\n        parseType(tp, path, base);\n      } else {\n        var proto = spec[\"!proto\"] && parseType(spec[\"!proto\"]);\n        infer.Obj.call(base, proto instanceof infer.Obj ? proto : true, path);\n      }\n    }\n\n    var effects = spec[\"!effects\"];\n    if (effects && base instanceof infer.Fn) for (var i = 0; i < effects.length; ++i)\n      parseEffect(effects[i], base);\n    copyInfo(spec, base);\n\n    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {\n      var inner = spec[name], known = base.defProp(name), innerPath = path ? path + \".\" + name : name;\n      if (typeof inner == \"string\") {\n        if (known.isEmpty()) parseType(inner, innerPath).propagate(known);\n      } else {\n        if (!isSimpleAnnotation(inner))\n          passTwo(known.getObjType(), inner, innerPath);\n        else if (known.isEmpty())\n          parseType(inner[\"!type\"], innerPath, null, true).propagate(known);\n        else\n          continue;\n        if (inner[\"!doc\"]) known.doc = inner[\"!doc\"];\n        if (inner[\"!url\"]) known.url = inner[\"!url\"];\n        if (inner[\"!span\"]) known.span = inner[\"!span\"];\n      }\n    }\n    return base;\n  }\n\n  function copyInfo(spec, type) {\n    if (spec[\"!doc\"]) type.doc = spec[\"!doc\"];\n    if (spec[\"!url\"]) type.url = spec[\"!url\"];\n    if (spec[\"!span\"]) type.span = spec[\"!span\"];\n    if (spec[\"!data\"]) type.metaData = spec[\"!data\"];\n  }\n\n  function doLoadEnvironment(data, scope) {\n    var cx = infer.cx(), server = cx.parent\n\n    infer.addOrigin(cx.curOrigin = data[\"!name\"] || \"env#\" + cx.origins.length);\n    cx.localDefs = cx.definitions[cx.curOrigin] = Object.create(null);\n\n    if (server) server.signal(\"preLoadDef\", data)\n\n    passOne(scope, data);\n\n    var def = data[\"!define\"];\n    if (def) {\n      for (var name in def) {\n        var spec = def[name];\n        cx.localDefs[name] = typeof spec == \"string\" ? parsePath(spec) : passOne(null, spec, name);\n      }\n      for (var name in def) {\n        var spec = def[name];\n        if (typeof spec != \"string\") passTwo(cx.localDefs[name], def[name], name);\n      }\n    }\n\n    passTwo(scope, data);\n\n    if (server) server.signal(\"postLoadDef\", data)\n\n    cx.curOrigin = cx.localDefs = null;\n  }\n\n  exports.load = function(data, scope) {\n    if (!scope) scope = infer.cx().topScope;\n    var oldScope = currentTopScope;\n    currentTopScope = scope;\n    try {\n      doLoadEnvironment(data, scope);\n    } finally {\n      currentTopScope = oldScope;\n    }\n  };\n\n  exports.parse = function(data, origin, path) {\n    var cx = infer.cx();\n    if (origin) {\n      cx.origin = origin;\n      cx.localDefs = cx.definitions[origin];\n    }\n\n    try {\n      if (typeof data == \"string\")\n        return parseType(data, path);\n      else\n        return passTwo(passOne(null, data, path), data, path);\n    } finally {\n      if (origin) cx.origin = cx.localDefs = null;\n    }\n  };\n\n  // Used to register custom logic for more involved effect or type\n  // computation.\n  var customFunctions = Object.create(null);\n  infer.registerFunction = function(name, f) { customFunctions[name] = f; };\n\n  var IsCreated = infer.constraint({\n    construct: function(created, target, spec) {\n      this.created = created;\n      this.target = target;\n      this.spec = spec;\n    },\n    addType: function(tp) {\n      if (tp instanceof infer.Obj && this.created++ < 5) {\n        var derived = new infer.Obj(tp), spec = this.spec;\n        if (spec instanceof infer.AVal) spec = spec.getObjType(false);\n        if (spec instanceof infer.Obj) for (var prop in spec.props) {\n          var cur = spec.props[prop].types[0];\n          var p = derived.defProp(prop);\n          if (cur && cur instanceof infer.Obj && cur.props.value) {\n            var vtp = cur.props.value.getType(false);\n            if (vtp) p.addType(vtp);\n          }\n        }\n        this.target.addType(derived);\n      }\n    }\n  });\n\n  infer.registerFunction(\"Object_create\", function(_self, args, argNodes) {\n    if (argNodes && argNodes.length && argNodes[0].type == \"Literal\" && argNodes[0].value == null)\n      return new infer.Obj();\n\n    var result = new infer.AVal;\n    if (args[0]) args[0].propagate(new IsCreated(0, result, args[1]));\n    return result;\n  });\n\n  var PropSpec = infer.constraint({\n    construct: function(target) { this.target = target; },\n    addType: function(tp) {\n      if (!(tp instanceof infer.Obj)) return;\n      if (tp.hasProp(\"value\"))\n        tp.getProp(\"value\").propagate(this.target);\n      else if (tp.hasProp(\"get\"))\n        tp.getProp(\"get\").propagate(new infer.IsCallee(infer.ANull, [], null, this.target));\n    }\n  });\n\n  infer.registerFunction(\"Object_defineProperty\", function(_self, args, argNodes) {\n    if (argNodes && argNodes.length >= 3 && argNodes[1].type == \"Literal\" &&\n        typeof argNodes[1].value == \"string\") {\n      var obj = args[0], connect = new infer.AVal;\n      obj.propagate(new infer.DefProp(argNodes[1].value, connect, argNodes[1]));\n      args[2].propagate(new PropSpec(connect));\n    }\n    return infer.ANull;\n  });\n\n  infer.registerFunction(\"Object_defineProperties\", function(_self, args, argNodes) {\n    if (args.length >= 2) {\n      var obj = args[0];\n      args[1].forAllProps(function(prop, val, local) {\n        if (!local) return;\n        var connect = new infer.AVal;\n        obj.propagate(new infer.DefProp(prop, connect, argNodes && argNodes[1]));\n        val.propagate(new PropSpec(connect));\n      });\n    }\n    return infer.ANull;\n  });\n\n  var IsBound = infer.constraint({\n    construct: function(self, args, target) {\n      this.self = self; this.args = args; this.target = target;\n    },\n    addType: function(tp) {\n      if (!(tp instanceof infer.Fn)) return;\n      this.target.addType(new infer.Fn(tp.name, infer.ANull, tp.args.slice(this.args.length),\n                                       tp.argNames.slice(this.args.length), tp.retval, tp.generator));\n      this.self.propagate(tp.self);\n      for (var i = 0; i < Math.min(tp.args.length, this.args.length); ++i)\n        this.args[i].propagate(tp.args[i]);\n    }\n  });\n\n  infer.registerFunction(\"Function_bind\", function(self, args) {\n    if (!args.length) return infer.ANull;\n    var result = new infer.AVal;\n    self.propagate(new IsBound(args[0], args.slice(1), result));\n    return result;\n  });\n\n  infer.registerFunction(\"Array_ctor\", function(_self, args) {\n    var arr = new infer.Arr;\n    if (args.length != 1 || !args[0].hasType(infer.cx().num)) {\n      var content = arr.getProp(\"<i>\");\n      for (var i = 0; i < args.length; ++i) args[i].propagate(content);\n    }\n    return arr;\n  });\n\n  function makePromise() {\n    var defs = infer.cx().definitions.ecmascript\n    return defs && new infer.Obj(defs[\"Promise.prototype\"])\n  }\n\n  infer.registerFunction(\"Promise_ctor\", function(_self, args, argNodes) {\n    var self = makePromise()\n    if (!self || args.length < 1) return infer.ANull;\n    var valProp = self.defProp(\":t\", argNodes && argNodes[0]);\n    var valArg = new infer.AVal;\n    valArg.propagate(valProp);\n    var exec = new infer.Fn(\"execute\", infer.ANull, [valArg], [\"value\"], infer.ANull);\n    var reject = infer.cx().definitions.ecmascript.Promise_reject;\n    args[0].propagate(new infer.IsCallee(infer.ANull, [exec, reject], null, infer.ANull));\n    return self;\n  });\n\n  // Definition for Promise.resolve()\n  // The behavior is different for Promise and non-Promise arguments, so we\n  // need a custom definition to handle the different cases properly.\n  infer.registerFunction(\"Promise_resolve\", function(_self, args, argNodes) {\n    var self = makePromise()\n    if (!self) return infer.ANull;\n    if (args.length) {\n      var valProp = self.defProp(\":t\", argNodes && argNodes[0]);\n      var valArg = new infer.AVal;\n      valArg.propagate(valProp);\n      args[0].propagate(new PromiseResolvesTo(valArg));\n    }\n    return self;\n  });\n\n  var PromiseResolvesTo = infer.constraint({\n    construct: function(output) { this.output = output; },\n    addType: function(tp) {\n      if (tp.constructor == infer.Obj && tp.name == \"Promise\" && tp.hasProp(\":t\"))\n        tp.getProp(\":t\").propagate(this.output);\n      else\n        tp.propagate(this.output);\n    }\n  });\n\n  var WG_PROMISE_KEEP_VALUE = 50;\n\n  infer.registerFunction(\"Promise_then\", function(self, args, argNodes) {\n    var fn = args.length && args[0].getFunctionType();\n    var defs = infer.cx().definitions.ecmascript\n    if (!fn || !defs) return self;\n\n    var result = new infer.Obj(defs[\"Promise.prototype\"]);\n    var value = result.defProp(\":t\", argNodes && argNodes[0]), ty;\n    if (fn.retval.isEmpty() && (ty = self.getType()) instanceof infer.Obj && ty.hasProp(\":t\"))\n      ty.getProp(\":t\").propagate(value, WG_PROMISE_KEEP_VALUE);\n    fn.retval.propagate(new PromiseResolvesTo(value));\n    return result;\n  });\n\n  infer.registerFunction(\"getOwnPropertySymbols\", function(_self, args) {\n    if (!args.length) return infer.ANull\n    var result = new infer.AVal\n    args[0].forAllProps(function(prop, _val, local) {\n      if (local && prop.charAt(0) == \":\") result.addType(infer.getSymbol(prop.slice(1)))\n    })\n    return result\n  })\n\n  infer.registerFunction(\"getSymbol\", function(_self, _args, argNodes) {\n    if (argNodes && argNodes.length && argNodes[0].type == \"Literal\" && typeof argNodes[0].value == \"string\")\n      return infer.getSymbol(argNodes[0].value)\n    else\n      return infer.ANull\n  })\n\n  return exports;\n});\n","// Main type inference engine\n\n// Walks an AST, building up a graph of abstract values and constraints\n// that cause types to flow from one node to another. Also defines a\n// number of utilities for accessing ASTs and scopes.\n\n// Analysis is done in a context, which is tracked by the dynamically\n// bound cx variable. Use withContext to set the current context.\n\n// For memory-saving reasons, individual types export an interface\n// similar to abstract values (which can hold multiple types), and can\n// thus be used in place abstract values that only ever contain a\n// single type.\n\n(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    return mod(exports, require(\"acorn\"), require(\"acorn/dist/acorn_loose\"), require(\"acorn/dist/walk\"),\n               require(\"./def\"), require(\"./signal\"));\n  if (typeof define == \"function\" && define.amd) // AMD\n    return define([\"exports\", \"acorn/dist/acorn\", \"acorn/dist/acorn_loose\", \"acorn/dist/walk\", \"./def\", \"./signal\"], mod);\n  mod(root.tern || (root.tern = {}), acorn, acorn, acorn.walk, tern.def, tern.signal); // Plain browser env\n})(this, function(exports, acorn, acorn_loose, walk, def, signal) {\n  \"use strict\";\n\n  var toString = exports.toString = function(type, maxDepth, parent) {\n    if (!type || type == parent || maxDepth && maxDepth < -3) return \"?\";\n    return type.toString(maxDepth, parent);\n  };\n\n  // A variant of AVal used for unknown, dead-end values. Also serves\n  // as prototype for AVals, Types, and Constraints because it\n  // implements 'empty' versions of all the methods that the code\n  // expects.\n  var ANull = exports.ANull = signal.mixin({\n    addType: function() {},\n    propagate: function() {},\n    getProp: function() { return ANull; },\n    forAllProps: function() {},\n    hasType: function() { return false; },\n    isEmpty: function() { return true; },\n    getFunctionType: function() {},\n    getObjType: function() {},\n    getSymbolType: function() {},\n    getType: function() {},\n    gatherProperties: function() {},\n    propagatesTo: function() {},\n    typeHint: function() {},\n    propHint: function() {},\n    toString: function() { return \"?\"; }\n  });\n\n  function extend(proto, props) {\n    var obj = Object.create(proto);\n    if (props) for (var prop in props) obj[prop] = props[prop];\n    return obj;\n  }\n\n  // ABSTRACT VALUES\n\n  var WG_DEFAULT = 100, WG_NEW_INSTANCE = 90, WG_MADEUP_PROTO = 10,\n      WG_MULTI_MEMBER = 6, WG_CATCH_ERROR = 6,\n      WG_PHANTOM_OBJ = 1,\n      WG_GLOBAL_THIS = 90, WG_SPECULATIVE_THIS = 2, WG_SPECULATIVE_PROTO_THIS = 4;\n\n  var AVal = exports.AVal = function() {\n    this.types = [];\n    this.forward = null;\n    this.maxWeight = 0;\n  };\n  AVal.prototype = extend(ANull, {\n    addType: function(type, weight) {\n      weight = weight || WG_DEFAULT;\n      if (this.maxWeight < weight) {\n        this.maxWeight = weight;\n        if (this.types.length == 1 && this.types[0] == type) return;\n        this.types.length = 0;\n      } else if (this.maxWeight > weight || this.types.indexOf(type) > -1) {\n        return;\n      }\n\n      this.signal(\"addType\", type);\n      this.types.push(type);\n      var forward = this.forward;\n      if (forward) withWorklist(function(add) {\n        for (var i = 0; i < forward.length; ++i) add(type, forward[i], weight);\n      });\n    },\n\n    propagate: function(target, weight) {\n      if (target == ANull || (target instanceof Type && this.forward && this.forward.length > 2)) return;\n      if (weight && weight != WG_DEFAULT) target = new Muffle(target, weight);\n      (this.forward || (this.forward = [])).push(target);\n      var types = this.types;\n      if (types.length) withWorklist(function(add) {\n        for (var i = 0; i < types.length; ++i) add(types[i], target, weight);\n      });\n    },\n\n    getProp: function(prop) {\n      if (ignoredProp(prop)) return ANull;\n      var found = (this.props || (this.props = Object.create(null)))[prop];\n      if (!found) {\n        found = this.props[prop] = new AVal;\n        this.propagate(new GetProp(prop, found));\n      }\n      return found;\n    },\n\n    forAllProps: function(c) {\n      this.propagate(new ForAllProps(c));\n    },\n\n    hasType: function(type) {\n      return this.types.indexOf(type) > -1;\n    },\n    isEmpty: function() { return this.types.length === 0; },\n    getFunctionType: function() {\n      for (var i = this.types.length - 1; i >= 0; --i)\n        if (this.types[i] instanceof Fn) return this.types[i];\n    },\n    getObjType: function() {\n      var seen = null;\n      for (var i = this.types.length - 1; i >= 0; --i) {\n        var type = this.types[i];\n        if (!(type instanceof Obj)) continue;\n        if (type.name) return type;\n        if (!seen) seen = type;\n      }\n      return seen;\n    },\n\n    getSymbolType: function() {\n      for (var i = this.types.length - 1; i >= 0; --i)\n        if (this.types[i] instanceof Sym) return this.types[i]\n    },\n\n    getType: function(guess) {\n      if (this.types.length === 0 && guess !== false) return this.makeupType();\n      if (this.types.length === 1) return this.types[0];\n      return canonicalType(this.types);\n    },\n\n    toString: function(maxDepth, parent) {\n      if (this.types.length == 0) return toString(this.makeupType(), maxDepth, parent);\n      if (this.types.length == 1) return toString(this.types[0], maxDepth, parent);\n      var simplified = simplifyTypes(this.types);\n      if (simplified.length > 2) return \"?\";\n      return simplified.map(function(tp) { return toString(tp, maxDepth, parent); }).join(\"|\");\n    },\n\n    makeupPropType: function(obj) {\n      var propName = this.propertyName;\n\n      var protoProp = obj.proto && obj.proto.hasProp(propName);\n      if (protoProp) {\n        var fromProto = protoProp.getType();\n        if (fromProto) return fromProto;\n      }\n\n      if (propName != \"<i>\") {\n        var computedProp = obj.hasProp(\"<i>\");\n        if (computedProp) return computedProp.getType();\n      } else if (obj.props[\"<i>\"] != this) {\n        for (var prop in obj.props) {\n          var val = obj.props[prop];\n          if (!val.isEmpty()) return val.getType();\n        }\n      }\n    },\n\n    makeupType: function() {\n      var computed = this.propertyOf && this.makeupPropType(this.propertyOf);\n      if (computed) return computed;\n\n      if (!this.forward) return null;\n      for (var i = this.forward.length - 1; i >= 0; --i) {\n        var hint = this.forward[i].typeHint();\n        if (hint && !hint.isEmpty()) {guessing = true; return hint;}\n      }\n\n      var props = Object.create(null), foundProp = null;\n      for (var i = 0; i < this.forward.length; ++i) {\n        var prop = this.forward[i].propHint();\n        if (prop && prop != \"length\" && prop != \"<i>\" && prop != \"✖\" && prop != cx.completingProperty) {\n          props[prop] = true;\n          foundProp = prop;\n        }\n      }\n      if (!foundProp) return null;\n\n      var objs = objsWithProp(foundProp);\n      if (objs) {\n        var matches = [];\n        search: for (var i = 0; i < objs.length; ++i) {\n          var obj = objs[i];\n          for (var prop in props) if (!obj.hasProp(prop)) continue search;\n          if (obj.hasCtor) obj = getInstance(obj);\n          matches.push(obj);\n        }\n        var canon = canonicalType(matches);\n        if (canon) {guessing = true; return canon;}\n      }\n    },\n\n    typeHint: function() { return this.types.length ? this.getType() : null; },\n    propagatesTo: function() { return this; },\n\n    gatherProperties: function(f, depth) {\n      for (var i = 0; i < this.types.length; ++i)\n        this.types[i].gatherProperties(f, depth);\n    },\n\n    guessProperties: function(f) {\n      if (this.forward) for (var i = 0; i < this.forward.length; ++i) {\n        var prop = this.forward[i].propHint();\n        if (prop) f(prop, null, 0);\n      }\n      var guessed = this.makeupType();\n      if (guessed) guessed.gatherProperties(f);\n    }\n  });\n\n  function similarAVal(a, b, depth) {\n    var typeA = a.getType(false), typeB = b.getType(false);\n    if (!typeA || !typeB) return true;\n    return similarType(typeA, typeB, depth);\n  }\n\n  function similarType(a, b, depth) {\n    if (!a || depth >= 5) return b;\n    if (!a || a == b) return a;\n    if (!b) return a;\n    if (a.constructor != b.constructor) return false;\n    if (a.constructor == Arr) {\n      var innerA = a.getProp(\"<i>\").getType(false);\n      if (!innerA) return b;\n      var innerB = b.getProp(\"<i>\").getType(false);\n      if (!innerB || similarType(innerA, innerB, depth + 1)) return b;\n    } else if (a.constructor == Obj) {\n      var propsA = 0, propsB = 0, same = 0;\n      for (var prop in a.props) {\n        propsA++;\n        if (prop in b.props && similarAVal(a.props[prop], b.props[prop], depth + 1))\n          same++;\n      }\n      for (var prop in b.props) propsB++;\n      if (propsA && propsB && same < Math.max(propsA, propsB) / 2) return false;\n      return propsA > propsB ? a : b;\n    } else if (a.constructor == Fn) {\n      if (a.args.length != b.args.length ||\n          !a.args.every(function(tp, i) { return similarAVal(tp, b.args[i], depth + 1); }) ||\n          !similarAVal(a.retval, b.retval, depth + 1) || !similarAVal(a.self, b.self, depth + 1))\n        return false;\n      return a;\n    } else {\n      return false;\n    }\n  }\n\n  var simplifyTypes = exports.simplifyTypes = function(types) {\n    var found = [];\n    outer: for (var i = 0; i < types.length; ++i) {\n      var tp = types[i];\n      for (var j = 0; j < found.length; j++) {\n        var similar = similarType(tp, found[j], 0);\n        if (similar) {\n          found[j] = similar;\n          continue outer;\n        }\n      }\n      found.push(tp);\n    }\n    return found;\n  };\n\n  function canonicalType(types) {\n    var arrays = 0, fns = 0, objs = 0, prim = null;\n    for (var i = 0; i < types.length; ++i) {\n      var tp = types[i];\n      if (tp instanceof Arr) ++arrays;\n      else if (tp instanceof Fn) ++fns;\n      else if (tp instanceof Obj) ++objs;\n      else if (tp instanceof Prim) {\n        if (prim && tp.name != prim.name) return null;\n        prim = tp;\n      }\n    }\n    var kinds = (arrays && 1) + (fns && 1) + (objs && 1) + (prim && 1);\n    if (kinds > 1) return null;\n    if (prim) return prim;\n\n    var maxScore = 0, maxTp = null;\n    for (var i = 0; i < types.length; ++i) {\n      var tp = types[i], score = 0;\n      if (arrays) {\n        score = tp.getProp(\"<i>\").isEmpty() ? 1 : 2;\n      } else if (fns) {\n        score = 1;\n        for (var j = 0; j < tp.args.length; ++j) if (!tp.args[j].isEmpty()) ++score;\n        if (!tp.retval.isEmpty()) ++score;\n      } else if (objs) {\n        score = tp.name ? 100 : 2;\n      }\n      if (score >= maxScore) { maxScore = score; maxTp = tp; }\n    }\n    return maxTp;\n  }\n\n  // PROPAGATION STRATEGIES\n\n  var constraint = exports.constraint = function(methods) {\n    var ctor = function() {\n      this.origin = cx.curOrigin;\n      this.construct.apply(this, arguments);\n    };\n    ctor.prototype = Object.create(ANull);\n    for (var m in methods) if (methods.hasOwnProperty(m)) ctor.prototype[m] = methods[m];\n    return ctor;\n  };\n\n  var GetProp = constraint({\n    construct: function(prop, target) {\n      this.prop = prop; this.target = target;\n    },\n    addType: function(type, weight) {\n      if (type.getProp)\n        type.getProp(this.prop).propagate(this.target, weight);\n    },\n    propHint: function() { return this.prop; },\n    propagatesTo: function() {\n      if (this.prop == \"<i>\" || !/[^\\w_]/.test(this.prop))\n        return {target: this.target, pathExt: \".\" + this.prop};\n    }\n  });\n\n  var DefProp = exports.PropHasSubset = exports.DefProp = constraint({\n    construct: function(prop, type, originNode) {\n      this.prop = prop; this.type = type; this.originNode = originNode;\n    },\n    addType: function(type, weight) {\n      if (!(type instanceof Obj)) return;\n      var prop = type.defProp(this.prop, this.originNode);\n      if (!prop.origin) prop.origin = this.origin;\n      this.type.propagate(prop, weight);\n    },\n    propHint: function() { return this.prop; }\n  });\n\n  var ForAllProps = constraint({\n    construct: function(c) { this.c = c; },\n    addType: function(type) {\n      if (!(type instanceof Obj)) return;\n      type.forAllProps(this.c);\n    }\n  });\n\n  function withDisabledComputing(fn, body) {\n    cx.disabledComputing = {fn: fn, prev: cx.disabledComputing};\n    var result = body();\n    cx.disabledComputing = cx.disabledComputing.prev;\n    return result;\n  }\n  var IsCallee = exports.IsCallee = constraint({\n    construct: function(self, args, argNodes, retval) {\n      this.self = self; this.args = args; this.argNodes = argNodes; this.retval = retval;\n      this.disabled = cx.disabledComputing;\n    },\n    addType: function(fn, weight) {\n      if (!(fn instanceof Fn)) return;\n      for (var i = 0; i < this.args.length; ++i) {\n        if (i < fn.args.length) this.args[i].propagate(fn.args[i], weight);\n        if (fn.arguments) this.args[i].propagate(fn.arguments, weight);\n      }\n      if (!fn.isArrowFn())\n        this.self.propagate(fn.self, this.self == cx.topScope ? WG_GLOBAL_THIS : weight);\n      var compute = fn.computeRet, result = fn.retval\n      if (compute) for (var d = this.disabled; d; d = d.prev)\n        if (d.fn == fn || fn.originNode && d.fn.originNode == fn.originNode) compute = null;\n      if (compute) {\n        var old = cx.disabledComputing;\n        cx.disabledComputing = this.disabled;\n        result = compute(this.self, this.args, this.argNodes)\n        cx.disabledComputing = old;\n      }\n      maybeIterator(fn, result).propagate(this.retval, weight)\n    },\n    typeHint: function() {\n      var names = [];\n      for (var i = 0; i < this.args.length; ++i) names.push(\"?\");\n      return new Fn(null, this.self, this.args, names, ANull);\n    },\n    propagatesTo: function() {\n      return {target: this.retval, pathExt: \".!ret\"};\n    }\n  });\n\n  var HasMethodCall = constraint({\n    construct: function(propName, args, argNodes, retval) {\n      this.propName = propName; this.args = args; this.argNodes = argNodes; this.retval = retval;\n      this.disabled = cx.disabledComputing;\n    },\n    addType: function(obj, weight) {\n      var callee = new IsCallee(obj, this.args, this.argNodes, this.retval);\n      callee.disabled = this.disabled;\n      obj.getProp(this.propName).propagate(callee, weight);\n    },\n    propHint: function() { return this.propName; }\n  });\n\n  var IsCtor = exports.IsCtor = constraint({\n    construct: function(target, noReuse) {\n      this.target = target; this.noReuse = noReuse;\n    },\n    addType: function(f, weight) {\n      if (!(f instanceof Fn)) return;\n      if (cx.parent && !cx.parent.options.reuseInstances) this.noReuse = true;\n      f.getProp(\"prototype\").propagate(new IsProto(this.noReuse ? false : f, this.target), weight);\n    }\n  });\n\n  var getInstance = exports.getInstance = function(obj, ctor) {\n    if (ctor === false) return new Obj(obj);\n\n    if (!ctor) ctor = obj.hasCtor;\n    if (!obj.instances) obj.instances = [];\n    for (var i = 0; i < obj.instances.length; ++i) {\n      var cur = obj.instances[i];\n      if (cur.ctor == ctor) return cur.instance;\n    }\n    var instance = new Obj(obj, ctor && ctor.name);\n    instance.origin = obj.origin;\n    obj.instances.push({ctor: ctor, instance: instance});\n    return instance;\n  };\n\n  var IsProto = exports.IsProto = constraint({\n    construct: function(ctor, target) {\n      this.ctor = ctor; this.target = target;\n    },\n    addType: function(o, _weight) {\n      if (!(o instanceof Obj)) return;\n      if ((this.count = (this.count || 0) + 1) > 8) return;\n      if (o == cx.protos.Array)\n        this.target.addType(new Arr);\n      else\n        this.target.addType(getInstance(o, this.ctor));\n    }\n  });\n\n  var FnPrototype = constraint({\n    construct: function(fn) { this.fn = fn; },\n    addType: function(o, _weight) {\n      if (o instanceof Obj && !o.hasCtor) {\n        o.hasCtor = this.fn;\n        var adder = new SpeculativeThis(o, this.fn);\n        adder.addType(this.fn);\n        o.forAllProps(function(_prop, val, local) {\n          if (local) val.propagate(adder);\n        });\n      }\n    }\n  });\n\n  var IsAdded = constraint({\n    construct: function(other, target) {\n      this.other = other; this.target = target;\n    },\n    addType: function(type, weight) {\n      if (type == cx.str)\n        this.target.addType(cx.str, weight);\n      else if (type == cx.num && this.other.hasType(cx.num))\n        this.target.addType(cx.num, weight);\n    },\n    typeHint: function() { return this.other; }\n  });\n\n  var IfObj = exports.IfObj = constraint({\n    construct: function(target) { this.target = target; },\n    addType: function(t, weight) {\n      if (t instanceof Obj) this.target.addType(t, weight);\n    },\n    propagatesTo: function() { return this.target; }\n  });\n\n  var SpeculativeThis = constraint({\n    construct: function(obj, ctor) { this.obj = obj; this.ctor = ctor; },\n    addType: function(tp) {\n      if (tp instanceof Fn && tp.self)\n        tp.self.addType(getInstance(this.obj, this.ctor), WG_SPECULATIVE_PROTO_THIS);\n    }\n  });\n\n  var HasProto = constraint({\n    construct: function(obj) { this.obj = obj },\n    addType: function(tp) {\n      if (tp instanceof Obj && this.obj.proto == cx.protos.Object)\n        this.obj.replaceProto(tp)\n    }\n  });\n\n  var Muffle = constraint({\n    construct: function(inner, weight) {\n      this.inner = inner; this.weight = weight;\n    },\n    addType: function(tp, weight) {\n      this.inner.addType(tp, Math.min(weight, this.weight));\n    },\n    propagatesTo: function() { return this.inner.propagatesTo(); },\n    typeHint: function() { return this.inner.typeHint(); },\n    propHint: function() { return this.inner.propHint(); }\n  });\n\n  // TYPE OBJECTS\n\n  var Type = exports.Type = function() {};\n  Type.prototype = extend(ANull, {\n    constructor: Type,\n    propagate: function(c, w) { c.addType(this, w); },\n    hasType: function(other) { return other == this; },\n    isEmpty: function() { return false; },\n    typeHint: function() { return this; },\n    getType: function() { return this; }\n  });\n\n  var Prim = exports.Prim = function(proto, name) { this.name = name; this.proto = proto; };\n  Prim.prototype = extend(Type.prototype, {\n    constructor: Prim,\n    toString: function() { return this.name; },\n    getProp: function(prop) {return this.proto.hasProp(prop) || ANull;},\n    gatherProperties: function(f, depth) {\n      if (this.proto) this.proto.gatherProperties(f, depth);\n    }\n  });\n\n  function isInteger(str) {\n    var c0 = str.charCodeAt(0)\n    if (c0 >= 48 && c0 <= 57) return !/\\D/.test(str)\n    else return false\n  }\n\n  var Obj = exports.Obj = function(proto, name) {\n    if (!this.props) this.props = Object.create(null);\n    this.proto = proto === true ? cx.protos.Object : proto;\n    if (proto && proto != cx.protos.Object && !name && proto.name && !(this instanceof Fn)) {\n      var match = /^(.*)\\.prototype$/.exec(this.proto.name);\n      if (match) name = match[1];\n    }\n    this.name = name;\n    this.maybeProps = null;\n    this.origin = cx.curOrigin;\n  };\n  Obj.prototype = extend(Type.prototype, {\n    constructor: Obj,\n    toString: function(maxDepth) {\n      if (maxDepth == null) maxDepth = 0;\n      if (maxDepth <= 0 && this.name) return this.name;\n      var props = [], etc = false;\n      for (var prop in this.props) if (prop != \"<i>\") {\n        if (props.length > 5) { etc = true; break; }\n        if (maxDepth)\n          props.push(prop + \": \" + toString(this.props[prop], maxDepth - 1, this));\n        else\n          props.push(prop);\n      }\n      props.sort();\n      if (etc) props.push(\"...\");\n      return \"{\" + props.join(\", \") + \"}\";\n    },\n    hasProp: function(prop, searchProto) {\n      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)\n      var found = this.props[prop];\n      if (searchProto !== false)\n        for (var p = this.proto; p && !found; p = p.proto) found = p.props[prop];\n      return found;\n    },\n    defProp: function(prop, originNode) {\n      var found = this.hasProp(prop, false);\n      if (found) {\n        if (originNode && !found.originNode) found.originNode = originNode;\n        return found;\n      }\n      if (ignoredProp(prop)) return ANull;\n      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)\n\n      var av = this.maybeProps && this.maybeProps[prop];\n      if (av) {\n        delete this.maybeProps[prop];\n        this.maybeUnregProtoPropHandler();\n      } else {\n        av = new AVal;\n        av.propertyOf = this;\n        av.propertyName = prop;\n      }\n\n      this.props[prop] = av;\n      av.originNode = originNode;\n      av.origin = cx.curOrigin;\n      this.broadcastProp(prop, av, true);\n      return av;\n    },\n    getProp: function(prop) {\n      var found = this.hasProp(prop, true) || (this.maybeProps && this.maybeProps[prop]);\n      if (found) return found;\n      if (ignoredProp(prop)) return ANull;\n      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)\n      var av = this.ensureMaybeProps()[prop] = new AVal;\n      av.propertyOf = this;\n      av.propertyName = prop;\n      return av;\n    },\n    normalizeIntegerProp: function(_) { return \"<i>\" },\n    broadcastProp: function(prop, val, local) {\n      if (local) {\n        this.signal(\"addProp\", prop, val);\n        // If this is a scope, it shouldn't be registered\n        if (!(this instanceof Scope)) registerProp(prop, this);\n      }\n\n      if (this.onNewProp) for (var i = 0; i < this.onNewProp.length; ++i) {\n        var h = this.onNewProp[i];\n        h.onProtoProp ? h.onProtoProp(prop, val, local) : h(prop, val, local);\n      }\n    },\n    onProtoProp: function(prop, val, _local) {\n      var maybe = this.maybeProps && this.maybeProps[prop];\n      if (maybe) {\n        delete this.maybeProps[prop];\n        this.maybeUnregProtoPropHandler();\n        this.proto.getProp(prop).propagate(maybe);\n      }\n      this.broadcastProp(prop, val, false);\n    },\n    replaceProto: function(proto) {\n      if (this.proto && this.maybeProps)\n        this.proto.unregPropHandler(this)\n      this.proto = proto\n      if (this.maybeProps)\n        this.proto.forAllProps(this)\n    },\n    ensureMaybeProps: function() {\n      if (!this.maybeProps) {\n        if (this.proto) this.proto.forAllProps(this);\n        this.maybeProps = Object.create(null);\n      }\n      return this.maybeProps;\n    },\n    removeProp: function(prop) {\n      var av = this.props[prop];\n      delete this.props[prop];\n      this.ensureMaybeProps()[prop] = av;\n      av.types.length = 0;\n    },\n    forAllProps: function(c) {\n      if (!this.onNewProp) {\n        this.onNewProp = [];\n        if (this.proto) this.proto.forAllProps(this);\n      }\n      this.onNewProp.push(c);\n      for (var o = this; o; o = o.proto) for (var prop in o.props) {\n        if (c.onProtoProp)\n          c.onProtoProp(prop, o.props[prop], o == this);\n        else\n          c(prop, o.props[prop], o == this);\n      }\n    },\n    maybeUnregProtoPropHandler: function() {\n      if (this.maybeProps) {\n        for (var _n in this.maybeProps) return;\n        this.maybeProps = null;\n      }\n      if (!this.proto || this.onNewProp && this.onNewProp.length) return;\n      this.proto.unregPropHandler(this);\n    },\n    unregPropHandler: function(handler) {\n      for (var i = 0; i < this.onNewProp.length; ++i)\n        if (this.onNewProp[i] == handler) { this.onNewProp.splice(i, 1); break; }\n      this.maybeUnregProtoPropHandler();\n    },\n    gatherProperties: function(f, depth) {\n      for (var prop in this.props) if (prop != \"<i>\" && prop.charAt(0) != \":\")\n        f(prop, this, depth);\n      if (this.proto) this.proto.gatherProperties(f, depth + 1);\n    },\n    getObjType: function() { return this; }\n  });\n\n  var geckoIterators = typeof StopIteration != \"undefined\";\n  function ignoredProp(name) {\n    return name == \"__proto__\" || name == \"✖\" || geckoIterators && name == \"__iterator__\";\n  }\n\n  var Fn = exports.Fn = function(name, self, args, argNames, retval, generator) {\n    Obj.call(this, cx.protos.Function, name);\n    this.self = self;\n    this.args = args;\n    this.argNames = argNames;\n    this.retval = retval;\n    this.generator = generator\n  };\n  Fn.prototype = extend(Obj.prototype, {\n    constructor: Fn,\n    toString: function(maxDepth) {\n      if (maxDepth == null) maxDepth = 0;\n      var str = this.generator ? \"fn*(\" : \"fn(\";\n      for (var i = 0; i < this.args.length; ++i) {\n        if (i) str += \", \";\n        var name = this.argNames[i];\n        if (name && name != \"?\") str += name + \": \";\n        str += maxDepth > -3 ? toString(this.args[i], maxDepth - 1, this) : \"?\";\n      }\n      str += \")\";\n      if (!this.retval.isEmpty())\n        str += \" -> \" + (maxDepth > -3 ? toString(this.retval, maxDepth - 1, this) : \"?\");\n      return str;\n    },\n    getProp: function(prop) {\n      if (prop == \"prototype\") {\n        var known = this.hasProp(prop, false);\n        if (!known) {\n          known = this.defProp(prop);\n          var proto = new Obj(true, this.name && this.name + \".prototype\");\n          proto.origin = this.origin;\n          known.addType(proto, WG_MADEUP_PROTO);\n        }\n        return known;\n      }\n      return Obj.prototype.getProp.call(this, prop);\n    },\n    defProp: function(prop, originNode) {\n      if (prop == \"prototype\") {\n        var found = this.hasProp(prop, false);\n        if (found) return found;\n        found = Obj.prototype.defProp.call(this, prop, originNode);\n        found.origin = this.origin;\n        found.propagate(new FnPrototype(this));\n        return found;\n      }\n      return Obj.prototype.defProp.call(this, prop, originNode);\n    },\n    getFunctionType: function() { return this; },\n    isArrowFn: function() { return this.originNode && this.originNode.type == \"ArrowFunctionExpression\" }\n  });\n\n  var Arr = exports.Arr = function(contentType) {\n    Obj.call(this, cx.protos.Array)\n    var content = this.defProp(\"<i>\")\n    if (Array.isArray(contentType)) {\n      this.tuple = contentType.length\n      for (var i = 0; i < contentType.length; i++) {\n        var prop = this.defProp(String(i))\n        contentType[i].propagate(prop)\n        prop.propagate(content)\n      }\n    } else if (contentType) {\n      this.tuple = 0\n      contentType.propagate(content)\n    }\n  };\n  Arr.prototype = extend(Obj.prototype, {\n    constructor: Arr,\n    toString: function(maxDepth) {\n      if (maxDepth == null) maxDepth = 0\n      if (maxDepth <= -3) return \"[?]\"\n      var content = \"\"\n      if (this.tuple) {\n        var similar\n        for (var i = 0; i in this.props; i++) {\n          var type = toString(this.getProp(String(i)), maxDepth - 1, this)\n          if (similar == null)\n            similar = type\n          else if (similar != type)\n            similar = false\n          else\n            similar = type\n          content += (content ? \", \" : \"\") + type\n        }\n        if (similar) content = similar\n      } else {\n        content = toString(this.getProp(\"<i>\"), maxDepth - 1, this)\n      }\n      return \"[\" + content + \"]\"\n    },\n    normalizeIntegerProp: function(prop) {\n      if (+prop < this.tuple) return prop\n      else return \"<i>\"\n    }\n  });\n\n  var Sym = exports.Sym = function(name, originNode) {\n    Prim.call(this, cx.protos.Symbol, \"Symbol\")\n    this.symName = name\n    this.originNode = originNode\n  }\n  Sym.prototype = extend(Prim.prototype, {\n    constructor: Sym,\n    asPropName: function() { return \":\" + this.symName },\n    getSymbolType: function() { return this }\n  })\n\n  exports.getSymbol = function(name, originNode) {\n    var cleanName = name.replace(/[^\\w$\\.]/g, \"_\")\n    var known = cx.symbols[cleanName]\n    if (known) {\n      if (originNode && !known.originNode) known.originNode = originNode\n      return known\n    }\n    return cx.symbols[cleanName] = new Sym(cleanName, originNode)\n  }\n\n  // THE PROPERTY REGISTRY\n\n  function registerProp(prop, obj) {\n    var data = cx.props[prop] || (cx.props[prop] = []);\n    data.push(obj);\n  }\n\n  function objsWithProp(prop) {\n    return cx.props[prop];\n  }\n\n  // INFERENCE CONTEXT\n\n  exports.Context = function(defs, parent) {\n    this.parent = parent;\n    this.props = Object.create(null);\n    this.protos = Object.create(null);\n    this.origins = [];\n    this.curOrigin = \"ecmascript\";\n    this.paths = Object.create(null);\n    this.definitions = Object.create(null);\n    this.purgeGen = 0;\n    this.workList = null;\n    this.disabledComputing = null;\n    this.curSuperCtor = this.curSuper = null;\n    this.symbols = Object.create(null)\n\n    exports.withContext(this, function() {\n      cx.protos.Object = new Obj(null, \"Object.prototype\");\n      cx.topScope = new Scope();\n      cx.topScope.name = \"<top>\";\n      cx.protos.Array = new Obj(true, \"Array.prototype\");\n      cx.protos.Function = new Fn(\"Function.prototype\", ANull, [], [], ANull);\n      cx.protos.Function.proto = cx.protos.Object;\n      cx.protos.RegExp = new Obj(true, \"RegExp.prototype\");\n      cx.protos.String = new Obj(true, \"String.prototype\");\n      cx.protos.Number = new Obj(true, \"Number.prototype\");\n      cx.protos.Boolean = new Obj(true, \"Boolean.prototype\");\n      cx.protos.Symbol = new Obj(true, \"Symbol.prototype\");\n      cx.str = new Prim(cx.protos.String, \"string\");\n      cx.bool = new Prim(cx.protos.Boolean, \"bool\");\n      cx.num = new Prim(cx.protos.Number, \"number\");\n      cx.curOrigin = null;\n\n      if (defs) for (var i = 0; i < defs.length; ++i)\n        def.load(defs[i]);\n    });\n  };\n\n  exports.Context.prototype.startAnalysis = function() {\n    this.disabledComputing = this.workList = this.curSuperCtor = this.curSuper = null;\n  };\n\n  var cx = null;\n  exports.cx = function() { return cx; };\n\n  exports.withContext = function(context, f) {\n    var old = cx;\n    cx = context;\n    try { return f(); }\n    finally { cx = old; }\n  };\n\n  exports.TimedOut = function() {\n    this.message = \"Timed out\";\n    this.stack = (new Error()).stack;\n  };\n  exports.TimedOut.prototype = Object.create(Error.prototype);\n  exports.TimedOut.prototype.name = \"infer.TimedOut\";\n\n  var timeout;\n  exports.withTimeout = function(ms, f) {\n    var end = +new Date + ms;\n    var oldEnd = timeout;\n    if (oldEnd && oldEnd < end) return f();\n    timeout = end;\n    try { return f(); }\n    finally { timeout = oldEnd; }\n  };\n\n  exports.addOrigin = function(origin) {\n    if (cx.origins.indexOf(origin) < 0) cx.origins.push(origin);\n  };\n\n  var baseMaxWorkDepth = 20, reduceMaxWorkDepth = 0.0001;\n  function withWorklist(f) {\n    if (cx.workList) return f(cx.workList);\n\n    var list = [], depth = 0;\n    var add = cx.workList = function(type, target, weight) {\n      if (depth < baseMaxWorkDepth - reduceMaxWorkDepth * list.length)\n        list.push(type, target, weight, depth);\n    };\n    var ret = f(add);\n    for (var i = 0; i < list.length; i += 4) {\n      if (timeout && +new Date >= timeout)\n        throw new exports.TimedOut();\n      depth = list[i + 3] + 1;\n      list[i + 1].addType(list[i], list[i + 2]);\n    }\n    cx.workList = null;\n    return ret;\n  }\n\n  function withSuper(ctor, obj, f) {\n    var oldCtor = cx.curSuperCtor, oldObj = cx.curSuper\n    cx.curSuperCtor = ctor; cx.curSuper = obj\n    var result = f()\n    cx.curSuperCtor = oldCtor; cx.curSuper = oldObj\n    return result\n  }\n\n  // SCOPES\n\n  var Scope = exports.Scope = function(prev, originNode, isBlock, isCatch) {\n    Obj.call(this, prev || true);\n    this.prev = prev;\n    this.originNode = originNode\n    this.isBlock = !!isBlock\n    this.isCatch = !!isCatch\n  };\n  Scope.prototype = extend(Obj.prototype, {\n    constructor: Scope,\n    defVar: function(name, originNode) {\n      for (var s = this; ; s = s.proto) {\n        var found = s.props[name];\n        if (found) return found;\n        if (!s.prev) return s.defProp(name, originNode);\n      }\n    }\n  });\n\n  function functionScope(scope, arrow) {\n    while (scope.isBlock || scope.isCatch || (arrow === false && scope.fnType && scope.fnType.isArrowFn()))\n      scope = scope.prev\n    return scope\n  }\n\n\n  // RETVAL COMPUTATION HEURISTICS\n\n  function maybeInstantiate(scope, score) {\n    var fn = functionScope(scope).fnType\n    if (fn) fn.instantiateScore = (fn.instantiateScore || 0) + score;\n  }\n\n  var NotSmaller = {};\n  function nodeSmallerThan(node, n) {\n    try {\n      walk.simple(node, {Expression: function() { if (--n <= 0) throw NotSmaller; }});\n      return true;\n    } catch(e) {\n      if (e == NotSmaller) return false;\n      throw e;\n    }\n  }\n\n  function maybeTagAsInstantiated(node, fn) {\n    var score = fn.instantiateScore;\n    if (!cx.disabledComputing && score && fn.args.length && nodeSmallerThan(node, score * 5)) {\n      maybeInstantiate(functionScope(fn.originNode.scope.prev), score / 2);\n      setFunctionInstantiated(node, fn);\n      return true;\n    } else {\n      fn.instantiateScore = null;\n    }\n  }\n\n  function setFunctionInstantiated(node, fn) {\n    // Disconnect the arg avals, so that we can add info to them without side effects\n    for (var i = 0; i < fn.args.length; ++i) fn.args[i] = new AVal;\n    fn.self = new AVal;\n    fn.computeRet = function(self, args) {\n      // Prevent recursion\n      return withDisabledComputing(fn, function() {\n        var oldOrigin = cx.curOrigin;\n        cx.curOrigin = fn.origin;\n        var scope = node.scope\n        var scopeCopy = new Scope(scope.prev, scope.originNode);\n        for (var v in scope.props) {\n          var local = scopeCopy.defProp(v, scope.props[v].originNode);\n          for (var i = 0; i < args.length; ++i) if (fn.argNames[i] == v && i < args.length)\n            args[i].propagate(local);\n        }\n        var argNames = fn.argNames.length != args.length ? fn.argNames.slice(0, args.length) : fn.argNames;\n        while (argNames.length < args.length) argNames.push(\"?\");\n        scopeCopy.fnType = new Fn(fn.name, self, args, argNames, ANull, fn.generator);\n        scopeCopy.fnType.originNode = fn.originNode;\n        if (fn.arguments) {\n          var argset = scopeCopy.fnType.arguments = new AVal;\n          scopeCopy.defProp(\"arguments\").addType(new Arr(argset));\n          for (var i = 0; i < args.length; ++i) args[i].propagate(argset);\n        }\n        node.scope = scopeCopy;\n        walk.recursive(node.body, scopeCopy, null, scopeGatherer);\n        walk.recursive(node.body, scopeCopy, null, inferWrapper);\n        cx.curOrigin = oldOrigin;\n        return scopeCopy.fnType.retval;\n      });\n    };\n  }\n\n  function maybeTagAsGeneric(fn) {\n    var target = fn.retval;\n    if (target == ANull || fn.isArrowFn()) return;\n    var targetInner, asArray;\n    if (!target.isEmpty() && (targetInner = target.getType()) instanceof Arr)\n      target = asArray = targetInner.getProp(\"<i>\");\n\n    function explore(aval, path, depth) {\n      if (depth > 3 || !aval.forward) return;\n      for (var i = 0; i < aval.forward.length; ++i) {\n        var prop = aval.forward[i].propagatesTo();\n        if (!prop) continue;\n        var newPath = path, dest;\n        if (prop instanceof AVal) {\n          dest = prop;\n        } else if (prop.target instanceof AVal) {\n          newPath += prop.pathExt;\n          dest = prop.target;\n        } else continue;\n        if (dest == target) return newPath;\n        var found = explore(dest, newPath, depth + 1);\n        if (found) return found;\n      }\n    }\n\n    var foundPath = explore(fn.self, \"!this\", 0);\n    for (var i = 0; !foundPath && i < fn.args.length; ++i)\n      foundPath = explore(fn.args[i], \"!\" + i, 0);\n\n    if (foundPath) {\n      if (asArray) foundPath = \"[\" + foundPath + \"]\";\n      var p = new def.TypeParser(foundPath);\n      var parsed = p.parseType(true);\n      fn.computeRet = parsed.apply ? parsed : function() { return parsed; };\n      fn.computeRetSource = foundPath;\n      return true;\n    }\n  }\n\n  // SCOPE GATHERING PASS\n\n  function addVar(scope, nameNode) {\n    return scope.defProp(nameNode.name, nameNode);\n  }\n  function patternName(node) {\n    if (node.type == \"Identifier\") return node.name\n    if (node.type == \"AssignmentPattern\") return patternName(node.left)\n    if (node.type == \"ObjectPattern\") return \"{\" + node.properties.map(function(e) { return patternName(e.value) }).join(\", \") + \"}\"\n    if (node.type == \"ArrayPattern\") return \"[\" + node.elements.map(function(e) { return e ? patternName(e) : \"\" }).join(\", \") + \"]\"\n    if (node.type == \"RestElement\") return \"...\" + patternName(node.argument)\n    return \"_\"\n  }\n\n  function isBlockScopedDecl(node) {\n    return node.type == \"VariableDeclaration\" && node.kind != \"var\" ||\n      node.type == \"FunctionDeclaration\" ||\n      node.type == \"ClassDeclaration\";\n  }\n\n  function patternScopes(inner, outer) {\n    return {inner: inner, outer: outer || inner}\n  }\n\n  var scopeGatherer = exports.scopeGatherer = walk.make({\n    VariablePattern: function(node, scopes) {\n      if (scopes.inner) addVar(scopes.inner, node)\n    },\n    AssignmentPattern: function(node, scopes, c) {\n      c(node.left, scopes, \"Pattern\")\n      c(node.right, scopes.outer, \"Expression\")\n    },\n    AssignmentExpression: function(node, scope, c) {\n      if (node.left.type == \"MemberExpression\")\n        c(node.left, scope, \"Expression\")\n      else\n        c(node.left, patternScopes(false, scope), \"Pattern\")\n      c(node.right, scope, \"Expression\")\n    },\n    MemberPattern: function(node, scope, c) {\n      c(node, scope.outer)\n    },\n    Function: function(node, scope, c) {\n      var inner = node.scope = new Scope(scope, node)\n      var argVals = [], argNames = []\n      for (var i = 0; i < node.params.length; ++i) {\n        var param = node.params[i]\n        argNames.push(patternName(param))\n        if (param.type == \"Identifier\") {\n          argVals.push(addVar(inner, param))\n        } else {\n          var arg = new AVal\n          argVals.push(arg)\n          arg.originNode = param\n          c(param, patternScopes(inner), \"Pattern\")\n        }\n      }\n      inner.fnType = new Fn(node.id && node.id.name, new AVal, argVals, argNames, ANull, node.generator)\n      inner.fnType.originNode = node;\n      if (node.id) {\n        var decl = node.type == \"FunctionDeclaration\";\n        addVar(decl ? scope : inner, node.id);\n      }\n      c(node.body, inner, node.expression ? \"Expression\" : \"Statement\");\n    },\n    BlockStatement: function(node, scope, c) {\n      if (!node.scope && node.body.some(isBlockScopedDecl))\n        scope = node.scope = new Scope(scope, node, true)\n      walk.base.BlockStatement(node, scope, c)\n    },\n    CatchClause: function(node, scope, c) {\n      scope = node.scope = new Scope(scope, node, false, true);\n      if (node.param.type == \"Identifier\") {\n        var v = addVar(scope, node.param);\n        c(node.body, scope, \"Statement\");\n        var ecma = cx.definitions.ecmascript;\n        if (ecma && v.isEmpty()) getInstance(ecma[\"Error.prototype\"]).propagate(v, WG_CATCH_ERROR);\n      } else {\n        c(node.param, patternScopes(scope), \"Pattern\")\n      }\n    },\n    VariableDeclaration: function(node, scope, c) {\n      var targetScope = node.kind == \"var\" ? functionScope(scope) : scope\n      for (var i = 0; i < node.declarations.length; ++i) {\n        var decl = node.declarations[i];\n        c(decl.id, patternScopes(targetScope, scope), \"Pattern\")\n        if (decl.init) c(decl.init, scope, \"Expression\");\n      }\n    },\n    ClassDeclaration: function(node, scope, c) {\n      addVar(scope, node.id)\n      if (node.superClass) c(node.superClass, scope, \"Expression\")\n      for (var i = 0; i < node.body.body.length; i++)\n        c(node.body.body[i], scope)\n    },\n    ForInStatement: function(node, scope, c) {\n      if (!node.scope && isBlockScopedDecl(node.left))\n        scope = node.scope = new Scope(scope, node, true)\n      walk.base.ForInStatement(node, scope, c)\n    },\n    ForStatement: function(node, scope, c) {\n      if (!node.scope && node.init && isBlockScopedDecl(node.init))\n        scope = node.scope = new Scope(scope, node, true)\n      walk.base.ForStatement(node, scope, c)\n    },\n    ImportDeclaration: function(node, scope) {\n      for (var i = 0; i < node.specifiers.length; i++)\n        addVar(scope, node.specifiers[i].local)\n    }\n  });\n  scopeGatherer.ForOfStatement = scopeGatherer.ForInStatement\n\n  function rmScope(node) { if (node.scope) node.scope = null }\n  var scopeClearer = {BlockStatement: rmScope, Function: rmScope, CatchClause: rmScope,\n                      ForInStateMent: rmScope, ForStatement: rmScope}\n  exports.clearScopes = function(ast) {\n    walk.simple(ast, scopeClearer)\n  };\n\n  // CONSTRAINT GATHERING PASS\n\n  var propName = exports.propName = function(node, inferInScope) {\n    var key = node.property || node.key;\n    if (!node.computed && key.type == \"Identifier\") return key.name;\n    if (key.type == \"Literal\") {\n      if (typeof key.value == \"string\") return key.value\n      if (typeof key.value == \"number\") return String(key.value)\n    }\n    if (inferInScope) {\n      var symName = symbolName(infer(key, inferInScope))\n      if (symName) return node.propName = symName\n    } else if (node.propName) {\n      return node.propName\n    }\n    return \"<i>\";\n  }\n  function symbolName(val) {\n    var sym = val.getSymbolType()\n    if (sym) return sym.asPropName()\n  }\n\n  function unopResultType(op) {\n    switch (op) {\n    case \"+\": case \"-\": case \"~\": return cx.num;\n    case \"!\": return cx.bool;\n    case \"typeof\": return cx.str;\n    case \"void\": case \"delete\": return ANull;\n    }\n  }\n  function binopIsBoolean(op) {\n    switch (op) {\n    case \"==\": case \"!=\": case \"===\": case \"!==\": case \"<\": case \">\": case \">=\": case \"<=\":\n    case \"in\": case \"instanceof\": return true;\n    }\n  }\n  function literalType(node) {\n    if (node.regex) return getInstance(cx.protos.RegExp);\n    switch (typeof node.value) {\n    case \"boolean\": return cx.bool;\n    case \"number\": return cx.num;\n    case \"string\": return cx.str;\n    case \"object\":\n    case \"function\":\n      if (!node.value) return ANull;\n      return getInstance(cx.protos.RegExp);\n    }\n  }\n\n  function join(a, b) {\n    if (a == b || b == ANull) return a\n    if (a == ANull) return b\n    var joined = new AVal\n    a.propagate(joined)\n    b.propagate(joined)\n    return joined\n  }\n\n  function connectParams(node, scope) {\n    for (var i = 0; i < node.params.length; i++) {\n      var param = node.params[i]\n      if (param.type == \"Identifier\") continue\n      connectPattern(param, scope, node.scope.fnType.args[i])\n    }\n  }\n\n  function ensureVar(node, scope) {\n    return scope.hasProp(node.name) || cx.topScope.defProp(node.name, node)\n  }\n\n  var inferPatternVisitor = exports.inferPatternVisitor = {\n    Identifier: function(node, scope, source) {\n      source.propagate(ensureVar(node, scope))\n    },\n    MemberExpression: function(node, scope, source) {\n      var obj = infer(node.object, scope)\n      var pName = propName(node, scope)\n      obj.propagate(new DefProp(pName, source, node.property))\n    },\n    RestElement: function(node, scope, source) {\n      connectPattern(node.argument, scope, new Arr(source))\n    },\n    ObjectPattern: function(node, scope, source) {\n      for (var i = 0; i < node.properties.length; ++i) {\n        var prop = node.properties[i]\n        connectPattern(prop.value, scope, source.getProp(propName(prop)))\n      }\n    },\n    ArrayPattern: function(node, scope, source) {\n      for (var i = 0; i < node.elements.length; i++)\n        if (node.elements[i])\n          connectPattern(node.elements[i], scope, source.getProp(String(i)))\n    },\n    AssignmentPattern: function(node, scope, source) {\n      connectPattern(node.left, scope, join(source, infer(node.right, scope)))\n    }\n  }\n\n  function connectPattern(node, scope, source) {\n    var connecter = inferPatternVisitor[node.type]\n    if (connecter) connecter(node, scope, source)\n  }\n\n  function getThis(scope) {\n    var fnScope = functionScope(scope)\n    return fnScope.fnType ? fnScope.fnType.self : fnScope\n  }\n\n  function maybeAddPhantomObj(obj) {\n    if (!obj.isEmpty() || !obj.propertyOf) return\n    obj.propertyOf.getProp(obj.propertyName).addType(new Obj, WG_PHANTOM_OBJ)\n    maybeAddPhantomObj(obj.propertyOf)\n  }\n\n  function inferClass(node, scope, name) {\n    if (!name && node.id) name = node.id.name\n\n    var sup = cx.protos.Object, supCtor, delayed\n    if (node.superClass) {\n      if (node.superClass.type == \"Literal\" && node.superClass.value == null) {\n        sup = null\n      } else {\n        var supVal = infer(node.superClass, scope), supProto\n        supCtor = supVal.getFunctionType()\n        if (supCtor && (supProto = supCtor.getProp(\"prototype\").getObjType())) {\n          sup = supProto\n        } else {\n          supCtor = supVal\n          delayed = supVal.getProp(\"prototype\")\n        }\n      }\n    }\n    var proto = new Obj(sup, name && name + \".prototype\")\n    if (delayed) delayed.propagate(new HasProto(proto))\n\n    return withSuper(supCtor, delayed || sup, function() {\n      var ctor, body = node.body.body\n      for (var i = 0; i < body.length; i++)\n        if (body[i].kind == \"constructor\") ctor = body[i].value\n      var fn = node.objType = ctor ? infer(ctor, scope) : new Fn(name, ANull, [], null, ANull)\n      fn.originNode = node.id || ctor || node\n\n      var inst = getInstance(proto, fn)\n      fn.self.addType(inst)\n      fn.defProp(\"prototype\", node).addType(proto)\n      for (var i = 0; i < body.length; i++) {\n        var method = body[i], target\n        if (method.kind == \"constructor\") continue\n        var pName = propName(method, scope)\n        if (pName == \"<i>\" || method.kind == \"set\") {\n          target = ANull\n        } else {\n          target = (method.static ? fn : proto).defProp(pName, method.key)\n          target.initializer = true\n          if (method.kind == \"get\") target = new IsCallee(inst, [], null, target)\n        }\n        infer(method.value, scope, target)\n        var methodFn = target.getFunctionType()\n        if (methodFn) methodFn.self.addType(inst)\n      }\n      return fn\n    })\n  }\n\n  function arrayLiteralType(elements, scope, inner) {\n    var tuple = elements.length > 1 && elements.length < 6\n    if (tuple) {\n      var homogenous = true, litType\n      for (var i = 0; i < elements.length; i++) {\n        var elt = elements[i]\n        if (!elt)\n          tuple = false\n        else if (elt.type != \"Literal\" || (litType && litType != typeof elt.value))\n          homogenous = false\n        else\n          litType = typeof elt.value\n      }\n      if (homogenous) tuple = false\n    }\n\n    if (tuple) {\n      var types = []\n      for (var i = 0; i < elements.length; ++i)\n        types.push(inner(elements[i], scope))\n      return new Arr(types)\n    } else if (elements.length < 2) {\n      return new Arr(elements[0] && inner(elements[0], scope))\n    } else {\n      var eltVal = new AVal\n      for (var i = 0; i < elements.length; i++)\n        if (elements[i]) inner(elements[i], scope).propagate(eltVal)\n      return new Arr(eltVal)\n    }\n  }\n\n  function ret(f) {\n    return function(node, scope, out, name) {\n      var r = f(node, scope, name);\n      if (out) r.propagate(out);\n      return r;\n    };\n  }\n  function fill(f) {\n    return function(node, scope, out, name) {\n      if (!out) out = new AVal;\n      f(node, scope, out, name);\n      return out;\n    };\n  }\n\n  var inferExprVisitor = exports.inferExprVisitor = {\n    ArrayExpression: ret(function(node, scope) {\n      return arrayLiteralType(node.elements, scope, infer)\n    }),\n    ObjectExpression: ret(function(node, scope, name) {\n      var proto = cx.protos.Object, waitForProto\n      for (var i = 0; i < node.properties.length; ++i) {\n        var prop = node.properties[i]\n        if (prop.key.name == \"__proto__\") {\n          if (prop.value.type == \"Literal\" && prop.value.value == null) {\n            proto = null\n          } else {\n            var protoVal = infer(prop.value, scope), known = protoVal.getObjType()\n            if (known) proto = known\n            else waitForProto = protoVal\n          }\n        }\n      }\n\n      var obj = node.objType = new Obj(proto, name);\n      if (waitForProto) waitForProto.propagate(new HasProto(obj))\n      obj.originNode = node;\n\n      withSuper(null, waitForProto || proto, function() {\n        for (var i = 0; i < node.properties.length; ++i) {\n          var prop = node.properties[i], key = prop.key;\n          if (ignoredProp(prop.key.name)) continue;\n\n          var name = propName(prop, scope), target\n          if (name == \"<i>\" || prop.kind == \"set\") {\n            target = ANull;\n          } else {\n            var val = target = obj.defProp(name, key);\n            val.initializer = true;\n            if (prop.kind == \"get\")\n              target = new IsCallee(obj, [], null, val);\n          }\n          infer(prop.value, scope, target, name);\n          if (prop.value.type == \"FunctionExpression\")\n            prop.value.scope.fnType.self.addType(obj, WG_SPECULATIVE_THIS);\n        }\n      })\n      return obj;\n    }),\n    FunctionExpression: ret(function(node, scope, name) {\n      var inner = node.scope, fn = inner.fnType;\n      if (name && !fn.name) fn.name = name;\n      connectParams(node, inner)\n      if (node.expression)\n        infer(node.body, inner, inner.fnType.retval = new AVal)\n      else\n        walk.recursive(node.body, inner, null, inferWrapper, \"Statement\")\n      if (node.type == \"ArrowFunctionExpression\")\n        getThis(scope).propagate(fn.self)\n      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);\n      if (node.id) inner.getProp(node.id.name).addType(fn);\n      return fn;\n    }),\n    ClassExpression: ret(inferClass),\n    SequenceExpression: ret(function(node, scope) {\n      for (var i = 0, l = node.expressions.length - 1; i < l; ++i)\n        infer(node.expressions[i], scope, ANull);\n      return infer(node.expressions[l], scope);\n    }),\n    UnaryExpression: ret(function(node, scope) {\n      infer(node.argument, scope, ANull);\n      return unopResultType(node.operator);\n    }),\n    UpdateExpression: ret(function(node, scope) {\n      infer(node.argument, scope, ANull);\n      return cx.num;\n    }),\n    BinaryExpression: ret(function(node, scope) {\n      if (node.operator == \"+\") {\n        var lhs = infer(node.left, scope);\n        var rhs = infer(node.right, scope);\n        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;\n        if (lhs.hasType(cx.num) && rhs.hasType(cx.num)) return cx.num;\n        var result = new AVal;\n        lhs.propagate(new IsAdded(rhs, result));\n        rhs.propagate(new IsAdded(lhs, result));\n        return result;\n      } else {\n        infer(node.left, scope, ANull);\n        infer(node.right, scope, ANull);\n        return binopIsBoolean(node.operator) ? cx.bool : cx.num;\n      }\n    }),\n    AssignmentExpression: ret(function(node, scope, name) {\n      var rhs, pName;\n      if (node.left.type == \"MemberExpression\") {\n        pName = propName(node.left, scope)\n        if (!name)\n          name = node.left.object.type == \"Identifier\" ? node.left.object.name + \".\" + pName : pName\n      } else if (!name && node.left.type == \"Identifier\") {\n        name = node.left.name\n      }\n\n      if (node.operator && node.operator != \"=\" && node.operator != \"+=\") {\n        infer(node.right, scope, ANull);\n        rhs = cx.num;\n      } else {\n        rhs = infer(node.right, scope, null, name);\n      }\n\n      if (node.left.type == \"MemberExpression\") {\n        var obj = infer(node.left.object, scope);\n        if (pName == \"prototype\") maybeInstantiate(scope, 20);\n        if (pName == \"<i>\") {\n          // This is a hack to recognize for/in loops that copy\n          // properties, and do the copying ourselves, insofar as we\n          // manage, because such loops tend to be relevant for type\n          // information.\n          var v = node.left.property.name, local = scope.props[v], over = local && local.iteratesOver;\n          if (over) {\n            maybeInstantiate(scope, 20);\n            var fromRight = node.right.type == \"MemberExpression\" && node.right.computed && node.right.property.name == v;\n            over.forAllProps(function(prop, val, local) {\n              if (local && prop != \"prototype\" && prop != \"<i>\")\n                obj.propagate(new DefProp(prop, fromRight ? val : ANull));\n            });\n            return rhs;\n          }\n        }\n\n        obj.propagate(new DefProp(pName, rhs, node.left.property));\n        maybeAddPhantomObj(obj)\n        if (node.right.type == \"FunctionExpression\")\n          obj.propagate(node.right.scope.fnType.self, WG_SPECULATIVE_THIS);\n      } else {\n        connectPattern(node.left, scope, rhs)\n      }\n      return rhs;\n    }),\n    LogicalExpression: fill(function(node, scope, out) {\n      infer(node.left, scope, out);\n      infer(node.right, scope, out);\n    }),\n    ConditionalExpression: fill(function(node, scope, out) {\n      infer(node.test, scope, ANull);\n      infer(node.consequent, scope, out);\n      infer(node.alternate, scope, out);\n    }),\n    NewExpression: fill(function(node, scope, out, name) {\n      if (node.callee.type == \"Identifier\" && node.callee.name in scope.props)\n        maybeInstantiate(scope, 20);\n\n      for (var i = 0, args = []; i < node.arguments.length; ++i)\n        args.push(infer(node.arguments[i], scope));\n      var callee = infer(node.callee, scope);\n      var self = new AVal;\n      callee.propagate(new IsCtor(self, name && /\\.prototype$/.test(name)));\n      self.propagate(out, WG_NEW_INSTANCE);\n      callee.propagate(new IsCallee(self, args, node.arguments, new IfObj(out)));\n    }),\n    CallExpression: fill(function(node, scope, out) {\n      for (var i = 0, args = []; i < node.arguments.length; ++i)\n        args.push(infer(node.arguments[i], scope));\n      var outerFn = functionScope(scope).fnType\n      if (node.callee.type == \"MemberExpression\") {\n        var self = infer(node.callee.object, scope);\n        var pName = propName(node.callee, scope)\n        if (outerFn && (pName == \"call\" || pName == \"apply\") &&\n            outerFn.args.indexOf(self) > -1)\n          maybeInstantiate(scope, 30);\n        self.propagate(new HasMethodCall(pName, args, node.arguments, out));\n      } else if (node.callee.type == \"Super\" && cx.curSuperCtor) {\n        node.callee.superType = cx.curSuperCtor\n        cx.curSuperCtor.propagate(new IsCallee(getThis(scope), args, node.arguments, out))\n        getThis(scope).propagate(out, WG_NEW_INSTANCE)\n      } else {\n        var callee = infer(node.callee, scope);\n        if (outerFn && outerFn.args.indexOf(callee) > -1)\n          maybeInstantiate(scope, 30);\n        var knownFn = callee.getFunctionType();\n        if (knownFn && knownFn.instantiateScore && outerFn)\n          maybeInstantiate(scope, knownFn.instantiateScore / 5);\n        callee.propagate(new IsCallee(cx.topScope, args, node.arguments, out));\n      }\n    }),\n    MemberExpression: fill(function(node, scope, out) {\n      var name = propName(node), wg;\n      if (name == \"<i>\") {\n        var propType = infer(node.property, scope)\n        var symName = symbolName(propType)\n        if (symName)\n          name = node.propName = symName\n        else if (!propType.hasType(cx.num))\n          wg = WG_MULTI_MEMBER\n      }\n      infer(node.object, scope).getProp(name).propagate(out, wg)\n    }),\n    Identifier: ret(function(node, scope) {\n      if (node.name == \"arguments\") {\n        var fnScope = functionScope(scope, false)\n        if (fnScope.fnType && !(node.name in fnScope.props))\n          fnScope.defProp(node.name, fnScope.fnType.originNode)\n            .addType(new Arr(fnScope.fnType.arguments = new AVal));\n      }\n      return scope.getProp(node.name);\n    }),\n    ThisExpression: ret(function(_node, scope) {\n      return getThis(scope)\n    }),\n    Super: ret(function(node) {\n      return node.superType = cx.curSuper || ANull\n    }),\n    Literal: ret(function(node) {\n      return literalType(node);\n    }),\n    TemplateLiteral: ret(function(node, scope) {\n      for (var i = 0; i < node.expressions.length; ++i)\n        infer(node.expressions[i], scope, ANull)\n      return cx.str\n    }),\n    TaggedTemplateExpression: fill(function(node, scope, out) {\n      var args = [new Arr(cx.str)]\n      for (var i = 0; i < node.quasi.expressions.length; ++i)\n        args.push(infer(node.quasi.expressions[i], scope))\n      infer(node.tag, scope, new IsCallee(cx.topScope, args, node.quasi.expressions, out))\n    }),\n    YieldExpression: ret(function(node, scope) {\n      var output = ANull, fn = functionScope(scope).fnType\n      if (fn) {\n        if (fn.retval == ANull) fn.retval = new AVal\n        if (!fn.yieldval) fn.yieldval = new AVal\n        output = fn.retval\n      }\n      if (node.argument) {\n        if (node.delegate) {\n          infer(node.argument, scope, new HasMethodCall(\"next\", [], null,\n                                                        new GetProp(\"value\", output)))\n        } else {\n          infer(node.argument, scope, output)\n        }\n      }\n      return fn ? fn.yieldval : ANull\n    })\n  };\n  inferExprVisitor.ArrowFunctionExpression = inferExprVisitor.FunctionExpression\n\n  function infer(node, scope, out, name) {\n    var handler = inferExprVisitor[node.type];\n    return handler ? handler(node, scope, out, name) : ANull;\n  }\n\n  function loopPattern(init) {\n    return init.type == \"VariableDeclaration\" ? init.declarations[0].id : init\n  }\n\n  var inferWrapper = exports.inferWrapper = walk.make({\n    Expression: function(node, scope) {\n      infer(node, node.scope || scope, ANull);\n    },\n\n    FunctionDeclaration: function(node, scope, c) {\n      var inner = node.scope, fn = inner.fnType;\n      connectParams(node, inner)\n      c(node.body, inner, \"Statement\");\n      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);\n      scope.getProp(node.id.name).addType(fn)\n    },\n\n    Statement: function(node, scope, c) {\n      c(node, node.scope || scope)\n    },\n\n    VariableDeclaration: function(node, scope) {\n      for (var i = 0; i < node.declarations.length; ++i) {\n        var decl = node.declarations[i];\n        if (decl.id.type == \"Identifier\") {\n          var prop = scope.getProp(decl.id.name);\n          if (decl.init)\n            infer(decl.init, scope, prop, decl.id.name);\n        } else if (decl.init) {\n          connectPattern(decl.id, scope, infer(decl.init, scope))\n        }\n      }\n    },\n\n    ClassDeclaration: function(node, scope) {\n      scope.getProp(node.id.name).addType(inferClass(node, scope, node.id.name))\n    },\n\n    ReturnStatement: function(node, scope) {\n      if (!node.argument) return;\n      var output = ANull, fn = functionScope(scope).fnType\n      if (fn) {\n        if (fn.retval == ANull) fn.retval = new AVal;\n        output = fn.retval;\n      }\n      infer(node.argument, scope, output);\n    },\n\n    ForInStatement: function(node, scope, c) {\n      var source = infer(node.right, scope);\n      if ((node.right.type == \"Identifier\" && node.right.name in scope.props) ||\n          (node.right.type == \"MemberExpression\" && node.right.property.name == \"prototype\")) {\n        maybeInstantiate(scope, 5);\n        var pattern = loopPattern(node.left)\n        if (pattern.type == \"Identifier\") {\n          if (pattern.name in scope.props)\n            scope.getProp(pattern.name).iteratesOver = source\n          source.getProp(\"<i>\").propagate(ensureVar(pattern, scope))\n        } else {\n          connectPattern(pattern, scope, source.getProp(\"<i>\"))\n        }\n      }\n      c(node.body, scope, \"Statement\");\n    },\n\n    ForOfStatement: function(node, scope, c) {\n      var pattern = loopPattern(node.left), target\n      if (pattern.type == \"Identifier\")\n        target = ensureVar(pattern, scope)\n      else\n        connectPattern(pattern, scope, target = new AVal)\n      infer(node.right, scope, new HasMethodCall(\":Symbol.iterator\", [], null,\n                                                 new HasMethodCall(\"next\", [], null,\n                                                                   new GetProp(\"value\", target))))\n      c(node.body, scope, \"Statement\")\n    }\n  });\n\n  // PARSING\n\n  var parse = exports.parse = function(text, options, thirdArg) {\n    if (!options || Array.isArray(options)) options = thirdArg\n    var ast;\n    try { ast = acorn.parse(text, options); }\n    catch(e) { ast = acorn_loose.parse_dammit(text, options); }\n    return ast;\n  };\n\n  // ANALYSIS INTERFACE\n\n  exports.analyze = function(ast, name, scope) {\n    if (typeof ast == \"string\") ast = parse(ast);\n\n    if (!name) name = \"file#\" + cx.origins.length;\n    exports.addOrigin(cx.curOrigin = name);\n\n    if (!scope) scope = cx.topScope;\n    cx.startAnalysis();\n\n    walk.recursive(ast, scope, null, scopeGatherer);\n    if (cx.parent) cx.parent.signal(\"preInfer\", ast, scope)\n    walk.recursive(ast, scope, null, inferWrapper);\n    if (cx.parent) cx.parent.signal(\"postInfer\", ast, scope)\n\n    cx.curOrigin = null;\n  };\n\n  // PURGING\n\n  exports.purge = function(origins, start, end) {\n    var test = makePredicate(origins, start, end);\n    ++cx.purgeGen;\n    cx.topScope.purge(test);\n    for (var prop in cx.props) {\n      var list = cx.props[prop];\n      for (var i = 0; i < list.length; ++i) {\n        var obj = list[i], av = obj.props[prop];\n        if (!av || test(av, av.originNode)) list.splice(i--, 1);\n      }\n      if (!list.length) delete cx.props[prop];\n    }\n  };\n\n  function makePredicate(origins, start, end) {\n    var arr = Array.isArray(origins);\n    if (arr && origins.length == 1) { origins = origins[0]; arr = false; }\n    if (arr) {\n      if (end == null) return function(n) { return origins.indexOf(n.origin) > -1; };\n      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && origins.indexOf(n.origin) > -1; };\n    } else {\n      if (end == null) return function(n) { return n.origin == origins; };\n      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && n.origin == origins; };\n    }\n  }\n\n  AVal.prototype.purge = function(test) {\n    if (this.purgeGen == cx.purgeGen) return;\n    this.purgeGen = cx.purgeGen;\n    for (var i = 0; i < this.types.length; ++i) {\n      var type = this.types[i];\n      if (test(type, type.originNode))\n        this.types.splice(i--, 1);\n      else\n        type.purge(test);\n    }\n    if (!this.types.length) this.maxWeight = 0;\n\n    if (this.forward) for (var i = 0; i < this.forward.length; ++i) {\n      var f = this.forward[i];\n      if (test(f)) {\n        this.forward.splice(i--, 1);\n        if (this.props) this.props = null;\n      } else if (f.purge) {\n        f.purge(test);\n      }\n    }\n  };\n  ANull.purge = function() {};\n  Obj.prototype.purge = function(test) {\n    if (this.purgeGen == cx.purgeGen) return true;\n    this.purgeGen = cx.purgeGen;\n    for (var p in this.props) {\n      var av = this.props[p];\n      if (test(av, av.originNode))\n        this.removeProp(p);\n      av.purge(test);\n    }\n  };\n  Fn.prototype.purge = function(test) {\n    if (Obj.prototype.purge.call(this, test)) return;\n    this.self.purge(test);\n    this.retval.purge(test);\n    for (var i = 0; i < this.args.length; ++i) this.args[i].purge(test);\n  };\n\n  // EXPRESSION TYPE DETERMINATION\n\n  function findByPropertyName(name) {\n    guessing = true;\n    var found = objsWithProp(name);\n    if (found) for (var i = 0; i < found.length; ++i) {\n      var val = found[i].getProp(name);\n      if (!val.isEmpty()) return val;\n    }\n    return ANull;\n  }\n\n  function generatorResult(input, output) {\n    var retObj = new Obj(true)\n    retObj.defProp(\"done\").addType(cx.bool)\n    output.propagate(retObj.defProp(\"value\"))\n    var method = new Fn(null, ANull, input ? [input] : [], input ? [\"?\"] : [], retObj)\n    var result = new Obj(cx.definitions.ecmascript && cx.definitions.ecmascript.generator_prototype || true)\n    result.defProp(\"next\").addType(method)\n    return result\n  }\n\n  function maybeIterator(fn, output) {\n    if (!fn.generator) return output\n    if (!fn.computeRet) { // Reuse iterator objects for non-computed return types\n      if (fn.generator === true) fn.generator = generatorResult(fn.yieldval, output)\n      return fn.generator\n    }\n    return generatorResult(fn.yieldval, output)\n  }\n\n  function computeReturnType(funcNode, argNodes, scope) {\n    var fn = findType(funcNode, scope).getFunctionType()\n    if (!fn) return ANull\n    var result = fn.retval\n    if (fn.computeRet) {\n      for (var i = 0, args = []; i < argNodes.length; ++i)\n        args.push(findType(argNodes[i], scope))\n      var self = ANull\n      if (funcNode.type == \"MemberExpression\")\n        self = findType(funcNode.object, scope)\n      result = fn.computeRet(self, args, argNodes);\n    }\n    return maybeIterator(fn, result)\n  }\n\n  var typeFinder = exports.typeFinder = {\n    ArrayExpression: function(node, scope) {\n      return arrayLiteralType(node.elements, scope, findType)\n    },\n    ObjectExpression: function(node) {\n      return node.objType;\n    },\n    ClassExpression: function(node) {\n      return node.objType;\n    },\n    FunctionExpression: function(node) {\n      return node.scope.fnType;\n    },\n    ArrowFunctionExpression: function(node) {\n      return node.scope.fnType;\n    },\n    SequenceExpression: function(node, scope) {\n      return findType(node.expressions[node.expressions.length-1], scope);\n    },\n    UnaryExpression: function(node) {\n      return unopResultType(node.operator);\n    },\n    UpdateExpression: function() {\n      return cx.num;\n    },\n    BinaryExpression: function(node, scope) {\n      if (binopIsBoolean(node.operator)) return cx.bool;\n      if (node.operator == \"+\") {\n        var lhs = findType(node.left, scope);\n        var rhs = findType(node.right, scope);\n        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;\n      }\n      return cx.num;\n    },\n    AssignmentExpression: function(node, scope) {\n      return findType(node.right, scope);\n    },\n    LogicalExpression: function(node, scope) {\n      var lhs = findType(node.left, scope);\n      return lhs.isEmpty() ? findType(node.right, scope) : lhs;\n    },\n    ConditionalExpression: function(node, scope) {\n      var lhs = findType(node.consequent, scope);\n      return lhs.isEmpty() ? findType(node.alternate, scope) : lhs;\n    },\n    NewExpression: function(node, scope) {\n      var f = findType(node.callee, scope).getFunctionType();\n      var proto = f && f.getProp(\"prototype\").getObjType();\n      if (!proto) return ANull;\n      return getInstance(proto, f);\n    },\n    CallExpression: function(node, scope) {\n      return computeReturnType(node.callee, node.arguments, scope)\n    },\n    MemberExpression: function(node, scope) {\n      var propN = propName(node), obj = findType(node.object, scope).getType();\n      if (obj) return obj.getProp(propN);\n      if (propN == \"<i>\") return ANull;\n      return findByPropertyName(propN);\n    },\n    MethodDefinition: function(node) {\n      var propN = propName(node), obj = getThis(node.value.scope).getType();\n      if (obj) return obj.getProp(propN);\n      return ANull;\n    },\n    Identifier: function(node, scope) {\n      return scope.hasProp(node.name) || ANull;\n    },\n    ThisExpression: function(_node, scope) {\n      return getThis(scope)\n    },\n    Literal: function(node) {\n      return literalType(node);\n    },\n    Super: ret(function(node) {\n      return node.superType\n    }),\n    TemplateLiteral: function() {\n      return cx.str\n    },\n    TaggedTemplateExpression: function(node, scope) {\n      return computeReturnType(node.tag, node.quasi.expressions, scope)\n    },\n    YieldExpression: function(_node, scope) {\n      var fn = functionScope(scope).fnType\n      return fn ? fn.yieldval : ANull\n    }\n  };\n\n  function findType(node, scope) {\n    var finder = typeFinder[node.type];\n    return finder ? finder(node, scope) : ANull;\n  }\n\n  var searchVisitor = exports.searchVisitor = walk.make({\n    Function: function(node, _st, c) {\n      walk.base.Function(node, node.scope, c)\n    },\n    CatchClause: function(node, _st, c) {\n      walk.base.CatchClause(node, node.scope, c)\n    },\n    Property: function(node, st, c) {\n      if (node.computed) c(node.key, st, \"Expression\");\n      if (node.key != node.value) c(node.value, st, \"Expression\");\n    },\n    Statement: function(node, st, c) {\n      c(node, node.scope || st)\n    },\n    ImportSpecifier: function(node, st, c) {\n      c(node.local, st)\n    },\n    ImportDefaultSpecifier: function(node, st, c) {\n      c(node.local, st)\n    },\n    ImportNamespaceSpecifier: function(node, st, c) {\n      c(node.local, st)\n    }\n  });\n  exports.fullVisitor = walk.make({\n    MemberExpression: function(node, st, c) {\n      c(node.object, st, \"Expression\");\n      c(node.property, st, node.computed ? \"Expression\" : null);\n    },\n    Property: function(node, st, c) {\n      if (node.computed) c(node.key, st, \"Expression\");\n      c(node.value, st, \"Expression\");\n    }\n  }, searchVisitor);\n\n  exports.findExpressionAt = function(ast, start, end, defaultScope, filter) {\n    var test = filter || function(_t, node) {\n      if (node.type == \"Identifier\" && node.name == \"✖\") return false;\n      return typeFinder.hasOwnProperty(node.type);\n    };\n    return walk.findNodeAt(ast, start, end, test, searchVisitor, defaultScope || cx.topScope);\n  };\n\n  exports.findExpressionAround = function(ast, start, end, defaultScope, filter) {\n    var test = filter || function(_t, node) {\n      if (start != null && node.start > start) return false;\n      if (node.type == \"Identifier\" && node.name == \"✖\") return false;\n      return typeFinder.hasOwnProperty(node.type);\n    };\n    return walk.findNodeAround(ast, end, test, searchVisitor, defaultScope || cx.topScope);\n  };\n\n  exports.expressionType = function(found) {\n    return findType(found.node, found.state);\n  };\n\n  // Finding the expected type of something, from context\n\n  exports.parentNode = function(child, ast) {\n    var stack = [];\n    function c(node, st, override) {\n      if (node.start <= child.start && node.end >= child.end) {\n        var top = stack[stack.length - 1];\n        if (node == child) throw {found: top};\n        if (top != node) stack.push(node);\n        walk.base[override || node.type](node, st, c);\n        if (top != node) stack.pop();\n      }\n    }\n    try {\n      c(ast, null);\n    } catch (e) {\n      if (e.found) return e.found;\n      throw e;\n    }\n  };\n\n  var findTypeFromContext = exports.findTypeFromContext = {\n    ArrayExpression: function(parent, _, get) { return get(parent, true).getProp(\"<i>\"); },\n    ObjectExpression: function(parent, node, get) {\n      for (var i = 0; i < parent.properties.length; ++i) {\n        var prop = node.properties[i];\n        if (prop.value == node)\n          return get(parent, true).getProp(propName(prop));\n      }\n    },\n    UnaryExpression: function(parent) { return unopResultType(parent.operator); },\n    UpdateExpression: function() { return cx.num; },\n    BinaryExpression: function(parent) { return binopIsBoolean(parent.operator) ? cx.bool : cx.num; },\n    AssignmentExpression: function(parent, _, get) { return get(parent.left); },\n    LogicalExpression: function(parent, _, get) { return get(parent, true); },\n    ConditionalExpression: function(parent, node, get) {\n      if (parent.consequent == node || parent.alternate == node) return get(parent, true);\n    },\n    CallExpression: function(parent, node, get) {\n      for (var i = 0; i < parent.arguments.length; i++) {\n        var arg = parent.arguments[i];\n        if (arg == node) {\n          var calleeType = get(parent.callee).getFunctionType();\n          if (calleeType instanceof Fn)\n            return calleeType.args[i];\n          break;\n        }\n      }\n    },\n    ReturnStatement: function(_parent, node, get) {\n      // tweaking search position to avoid endless recursion\n      // when looking for definition of key in fn ( return fn ( return object ) )\n      // see ternjs/tern#777\n      var fnNode = walk.findNodeAround(node.sourceFile.ast, node.start - 1, \"Function\");\n      if (fnNode) {\n        var fnType = fnNode.node.type != \"FunctionDeclaration\"\n          ? get(fnNode.node, true).getFunctionType()\n          : fnNode.node.scope.fnType;\n        if (fnType) return fnType.retval.getType();\n      }\n    },\n    VariableDeclarator: function(parent, node, get) {\n      if (parent.init == node) return get(parent.id)\n    }\n  };\n  findTypeFromContext.NewExpression = findTypeFromContext.CallExpression\n\n  exports.typeFromContext = function(ast, found) {\n    var parent = exports.parentNode(found.node, ast);\n    var type = null;\n    if (findTypeFromContext.hasOwnProperty(parent.type)) {\n      var finder = findTypeFromContext[parent.type];\n      type = finder && finder(parent, found.node, function(node, fromContext) {\n        var obj = {node: node, state: found.state};\n        var tp = fromContext ? exports.typeFromContext(ast, obj) : exports.expressionType(obj);\n        return tp || ANull;\n      });\n    }\n    return type || exports.expressionType(found);\n  };\n\n  // Flag used to indicate that some wild guessing was used to produce\n  // a type or set of completions.\n  var guessing = false;\n\n  exports.resetGuessing = function(val) { guessing = val; };\n  exports.didGuess = function() { return guessing; };\n\n  exports.forAllPropertiesOf = function(type, f) {\n    type.gatherProperties(f, 0);\n  };\n\n  exports.findRefs = function(ast, baseScope, name, refScope, f) {\n    function handleId(node, scope, ancestors) {\n      if (node.name != name ||\n          (node == ast.id && ast.type == \"FunctionDeclaration\")) return;\n      for (var s = scope; s; s = s.prev) {\n        if (s == refScope) f(node, scope, ancestors);\n        if (name in s.props) return;\n      }\n    }\n    walk.ancestor(ast, {Identifier: handleId, VariablePattern: handleId},\n                  exports.fullVisitor, baseScope)\n  };\n\n  var simpleWalker = walk.make({\n    Function: function(node, _scope, c) {\n      c(node.body, node.scope, node.expression ? \"Expression\" : \"Statement\")\n    },\n    Statement: function(node, scope, c) {\n      c(node, node.scope || scope)\n    }\n  });\n\n  exports.findPropRefs = function(ast, scope, objType, name, f) {\n    // Find the type which owns the property in hierarchy\n    while (objType && !objType.props[name] && !(objType.maybeProps && objType.maybeProps[name])) {\n      objType = objType.proto;\n    }\n    if (!objType) throw new Error(\"Couldn't locate property in the base object type.\");\n\n    function isObjTypeProto(type) {\n      // Check whether the found type has objType in its hierarchy\n      while (type && type != objType) {\n        // Ff property is overriden higher in the hierarchy, return false\n        if (type.props[name] || (type.maybeProps && type.maybeProps[name])) {\n          return false;\n        }\n        type = type.proto;\n      }\n      return type;\n    }\n\n    walk.simple(ast, {\n      MemberExpression: function(node, scope) {\n        if (node.computed || propName(node) != name) return;\n        if (isObjTypeProto(findType(node.object, scope).getType())) f(node.property, scope);\n      },\n      ObjectExpression: function(node, scope) {\n        if (findType(node, scope).getType() != objType) return;\n        for (var i = 0; i < node.properties.length; ++i)\n          if (propName(node.properties[i]) == name) f(node.properties[i].key, scope);\n      },\n      MethodDefinition: function(node) {\n        if (propName(node) != name) return;\n        if (node.value && isObjTypeProto(getThis(node.value.scope).getType())) f(node.key, node.value.scope);\n      }\n    }, simpleWalker, scope);\n  };\n\n  // LOCAL-VARIABLE QUERIES\n\n  var scopeAt = exports.scopeAt = function(ast, pos, defaultScope) {\n    var found = walk.findNodeAround(ast, pos, function(_, node) {\n      return node.scope;\n    });\n    if (found) return found.node.scope;\n    else return defaultScope || cx.topScope;\n  };\n\n  exports.forAllLocalsAt = function(ast, pos, defaultScope, f) {\n    var scope = scopeAt(ast, pos, defaultScope);\n    scope.gatherProperties(f, 0);\n  };\n\n  // INIT DEF MODULE\n\n  // Delayed initialization because of cyclic dependencies.\n  def = exports.def = def.init({}, exports);\n});\n","(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    return mod(exports);\n  if (typeof define == \"function\" && define.amd) // AMD\n    return define([\"exports\"], mod);\n  mod((root.tern || (root.tern = {})).signal = {}); // Plain browser env\n})(this, function(exports) {\n\n  function on(type, f) {\n    var handlers = this._handlers || (this._handlers = Object.create(null));\n    (handlers[type] || (handlers[type] = [])).push(f);\n  }\n\n  function off(type, f) {\n    var arr = this._handlers && this._handlers[type];\n    if (arr) for (var i = 0; i < arr.length; ++i)\n      if (arr[i] == f) { arr.splice(i, 1); break; }\n  }\n\n  var noHandlers = []\n  function getHandlers(emitter, type) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    return arr && arr.length ? arr.slice() : noHandlers\n  }\n\n  function signal(type, a1, a2, a3, a4) {\n    var arr = getHandlers(this, type)\n    for (var i = 0; i < arr.length; ++i) arr[i].call(this, a1, a2, a3, a4)\n  }\n\n  function signalReturnFirst(type, a1, a2, a3, a4) {\n    var arr = getHandlers(this, type)\n    for (var i = 0; i < arr.length; ++i) {\n      var result = arr[i].call(this, a1, a2, a3, a4)\n      if (result) return result\n    }\n  }\n\n  function hasHandler(type) {\n    var arr = this._handlers && this._handlers[type]\n    return arr && arr.length > 0 && arr\n  }\n\n  exports.mixin = function(obj) {\n    obj.on = on; obj.off = off;\n    obj.signal = signal;\n    obj.signalReturnFirst = signalReturnFirst;\n    obj.hasHandler = hasHandler;\n    return obj;\n  };\n});\n","// The Tern server object\n\n// A server is a stateful object that manages the analysis for a\n// project, and defines an interface for querying the code in the\n// project.\n\n(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    return mod(exports, require(\"./infer\"), require(\"./signal\"),\n               require(\"acorn\"), require(\"acorn/dist/walk\"));\n  if (typeof define == \"function\" && define.amd) // AMD\n    return define([\"exports\", \"./infer\", \"./signal\", \"acorn/dist/acorn\", \"acorn/dist/walk\"], mod);\n  mod(root.tern || (root.tern = {}), tern, tern.signal, acorn, acorn.walk); // Plain browser env\n})(this, function(exports, infer, signal, acorn, walk) {\n  \"use strict\";\n\n  var plugins = Object.create(null);\n  exports.registerPlugin = function(name, init) { plugins[name] = init; };\n\n  var defaultOptions = exports.defaultOptions = {\n    debug: false,\n    async: false,\n    getFile: function(_f, c) { if (this.async) c(null, null); },\n    normalizeFilename: function(name) { return name },\n    defs: [],\n    plugins: {},\n    fetchTimeout: 1000,\n    dependencyBudget: 20000,\n    reuseInstances: true,\n    stripCRs: false,\n    ecmaVersion: 6,\n    projectDir: \"/\",\n    parent: null\n  };\n\n  var queryTypes = {\n    completions: {\n      takesFile: true,\n      run: findCompletions\n    },\n    properties: {\n      run: findProperties\n    },\n    type: {\n      takesFile: true,\n      run: findTypeAt\n    },\n    documentation: {\n      takesFile: true,\n      run: findDocs\n    },\n    definition: {\n      takesFile: true,\n      run: findDef\n    },\n    refs: {\n      takesFile: true,\n      fullFile: true,\n      run: findRefs\n    },\n    rename: {\n      takesFile: true,\n      fullFile: true,\n      run: buildRename\n    },\n    files: {\n      run: listFiles\n    }\n  };\n\n  exports.defineQueryType = function(name, desc) { queryTypes[name] = desc; };\n\n  function File(name, parent) {\n    this.name = name;\n    this.parent = parent;\n    this.scope = this.text = this.ast = this.lineOffsets = null;\n  }\n  File.prototype.asLineChar = function(pos) { return asLineChar(this, pos); };\n\n  function parseFile(srv, file) {\n    var options = {\n      directSourceFile: file,\n      allowReturnOutsideFunction: true,\n      allowImportExportEverywhere: true,\n      ecmaVersion: srv.options.ecmaVersion,\n      allowHashBang: true\n    }\n    var text = srv.signalReturnFirst(\"preParse\", file.text, options) || file.text\n    var ast = infer.parse(text, options)\n    srv.signal(\"postParse\", ast, text)\n    return ast\n  }\n\n  var astral = /[\\uD800-\\uDBFF]/g\n\n  function updateText(file, text, srv) {\n    file.text = srv.options.stripCRs ? text.replace(/\\r\\n/g, \"\\n\") : text;\n    file.hasAstral = astral.test(file.text)\n    infer.withContext(srv.cx, function() {\n      file.ast = parseFile(srv, file)\n    });\n    file.lineOffsets = null;\n  }\n\n  var Server = exports.Server = function(options) {\n    this.cx = null;\n    this.options = options || {};\n    for (var o in defaultOptions) if (!options.hasOwnProperty(o))\n      options[o] = defaultOptions[o];\n\n    this.projectDir = options.projectDir.replace(/\\\\/g, \"/\")\n    if (!/\\/$/.test(this.projectDir)) this.projectDir += \"/\"\n\n    this.parent = options.parent;\n    this.handlers = Object.create(null);\n    this.files = [];\n    this.fileMap = Object.create(null);\n    this.needsPurge = [];\n    this.budgets = Object.create(null);\n    this.uses = 0;\n    this.pending = 0;\n    this.asyncError = null;\n    this.mod = {}\n\n    this.defs = options.defs.slice(0)\n    this.plugins = Object.create(null)\n    for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin))\n      this.loadPlugin(plugin, options.plugins[plugin])\n\n    this.reset();\n  };\n  Server.prototype = signal.mixin({\n    addFile: function(name, /*optional*/ text, parent) {\n      // Don't crash when sloppy plugins pass non-existent parent ids\n      if (parent && !(parent in this.fileMap)) parent = null;\n      if (!(name in this.fileMap))\n        name = this.normalizeFilename(name)\n      ensureFile(this, name, parent, text);\n    },\n    delFile: function(name) {\n      var file = this.findFile(name);\n      if (file) {\n        this.needsPurge.push(file.name);\n        for (var i = 0; i < this.files.length; i++) {\n          if (this.files[i] == file) this.files.splice(i--, 1);\n          else if (this.files[i].parent == name) this.files[i].parent = null;\n        }\n        delete this.fileMap[file.name];\n      }\n    },\n    reset: function() {\n      this.signal(\"reset\");\n      this.cx = new infer.Context(this.defs, this);\n      this.uses = 0;\n      this.budgets = Object.create(null);\n      for (var i = 0; i < this.files.length; ++i) {\n        var file = this.files[i];\n        if (file.scope) {\n          infer.clearScopes(file.ast);\n          file.scope = null;\n        }\n      }\n      this.signal(\"postReset\");\n    },\n\n    request: function(doc, c) {\n      var inv = invalidDoc(doc);\n      if (inv) return c(inv);\n\n      var self = this;\n      doRequest(this, doc, function(err, data) {\n        c(err, data);\n        if (self.uses > 40) {\n          self.reset();\n          analyzeAll(self, null, function(){});\n        }\n      });\n    },\n\n    findFile: function(name) {\n      return this.fileMap[this.normalizeFilename(name)];\n    },\n\n    flush: function(c) {\n      var cx = this.cx;\n      analyzeAll(this, null, function(err) {\n        if (err) return c(err);\n        infer.withContext(cx, c);\n      });\n    },\n\n    startAsyncAction: function() {\n      ++this.pending;\n    },\n    finishAsyncAction: function(err) {\n      if (err) this.asyncError = err;\n      if (--this.pending === 0) this.signal(\"everythingFetched\");\n    },\n\n    addDefs: function(defs, toFront) {\n      if (toFront) this.defs.unshift(defs)\n      else this.defs.push(defs)\n\n      if (this.cx) this.reset()\n    },\n\n    deleteDefs: function(name) {\n      for (var i = 0; i < this.defs.length; i++) if (this.defs[i][\"!name\"] == name) {\n        this.defs.splice(i, 1);\n        if (this.cx) this.reset();\n        return;\n      }\n    },\n\n    loadPlugin: function(name, options) {\n      if (arguments.length == 1) options = this.options.plugins[name] || true\n      if (name in this.plugins || !(name in plugins) || !options) return\n      this.plugins[name] = true\n      var init = plugins[name](this, options)\n\n      // This is for backwards-compatibilty. Don't rely on it -- use addDef and on directly\n      if (!init) return\n      if (init.defs) this.addDefs(init.defs, init.loadFirst)\n      if (init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type))\n        this.on(type, init.passes[type])\n    },\n\n    normalizeFilename: function(name) {\n      var norm = this.options.normalizeFilename(name).replace(/\\\\/g, \"/\")\n      if (norm.indexOf(this.projectDir) == 0) norm = norm.slice(this.projectDir.length)\n      return norm\n    }\n  });\n\n  function doRequest(srv, doc, c) {\n    if (doc.query && !queryTypes.hasOwnProperty(doc.query.type))\n      return c(\"No query type '\" + doc.query.type + \"' defined\");\n\n    var query = doc.query;\n    // Respond as soon as possible when this just uploads files\n    if (!query) c(null, {});\n\n    var files = doc.files || [];\n    if (files.length) ++srv.uses;\n    for (var i = 0; i < files.length; ++i) {\n      var file = files[i];\n      file.name = srv.normalizeFilename(file.name)\n      if (file.type == \"delete\")\n        srv.delFile(file.name);\n      else\n        ensureFile(srv, file.name, null, file.type == \"full\" ? file.text : null);\n    }\n\n    var timeBudget = typeof doc.timeout == \"number\" ? [doc.timeout] : null;\n    if (!query) {\n      analyzeAll(srv, timeBudget, function(){});\n      return;\n    }\n\n    var queryType = queryTypes[query.type];\n    if (queryType.takesFile) {\n      if (typeof query.file != \"string\") return c(\".query.file must be a string\");\n      if (!/^#/.test(query.file)) ensureFile(srv, query.file, null);\n    }\n\n    analyzeAll(srv, timeBudget, function(err) {\n      if (err) return c(err);\n      var file = queryType.takesFile && resolveFile(srv, files, query.file);\n      if (queryType.fullFile && file.type == \"part\")\n        return c(\"Can't run a \" + query.type + \" query on a file fragment\");\n\n      infer.resetGuessing()\n      infer.withContext(srv.cx, function() {\n        var result, run = function() { result = queryType.run(srv, query, file); };\n        try {\n          if (timeBudget) infer.withTimeout(timeBudget[0], run);\n          else run();\n        } catch (e) {\n          if (srv.options.debug && e.name != \"TernError\") console.error(e.stack);\n          return c(e);\n        }\n        c(null, result);\n      });\n    });\n  }\n\n  function analyzeFile(srv, file) {\n    infer.withContext(srv.cx, function() {\n      file.scope = srv.cx.topScope;\n      srv.signal(\"beforeLoad\", file);\n      infer.analyze(file.ast, file.name, file.scope);\n      srv.signal(\"afterLoad\", file);\n    });\n    return file;\n  }\n\n  function ensureFile(srv, name, parent, text) {\n    var known = srv.findFile(name);\n    if (known) {\n      if (text != null) {\n        if (known.scope) {\n          srv.needsPurge.push(name);\n          infer.clearScopes(known.ast);\n          known.scope = null;\n        }\n        updateText(known, text, srv);\n      }\n      if (parentDepth(srv, known.parent) > parentDepth(srv, parent)) {\n        known.parent = parent;\n        if (known.excluded) known.excluded = null;\n      }\n      return;\n    }\n\n    var file = new File(name, parent);\n    srv.files.push(file);\n    srv.fileMap[name] = file;\n    if (text != null) {\n      updateText(file, text, srv);\n    } else if (srv.options.async) {\n      srv.startAsyncAction();\n      srv.options.getFile(name, function(err, text) {\n        updateText(file, text || \"\", srv);\n        srv.finishAsyncAction(err);\n      });\n    } else {\n      updateText(file, srv.options.getFile(name) || \"\", srv);\n    }\n  }\n\n  function fetchAll(srv, c) {\n    var done = true, returned = false;\n    srv.files.forEach(function(file) {\n      if (file.text != null) return;\n      if (srv.options.async) {\n        done = false;\n        srv.options.getFile(file.name, function(err, text) {\n          if (err && !returned) { returned = true; return c(err); }\n          updateText(file, text || \"\", srv);\n          fetchAll(srv, c);\n        });\n      } else {\n        try {\n          updateText(file, srv.options.getFile(file.name) || \"\", srv);\n        } catch (e) { return c(e); }\n      }\n    });\n    if (done) c();\n  }\n\n  function waitOnFetch(srv, timeBudget, c) {\n    var done = function() {\n      srv.off(\"everythingFetched\", done);\n      clearTimeout(timeout);\n      analyzeAll(srv, timeBudget, c);\n    };\n    srv.on(\"everythingFetched\", done);\n    var timeout = setTimeout(done, srv.options.fetchTimeout);\n  }\n\n  function analyzeAll(srv, timeBudget, c) {\n    if (srv.pending) return waitOnFetch(srv, timeBudget, c);\n\n    var e = srv.fetchError;\n    if (e) { srv.fetchError = null; return c(e); }\n\n    if (srv.needsPurge.length > 0) infer.withContext(srv.cx, function() {\n      infer.purge(srv.needsPurge);\n      srv.needsPurge.length = 0;\n    });\n\n    var done = true;\n    // The second inner loop might add new files. The outer loop keeps\n    // repeating both inner loops until all files have been looked at.\n    for (var i = 0; i < srv.files.length;) {\n      var toAnalyze = [];\n      for (; i < srv.files.length; ++i) {\n        var file = srv.files[i];\n        if (file.text == null) done = false;\n        else if (file.scope == null && !file.excluded) toAnalyze.push(file);\n      }\n      toAnalyze.sort(function(a, b) {\n        return parentDepth(srv, a.parent) - parentDepth(srv, b.parent);\n      });\n      for (var j = 0; j < toAnalyze.length; j++) {\n        var file = toAnalyze[j];\n        if (file.parent && !chargeOnBudget(srv, file)) {\n          file.excluded = true;\n        } else if (timeBudget) {\n          var startTime = +new Date;\n          try {\n            infer.withTimeout(timeBudget[0], function() { analyzeFile(srv, file); });\n          } catch(e) {\n            if (e instanceof infer.TimedOut) return c(e)\n            else throw e\n          }\n          timeBudget[0] -= +new Date - startTime;\n        } else {\n          analyzeFile(srv, file);\n        }\n      }\n    }\n    if (done) c();\n    else waitOnFetch(srv, timeBudget, c);\n  }\n\n  function firstLine(str) {\n    var end = str.indexOf(\"\\n\");\n    if (end < 0) return str;\n    return str.slice(0, end);\n  }\n\n  function findMatchingPosition(line, file, near) {\n    var pos = Math.max(0, near - 500), closest = null;\n    if (!/^\\s*$/.test(line)) for (;;) {\n      var found = file.indexOf(line, pos);\n      if (found < 0 || found > near + 500) break;\n      if (closest == null || Math.abs(closest - near) > Math.abs(found - near))\n        closest = found;\n      pos = found + line.length;\n    }\n    return closest;\n  }\n\n  function scopeDepth(s) {\n    for (var i = 0; s; ++i, s = s.prev) {}\n    return i;\n  }\n\n  function ternError(msg) {\n    var err = new Error(msg);\n    err.name = \"TernError\";\n    return err;\n  }\n\n  function resolveFile(srv, localFiles, name) {\n    var isRef = name.match(/^#(\\d+)$/);\n    if (!isRef) return srv.findFile(name);\n\n    var file = localFiles[isRef[1]];\n    if (!file || file.type == \"delete\") throw ternError(\"Reference to unknown file \" + name);\n    if (file.type == \"full\") return srv.fileMap[file.name];\n\n    // This is a partial file\n\n    var realFile = file.backing = srv.fileMap[file.name];\n    var offset = resolvePos(realFile, file.offsetLines == null ? file.offset : {line: file.offsetLines, ch: 0}, true);\n    var line = firstLine(file.text);\n    var foundPos = findMatchingPosition(line, realFile.text, offset);\n    var pos = foundPos == null ? Math.max(0, realFile.text.lastIndexOf(\"\\n\", offset)) : foundPos;\n    var inObject, atFunction;\n\n    infer.withContext(srv.cx, function() {\n      infer.purge(file.name, pos, pos + file.text.length);\n\n      var text = file.text, m;\n      if (m = text.match(/(?:\"([^\"]*)\"|([\\w$]+))\\s*:\\s*function\\b/)) {\n        var objNode = walk.findNodeAround(file.backing.ast, pos, \"ObjectExpression\");\n        if (objNode && objNode.node.objType)\n          inObject = {type: objNode.node.objType, prop: m[2] || m[1]};\n      }\n      if (foundPos && (m = line.match(/^(.*?)\\bfunction\\b/))) {\n        var cut = m[1].length, white = \"\";\n        for (var i = 0; i < cut; ++i) white += \" \";\n        file.text = white + text.slice(cut);\n        atFunction = true;\n      }\n\n      var scopeStart = infer.scopeAt(realFile.ast, pos, realFile.scope);\n      var scopeEnd = infer.scopeAt(realFile.ast, pos + text.length, realFile.scope);\n      var scope = file.scope = scopeDepth(scopeStart) < scopeDepth(scopeEnd) ? scopeEnd : scopeStart;\n      file.ast = parseFile(srv, file)\n      infer.analyze(file.ast, file.name, scope);\n\n      // This is a kludge to tie together the function types (if any)\n      // outside and inside of the fragment, so that arguments and\n      // return values have some information known about them.\n      tieTogether: if (inObject || atFunction) {\n        var newInner = infer.scopeAt(file.ast, line.length, scopeStart);\n        if (!newInner.fnType) break tieTogether;\n        if (inObject) {\n          var prop = inObject.type.getProp(inObject.prop);\n          prop.addType(newInner.fnType);\n        } else if (atFunction) {\n          var inner = infer.scopeAt(realFile.ast, pos + line.length, realFile.scope);\n          if (inner == scopeStart || !inner.fnType) break tieTogether;\n          var fOld = inner.fnType, fNew = newInner.fnType;\n          if (!fNew || (fNew.name != fOld.name && fOld.name)) break tieTogether;\n          for (var i = 0, e = Math.min(fOld.args.length, fNew.args.length); i < e; ++i)\n            fOld.args[i].propagate(fNew.args[i]);\n          fOld.self.propagate(fNew.self);\n          fNew.retval.propagate(fOld.retval);\n        }\n      }\n    });\n    return file;\n  }\n\n  // Budget management\n\n  function astSize(node) {\n    var size = 0;\n    walk.simple(node, {Expression: function() { ++size; }});\n    return size;\n  }\n\n  function parentDepth(srv, parent) {\n    var depth = 0;\n    while (parent) {\n      parent = srv.fileMap[parent].parent;\n      ++depth;\n    }\n    return depth;\n  }\n\n  function budgetName(srv, file) {\n    for (;;) {\n      var parent = srv.fileMap[file.parent];\n      if (!parent.parent) break;\n      file = parent;\n    }\n    return file.name;\n  }\n\n  function chargeOnBudget(srv, file) {\n    var bName = budgetName(srv, file);\n    var size = astSize(file.ast);\n    var known = srv.budgets[bName];\n    if (known == null)\n      known = srv.budgets[bName] = srv.options.dependencyBudget;\n    if (known < size) return false;\n    srv.budgets[bName] = known - size;\n    return true;\n  }\n\n  // Query helpers\n\n  function isPosition(val) {\n    return typeof val == \"number\" || typeof val == \"object\" &&\n      typeof val.line == \"number\" && typeof val.ch == \"number\";\n  }\n\n  // Baseline query document validation\n  function invalidDoc(doc) {\n    if (doc.query) {\n      if (typeof doc.query.type != \"string\") return \".query.type must be a string\";\n      if (doc.query.start && !isPosition(doc.query.start)) return \".query.start must be a position\";\n      if (doc.query.end && !isPosition(doc.query.end)) return \".query.end must be a position\";\n    }\n    if (doc.files) {\n      if (!Array.isArray(doc.files)) return \"Files property must be an array\";\n      for (var i = 0; i < doc.files.length; ++i) {\n        var file = doc.files[i];\n        if (typeof file != \"object\") return \".files[n] must be objects\";\n        else if (typeof file.name != \"string\") return \".files[n].name must be a string\";\n        else if (file.type == \"delete\") continue;\n        else if (typeof file.text != \"string\") return \".files[n].text must be a string\";\n        else if (file.type == \"part\") {\n          if (!isPosition(file.offset) && typeof file.offsetLines != \"number\")\n            return \".files[n].offset must be a position\";\n        } else if (file.type != \"full\") return \".files[n].type must be \\\"full\\\" or \\\"part\\\"\";\n      }\n    }\n  }\n\n  var offsetSkipLines = 25;\n\n  function forwardCharacters(file, start, chars) {\n    var pos = start + chars, m\n    if (file.hasAstral) {\n      astral.lastIndex = start\n      while ((m = astral.exec(file.text)) && m.index < pos) pos++\n    }\n    return pos\n  }\n\n  function findLineStart(file, line) {\n    var text = file.text, offsets = file.lineOffsets || (file.lineOffsets = [0]);\n    var pos = 0, curLine = 0;\n    var storePos = Math.min(Math.floor(line / offsetSkipLines), offsets.length - 1);\n    var pos = offsets[storePos], curLine = storePos * offsetSkipLines;\n\n    while (curLine < line) {\n      ++curLine;\n      pos = text.indexOf(\"\\n\", pos) + 1;\n      if (pos === 0) return null;\n      if (curLine % offsetSkipLines === 0) offsets.push(pos);\n    }\n    return pos;\n  }\n\n  var resolvePos = exports.resolvePos = function(file, pos, tolerant) {\n    if (typeof pos != \"number\") {\n      var lineStart = findLineStart(file, pos.line);\n      if (lineStart == null) {\n        if (tolerant) pos = file.text.length;\n        else throw ternError(\"File doesn't contain a line \" + pos.line);\n      } else {\n        pos = forwardCharacters(file, lineStart, pos.ch);\n      }\n    } else {\n      pos = forwardCharacters(file, 0, pos)\n    }\n    if (pos > file.text.length) {\n      if (tolerant) pos = file.text.length;\n      else throw ternError(\"Position \" + pos + \" is outside of file.\");\n    }\n    return pos;\n  };\n\n  function charDistanceBetween(file, start, end) {\n    var diff = end - start, m\n    if (file.hasAstral) {\n      astral.lastIndex = start\n      while ((m = astral.exec(file.text)) && m.index < end) diff--\n    }\n    return diff\n  }\n\n  function asLineChar(file, pos) {\n    if (!file) return {line: 0, ch: 0};\n    var offsets = file.lineOffsets || (file.lineOffsets = [0]);\n    var text = file.text, line, lineStart;\n    for (var i = offsets.length - 1; i >= 0; --i) if (offsets[i] <= pos) {\n      line = i * offsetSkipLines;\n      lineStart = offsets[i];\n    }\n    for (;;) {\n      var eol = text.indexOf(\"\\n\", lineStart);\n      if (eol >= pos || eol < 0) break;\n      lineStart = eol + 1;\n      ++line;\n    }\n    return {line: line, ch: charDistanceBetween(file, lineStart, pos)};\n  }\n\n  var outputPos = exports.outputPos = function(query, file, pos) {\n    if (query.lineCharPositions) {\n      var out = asLineChar(file, pos);\n      if (file.type == \"part\")\n        out.line += file.offsetLines != null ? file.offsetLines : asLineChar(file.backing, file.offset).line;\n      return out;\n    } else {\n      return charDistanceBetween(file, 0, pos) + (file.type == \"part\" ? file.offset : 0);\n    }\n  };\n\n  // Delete empty fields from result objects\n  function clean(obj) {\n    for (var prop in obj) if (obj[prop] == null) delete obj[prop];\n    return obj;\n  }\n  function maybeSet(obj, prop, val) {\n    if (val != null) obj[prop] = val;\n  }\n\n  // Built-in query types\n\n  function compareCompletions(a, b) {\n    if (typeof a != \"string\") { a = a.name; b = b.name; }\n    var aUp = /^[A-Z]/.test(a), bUp = /^[A-Z]/.test(b);\n    if (aUp == bUp) return a < b ? -1 : a == b ? 0 : 1;\n    else return aUp ? 1 : -1;\n  }\n\n  function isStringAround(node, start, end) {\n    return node.type == \"Literal\" && typeof node.value == \"string\" &&\n      node.start == start - 1 && node.end <= end + 1;\n  }\n\n  function pointInProp(objNode, point) {\n    for (var i = 0; i < objNode.properties.length; i++) {\n      var curProp = objNode.properties[i];\n      if (curProp.key.start <= point && curProp.key.end >= point)\n        return curProp;\n    }\n  }\n\n  var jsKeywords = (\"break do instanceof typeof case else new var \" +\n    \"catch finally return void continue for switch while debugger \" +\n    \"function this with default if throw delete in try\").split(\" \");\n  var jsKeywordsES6 = jsKeywords.concat(\"export class extends const super yield import let static\".split(\" \"))\n\n  var addCompletion = exports.addCompletion = function(query, completions, name, aval, depth) {\n    var typeInfo = query.types || query.docs || query.urls || query.origins;\n    var wrapAsObjs = typeInfo || query.depths;\n\n    for (var i = 0; i < completions.length; ++i) {\n      var c = completions[i];\n      if ((wrapAsObjs ? c.name : c) == name) return;\n    }\n    var rec = wrapAsObjs ? {name: name} : name;\n    completions.push(rec);\n\n    if (aval && typeInfo) {\n      infer.resetGuessing();\n      var type = aval.getType();\n      rec.guess = infer.didGuess();\n      if (query.types)\n        rec.type = infer.toString(aval);\n      if (query.docs)\n        maybeSet(rec, \"doc\", parseDoc(query, aval.doc || type && type.doc));\n      if (query.urls)\n        maybeSet(rec, \"url\", aval.url || type && type.url);\n      if (query.origins)\n        maybeSet(rec, \"origin\", aval.origin || type && type.origin);\n    }\n    if (query.depths) rec.depth = depth || 0;\n    return rec;\n  };\n\n  function findCompletions(srv, query, file) {\n    if (query.end == null) throw ternError(\"missing .query.end field\");\n    var fromPlugin = srv.signalReturnFirst(\"completion\", file, query)\n    if (fromPlugin) return fromPlugin\n\n    var wordStart = resolvePos(file, query.end), wordEnd = wordStart, text = file.text;\n    while (wordStart && acorn.isIdentifierChar(text.charCodeAt(wordStart - 1))) --wordStart;\n    if (query.expandWordForward !== false)\n      while (wordEnd < text.length && acorn.isIdentifierChar(text.charCodeAt(wordEnd))) ++wordEnd;\n    var word = text.slice(wordStart, wordEnd), completions = [], ignoreObj;\n    if (query.caseInsensitive) word = word.toLowerCase();\n\n    function gather(prop, obj, depth, addInfo) {\n      // 'hasOwnProperty' and such are usually just noise, leave them\n      // out when no prefix is provided.\n      if ((objLit || query.omitObjectPrototype !== false) && obj == srv.cx.protos.Object && !word) return;\n      if (query.filter !== false && word &&\n          (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) !== 0) return;\n      if (ignoreObj && ignoreObj.props[prop]) return;\n      var result = addCompletion(query, completions, prop, obj && obj.props[prop], depth);\n      if (addInfo && result && typeof result != \"string\") addInfo(result);\n    }\n\n    var hookname, prop, objType, isKey;\n\n    var exprAt = infer.findExpressionAround(file.ast, null, wordStart, file.scope);\n    var memberExpr, objLit;\n    // Decide whether this is an object property, either in a member\n    // expression or an object literal.\n    if (exprAt) {\n      var exprNode = exprAt.node;\n\n      if (query.inLiteral === false && exprNode.type === \"Literal\" &&\n          (typeof exprNode.value === 'string' || exprNode.regex))\n        return {\n          start: outputPos(query, file, wordStart),\n          end: outputPos(query, file, wordEnd),\n          completions: []\n        };\n\n      if (exprNode.type == \"MemberExpression\" && exprNode.object.end < wordStart) {\n        memberExpr = exprAt;\n      } else if (isStringAround(exprNode, wordStart, wordEnd)) {\n        var parent = infer.parentNode(exprNode, file.ast);\n        if (parent.type == \"MemberExpression\" && parent.property == exprNode)\n          memberExpr = {node: parent, state: exprAt.state};\n      } else if (exprNode.type == \"ObjectExpression\") {\n        var objProp = pointInProp(exprNode, wordEnd);\n        if (objProp) {\n          objLit = exprAt;\n          prop = isKey = objProp.key.name;\n        } else if (!word && !/:\\s*$/.test(file.text.slice(0, wordStart))) {\n          objLit = exprAt;\n          prop = isKey = true;\n        }\n      }\n    }\n\n    if (objLit) {\n      // Since we can't use the type of the literal itself to complete\n      // its properties (it doesn't contain the information we need),\n      // we have to try asking the surrounding expression for type info.\n      objType = infer.typeFromContext(file.ast, objLit);\n      ignoreObj = objLit.node.objType;\n    } else if (memberExpr) {\n      prop = memberExpr.node.property;\n      prop = prop.type == \"Literal\" ? prop.value.slice(1) : prop.name;\n      memberExpr.node = memberExpr.node.object;\n      objType = infer.expressionType(memberExpr);\n    } else if (text.charAt(wordStart - 1) == \".\") {\n      var pathStart = wordStart - 1;\n      while (pathStart && (text.charAt(pathStart - 1) == \".\" || acorn.isIdentifierChar(text.charCodeAt(pathStart - 1)))) pathStart--;\n      var path = text.slice(pathStart, wordStart - 1);\n      if (path) {\n        objType = infer.def.parsePath(path, file.scope).getObjType();\n        prop = word;\n      }\n    }\n\n    if (prop != null) {\n      srv.cx.completingProperty = prop;\n\n      if (objType) infer.forAllPropertiesOf(objType, gather);\n\n      if (!completions.length && query.guess !== false && objType && objType.guessProperties)\n        objType.guessProperties(function(p, o, d) {if (p != prop && p != \"✖\") gather(p, o, d);});\n      if (!completions.length && word.length >= 2 && query.guess !== false)\n        for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0);\n      hookname = \"memberCompletion\";\n    } else {\n      infer.forAllLocalsAt(file.ast, wordStart, file.scope, gather);\n      if (query.includeKeywords) {\n        (srv.options.ecmaVersion >= 6 ? jsKeywordsES6 : jsKeywords).forEach(function(kw) {\n          gather(kw, null, 0, function(rec) { rec.isKeyword = true; });\n        });\n      };\n      hookname = \"variableCompletion\";\n    }\n    srv.signal(hookname, file, wordStart, wordEnd, gather)\n\n    if (query.sort !== false) completions.sort(compareCompletions);\n    srv.cx.completingProperty = null;\n\n    return {start: outputPos(query, file, wordStart),\n            end: outputPos(query, file, wordEnd),\n            isProperty: !!prop,\n            isObjectKey: !!isKey,\n            completions: completions};\n  }\n\n  function findProperties(srv, query) {\n    var prefix = query.prefix, found = [];\n    for (var prop in srv.cx.props)\n      if (prop != \"<i>\" && (!prefix || prop.indexOf(prefix) === 0)) found.push(prop);\n    if (query.sort !== false) found.sort(compareCompletions);\n    return {completions: found};\n  }\n\n  function inBody(node, pos) {\n    var body = node.body, start, end\n    if (!body) return false\n    if (Array.isArray(body)) {\n      start = body[0].start\n      end = body[body.length - 1].end\n    } else {\n      start = body.start\n      end = body.end\n    }\n    return start <= pos && end >= pos\n  }\n\n  var findExpr = exports.findQueryExpr = function(file, query, wide) {\n    if (query.end == null) throw ternError(\"missing .query.end field\");\n\n    if (query.variable) {\n      var scope = infer.scopeAt(file.ast, resolvePos(file, query.end), file.scope);\n      return {node: {type: \"Identifier\", name: query.variable, start: query.end, end: query.end + 1},\n              state: scope};\n    } else {\n      var start = query.start && resolvePos(file, query.start), end = resolvePos(file, query.end);\n      var expr = infer.findExpressionAt(file.ast, start, end, file.scope);\n      if (!expr) {\n        var around = infer.findExpressionAround(file.ast, start, end, file.scope);\n        if (around && !inBody(around.node, end) &&\n            (around.node.type == \"ObjectExpression\" || wide ||\n             (start == null ? end : start) - around.node.start < 20 || around.node.end - end < 20))\n          expr = around\n      }\n      return expr\n    }\n  };\n\n  function findExprOrThrow(file, query, wide) {\n    var expr = findExpr(file, query, wide);\n    if (expr) return expr;\n    throw ternError(\"No expression at the given position.\");\n  }\n\n  function ensureObj(tp) {\n    if (!tp || !(tp = tp.getType()) || !(tp instanceof infer.Obj)) return null;\n    return tp;\n  }\n\n  function findExprType(srv, query, file, expr) {\n    var type;\n    if (expr) {\n      infer.resetGuessing();\n      type = infer.expressionType(expr);\n    }\n    var typeHandlers = srv.hasHandler(\"typeAt\")\n    if (typeHandlers) {\n      var pos = resolvePos(file, query.end)\n      for (var i = 0; i < typeHandlers.length; i++)\n        type = typeHandlers[i](file, pos, expr, type)\n    }\n    if (!type) throw ternError(\"No type found at the given position.\");\n\n    var objProp;\n    if (expr.node.type == \"ObjectExpression\" && query.end != null &&\n        (objProp = pointInProp(expr.node, resolvePos(file, query.end)))) {\n      var name = objProp.key.name;\n      var fromCx = ensureObj(infer.typeFromContext(file.ast, expr));\n      if (fromCx && fromCx.hasProp(name)) {\n        type = fromCx.hasProp(name);\n      } else {\n        var fromLocal = ensureObj(type);\n        if (fromLocal && fromLocal.hasProp(name))\n          type = fromLocal.hasProp(name);\n      }\n    }\n    return type;\n  };\n\n  function findTypeAt(srv, query, file) {\n    var expr = findExpr(file, query), exprName;\n    var type = findExprType(srv, query, file, expr), exprType = type;\n    if (query.preferFunction)\n      type = type.getFunctionType() || type.getType();\n    else\n      type = type.getType();\n\n    if (expr) {\n      if (expr.node.type == \"Identifier\")\n        exprName = expr.node.name;\n      else if (expr.node.type == \"MemberExpression\" && !expr.node.computed)\n        exprName = expr.node.property.name;\n      else if (expr.node.type == \"MethodDefinition\" && !expr.node.computed)\n        exprName = expr.node.key.name\n    }\n\n    if (query.depth != null && typeof query.depth != \"number\")\n      throw ternError(\".query.depth must be a number\");\n\n    var result = {guess: infer.didGuess(),\n                  type: infer.toString(exprType, query.depth),\n                  name: type && type.name,\n                  exprName: exprName,\n                  doc: exprType.doc,\n                  url: exprType.url};\n    if (type) storeTypeDocs(query, type, result);\n\n    return clean(result);\n  }\n\n  function parseDoc(query, doc) {\n    if (!doc) return null;\n    if (query.docFormat == \"full\") return doc;\n    var parabreak = /.\\n[\\s@\\n]/.exec(doc);\n    if (parabreak) doc = doc.slice(0, parabreak.index + 1);\n    doc = doc.replace(/\\n\\s*/g, \" \");\n    if (doc.length < 100) return doc;\n    var sentenceEnd = /[\\.!?] [A-Z]/g;\n    sentenceEnd.lastIndex = 80;\n    var found = sentenceEnd.exec(doc);\n    if (found) doc = doc.slice(0, found.index + 1);\n    return doc;\n  }\n\n  function findDocs(srv, query, file) {\n    var expr = findExpr(file, query);\n    var type = findExprType(srv, query, file, expr);\n    var result = {url: type.url, doc: parseDoc(query, type.doc), type: infer.toString(type)};\n    var inner = type.getType();\n    if (inner) storeTypeDocs(query, inner, result);\n    return clean(result);\n  }\n\n  function storeTypeDocs(query, type, out) {\n    if (!out.url) out.url = type.url;\n    if (!out.doc) out.doc = parseDoc(query, type.doc);\n    if (!out.origin) out.origin = type.origin;\n    var ctor, boring = infer.cx().protos;\n    if (!out.url && !out.doc && type.proto && (ctor = type.proto.hasCtor) &&\n        type.proto != boring.Object && type.proto != boring.Function && type.proto != boring.Array) {\n      out.url = ctor.url;\n      out.doc = parseDoc(query, ctor.doc);\n    }\n  }\n\n  var getSpan = exports.getSpan = function(obj) {\n    if (!obj.origin) return;\n    if (obj.originNode) {\n      var node = obj.originNode;\n      if (/^Function/.test(node.type) && node.id) node = node.id;\n      return {origin: obj.origin, node: node};\n    }\n    if (obj.span) return {origin: obj.origin, span: obj.span};\n  };\n\n  var storeSpan = exports.storeSpan = function(srv, query, span, target) {\n    target.origin = span.origin;\n    if (span.span) {\n      var m = /^(\\d+)\\[(\\d+):(\\d+)\\]-(\\d+)\\[(\\d+):(\\d+)\\]$/.exec(span.span);\n      target.start = query.lineCharPositions ? {line: Number(m[2]), ch: Number(m[3])} : Number(m[1]);\n      target.end = query.lineCharPositions ? {line: Number(m[5]), ch: Number(m[6])} : Number(m[4]);\n    } else {\n      var file = srv.fileMap[span.origin];\n      target.start = outputPos(query, file, span.node.start);\n      target.end = outputPos(query, file, span.node.end);\n    }\n  };\n\n  function findDef(srv, query, file) {\n    var expr = findExpr(file, query);\n    var type = findExprType(srv, query, file, expr);\n    if (infer.didGuess()) return {};\n\n    var span = getSpan(type);\n    var result = {url: type.url, doc: parseDoc(query, type.doc), origin: type.origin};\n\n    if (type.types) for (var i = type.types.length - 1; i >= 0; --i) {\n      var tp = type.types[i];\n      storeTypeDocs(query, tp, result);\n      if (!span) span = getSpan(tp);\n    }\n\n    if (span && span.node) { // refers to a loaded file\n      var spanFile = span.node.sourceFile || srv.fileMap[span.origin];\n      var start = outputPos(query, spanFile, span.node.start), end = outputPos(query, spanFile, span.node.end);\n      result.start = start; result.end = end;\n      result.file = span.origin;\n      var cxStart = Math.max(0, span.node.start - 50);\n      result.contextOffset = span.node.start - cxStart;\n      result.context = spanFile.text.slice(cxStart, cxStart + 50);\n    } else if (span) { // external\n      result.file = span.origin;\n      storeSpan(srv, query, span, result);\n    }\n    return clean(result);\n  }\n\n  function findRefsToVariable(srv, query, file, expr, isRename) {\n    var name = expr.node.name;\n\n    for (var scope = expr.state; scope && !(name in scope.props); scope = scope.prev) {}\n    if (!scope) throw ternError(\"Could not find a definition for \" + name);\n\n    var type, refs = [];\n    function storeRef(file) {\n      return function(node, scopeHere, ancestors) {\n        var value = {file: file.name,\n                     start: outputPos(query, file, node.start),\n                     end: outputPos(query, file, node.end)}\n        if (isRename) {\n          for (var s = scopeHere; s != scope; s = s.prev) {\n            var exists = s.hasProp(isRename);\n            if (exists)\n              throw ternError(\"Renaming `\" + name + \"` to `\" + isRename + \"` would make a variable at line \" +\n                              (asLineChar(file, node.start).line + 1) + \" point to the definition at line \" +\n                              (asLineChar(file, exists.name.start).line + 1));\n          }\n          var parent = ancestors[ancestors.length - 2]\n          if (parent && parent.type == \"Property\" && parent.key == parent.value)\n            value.isShorthand = true\n        }\n        refs.push(value);\n      };\n    }\n\n    if (scope.originNode) {\n      type = \"local\";\n      if (isRename) {\n        for (var prev = scope.prev; prev; prev = prev.prev)\n          if (isRename in prev.props) break;\n        if (prev) infer.findRefs(scope.originNode, scope, isRename, prev, function(node) {\n          throw ternError(\"Renaming `\" + name + \"` to `\" + isRename + \"` would shadow the definition used at line \" +\n                          (asLineChar(file, node.start).line + 1));\n        });\n      }\n      infer.findRefs(scope.originNode, scope, name, scope, storeRef(file));\n    } else {\n      type = \"global\";\n      if (query.onlySourceFile) {\n        infer.findRefs(file.ast, file.scope, name, scope, storeRef(file));\n      } else {\n        for (var i = 0; i < srv.files.length; ++i) {\n          var cur = srv.files[i];\n          infer.findRefs(cur.ast, cur.scope, name, scope, storeRef(cur));\n        }\n      }\n    }\n\n    return {refs: refs, type: type, name: name};\n  }\n\n  function findRefsToProperty(srv, query, sourceFile, expr, prop) {\n    var exprType = infer.expressionType(expr);\n    if (expr.node.type == \"MethodDefinition\") {\n      exprType = exprType.propertyOf;\n    }\n    var objType = exprType.getObjType();\n    if (!objType) throw ternError(\"Couldn't determine type of base object.\");\n\n    var refs = [];\n    function storeRef(file) {\n      return function(node) {\n        refs.push({file: file.name,\n                   start: outputPos(query, file, node.start),\n                   end: outputPos(query, file, node.end)});\n      };\n    }\n\n    if (query.onlySourceFile) {\n        infer.findPropRefs(sourceFile.ast, sourceFile.scope, objType, prop.name, storeRef(sourceFile));\n    } else {\n      for (var i = 0; i < srv.files.length; ++i) {\n        var cur = srv.files[i];\n        infer.findPropRefs(cur.ast, cur.scope, objType, prop.name, storeRef(cur));\n      }\n    }\n\n    return {refs: refs, name: prop.name};\n  }\n\n  function findRefs(srv, query, file) {\n    var expr = findExprOrThrow(file, query, true);\n    if (expr && expr.node.type == \"Identifier\") {\n      return findRefsToVariable(srv, query, file, expr);\n    } else if (expr && expr.node.type == \"MemberExpression\" && !expr.node.computed) {\n      var p = expr.node.property;\n      expr.node = expr.node.object;\n      return findRefsToProperty(srv, query, file, expr, p);\n    } else if (expr && expr.node.type == \"ObjectExpression\") {\n      var pos = resolvePos(file, query.end);\n      for (var i = 0; i < expr.node.properties.length; ++i) {\n        var k = expr.node.properties[i].key;\n        if (k.start <= pos && k.end >= pos)\n          return findRefsToProperty(srv, query, file, expr, k);\n      }\n    } else if (expr && expr.node.type == \"MethodDefinition\") {\n      var p = expr.node.key;\n      return findRefsToProperty(srv, query, file, expr, p);\n    }\n    throw ternError(\"Not at a variable or property name.\");\n  }\n\n  function buildRename(srv, query, file) {\n    if (typeof query.newName != \"string\") throw ternError(\".query.newName should be a string\");\n    var expr = findExprOrThrow(file, query);\n    if (!expr || expr.node.type != \"Identifier\") throw ternError(\"Not at a variable.\");\n\n    var data = findRefsToVariable(srv, query, file, expr, query.newName), refs = data.refs;\n    delete data.refs;\n    data.files = srv.files.map(function(f){return f.name;});\n\n    var changes = data.changes = [];\n    for (var i = 0; i < refs.length; ++i) {\n      var use = refs[i];\n      if (use.isShorthand) use.text = expr.node.name + \": \" + query.newName\n      else use.text = query.newName;\n      changes.push(use);\n    }\n\n    return data;\n  }\n\n  function listFiles(srv) {\n    return {files: srv.files.map(function(f){return f.name;})};\n  }\n\n  exports.version = \"0.21.0\";\n});\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.acorn = global.acorn || {})));\n}(this, (function (exports) { 'use strict';\n\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n}\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\"\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n}\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fd5\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ae\\ua7b0-\\ua7b7\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\"\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d4-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d01-\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf8\\u1cf9\\u1dc0-\\u1df5\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\"\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\")\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\")\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541]\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239]\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i]\n    if (pos > code) return false\n    pos += set[i + 1]\n    if (pos >= code) return true\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) return code === 36\n  if (code < 91) return true\n  if (code < 97) return code === 95\n  if (code < 123) return true\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\n  if (astral === false) return false\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) return code === 36\n  if (code < 58) return true\n  if (code < 65) return false\n  if (code < 91) return true\n  if (code < 97) return code === 95\n  if (code < 123) return true\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))\n  if (astral === false) return false\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label\n  this.keyword = conf.keyword\n  this.beforeExpr = !!conf.beforeExpr\n  this.startsExpr = !!conf.startsExpr\n  this.isLoop = !!conf.isLoop\n  this.isAssign = !!conf.isAssign\n  this.prefix = !!conf.prefix\n  this.postfix = !!conf.postfix\n  this.binop = conf.binop || null\n  this.updateContext = null\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true};\nvar startsExpr = {startsExpr: true};\n// Map keyword names to token types.\n\nvar keywordTypes = {}\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name\n  return keywordTypes[name] = new TokenType(name, options)\n}\n\nvar tt = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"prefix\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=\", 6),\n  relational: binop(\"</>\", 7),\n  bitShift: binop(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\"),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n}\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/\nvar lineBreakG = new RegExp(lineBreak.source, \"g\")\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g\n\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === \"[object Array]\"\n}\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return Object.prototype.hasOwnProperty.call(obj, propName)\n}\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line\n  this.column = col\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start\n  this.end = end\n  if (p.sourceFile !== null) this.source = p.sourceFile\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur\n    var match = lineBreakG.exec(input)\n    if (match && match.index < offset) {\n      ++line\n      cur = match.index + match[0].length\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n}\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {}\n\n  for (var opt in defaultOptions)\n    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]\n\n  if (options.ecmaVersion >= 2015)\n    options.ecmaVersion -= 2009\n\n  if (options.allowReserved == null)\n    options.allowReserved = options.ecmaVersion < 5\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken\n    options.onToken = function (token) { return tokens.push(token); }\n  }\n  if (isArray(options.onComment))\n    options.onComment = pushComment(options, options.onComment)\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function (block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? 'Block' : 'Line',\n      value: text,\n      start: start,\n      end: end\n    }\n    if (options.locations)\n      comment.loc = new SourceLocation(this, startLoc, endLoc)\n    if (options.ranges)\n      comment.range = [start, end]\n    array.push(comment)\n  }\n}\n\n// Registered plugins\nvar plugins = {}\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options)\n  this.sourceFile = options.sourceFile\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5])\n  var reserved = \"\"\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--)\n      if (reserved = reservedWords[v]) break\n    if (options.sourceType == \"module\") reserved += \" await\"\n  }\n  this.reservedWords = keywordRegexp(reserved)\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict\n  this.reservedWordsStrict = keywordRegexp(reservedStrict)\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind)\n  this.input = String(input)\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false\n\n  // Load plugins\n  this.loadPlugins(options.plugins)\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length\n  } else {\n    this.pos = this.lineStart = 0\n    this.curLine = 1\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = tt.eof\n  // For tokens that include more information than their type, the value\n  this.value = null\n  // Its start and end offset\n  this.start = this.end = this.pos\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition()\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null\n  this.lastTokStart = this.lastTokEnd = this.pos\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext()\n  this.exprAllowed = true\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\"\n  this.strict = this.inModule || this.strictDirective(this.pos)\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1\n\n  // Flags to track whether we are in a function, a generator, an async function.\n  this.inFunction = this.inGenerator = this.inAsync = false\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = 0\n  // Labels in scope.\n  this.labels = []\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!')\n    this.skipLineComment(2)\n};\n\n// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\nParser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\nParser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n\nParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name])\n};\n\nParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n    var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name]\n    if (!plugin) throw new Error(\"Plugin '\" + name + \"' not found\")\n    plugin(this$1, pluginConfigs[name])\n  }\n};\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode()\n  this.nextToken()\n  return this.parseTopLevel(node)\n};\n\nvar pp = Parser.prototype\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:[^\\']|\\.)*)'|\"((?:[^\\\"]|\\.)*)\"|;)/\npp.strictDirective = function(start) {\n  var this$1 = this;\n\n  for (;;) {\n    skipWhiteSpace.lastIndex = start\n    start += skipWhiteSpace.exec(this$1.input)[0].length\n    var match = literal.exec(this$1.input.slice(start))\n    if (!match) return false\n    if ((match[1] || match[2]) == \"use strict\") return true\n    start += match[0].length\n  }\n}\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next()\n    return true\n  } else {\n    return false\n  }\n}\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === tt.name && this.value === name\n}\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  return this.value === name && this.eat(tt.name)\n}\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) this.unexpected()\n}\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === tt.eof ||\n    this.type === tt.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n}\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)\n    return true\n  }\n}\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()\n}\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)\n    if (!notNext)\n      this.next()\n    return true\n  }\n}\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected()\n}\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\")\n}\n\nvar DestructuringErrors = function DestructuringErrors() {\n  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1\n};\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) return\n  if (refDestructuringErrors.trailingComma > -1)\n    this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\")\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind\n  if (parens > -1) this.raiseRecoverable(parens, \"Parenthesized pattern\")\n}\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1\n  if (!andThrow) return pos >= 0\n  if (pos > -1) this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\")\n}\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    this.raise(this.yieldPos, \"Yield expression cannot be a default value\")\n  if (this.awaitPos)\n    this.raise(this.awaitPos, \"Await expression cannot be a default value\")\n}\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    return this.isSimpleAssignTarget(expr.expression)\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n}\n\nvar pp$1 = Parser.prototype\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var this$1 = this;\n\n  var exports = {}\n  if (!node.body) node.body = []\n  while (this.type !== tt.eof) {\n    var stmt = this$1.parseStatement(true, true, exports)\n    node.body.push(stmt)\n  }\n  this.next()\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType\n  }\n  return this.finishNode(node, \"Program\")\n}\n\nvar loopLabel = {kind: \"loop\"};\nvar switchLabel = {kind: \"switch\"};\npp$1.isLet = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != \"let\") return false\n  skipWhiteSpace.lastIndex = this.pos\n  var skip = skipWhiteSpace.exec(this.input)\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)\n  if (nextCh === 91 || nextCh == 123) return true // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), true); ++pos) {}\n    var ident = this.input.slice(next, pos)\n    if (!this.isKeyword(ident)) return true\n  }\n  return false\n}\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 8 || this.value != \"async\")\n    return false\n\n  skipWhiteSpace.lastIndex = this.pos\n  var skip = skipWhiteSpace.exec(this.input)\n  var next = this.pos + skip[0].length\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(declaration, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind\n\n  if (this.isLet()) {\n    starttype = tt._var\n    kind = \"let\"\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case tt._debugger: return this.parseDebuggerStatement(node)\n  case tt._do: return this.parseDoStatement(node)\n  case tt._for: return this.parseForStatement(node)\n  case tt._function:\n    if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()\n    return this.parseFunctionStatement(node, false)\n  case tt._class:\n    if (!declaration) this.unexpected()\n    return this.parseClass(node, true)\n  case tt._if: return this.parseIfStatement(node)\n  case tt._return: return this.parseReturnStatement(node)\n  case tt._switch: return this.parseSwitchStatement(node)\n  case tt._throw: return this.parseThrowStatement(node)\n  case tt._try: return this.parseTryStatement(node)\n  case tt._const: case tt._var:\n    kind = kind || this.value\n    if (!declaration && kind != \"var\") this.unexpected()\n    return this.parseVarStatement(node, kind)\n  case tt._while: return this.parseWhileStatement(node)\n  case tt._with: return this.parseWithStatement(node)\n  case tt.braceL: return this.parseBlock()\n  case tt.semi: return this.parseEmptyStatement(node)\n  case tt._export:\n  case tt._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        this.raise(this.start, \"'import' and 'export' may only appear at the top level\")\n      if (!this.inModule)\n        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")\n    }\n    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction() && declaration) {\n      this.next()\n      return this.parseFunctionStatement(node, true)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression()\n    if (starttype === tt.name && expr.type === \"Identifier\" && this.eat(tt.colon))\n      return this.parseLabeledStatement(node, maybeName, expr)\n    else return this.parseExpressionStatement(node, expr)\n  }\n}\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var this$1 = this;\n\n  var isBreak = keyword == \"break\"\n  this.next()\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null\n  else if (this.type !== tt.name) this.unexpected()\n  else {\n    node.label = this.parseIdent()\n    this.semicolon()\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  for (var i = 0; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i]\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break\n      if (node.label && isBreak) break\n    }\n  }\n  if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword)\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n}\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next()\n  this.semicolon()\n  return this.finishNode(node, \"DebuggerStatement\")\n}\n\npp$1.parseDoStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  this.expect(tt._while)\n  node.test = this.parseParenExpression()\n  if (this.options.ecmaVersion >= 6)\n    this.eat(tt.semi)\n  else\n    this.semicolon()\n  return this.finishNode(node, \"DoWhileStatement\")\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  this.expect(tt.parenL)\n  if (this.type === tt.semi) return this.parseFor(node, null)\n  var isLet = this.isLet()\n  if (this.type === tt._var || this.type === tt._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value\n    this.next()\n    this.parseVar(init$1, true, kind)\n    this.finishNode(init$1, \"VariableDeclaration\")\n    if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\n        !(kind !== \"var\" && init$1.declarations[0].init))\n      return this.parseForIn(node, init$1)\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors\n  var init = this.parseExpression(true, refDestructuringErrors)\n  if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    this.toAssignable(init)\n    this.checkLVal(init)\n    this.checkPatternErrors(refDestructuringErrors, true)\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  return this.parseFor(node, init)\n}\n\npp$1.parseFunctionStatement = function(node, isAsync) {\n  this.next()\n  return this.parseFunction(node, true, false, isAsync)\n}\n\npp$1.isFunction = function() {\n  return this.type === tt._function || this.isAsyncFunction()\n}\n\npp$1.parseIfStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.isFunction())\n  node.alternate = this.eat(tt._else) ? this.parseStatement(!this.strict && this.isFunction()) : null\n  return this.finishNode(node, \"IfStatement\")\n}\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    this.raise(this.start, \"'return' outside of function\")\n  this.next()\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null\n  else { node.argument = this.parseExpression(); this.semicolon() }\n  return this.finishNode(node, \"ReturnStatement\")\n}\n\npp$1.parseSwitchStatement = function(node) {\n  var this$1 = this;\n\n  this.next()\n  node.discriminant = this.parseParenExpression()\n  node.cases = []\n  this.expect(tt.braceL)\n  this.labels.push(switchLabel)\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  for (var cur, sawDefault = false; this.type != tt.braceR;) {\n    if (this$1.type === tt._case || this$1.type === tt._default) {\n      var isCase = this$1.type === tt._case\n      if (cur) this$1.finishNode(cur, \"SwitchCase\")\n      node.cases.push(cur = this$1.startNode())\n      cur.consequent = []\n      this$1.next()\n      if (isCase) {\n        cur.test = this$1.parseExpression()\n      } else {\n        if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\")\n        sawDefault = true\n        cur.test = null\n      }\n      this$1.expect(tt.colon)\n    } else {\n      if (!cur) this$1.unexpected()\n      cur.consequent.push(this$1.parseStatement(true))\n    }\n  }\n  if (cur) this.finishNode(cur, \"SwitchCase\")\n  this.next() // Closing brace\n  this.labels.pop()\n  return this.finishNode(node, \"SwitchStatement\")\n}\n\npp$1.parseThrowStatement = function(node) {\n  this.next()\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    this.raise(this.lastTokEnd, \"Illegal newline after throw\")\n  node.argument = this.parseExpression()\n  this.semicolon()\n  return this.finishNode(node, \"ThrowStatement\")\n}\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = []\n\npp$1.parseTryStatement = function(node) {\n  this.next()\n  node.block = this.parseBlock()\n  node.handler = null\n  if (this.type === tt._catch) {\n    var clause = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    clause.param = this.parseBindingAtom()\n    this.checkLVal(clause.param, true)\n    this.expect(tt.parenR)\n    clause.body = this.parseBlock()\n    node.handler = this.finishNode(clause, \"CatchClause\")\n  }\n  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null\n  if (!node.handler && !node.finalizer)\n    this.raise(node.start, \"Missing catch or finally clause\")\n  return this.finishNode(node, \"TryStatement\")\n}\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next()\n  this.parseVar(node, false, kind)\n  this.semicolon()\n  return this.finishNode(node, \"VariableDeclaration\")\n}\n\npp$1.parseWhileStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"WhileStatement\")\n}\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) this.raise(this.start, \"'with' in strict mode\")\n  this.next()\n  node.object = this.parseParenExpression()\n  node.body = this.parseStatement(false)\n  return this.finishNode(node, \"WithStatement\")\n}\n\npp$1.parseEmptyStatement = function(node) {\n  this.next()\n  return this.finishNode(node, \"EmptyStatement\")\n}\n\npp$1.parseLabeledStatement = function(node, maybeName, expr) {\n  var this$1 = this;\n\n  for (var i = 0; i < this.labels.length; ++i)\n    if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\")\n  var kind = this.type.isLoop ? \"loop\" : this.type === tt._switch ? \"switch\" : null\n  for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {\n    var label = this$1.labels[i$1]\n    if (label.statementStart == node.start) {\n      label.statementStart = this$1.start\n      label.kind = kind\n    } else break\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start})\n  node.body = this.parseStatement(true)\n  if (node.body.type == \"ClassDeclaration\" ||\n      node.body.type == \"VariableDeclaration\" && (this.strict || node.body.kind != \"var\") ||\n      node.body.type == \"FunctionDeclaration\" && (this.strict || node.body.generator))\n    this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\")\n  this.labels.pop()\n  node.label = expr\n  return this.finishNode(node, \"LabeledStatement\")\n}\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr\n  this.semicolon()\n  return this.finishNode(node, \"ExpressionStatement\")\n}\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function() {\n  var this$1 = this;\n\n  var node = this.startNode()\n  node.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    var stmt = this$1.parseStatement(true)\n    node.body.push(stmt)\n  }\n  return this.finishNode(node, \"BlockStatement\")\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init\n  this.expect(tt.semi)\n  node.test = this.type === tt.semi ? null : this.parseExpression()\n  this.expect(tt.semi)\n  node.update = this.type === tt.parenR ? null : this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"ForStatement\")\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var type = this.type === tt._in ? \"ForInStatement\" : \"ForOfStatement\"\n  this.next()\n  node.left = init\n  node.right = this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, type)\n}\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  var this$1 = this;\n\n  node.declarations = []\n  node.kind = kind\n  for (;;) {\n    var decl = this$1.startNode()\n    this$1.parseVarId(decl)\n    if (this$1.eat(tt.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor)\n    } else if (kind === \"const\" && !(this$1.type === tt._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\n      this$1.unexpected()\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this$1.type === tt._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\")\n    } else {\n      decl.init = null\n    }\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"))\n    if (!this$1.eat(tt.comma)) break\n  }\n  return node\n}\n\npp$1.parseVarId = function(decl) {\n  decl.id = this.parseBindingAtom()\n  this.checkLVal(decl.id, true)\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6 && !isAsync)\n    node.generator = this.eat(tt.star)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  if (isStatement == null)\n    isStatement = this.type == tt.name\n  if (isStatement)\n    node.id = this.parseIdent()\n\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n  this.inGenerator = node.generator\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  if (!isStatement && this.type === tt.name)\n    node.id = this.parseIdent()\n  this.parseFunctionParams(node)\n  this.parseFunctionBody(node, allowExpressionBody)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n}\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8, true)\n  this.checkYieldAwaitInDefaultParams()\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  var this$1 = this;\n\n  this.next()\n  if (isStatement == null) isStatement = this.type === tt.name\n  this.parseClassId(node, isStatement)\n  this.parseClassSuper(node)\n  var classBody = this.startNode()\n  var hadConstructor = false\n  classBody.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (this$1.eat(tt.semi)) continue\n    var method = this$1.startNode()\n    var isGenerator = this$1.eat(tt.star)\n    var isAsync = false\n    var isMaybeStatic = this$1.type === tt.name && this$1.value === \"static\"\n    this$1.parsePropertyName(method)\n    method.static = isMaybeStatic && this$1.type !== tt.parenL\n    if (method.static) {\n      if (isGenerator) this$1.unexpected()\n      isGenerator = this$1.eat(tt.star)\n      this$1.parsePropertyName(method)\n    }\n    if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed &&\n        method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.type !== tt.parenL &&\n        !this$1.canInsertSemicolon()) {\n      isAsync = true\n      this$1.parsePropertyName(method)\n    }\n    method.kind = \"method\"\n    var isGetSet = false\n    if (!method.computed) {\n      var key = method.key;\n      if (!isGenerator && !isAsync && key.type === \"Identifier\" && this$1.type !== tt.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true\n        method.kind = key.name\n        key = this$1.parsePropertyName(method)\n      }\n      if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n          key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) this$1.raise(key.start, \"Duplicate constructor in the same class\")\n        if (isGetSet) this$1.raise(key.start, \"Constructor can't have get/set modifier\")\n        if (isGenerator) this$1.raise(key.start, \"Constructor can't be a generator\")\n        if (isAsync) this$1.raise(key.start, \"Constructor can't be an async method\")\n        method.kind = \"constructor\"\n        hadConstructor = true\n      }\n    }\n    this$1.parseClassMethod(classBody, method, isGenerator, isAsync)\n    if (isGetSet) {\n      var paramCount = method.kind === \"get\" ? 0 : 1\n      if (method.value.params.length !== paramCount) {\n        var start = method.value.start\n        if (method.kind === \"get\")\n          this$1.raiseRecoverable(start, \"getter should have no params\")\n        else\n          this$1.raiseRecoverable(start, \"setter should have exactly one param\")\n      } else {\n        if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n          this$1.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\")\n      }\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\")\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n}\n\npp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync)\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"))\n}\n\npp$1.parseClassId = function(node, isStatement) {\n  node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null\n}\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null\n}\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  var this$1 = this;\n\n  this.next()\n  // export * from '...'\n  if (this.eat(tt.star)) {\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    this.semicolon()\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(tt._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart)\n    var isAsync\n    if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode()\n      this.next()\n      if (isAsync) this.next()\n      node.declaration = this.parseFunction(fNode, null, false, isAsync)\n    } else if (this.type === tt._class) {\n      var cNode = this.startNode()\n      node.declaration = this.parseClass(cNode, null)\n    } else {\n      node.declaration = this.parseMaybeAssign()\n      this.semicolon()\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true)\n    if (node.declaration.type === \"VariableDeclaration\")\n      this.checkVariableExport(exports, node.declaration.declarations)\n    else\n      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start)\n    node.specifiers = []\n    node.source = null\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null\n    node.specifiers = this.parseExportSpecifiers(exports)\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    } else {\n      // check for keywords used as local names\n      for (var i = 0; i < node.specifiers.length; i++) {\n        if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {\n          this$1.unexpected(node.specifiers[i].local.start)\n        }\n      }\n\n      node.source = null\n    }\n    this.semicolon()\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n}\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) return\n  if (Object.prototype.hasOwnProperty.call(exports, name))\n    this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\")\n  exports[name] = true\n}\n\npp$1.checkPatternExport = function(exports, pat) {\n  var this$1 = this;\n\n  var type = pat.type\n  if (type == \"Identifier\")\n    this.checkExport(exports, pat.name, pat.start)\n  else if (type == \"ObjectPattern\")\n    for (var i = 0; i < pat.properties.length; ++i)\n      this$1.checkPatternExport(exports, pat.properties[i].value)\n  else if (type == \"ArrayPattern\")\n    for (var i$1 = 0; i$1 < pat.elements.length; ++i$1) {\n      var elt = pat.elements[i$1]\n      if (elt) this$1.checkPatternExport(exports, elt)\n    }\n  else if (type == \"AssignmentPattern\")\n    this.checkPatternExport(exports, pat.left)\n  else if (type == \"ParenthesizedExpression\")\n    this.checkPatternExport(exports, pat.expression)\n}\n\npp$1.checkVariableExport = function(exports, decls) {\n  var this$1 = this;\n\n  if (!exports) return\n  for (var i = 0; i < decls.length; i++)\n    this$1.checkPatternExport(exports, decls[i].id)\n}\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\"\n    || this.type.keyword === \"const\"\n    || this.type.keyword === \"class\"\n    || this.type.keyword === \"function\"\n    || this.isLet()\n    || this.isAsyncFunction()\n}\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var this$1 = this;\n\n  var nodes = [], first = true\n  // export { x, y as z } [from '...']\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var node = this$1.startNode()\n    node.local = this$1.parseIdent(true)\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local\n    this$1.checkExport(exports, node.exported.name, node.exported.start)\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"))\n  }\n  return nodes\n}\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next()\n  // import '...'\n  if (this.type === tt.string) {\n    node.specifiers = empty\n    node.source = this.parseExprAtom()\n  } else {\n    node.specifiers = this.parseImportSpecifiers()\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n  }\n  this.semicolon()\n  return this.finishNode(node, \"ImportDeclaration\")\n}\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var this$1 = this;\n\n  var nodes = [], first = true\n  if (this.type === tt.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode()\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"))\n    if (!this.eat(tt.comma)) return nodes\n  }\n  if (this.type === tt.star) {\n    var node$1 = this.startNode()\n    this.next()\n    this.expectContextual(\"as\")\n    node$1.local = this.parseIdent()\n    this.checkLVal(node$1.local, true)\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"))\n    return nodes\n  }\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var node$2 = this$1.startNode()\n    node$2.imported = this$1.parseIdent(true)\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent()\n    } else {\n      node$2.local = node$2.imported\n      if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start)\n      if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raiseRecoverable(node$2.local.start, \"The keyword '\" + node$2.local.name + \"' is reserved\")\n    }\n    this$1.checkLVal(node$2.local, true)\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"))\n  }\n  return nodes\n}\n\nvar pp$2 = Parser.prototype\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding) {\n  var this$1 = this;\n\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n      case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        this.raise(node.start, \"Can not use 'await' as identifier inside an async function\")\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\"\n      for (var i = 0; i < node.properties.length; i++) {\n        var prop = node.properties[i]\n        if (prop.kind !== \"init\") this$1.raise(prop.key.start, \"Object pattern can't contain getter or setter\")\n        this$1.toAssignable(prop.value, isBinding)\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\"\n      this.toAssignableList(node.elements, isBinding)\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\"\n        delete node.operator\n        this.toAssignable(node.left, isBinding)\n        // falls through to AssignmentPattern\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\")\n        break\n      }\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      node.expression = this.toAssignable(node.expression, isBinding)\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) break\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\")\n    }\n  }\n  return node\n}\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var this$1 = this;\n\n  var end = exprList.length\n  if (end) {\n    var last = exprList[end - 1]\n    if (last && last.type == \"RestElement\") {\n      --end\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\"\n      var arg = last.argument\n      this.toAssignable(arg, isBinding)\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\")\n        this.unexpected(arg.start)\n      --end\n    }\n\n    if (isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      this.unexpected(last.argument.start)\n  }\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i]\n    if (elt) this$1.toAssignable(elt, isBinding)\n  }\n  return exprList\n}\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors)\n  return this.finishNode(node, \"SpreadElement\")\n}\n\npp$2.parseRest = function(allowNonIdent) {\n  var node = this.startNode()\n  this.next()\n\n  // RestElement inside of a function parameter must be an identifier\n  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()\n  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()\n\n  return this.finishNode(node, \"RestElement\")\n}\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) return this.parseIdent()\n  switch (this.type) {\n  case tt.name:\n    return this.parseIdent()\n\n  case tt.bracketL:\n    var node = this.startNode()\n    this.next()\n    node.elements = this.parseBindingList(tt.bracketR, true, true)\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case tt.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected()\n  }\n}\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {\n  var this$1 = this;\n\n  var elts = [], first = true\n  while (!this.eat(close)) {\n    if (first) first = false\n    else this$1.expect(tt.comma)\n    if (allowEmpty && this$1.type === tt.comma) {\n      elts.push(null)\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break\n    } else if (this$1.type === tt.ellipsis) {\n      var rest = this$1.parseRest(allowNonIdent)\n      this$1.parseBindingListItem(rest)\n      elts.push(rest)\n      if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\")\n      this$1.expect(close)\n      break\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc)\n      this$1.parseBindingListItem(elem)\n      elts.push(elem)\n    }\n  }\n  return elts\n}\n\npp$2.parseBindingListItem = function(param) {\n  return param\n}\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom()\n  if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left\n  var node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.right = this.parseMaybeAssign()\n  return this.finishNode(node, \"AssignmentPattern\")\n}\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n\npp$2.checkLVal = function(expr, isBinding, checkClashes) {\n  var this$1 = this;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      this.raiseRecoverable(expr.start, (isBinding ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\")\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        this.raiseRecoverable(expr.start, \"Argument name clash\")\n      checkClashes[expr.name] = true\n    }\n    break\n\n  case \"MemberExpression\":\n    if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\")\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0; i < expr.properties.length; i++)\n      this$1.checkLVal(expr.properties[i].value, isBinding, checkClashes)\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {\n      var elem = expr.elements[i$1]\n      if (elem) this$1.checkLVal(elem, isBinding, checkClashes)\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, isBinding, checkClashes)\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, isBinding, checkClashes)\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, isBinding, checkClashes)\n    break\n\n  default:\n    this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" rvalue\")\n  }\n}\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    return\n  var key = prop.key;\n  var name\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\")\n      propHash.proto = true\n    }\n    return\n  }\n  name = \"$\" + name\n  var other = propHash[name]\n  if (other) {\n    var isGetSet = kind !== \"init\"\n    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))\n      this.raiseRecoverable(key.start, \"Redefinition of property\")\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    }\n  }\n  other[kind] = true\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors)\n  if (this.type === tt.comma) {\n    var node = this.startNodeAt(startPos, startLoc)\n    node.expressions = [expr]\n    while (this.eat(tt.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) return this.parseYield()\n\n  var ownDestructuringErrors = false, oldParenAssign = -1\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign\n    refDestructuringErrors.parenthesizedAssign = -1\n  } else {\n    refDestructuringErrors = new DestructuringErrors\n    ownDestructuringErrors = true\n  }\n\n  var startPos = this.start, startLoc = this.startLoc\n  if (this.type == tt.parenL || this.type == tt.name)\n    this.potentialArrowAt = this.start\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors)\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)\n  if (this.type.isAssign) {\n    this.checkPatternErrors(refDestructuringErrors, true)\n    if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)\n    var node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.left = this.type === tt.eq ? this.toAssignable(left) : left\n    refDestructuringErrors.shorthandAssign = -1 // reset because shorthand default was used correctly\n    this.checkLVal(left)\n    this.next()\n    node.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign\n  return left\n}\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseExprOps(noIn, refDestructuringErrors)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  if (this.eat(tt.question)) {\n    var node = this.startNodeAt(startPos, startLoc)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    this.expect(tt.colon)\n    node.alternate = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  return this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop\n  if (prec != null && (!noIn || this.type !== tt._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === tt.logicalOR || this.type === tt.logicalAND\n      var op = this.value\n      this.next()\n      var startPos = this.start, startLoc = this.startLoc\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n}\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.operator = op\n  node.right = right\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n}\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, expr\n  if (this.inAsync && this.isContextual(\"await\")) {\n    expr = this.parseAwait(refDestructuringErrors)\n    sawUnary = true\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === tt.incDec\n    node.operator = this.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary(null, true)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    if (update) this.checkLVal(node.argument)\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\")\n    else sawUnary = true\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors)\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc)\n      node$1.operator = this$1.value\n      node$1.prefix = false\n      node$1.argument = expr\n      this$1.checkLVal(expr)\n      this$1.next()\n      expr = this$1.finishNode(node$1, \"UpdateExpression\")\n    }\n  }\n\n  if (!sawUnary && this.eat(tt.starstar))\n    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false)\n  else\n    return expr\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseExprAtom(refDestructuringErrors)\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\"\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr\n  var result = this.parseSubscripts(expr, startPos, startLoc)\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1\n    if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1\n  }\n  return result\n}\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd == base.end && !this.canInsertSemicolon()\n  for (var computed;;) {\n    if ((computed = this$1.eat(tt.bracketL)) || this$1.eat(tt.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true)\n      node.computed = !!computed\n      if (computed) this$1.expect(tt.bracketR)\n      base = this$1.finishNode(node, \"MemberExpression\")\n    } else if (!noCalls && this$1.eat(tt.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos\n      this$1.yieldPos = 0\n      this$1.awaitPos = 0\n      var exprList = this$1.parseExprList(tt.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors)\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(tt.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false)\n        this$1.checkYieldAwaitInDefaultParams()\n        this$1.yieldPos = oldYieldPos\n        this$1.awaitPos = oldAwaitPos\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this$1.checkExpressionErrors(refDestructuringErrors, true)\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos\n      var node$1 = this$1.startNodeAt(startPos, startLoc)\n      node$1.callee = base\n      node$1.arguments = exprList\n      base = this$1.finishNode(node$1, \"CallExpression\")\n    } else if (this$1.type === tt.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc)\n      node$2.tag = base\n      node$2.quasi = this$1.parseTemplate()\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\")\n    } else {\n      return base\n    }\n  }\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  var node, canBeArrow = this.potentialArrowAt == this.start\n  switch (this.type) {\n  case tt._super:\n    if (!this.inFunction)\n      this.raise(this.start, \"'super' outside of function or class\")\n\n  case tt._this:\n    var type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case tt.name:\n    var startPos = this.start, startLoc = this.startLoc\n    var id = this.parseIdent(this.type !== tt.name)\n    if (this.options.ecmaVersion >= 8 && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(tt._function))\n      return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true)\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(tt.arrow))\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false)\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === tt.name) {\n        id = this.parseIdent()\n        if (this.canInsertSemicolon() || !this.eat(tt.arrow))\n          this.unexpected()\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case tt.regexp:\n    var value = this.value\n    node = this.parseLiteral(value.value)\n    node.regex = {pattern: value.pattern, flags: value.flags}\n    return node\n\n  case tt.num: case tt.string:\n    return this.parseLiteral(this.value)\n\n  case tt._null: case tt._true: case tt._false:\n    node = this.startNode()\n    node.value = this.type === tt._null ? null : this.type === tt._true\n    node.raw = this.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case tt.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow)\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        refDestructuringErrors.parenthesizedAssign = start\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        refDestructuringErrors.parenthesizedBind = start\n    }\n    return expr\n\n  case tt.bracketL:\n    node = this.startNode()\n    this.next()\n    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tt.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case tt._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case tt._class:\n    return this.parseClass(this.startNode(), false)\n\n  case tt._new:\n    return this.parseNew()\n\n  case tt.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected()\n  }\n}\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode()\n  node.value = value\n  node.raw = this.input.slice(this.start, this.end)\n  this.next()\n  return this.finishNode(node, \"Literal\")\n}\n\npp$3.parseParenExpression = function() {\n  this.expect(tt.parenL)\n  var val = this.parseExpression()\n  this.expect(tt.parenR)\n  return val\n}\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8\n  if (this.options.ecmaVersion >= 6) {\n    this.next()\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc\n    var exprList = [], first = true, lastIsComma = false\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart, innerParenStart\n    this.yieldPos = 0\n    this.awaitPos = 0\n    while (this.type !== tt.parenR) {\n      first ? first = false : this$1.expect(tt.comma)\n      if (allowTrailingComma && this$1.afterTrailingComma(tt.parenR, true)) {\n        lastIsComma = true\n        break\n      } else if (this$1.type === tt.ellipsis) {\n        spreadStart = this$1.start\n        exprList.push(this$1.parseParenItem(this$1.parseRest()))\n        if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\")\n        break\n      } else {\n        if (this$1.type === tt.parenL && !innerParenStart) {\n          innerParenStart = this$1.start\n        }\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem))\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc\n    this.expect(tt.parenR)\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false)\n      this.checkYieldAwaitInDefaultParams()\n      if (innerParenStart) this.unexpected(innerParenStart)\n      this.yieldPos = oldYieldPos\n      this.awaitPos = oldAwaitPos\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart)\n    if (spreadStart) this.unexpected(spreadStart)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    this.yieldPos = oldYieldPos || this.yieldPos\n    this.awaitPos = oldAwaitPos || this.awaitPos\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc)\n      val.expressions = exprList\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc)\n    } else {\n      val = exprList[0]\n    }\n  } else {\n    val = this.parseParenExpression()\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc)\n    par.expression = val\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n}\n\npp$3.parseParenItem = function(item) {\n  return item\n}\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = []\n\npp$3.parseNew = function() {\n  var node = this.startNode()\n  var meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    if (node.property.name !== \"target\")\n      this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\")\n    if (!this.inFunction)\n      this.raiseRecoverable(node.start, \"new.target can only be used in functions\")\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)\n  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, this.options.ecmaVersion >= 8, false)\n  else node.arguments = empty$1\n  return this.finishNode(node, \"NewExpression\")\n}\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function() {\n  var elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, '\\n'),\n    cooked: this.value\n  }\n  this.next()\n  elem.tail = this.type === tt.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\npp$3.parseTemplate = function() {\n  var this$1 = this;\n\n  var node = this.startNode()\n  this.next()\n  node.expressions = []\n  var curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this$1.expect(tt.dollarBraceL)\n    node.expressions.push(this$1.parseExpression())\n    this$1.expect(tt.braceR)\n    node.quasis.push(curElt = this$1.parseTemplateElement())\n  }\n  this.next()\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var this$1 = this;\n\n  var node = this.startNode(), first = true, propHash = {}\n  node.properties = []\n  this.next()\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var prop = this$1.startNode(), isGenerator, isAsync, startPos, startLoc\n    if (this$1.options.ecmaVersion >= 6) {\n      prop.method = false\n      prop.shorthand = false\n      if (isPattern || refDestructuringErrors) {\n        startPos = this$1.start\n        startLoc = this$1.startLoc\n      }\n      if (!isPattern)\n        isGenerator = this$1.eat(tt.star)\n    }\n    this$1.parsePropertyName(prop)\n    if (!isPattern && this$1.options.ecmaVersion >= 8 && !isGenerator && !prop.computed &&\n        prop.key.type === \"Identifier\" && prop.key.name === \"async\" && this$1.type !== tt.parenL &&\n        this$1.type !== tt.colon && !this$1.canInsertSemicolon()) {\n      isAsync = true\n      this$1.parsePropertyName(prop, refDestructuringErrors)\n    } else {\n      isAsync = false\n    }\n    this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)\n    this$1.checkPropClash(prop, propHash)\n    node.properties.push(this$1.finishNode(prop, \"Property\"))\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n}\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {\n  if ((isGenerator || isAsync) && this.type === tt.colon)\n    this.unexpected()\n\n  if (this.eat(tt.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)\n    prop.kind = \"init\"\n  } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n    if (isPattern) this.unexpected()\n    prop.kind = \"init\"\n    prop.method = true\n    prop.value = this.parseMethod(isGenerator, isAsync)\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type != tt.comma && this.type != tt.braceR)) {\n    if (isGenerator || isAsync || isPattern) this.unexpected()\n    prop.kind = prop.key.name\n    this.parsePropertyName(prop)\n    prop.value = this.parseMethod(false)\n    var paramCount = prop.kind === \"get\" ? 0 : 1\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start\n      if (prop.kind === \"get\")\n        this.raiseRecoverable(start, \"getter should have no params\")\n      else\n        this.raiseRecoverable(start, \"setter should have exactly one param\")\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\")\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (this.keywords.test(prop.key.name) ||\n        (this.strict ? this.reservedWordsStrict : this.reservedWords).test(prop.key.name) ||\n        (this.inGenerator && prop.key.name == \"yield\") ||\n        (this.inAsync && prop.key.name == \"await\"))\n      this.raiseRecoverable(prop.key.start, \"'\" + prop.key.name + \"' can not be used as shorthand property\")\n    prop.kind = \"init\"\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else if (this.type === tt.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        refDestructuringErrors.shorthandAssign = this.start\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else {\n      prop.value = prop.key\n    }\n    prop.shorthand = true\n  } else this.unexpected()\n}\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tt.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseMaybeAssign()\n      this.expect(tt.bracketR)\n      return prop.key\n    } else {\n      prop.computed = false\n    }\n  }\n  return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)\n}\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n  if (this.options.ecmaVersion >= 8)\n    node.async = false\n}\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = isGenerator\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  this.inGenerator = node.generator\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8)\n  this.checkYieldAwaitInDefaultParams()\n  this.parseFunctionBody(node, false)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  this.inGenerator = false\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  node.params = this.toAssignableList(params, true)\n  this.parseFunctionBody(node, true)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== tt.braceL\n  var oldStrict = this.strict, useStrict = false\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign()\n    node.expression = true\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params)\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end)\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\")\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels\n    this.labels = []\n    if (useStrict) this.strict = true\n    node.body = this.parseBlock(true)\n    node.expression = false\n    this.labels = oldLabels\n  }\n\n  if (oldStrict || useStrict) {\n    this.strict = true\n    if (node.id)\n      this.checkLVal(node.id, true)\n    this.checkParams(node)\n    this.strict = oldStrict\n  } else if (isArrowFunction || !this.isSimpleParamList(node.params)) {\n    this.checkParams(node)\n  }\n}\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0; i < params.length; i++)\n    if (params[i].type !== \"Identifier\") return false\n  return true\n}\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node) {\n  var this$1 = this;\n\n  var nameHash = {}\n  for (var i = 0; i < node.params.length; i++) this$1.checkLVal(node.params[i], true, nameHash)\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n\n  var elts = [], first = true\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) break\n    } else first = false\n\n    var elt\n    if (allowEmpty && this$1.type === tt.comma)\n      elt = null\n    else if (this$1.type === tt.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors)\n      if (refDestructuringErrors && this$1.type === tt.comma && refDestructuringErrors.trailingComma < 0)\n        refDestructuringErrors.trailingComma = this$1.start\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors)\n    }\n    elts.push(elt)\n  }\n  return elts\n}\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal) {\n  var node = this.startNode()\n  if (liberal && this.options.allowReserved == \"never\") liberal = false\n  if (this.type === tt.name) {\n    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&\n        (this.options.ecmaVersion >= 6 ||\n         this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1))\n      this.raiseRecoverable(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n    if (this.inGenerator && this.value === \"yield\")\n      this.raiseRecoverable(this.start, \"Can not use 'yield' as identifier inside a generator\")\n    if (this.inAsync && this.value === \"await\")\n      this.raiseRecoverable(this.start, \"Can not use 'await' as identifier inside an async function\")\n    node.name = this.value\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword\n  } else {\n    this.unexpected()\n  }\n  this.next()\n  return this.finishNode(node, \"Identifier\")\n}\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function() {\n  if (!this.yieldPos) this.yieldPos = this.start\n\n  var node = this.startNode()\n  this.next()\n  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n    node.delegate = false\n    node.argument = null\n  } else {\n    node.delegate = this.eat(tt.star)\n    node.argument = this.parseMaybeAssign()\n  }\n  return this.finishNode(node, \"YieldExpression\")\n}\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) this.awaitPos = this.start\n\n  var node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeUnary(null, true)\n  return this.finishNode(node, \"AwaitExpression\")\n}\n\nvar pp$4 = Parser.prototype\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos)\n  message += \" (\" + loc.line + \":\" + loc.column + \")\"\n  var err = new SyntaxError(message)\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos\n  throw err\n}\n\npp$4.raiseRecoverable = pp$4.raise\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n}\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\"\n  this.start = pos\n  this.end = 0\n  if (parser.options.locations)\n    this.loc = new SourceLocation(parser, loc)\n  if (parser.options.directSourceFile)\n    this.sourceFile = parser.options.directSourceFile\n  if (parser.options.ranges)\n    this.range = [pos, 0]\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$5 = Parser.prototype\n\npp$5.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n}\n\npp$5.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n}\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type\n  node.end = pos\n  if (this.options.locations)\n    node.loc.end = loc\n  if (this.options.ranges)\n    node.range[1] = pos\n  return node\n}\n\npp$5.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n}\n\n// Finish node at given position\n\npp$5.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n}\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override) {\n  this.token = token\n  this.isExpr = !!isExpr\n  this.preserveSpace = !!preserveSpace\n  this.override = override\n};\n\nvar types = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", true),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.readTmplToken(); }),\n  f_expr: new TokContext(\"function\", true)\n}\n\nvar pp$6 = Parser.prototype\n\npp$6.initialContext = function() {\n  return [types.b_stat]\n}\n\npp$6.braceIsBlock = function(prevType) {\n  if (prevType === tt.colon) {\n    var parent = this.curContext()\n    if (parent === types.b_stat || parent === types.b_expr)\n      return !parent.isExpr\n  }\n  if (prevType === tt._return)\n    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR)\n    return true\n  if (prevType == tt.braceL)\n    return this.curContext() === types.b_stat\n  return !this.exprAllowed\n}\n\npp$6.updateContext = function(prevType) {\n  var update, type = this.type\n  if (type.keyword && prevType == tt.dot)\n    this.exprAllowed = false\n  else if (update = type.updateContext)\n    update.call(this, prevType)\n  else\n    this.exprAllowed = type.beforeExpr\n}\n\n// Token-specific context update code\n\ntt.parenR.updateContext = tt.braceR.updateContext = function() {\n  if (this.context.length == 1) {\n    this.exprAllowed = true\n    return\n  }\n  var out = this.context.pop()\n  if (out === types.b_stat && this.curContext() === types.f_expr) {\n    this.context.pop()\n    this.exprAllowed = false\n  } else if (out === types.b_tmpl) {\n    this.exprAllowed = true\n  } else {\n    this.exprAllowed = !out.isExpr\n  }\n}\n\ntt.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr)\n  this.exprAllowed = true\n}\n\ntt.dollarBraceL.updateContext = function() {\n  this.context.push(types.b_tmpl)\n  this.exprAllowed = true\n}\n\ntt.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while\n  this.context.push(statementParens ? types.p_stat : types.p_expr)\n  this.exprAllowed = true\n}\n\ntt.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n}\n\ntt._function.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== tt.semi && prevType !== tt._else &&\n      !((prevType === tt.colon || prevType === tt.braceL) && this.curContext() === types.b_stat))\n    this.context.push(types.f_expr)\n  this.exprAllowed = false\n}\n\ntt.backQuote.updateContext = function() {\n  if (this.curContext() === types.q_tmpl)\n    this.context.pop()\n  else\n    this.context.push(types.q_tmpl)\n  this.exprAllowed = false\n}\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type\n  this.value = p.value\n  this.start = p.start\n  this.end = p.end\n  if (p.options.locations)\n    this.loc = new SourceLocation(p, p.startLoc, p.endLoc)\n  if (p.options.ranges)\n    this.range = [p.start, p.end]\n};\n\n// ## Tokenizer\n\nvar pp$7 = Parser.prototype\n\n// Are we running under Rhino?\nvar isRhino = typeof Packages == \"object\" && Object.prototype.toString.call(Packages) == \"[object JavaPackage]\"\n\n// Move to the next token\n\npp$7.next = function() {\n  if (this.options.onToken)\n    this.options.onToken(new Token(this))\n\n  this.lastTokEnd = this.end\n  this.lastTokStart = this.start\n  this.lastTokEndLoc = this.endLoc\n  this.lastTokStartLoc = this.startLoc\n  this.nextToken()\n}\n\npp$7.getToken = function() {\n  this.next()\n  return new Token(this)\n}\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  pp$7[Symbol.iterator] = function () {\n    var self = this\n    return {next: function () {\n      var token = self.getToken()\n      return {\n        done: token.type === tt.eof,\n        value: token\n      }\n    }}\n  }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$7.curContext = function() {\n  return this.context[this.context.length - 1]\n}\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$7.nextToken = function() {\n  var curContext = this.curContext()\n  if (!curContext || !curContext.preserveSpace) this.skipSpace()\n\n  this.start = this.pos\n  if (this.options.locations) this.startLoc = this.curPosition()\n  if (this.pos >= this.input.length) return this.finishToken(tt.eof)\n\n  if (curContext.override) return curContext.override(this)\n  else this.readToken(this.fullCharCodeAtPos())\n}\n\npp$7.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    return this.readWord()\n\n  return this.getTokenFromCode(code)\n}\n\npp$7.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos)\n  if (code <= 0xd7ff || code >= 0xe000) return code\n  var next = this.input.charCodeAt(this.pos + 1)\n  return (code << 10) + next - 0x35fdc00\n}\n\npp$7.skipBlockComment = function() {\n  var this$1 = this;\n\n  var startLoc = this.options.onComment && this.curPosition()\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2)\n  if (end === -1) this.raise(this.pos - 2, \"Unterminated comment\")\n  this.pos = end + 2\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start\n    var match\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine\n      this$1.lineStart = match.index + match[0].length\n    }\n  }\n  if (this.options.onComment)\n    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition())\n}\n\npp$7.skipLineComment = function(startSkip) {\n  var this$1 = this;\n\n  var start = this.pos\n  var startLoc = this.options.onComment && this.curPosition()\n  var ch = this.input.charCodeAt(this.pos+=startSkip)\n  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n    ++this$1.pos\n    ch = this$1.input.charCodeAt(this$1.pos)\n  }\n  if (this.options.onComment)\n    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition())\n}\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$7.skipSpace = function() {\n  var this$1 = this;\n\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    switch (ch) {\n      case 32: case 160: // ' '\n        ++this$1.pos\n        break\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n          ++this$1.pos\n        }\n      case 10: case 8232: case 8233:\n        ++this$1.pos\n        if (this$1.options.locations) {\n          ++this$1.curLine\n          this$1.lineStart = this$1.pos\n        }\n        break\n      case 47: // '/'\n        switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n          case 42: // '*'\n            this$1.skipBlockComment()\n            break\n          case 47:\n            this$1.skipLineComment(2)\n            break\n          default:\n            break loop\n        }\n        break\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this$1.pos\n        } else {\n          break loop\n        }\n    }\n  }\n}\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$7.finishToken = function(type, val) {\n  this.end = this.pos\n  if (this.options.locations) this.endLoc = this.curPosition()\n  var prevType = this.type\n  this.type = type\n  this.value = val\n\n  this.updateContext(prevType)\n}\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$7.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next >= 48 && next <= 57) return this.readNumber(true)\n  var next2 = this.input.charCodeAt(this.pos + 2)\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3\n    return this.finishToken(tt.ellipsis)\n  } else {\n    ++this.pos\n    return this.finishToken(tt.dot)\n  }\n}\n\npp$7.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (this.exprAllowed) {++this.pos; return this.readRegexp()}\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.slash, 1)\n}\n\npp$7.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1)\n  var size = 1\n  var tokentype = code === 42 ? tt.star : tt.modulo\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && next === 42) {\n    ++size\n    tokentype = tt.starstar\n    next = this.input.charCodeAt(this.pos + 2)\n  }\n\n  if (next === 61) return this.finishOp(tt.assign, size + 1)\n  return this.finishOp(tokentype, size)\n}\n\npp$7.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2)\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1)\n}\n\npp$7.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.bitwiseXOR, 1)\n}\n\npp$7.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === code) {\n    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 &&\n        lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {\n      // A `-->` line comment\n      this.skipLineComment(3)\n      this.skipSpace()\n      return this.nextToken()\n    }\n    return this.finishOp(tt.incDec, 2)\n  }\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.plusMin, 1)\n}\n\npp$7.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1)\n  var size = 1\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2\n    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1)\n    return this.finishOp(tt.bitShift, size)\n  }\n  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 &&\n      this.input.charCodeAt(this.pos + 3) == 45) {\n    if (this.inModule) this.unexpected()\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4)\n    this.skipSpace()\n    return this.nextToken()\n  }\n  if (next === 61) size = 2\n  return this.finishOp(tt.relational, size)\n}\n\npp$7.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2\n    return this.finishToken(tt.arrow)\n  }\n  return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)\n}\n\npp$7.getTokenFromCode = function(code) {\n  switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n    // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(tt.parenL)\n  case 41: ++this.pos; return this.finishToken(tt.parenR)\n  case 59: ++this.pos; return this.finishToken(tt.semi)\n  case 44: ++this.pos; return this.finishToken(tt.comma)\n  case 91: ++this.pos; return this.finishToken(tt.bracketL)\n  case 93: ++this.pos; return this.finishToken(tt.bracketR)\n  case 123: ++this.pos; return this.finishToken(tt.braceL)\n  case 125: ++this.pos; return this.finishToken(tt.braceR)\n  case 58: ++this.pos; return this.finishToken(tt.colon)\n  case 63: ++this.pos; return this.finishToken(tt.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) break\n    ++this.pos\n    return this.finishToken(tt.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1)\n    if (next === 120 || next === 88) return this.readRadixNumber(16) // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) return this.readRadixNumber(8) // '0o', '0O' - octal number\n      if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number\n    }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n    // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(tt.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\")\n}\n\npp$7.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size)\n  this.pos += size\n  return this.finishToken(type, str)\n}\n\n// Parse a regular expression. Some context-awareness is necessary,\n// since a '/' inside a '[]' set does not end the expression.\n\nfunction tryCreateRegexp(src, flags, throwErrorAt, parser) {\n  try {\n    return new RegExp(src, flags)\n  } catch (e) {\n    if (throwErrorAt !== undefined) {\n      if (e instanceof SyntaxError) parser.raise(throwErrorAt, \"Error parsing regular expression: \" + e.message)\n      throw e\n    }\n  }\n}\n\nvar regexpUnicodeSupport = !!tryCreateRegexp(\"\\uffff\", \"u\")\n\npp$7.readRegexp = function() {\n  var this$1 = this;\n\n  var escaped, inClass, start = this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(start, \"Unterminated regular expression\")\n    var ch = this$1.input.charAt(this$1.pos)\n    if (lineBreak.test(ch)) this$1.raise(start, \"Unterminated regular expression\")\n    if (!escaped) {\n      if (ch === \"[\") inClass = true\n      else if (ch === \"]\" && inClass) inClass = false\n      else if (ch === \"/\" && !inClass) break\n      escaped = ch === \"\\\\\"\n    } else escaped = false\n    ++this$1.pos\n  }\n  var content = this.input.slice(start, this.pos)\n  ++this.pos\n  // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n  // here (don't ask).\n  var mods = this.readWord1()\n  var tmp = content, tmpFlags = \"\"\n  if (mods) {\n    var validFlags = /^[gim]*$/\n    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/\n    if (!validFlags.test(mods)) this.raise(start, \"Invalid regular expression flag\")\n    if (mods.indexOf(\"u\") >= 0) {\n      if (regexpUnicodeSupport) {\n        tmpFlags = \"u\"\n      } else {\n        // Replace each astral symbol and every Unicode escape sequence that\n        // possibly represents an astral symbol or a paired surrogate with a\n        // single ASCII symbol to avoid throwing on regular expressions that\n        // are only valid in combination with the `/u` flag.\n        // Note: replacing with the ASCII symbol `x` might cause false\n        // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n        // perfectly valid pattern that is equivalent to `[a-b]`, but it would\n        // be replaced by `[x-b]` which throws an error.\n        tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function (_match, code, offset) {\n          code = Number(\"0x\" + code)\n          if (code > 0x10FFFF) this$1.raise(start + offset + 3, \"Code point out of bounds\")\n          return \"x\"\n        })\n        tmp = tmp.replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"x\")\n        tmpFlags = tmpFlags.replace(\"u\", \"\")\n      }\n    }\n  }\n  // Detect invalid regular expressions.\n  var value = null\n  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,\n  // so don't do detection if we are running under Rhino\n  if (!isRhino) {\n    tryCreateRegexp(tmp, tmpFlags, start, this)\n    // Get a regular expression object for this pattern-flag pair, or `null` in\n    // case the current environment doesn't support the flags it uses.\n    value = tryCreateRegexp(content, mods)\n  }\n  return this.finishToken(tt.regexp, {pattern: content, flags: mods, value: value})\n}\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$7.readInt = function(radix, len) {\n  var this$1 = this;\n\n  var start = this.pos, total = 0\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos), val\n    if (code >= 97) val = code - 97 + 10 // a\n    else if (code >= 65) val = code - 65 + 10 // A\n    else if (code >= 48 && code <= 57) val = code - 48 // 0-9\n    else val = Infinity\n    if (val >= radix) break\n    ++this$1.pos\n    total = total * radix + val\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) return null\n\n  return total\n}\n\npp$7.readRadixNumber = function(radix) {\n  this.pos += 2 // 0x\n  var val = this.readInt(radix)\n  if (val == null) this.raise(this.start + 2, \"Expected number in radix \" + radix)\n  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\")\n  return this.finishToken(tt.num, val)\n}\n\n// Read an integer, octal integer, or floating-point number.\n\npp$7.readNumber = function(startsWithDot) {\n  var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48\n  if (!startsWithDot && this.readInt(10) === null) this.raise(start, \"Invalid number\")\n  if (octal && this.pos == start + 1) octal = false\n  var next = this.input.charCodeAt(this.pos)\n  if (next === 46 && !octal) { // '.'\n    ++this.pos\n    this.readInt(10)\n    isFloat = true\n    next = this.input.charCodeAt(this.pos)\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos)\n    if (next === 43 || next === 45) ++this.pos // '+-'\n    if (this.readInt(10) === null) this.raise(start, \"Invalid number\")\n    isFloat = true\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\")\n\n  var str = this.input.slice(start, this.pos), val\n  if (isFloat) val = parseFloat(str)\n  else if (!octal || str.length === 1) val = parseInt(str, 10)\n  else if (/[89]/.test(str) || this.strict) this.raise(start, \"Invalid number\")\n  else val = parseInt(str, 8)\n  return this.finishToken(tt.num, val)\n}\n\n// Read a string value, interpreting backslash-escapes.\n\npp$7.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code\n\n  if (ch === 123) {\n    if (this.options.ecmaVersion < 6) this.unexpected()\n    var codePos = ++this.pos\n    code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos)\n    ++this.pos\n    if (code > 0x10FFFF) this.raise(codePos, \"Code point out of bounds\")\n  } else {\n    code = this.readHexChar(4)\n  }\n  return code\n}\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) return String.fromCharCode(code)\n  code -= 0x10000\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$7.readString = function(quote) {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = ++this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated string constant\")\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    if (ch === quote) break\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      out += this$1.readEscapedChar(false)\n      chunkStart = this$1.pos\n    } else {\n      if (isNewLine(ch)) this$1.raise(this$1.start, \"Unterminated string constant\")\n      ++this$1.pos\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++)\n  return this.finishToken(tt.string, out)\n}\n\n// Reads template string tokens.\n\npp$7.readTmplToken = function() {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated template\")\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\n      if (this$1.pos === this$1.start && this$1.type === tt.template) {\n        if (ch === 36) {\n          this$1.pos += 2\n          return this$1.finishToken(tt.dollarBraceL)\n        } else {\n          ++this$1.pos\n          return this$1.finishToken(tt.backQuote)\n        }\n      }\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      return this$1.finishToken(tt.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      out += this$1.readEscapedChar(true)\n      chunkStart = this$1.pos\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      ++this$1.pos\n      switch (ch) {\n        case 13:\n          if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos\n        case 10:\n          out += \"\\n\"\n          break\n        default:\n          out += String.fromCharCode(ch)\n          break\n      }\n      if (this$1.options.locations) {\n        ++this$1.curLine\n        this$1.lineStart = this$1.pos\n      }\n      chunkStart = this$1.pos\n    } else {\n      ++this$1.pos\n    }\n  }\n}\n\n// Used to read escaped characters\n\npp$7.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos)\n  ++this.pos\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]\n      var octal = parseInt(octalStr, 8)\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1)\n        octal = parseInt(octalStr, 8)\n      }\n      if (octalStr !== \"0\" && (this.strict || inTemplate)) {\n        this.raise(this.pos - 2, \"Octal literal in strict mode\")\n      }\n      this.pos += octalStr.length - 1\n      return String.fromCharCode(octal)\n    }\n    return String.fromCharCode(ch)\n  }\n}\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$7.readHexChar = function(len) {\n  var codePos = this.pos\n  var n = this.readInt(16, len)\n  if (n === null) this.raise(codePos, \"Bad character escape sequence\")\n  return n\n}\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$7.readWord1 = function() {\n  var this$1 = this;\n\n  this.containsEsc = false\n  var word = \"\", first = true, chunkStart = this.pos\n  var astral = this.options.ecmaVersion >= 6\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos()\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2\n    } else if (ch === 92) { // \"\\\"\n      this$1.containsEsc = true\n      word += this$1.input.slice(chunkStart, this$1.pos)\n      var escStart = this$1.pos\n      if (this$1.input.charCodeAt(++this$1.pos) != 117) // \"u\"\n        this$1.raise(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\")\n      ++this$1.pos\n      var esc = this$1.readCodePoint()\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        this$1.raise(escStart, \"Invalid Unicode escape\")\n      word += codePointToString(esc)\n      chunkStart = this$1.pos\n    } else {\n      break\n    }\n    first = false\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n}\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$7.readWord = function() {\n  var word = this.readWord1()\n  var type = tt.name\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word)\n    type = keywordTypes[word]\n  }\n  return this.finishToken(type, word)\n}\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/ternjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/ternjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\nvar version = \"4.0.11\"\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse()\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos)\n  p.nextToken()\n  return p.parseExpression()\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input)\n}\n\n// This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\nfunction addLooseExports(parse, Parser, plugins) {\n  exports.parse_dammit = parse\n  exports.LooseParser = Parser\n  exports.pluginsLoose = plugins\n}\n\nexports.version = version;\nexports.parse = parse;\nexports.parseExpressionAt = parseExpressionAt;\nexports.tokenizer = tokenizer;\nexports.addLooseExports = addLooseExports;\nexports.Parser = Parser;\nexports.plugins = plugins;\nexports.defaultOptions = defaultOptions;\nexports.Position = Position;\nexports.SourceLocation = SourceLocation;\nexports.getLineInfo = getLineInfo;\nexports.Node = Node;\nexports.TokenType = TokenType;\nexports.tokTypes = tt;\nexports.keywordTypes = keywordTypes;\nexports.TokContext = TokContext;\nexports.tokContexts = types;\nexports.isIdentifierChar = isIdentifierChar;\nexports.isIdentifierStart = isIdentifierStart;\nexports.Token = Token;\nexports.isNewLine = isNewLine;\nexports.lineBreak = lineBreak;\nexports.lineBreakG = lineBreakG;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('./acorn')) :\n  typeof define === 'function' && define.amd ? define(['exports', './acorn'], factory) :\n  (factory((global.acorn = global.acorn || {}, global.acorn.loose = global.acorn.loose || {}),global.acorn));\n}(this, (function (exports,__acorn) { 'use strict';\n\n// Registered plugins\nvar pluginsLoose = {}\n\nvar LooseParser = function LooseParser(input, options) {\n  if ( options === void 0 ) options = {};\n\n  this.toks = __acorn.tokenizer(input, options)\n  this.options = this.toks.options\n  this.input = this.toks.input\n  this.tok = this.last = {type: __acorn.tokTypes.eof, start: 0, end: 0}\n  if (this.options.locations) {\n    var here = this.toks.curPosition()\n    this.tok.loc = new __acorn.SourceLocation(this.toks, here, here)\n  }\n  this.ahead = [] // Tokens ahead\n  this.context = [] // Indentation contexted\n  this.curIndent = 0\n  this.curLineStart = 0\n  this.nextLineStart = this.lineEnd(this.curLineStart) + 1\n  this.inAsync = false\n  // Load plugins\n  this.options.pluginsLoose = options.pluginsLoose || {}\n  this.loadPlugins(this.options.pluginsLoose)\n};\n\nLooseParser.prototype.startNode = function startNode () {\n  return new __acorn.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null)\n};\n\nLooseParser.prototype.storeCurrentPos = function storeCurrentPos () {\n  return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start\n};\n\nLooseParser.prototype.startNodeAt = function startNodeAt (pos) {\n  if (this.options.locations) {\n    return new __acorn.Node(this.toks, pos[0], pos[1])\n  } else {\n    return new __acorn.Node(this.toks, pos)\n  }\n};\n\nLooseParser.prototype.finishNode = function finishNode (node, type) {\n  node.type = type\n  node.end = this.last.end\n  if (this.options.locations)\n    node.loc.end = this.last.loc.end\n  if (this.options.ranges)\n    node.range[1] = this.last.end\n  return node\n};\n\nLooseParser.prototype.dummyNode = function dummyNode (type) {\n  var dummy = this.startNode()\n  dummy.type = type\n  dummy.end = dummy.start\n  if (this.options.locations)\n    dummy.loc.end = dummy.loc.start\n  if (this.options.ranges)\n    dummy.range[1] = dummy.start\n  this.last = {type: __acorn.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc}\n  return dummy\n};\n\nLooseParser.prototype.dummyIdent = function dummyIdent () {\n  var dummy = this.dummyNode(\"Identifier\")\n  dummy.name = \"✖\"\n  return dummy\n};\n\nLooseParser.prototype.dummyString = function dummyString () {\n  var dummy = this.dummyNode(\"Literal\")\n  dummy.value = dummy.raw = \"✖\"\n  return dummy\n};\n\nLooseParser.prototype.eat = function eat (type) {\n  if (this.tok.type === type) {\n    this.next()\n    return true\n  } else {\n    return false\n  }\n};\n\nLooseParser.prototype.isContextual = function isContextual (name) {\n  return this.tok.type === __acorn.tokTypes.name && this.tok.value === name\n};\n\nLooseParser.prototype.eatContextual = function eatContextual (name) {\n  return this.tok.value === name && this.eat(__acorn.tokTypes.name)\n};\n\nLooseParser.prototype.canInsertSemicolon = function canInsertSemicolon () {\n  return this.tok.type === __acorn.tokTypes.eof || this.tok.type === __acorn.tokTypes.braceR ||\n    __acorn.lineBreak.test(this.input.slice(this.last.end, this.tok.start))\n};\n\nLooseParser.prototype.semicolon = function semicolon () {\n  return this.eat(__acorn.tokTypes.semi)\n};\n\nLooseParser.prototype.expect = function expect (type) {\n    var this$1 = this;\n\n  if (this.eat(type)) return true\n  for (var i = 1; i <= 2; i++) {\n    if (this$1.lookAhead(i).type == type) {\n      for (var j = 0; j < i; j++) this$1.next()\n      return true\n    }\n  }\n};\n\nLooseParser.prototype.pushCx = function pushCx () {\n  this.context.push(this.curIndent)\n};\n\nLooseParser.prototype.popCx = function popCx () {\n  this.curIndent = this.context.pop()\n};\n\nLooseParser.prototype.lineEnd = function lineEnd (pos) {\n  while (pos < this.input.length && !__acorn.isNewLine(this.input.charCodeAt(pos))) ++pos\n  return pos\n};\n\nLooseParser.prototype.indentationAfter = function indentationAfter (pos) {\n    var this$1 = this;\n\n  for (var count = 0;; ++pos) {\n    var ch = this$1.input.charCodeAt(pos)\n    if (ch === 32) ++count\n    else if (ch === 9) count += this$1.options.tabSize\n    else return count\n  }\n};\n\nLooseParser.prototype.closes = function closes (closeTok, indent, line, blockHeuristic) {\n  if (this.tok.type === closeTok || this.tok.type === __acorn.tokTypes.eof) return true\n  return line != this.curLineStart && this.curIndent < indent && this.tokenStartsLine() &&\n    (!blockHeuristic || this.nextLineStart >= this.input.length ||\n     this.indentationAfter(this.nextLineStart) < indent)\n};\n\nLooseParser.prototype.tokenStartsLine = function tokenStartsLine () {\n    var this$1 = this;\n\n  for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {\n    var ch = this$1.input.charCodeAt(p)\n    if (ch !== 9 && ch !== 32) return false\n  }\n  return true\n};\n\nLooseParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name])\n};\n\nLooseParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n    var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = pluginsLoose[name]\n    if (!plugin) throw new Error(\"Plugin '\" + name + \"' not found\")\n    plugin(this$1, pluginConfigs[name])\n  }\n};\n\nvar lp = LooseParser.prototype\n\nfunction isSpace(ch) {\n  return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || __acorn.isNewLine(ch)\n}\n\nlp.next = function() {\n  var this$1 = this;\n\n  this.last = this.tok\n  if (this.ahead.length)\n    this.tok = this.ahead.shift()\n  else\n    this.tok = this.readToken()\n\n  if (this.tok.start >= this.nextLineStart) {\n    while (this.tok.start >= this.nextLineStart) {\n      this$1.curLineStart = this$1.nextLineStart\n      this$1.nextLineStart = this$1.lineEnd(this$1.curLineStart) + 1\n    }\n    this.curIndent = this.indentationAfter(this.curLineStart)\n  }\n}\n\nlp.readToken = function() {\n  var this$1 = this;\n\n  for (;;) {\n    try {\n      this$1.toks.next()\n      if (this$1.toks.type === __acorn.tokTypes.dot &&\n          this$1.input.substr(this$1.toks.end, 1) === \".\" &&\n          this$1.options.ecmaVersion >= 6) {\n        this$1.toks.end++\n        this$1.toks.type = __acorn.tokTypes.ellipsis\n      }\n      return new __acorn.Token(this$1.toks)\n    } catch(e) {\n      if (!(e instanceof SyntaxError)) throw e\n\n      // Try to skip some text, based on the error message, and then continue\n      var msg = e.message, pos = e.raisedAt, replace = true\n      if (/unterminated/i.test(msg)) {\n        pos = this$1.lineEnd(e.pos + 1)\n        if (/string/.test(msg)) {\n          replace = {start: e.pos, end: pos, type: __acorn.tokTypes.string, value: this$1.input.slice(e.pos + 1, pos)}\n        } else if (/regular expr/i.test(msg)) {\n          var re = this$1.input.slice(e.pos, pos)\n          try { re = new RegExp(re) } catch(e) {}\n          replace = {start: e.pos, end: pos, type: __acorn.tokTypes.regexp, value: re}\n        } else if (/template/.test(msg)) {\n          replace = {start: e.pos, end: pos,\n                     type: __acorn.tokTypes.template,\n                     value: this$1.input.slice(e.pos, pos)}\n        } else {\n          replace = false\n        }\n      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) ++pos\n      } else if (/character escape|expected hexadecimal/i.test(msg)) {\n        while (pos < this.input.length) {\n          var ch = this$1.input.charCodeAt(pos++)\n          if (ch === 34 || ch === 39 || __acorn.isNewLine(ch)) break\n        }\n      } else if (/unexpected character/i.test(msg)) {\n        pos++\n        replace = false\n      } else if (/regular expression/i.test(msg)) {\n        replace = true\n      } else {\n        throw e\n      }\n      this$1.resetTo(pos)\n      if (replace === true) replace = {start: pos, end: pos, type: __acorn.tokTypes.name, value: \"✖\"}\n      if (replace) {\n        if (this$1.options.locations)\n          replace.loc = new __acorn.SourceLocation(\n            this$1.toks,\n            __acorn.getLineInfo(this$1.input, replace.start),\n            __acorn.getLineInfo(this$1.input, replace.end))\n        return replace\n      }\n    }\n  }\n}\n\nlp.resetTo = function(pos) {\n  var this$1 = this;\n\n  this.toks.pos = pos\n  var ch = this.input.charAt(pos - 1)\n  this.toks.exprAllowed = !ch || /[\\[\\{\\(,;:?\\/*=+\\-~!|&%^<>]/.test(ch) ||\n    /[enwfd]/.test(ch) &&\n    /\\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(this.input.slice(pos - 10, pos))\n\n  if (this.options.locations) {\n    this.toks.curLine = 1\n    this.toks.lineStart = __acorn.lineBreakG.lastIndex = 0\n    var match\n    while ((match = __acorn.lineBreakG.exec(this.input)) && match.index < pos) {\n      ++this$1.toks.curLine\n      this$1.toks.lineStart = match.index + match[0].length\n    }\n  }\n}\n\nlp.lookAhead = function(n) {\n  var this$1 = this;\n\n  while (n > this.ahead.length)\n    this$1.ahead.push(this$1.readToken())\n  return this.ahead[n - 1]\n}\n\nfunction isDummy(node) { return node.name == \"✖\" }\n\nvar lp$1 = LooseParser.prototype\n\nlp$1.parseTopLevel = function() {\n  var this$1 = this;\n\n  var node = this.startNodeAt(this.options.locations ? [0, __acorn.getLineInfo(this.input, 0)] : 0)\n  node.body = []\n  while (this.tok.type !== __acorn.tokTypes.eof) node.body.push(this$1.parseStatement())\n  this.last = this.tok\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType\n  }\n  return this.finishNode(node, \"Program\")\n}\n\nlp$1.parseStatement = function() {\n  var this$1 = this;\n\n  var starttype = this.tok.type, node = this.startNode(), kind\n\n  if (this.toks.isLet()) {\n    starttype = __acorn.tokTypes._var\n    kind = \"let\"\n  }\n\n  switch (starttype) {\n  case __acorn.tokTypes._break: case __acorn.tokTypes._continue:\n    this.next()\n    var isBreak = starttype === __acorn.tokTypes._break\n    if (this.semicolon() || this.canInsertSemicolon()) {\n      node.label = null\n    } else {\n      node.label = this.tok.type === __acorn.tokTypes.name ? this.parseIdent() : null\n      this.semicolon()\n    }\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n\n  case __acorn.tokTypes._debugger:\n    this.next()\n    this.semicolon()\n    return this.finishNode(node, \"DebuggerStatement\")\n\n  case __acorn.tokTypes._do:\n    this.next()\n    node.body = this.parseStatement()\n    node.test = this.eat(__acorn.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent()\n    this.semicolon()\n    return this.finishNode(node, \"DoWhileStatement\")\n\n  case __acorn.tokTypes._for:\n    this.next()\n    this.pushCx()\n    this.expect(__acorn.tokTypes.parenL)\n    if (this.tok.type === __acorn.tokTypes.semi) return this.parseFor(node, null)\n    var isLet = this.toks.isLet()\n    if (isLet || this.tok.type === __acorn.tokTypes._var || this.tok.type === __acorn.tokTypes._const) {\n      var init$1 = this.parseVar(true, isLet ? \"let\" : this.tok.value)\n      if (init$1.declarations.length === 1 && (this.tok.type === __acorn.tokTypes._in || this.isContextual(\"of\"))) {\n        return this.parseForIn(node, init$1)\n      }\n      return this.parseFor(node, init$1)\n    }\n    var init = this.parseExpression(true)\n    if (this.tok.type === __acorn.tokTypes._in || this.isContextual(\"of\"))\n      return this.parseForIn(node, this.toAssignable(init))\n    return this.parseFor(node, init)\n\n  case __acorn.tokTypes._function:\n    this.next()\n    return this.parseFunction(node, true)\n\n  case __acorn.tokTypes._if:\n    this.next()\n    node.test = this.parseParenExpression()\n    node.consequent = this.parseStatement()\n    node.alternate = this.eat(__acorn.tokTypes._else) ? this.parseStatement() : null\n    return this.finishNode(node, \"IfStatement\")\n\n  case __acorn.tokTypes._return:\n    this.next()\n    if (this.eat(__acorn.tokTypes.semi) || this.canInsertSemicolon()) node.argument = null\n    else { node.argument = this.parseExpression(); this.semicolon() }\n    return this.finishNode(node, \"ReturnStatement\")\n\n  case __acorn.tokTypes._switch:\n    var blockIndent = this.curIndent, line = this.curLineStart\n    this.next()\n    node.discriminant = this.parseParenExpression()\n    node.cases = []\n    this.pushCx()\n    this.expect(__acorn.tokTypes.braceL)\n\n    var cur\n    while (!this.closes(__acorn.tokTypes.braceR, blockIndent, line, true)) {\n      if (this$1.tok.type === __acorn.tokTypes._case || this$1.tok.type === __acorn.tokTypes._default) {\n        var isCase = this$1.tok.type === __acorn.tokTypes._case\n        if (cur) this$1.finishNode(cur, \"SwitchCase\")\n        node.cases.push(cur = this$1.startNode())\n        cur.consequent = []\n        this$1.next()\n        if (isCase) cur.test = this$1.parseExpression()\n        else cur.test = null\n        this$1.expect(__acorn.tokTypes.colon)\n      } else {\n        if (!cur) {\n          node.cases.push(cur = this$1.startNode())\n          cur.consequent = []\n          cur.test = null\n        }\n        cur.consequent.push(this$1.parseStatement())\n      }\n    }\n    if (cur) this.finishNode(cur, \"SwitchCase\")\n    this.popCx()\n    this.eat(__acorn.tokTypes.braceR)\n    return this.finishNode(node, \"SwitchStatement\")\n\n  case __acorn.tokTypes._throw:\n    this.next()\n    node.argument = this.parseExpression()\n    this.semicolon()\n    return this.finishNode(node, \"ThrowStatement\")\n\n  case __acorn.tokTypes._try:\n    this.next()\n    node.block = this.parseBlock()\n    node.handler = null\n    if (this.tok.type === __acorn.tokTypes._catch) {\n      var clause = this.startNode()\n      this.next()\n      this.expect(__acorn.tokTypes.parenL)\n      clause.param = this.toAssignable(this.parseExprAtom(), true)\n      this.expect(__acorn.tokTypes.parenR)\n      clause.body = this.parseBlock()\n      node.handler = this.finishNode(clause, \"CatchClause\")\n    }\n    node.finalizer = this.eat(__acorn.tokTypes._finally) ? this.parseBlock() : null\n    if (!node.handler && !node.finalizer) return node.block\n    return this.finishNode(node, \"TryStatement\")\n\n  case __acorn.tokTypes._var:\n  case __acorn.tokTypes._const:\n    return this.parseVar(false, kind || this.tok.value)\n\n  case __acorn.tokTypes._while:\n    this.next()\n    node.test = this.parseParenExpression()\n    node.body = this.parseStatement()\n    return this.finishNode(node, \"WhileStatement\")\n\n  case __acorn.tokTypes._with:\n    this.next()\n    node.object = this.parseParenExpression()\n    node.body = this.parseStatement()\n    return this.finishNode(node, \"WithStatement\")\n\n  case __acorn.tokTypes.braceL:\n    return this.parseBlock()\n\n  case __acorn.tokTypes.semi:\n    this.next()\n    return this.finishNode(node, \"EmptyStatement\")\n\n  case __acorn.tokTypes._class:\n    return this.parseClass(true)\n\n  case __acorn.tokTypes._import:\n    return this.parseImport()\n\n  case __acorn.tokTypes._export:\n    return this.parseExport()\n\n  default:\n    if (this.toks.isAsyncFunction()) {\n      this.next()\n      this.next()\n      return this.parseFunction(node, true, true)\n    }\n    var expr = this.parseExpression()\n    if (isDummy(expr)) {\n      this.next()\n      if (this.tok.type === __acorn.tokTypes.eof) return this.finishNode(node, \"EmptyStatement\")\n      return this.parseStatement()\n    } else if (starttype === __acorn.tokTypes.name && expr.type === \"Identifier\" && this.eat(__acorn.tokTypes.colon)) {\n      node.body = this.parseStatement()\n      node.label = expr\n      return this.finishNode(node, \"LabeledStatement\")\n    } else {\n      node.expression = expr\n      this.semicolon()\n      return this.finishNode(node, \"ExpressionStatement\")\n    }\n  }\n}\n\nlp$1.parseBlock = function() {\n  var this$1 = this;\n\n  var node = this.startNode()\n  this.pushCx()\n  this.expect(__acorn.tokTypes.braceL)\n  var blockIndent = this.curIndent, line = this.curLineStart\n  node.body = []\n  while (!this.closes(__acorn.tokTypes.braceR, blockIndent, line, true))\n    node.body.push(this$1.parseStatement())\n  this.popCx()\n  this.eat(__acorn.tokTypes.braceR)\n  return this.finishNode(node, \"BlockStatement\")\n}\n\nlp$1.parseFor = function(node, init) {\n  node.init = init\n  node.test = node.update = null\n  if (this.eat(__acorn.tokTypes.semi) && this.tok.type !== __acorn.tokTypes.semi) node.test = this.parseExpression()\n  if (this.eat(__acorn.tokTypes.semi) && this.tok.type !== __acorn.tokTypes.parenR) node.update = this.parseExpression()\n  this.popCx()\n  this.expect(__acorn.tokTypes.parenR)\n  node.body = this.parseStatement()\n  return this.finishNode(node, \"ForStatement\")\n}\n\nlp$1.parseForIn = function(node, init) {\n  var type = this.tok.type === __acorn.tokTypes._in ? \"ForInStatement\" : \"ForOfStatement\"\n  this.next()\n  node.left = init\n  node.right = this.parseExpression()\n  this.popCx()\n  this.expect(__acorn.tokTypes.parenR)\n  node.body = this.parseStatement()\n  return this.finishNode(node, type)\n}\n\nlp$1.parseVar = function(noIn, kind) {\n  var this$1 = this;\n\n  var node = this.startNode()\n  node.kind = kind\n  this.next()\n  node.declarations = []\n  do {\n    var decl = this$1.startNode()\n    decl.id = this$1.options.ecmaVersion >= 6 ? this$1.toAssignable(this$1.parseExprAtom(), true) : this$1.parseIdent()\n    decl.init = this$1.eat(__acorn.tokTypes.eq) ? this$1.parseMaybeAssign(noIn) : null\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"))\n  } while (this.eat(__acorn.tokTypes.comma))\n  if (!node.declarations.length) {\n    var decl$1 = this.startNode()\n    decl$1.id = this.dummyIdent()\n    node.declarations.push(this.finishNode(decl$1, \"VariableDeclarator\"))\n  }\n  if (!noIn) this.semicolon()\n  return this.finishNode(node, \"VariableDeclaration\")\n}\n\nlp$1.parseClass = function(isStatement) {\n  var this$1 = this;\n\n  var node = this.startNode()\n  this.next()\n  if (isStatement == null) isStatement = this.tok.type === __acorn.tokTypes.name\n  if (this.tok.type === __acorn.tokTypes.name) node.id = this.parseIdent()\n  else if (isStatement) node.id = this.dummyIdent()\n  else node.id = null\n  node.superClass = this.eat(__acorn.tokTypes._extends) ? this.parseExpression() : null\n  node.body = this.startNode()\n  node.body.body = []\n  this.pushCx()\n  var indent = this.curIndent + 1, line = this.curLineStart\n  this.eat(__acorn.tokTypes.braceL)\n  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart }\n  while (!this.closes(__acorn.tokTypes.braceR, indent, line)) {\n    if (this$1.semicolon()) continue\n    var method = this$1.startNode(), isGenerator, isAsync\n    if (this$1.options.ecmaVersion >= 6) {\n      method.static = false\n      isGenerator = this$1.eat(__acorn.tokTypes.star)\n    }\n    this$1.parsePropertyName(method)\n    if (isDummy(method.key)) { if (isDummy(this$1.parseMaybeAssign())) this$1.next(); this$1.eat(__acorn.tokTypes.comma); continue }\n    if (method.key.type === \"Identifier\" && !method.computed && method.key.name === \"static\" &&\n        (this$1.tok.type != __acorn.tokTypes.parenL && this$1.tok.type != __acorn.tokTypes.braceL)) {\n      method.static = true\n      isGenerator = this$1.eat(__acorn.tokTypes.star)\n      this$1.parsePropertyName(method)\n    } else {\n      method.static = false\n    }\n    if (!method.computed &&\n        method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.tok.type !== __acorn.tokTypes.parenL &&\n        !this$1.canInsertSemicolon()) {\n      this$1.parsePropertyName(method)\n      isAsync = true\n    } else {\n      isAsync = false\n    }\n    if (this$1.options.ecmaVersion >= 5 && method.key.type === \"Identifier\" &&\n        !method.computed && (method.key.name === \"get\" || method.key.name === \"set\") &&\n        this$1.tok.type !== __acorn.tokTypes.parenL && this$1.tok.type !== __acorn.tokTypes.braceL) {\n      method.kind = method.key.name\n      this$1.parsePropertyName(method)\n      method.value = this$1.parseMethod(false)\n    } else {\n      if (!method.computed && !method.static && !isGenerator && !isAsync && (\n        method.key.type === \"Identifier\" && method.key.name === \"constructor\" ||\n          method.key.type === \"Literal\" && method.key.value === \"constructor\")) {\n        method.kind = \"constructor\"\n      } else {\n        method.kind =  \"method\"\n      }\n      method.value = this$1.parseMethod(isGenerator, isAsync)\n    }\n    node.body.body.push(this$1.finishNode(method, \"MethodDefinition\"))\n  }\n  this.popCx()\n  if (!this.eat(__acorn.tokTypes.braceR)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start\n    if (this.options.locations) this.last.loc.end = this.tok.loc.start\n  }\n  this.semicolon()\n  this.finishNode(node.body, \"ClassBody\")\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n}\n\nlp$1.parseFunction = function(node, isStatement, isAsync) {\n  var oldInAsync = this.inAsync\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = this.eat(__acorn.tokTypes.star)\n  }\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync\n  }\n  if (isStatement == null) isStatement = this.tok.type === __acorn.tokTypes.name\n  if (this.tok.type === __acorn.tokTypes.name) node.id = this.parseIdent()\n  else if (isStatement) node.id = this.dummyIdent()\n  this.inAsync = node.async\n  node.params = this.parseFunctionParams()\n  node.body = this.parseBlock()\n  this.inAsync = oldInAsync\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n}\n\nlp$1.parseExport = function() {\n  var node = this.startNode()\n  this.next()\n  if (this.eat(__acorn.tokTypes.star)) {\n    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : this.dummyString()\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(__acorn.tokTypes._default)) {\n    // export default (function foo() {}) // This is FunctionExpression.\n    var isAsync\n    if (this.tok.type === __acorn.tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {\n      var fNode = this.startNode()\n      this.next()\n      if (isAsync) this.next()\n      node.declaration = this.parseFunction(fNode, null, isAsync)\n    } else if (this.tok.type === __acorn.tokTypes._class) {\n      node.declaration = this.parseClass(null)\n    } else {\n      node.declaration = this.parseMaybeAssign()\n      this.semicolon()\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {\n    node.declaration = this.parseStatement()\n    node.specifiers = []\n    node.source = null\n  } else {\n    node.declaration = null\n    node.specifiers = this.parseExportSpecifierList()\n    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : null\n    this.semicolon()\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n}\n\nlp$1.parseImport = function() {\n  var node = this.startNode()\n  this.next()\n  if (this.tok.type === __acorn.tokTypes.string) {\n    node.specifiers = []\n    node.source = this.parseExprAtom()\n    node.kind = ''\n  } else {\n    var elt\n    if (this.tok.type === __acorn.tokTypes.name && this.tok.value !== \"from\") {\n      elt = this.startNode()\n      elt.local = this.parseIdent()\n      this.finishNode(elt, \"ImportDefaultSpecifier\")\n      this.eat(__acorn.tokTypes.comma)\n    }\n    node.specifiers = this.parseImportSpecifierList()\n    node.source = this.eatContextual(\"from\") && this.tok.type == __acorn.tokTypes.string ? this.parseExprAtom() : this.dummyString()\n    if (elt) node.specifiers.unshift(elt)\n  }\n  this.semicolon()\n  return this.finishNode(node, \"ImportDeclaration\")\n}\n\nlp$1.parseImportSpecifierList = function() {\n  var this$1 = this;\n\n  var elts = []\n  if (this.tok.type === __acorn.tokTypes.star) {\n    var elt = this.startNode()\n    this.next()\n    elt.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent()\n    elts.push(this.finishNode(elt, \"ImportNamespaceSpecifier\"))\n  } else {\n    var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart\n    this.pushCx()\n    this.eat(__acorn.tokTypes.braceL)\n    if (this.curLineStart > continuedLine) continuedLine = this.curLineStart\n    while (!this.closes(__acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n      var elt$1 = this$1.startNode()\n      if (this$1.eat(__acorn.tokTypes.star)) {\n        elt$1.local = this$1.eatContextual(\"as\") ? this$1.parseIdent() : this$1.dummyIdent()\n        this$1.finishNode(elt$1, \"ImportNamespaceSpecifier\")\n      } else {\n        if (this$1.isContextual(\"from\")) break\n        elt$1.imported = this$1.parseIdent()\n        if (isDummy(elt$1.imported)) break\n        elt$1.local = this$1.eatContextual(\"as\") ? this$1.parseIdent() : elt$1.imported\n        this$1.finishNode(elt$1, \"ImportSpecifier\")\n      }\n      elts.push(elt$1)\n      this$1.eat(__acorn.tokTypes.comma)\n    }\n    this.eat(__acorn.tokTypes.braceR)\n    this.popCx()\n  }\n  return elts\n}\n\nlp$1.parseExportSpecifierList = function() {\n  var this$1 = this;\n\n  var elts = []\n  var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart\n  this.pushCx()\n  this.eat(__acorn.tokTypes.braceL)\n  if (this.curLineStart > continuedLine) continuedLine = this.curLineStart\n  while (!this.closes(__acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n    if (this$1.isContextual(\"from\")) break\n    var elt = this$1.startNode()\n    elt.local = this$1.parseIdent()\n    if (isDummy(elt.local)) break\n    elt.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent() : elt.local\n    this$1.finishNode(elt, \"ExportSpecifier\")\n    elts.push(elt)\n    this$1.eat(__acorn.tokTypes.comma)\n  }\n  this.eat(__acorn.tokTypes.braceR)\n  this.popCx()\n  return elts\n}\n\nvar lp$2 = LooseParser.prototype\n\nlp$2.checkLVal = function(expr) {\n  if (!expr) return expr\n  switch (expr.type) {\n  case \"Identifier\":\n  case \"MemberExpression\":\n    return expr\n\n  case \"ParenthesizedExpression\":\n    expr.expression = this.checkLVal(expr.expression)\n    return expr\n\n  default:\n    return this.dummyIdent()\n  }\n}\n\nlp$2.parseExpression = function(noIn) {\n  var this$1 = this;\n\n  var start = this.storeCurrentPos()\n  var expr = this.parseMaybeAssign(noIn)\n  if (this.tok.type === __acorn.tokTypes.comma) {\n    var node = this.startNodeAt(start)\n    node.expressions = [expr]\n    while (this.eat(__acorn.tokTypes.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\nlp$2.parseParenExpression = function() {\n  this.pushCx()\n  this.expect(__acorn.tokTypes.parenL)\n  var val = this.parseExpression()\n  this.popCx()\n  this.expect(__acorn.tokTypes.parenR)\n  return val\n}\n\nlp$2.parseMaybeAssign = function(noIn) {\n  if (this.toks.isContextual(\"yield\")) {\n    var node = this.startNode()\n    this.next()\n    if (this.semicolon() || this.canInsertSemicolon() || (this.tok.type != __acorn.tokTypes.star && !this.tok.type.startsExpr)) {\n      node.delegate = false\n      node.argument = null\n    } else {\n      node.delegate = this.eat(__acorn.tokTypes.star)\n      node.argument = this.parseMaybeAssign()\n    }\n    return this.finishNode(node, \"YieldExpression\")\n  }\n\n  var start = this.storeCurrentPos()\n  var left = this.parseMaybeConditional(noIn)\n  if (this.tok.type.isAssign) {\n    var node$1 = this.startNodeAt(start)\n    node$1.operator = this.tok.value\n    node$1.left = this.tok.type === __acorn.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left)\n    this.next()\n    node$1.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node$1, \"AssignmentExpression\")\n  }\n  return left\n}\n\nlp$2.parseMaybeConditional = function(noIn) {\n  var start = this.storeCurrentPos()\n  var expr = this.parseExprOps(noIn)\n  if (this.eat(__acorn.tokTypes.question)) {\n    var node = this.startNodeAt(start)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    node.alternate = this.expect(__acorn.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent()\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\nlp$2.parseExprOps = function(noIn) {\n  var start = this.storeCurrentPos()\n  var indent = this.curIndent, line = this.curLineStart\n  return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line)\n}\n\nlp$2.parseExprOp = function(left, start, minPrec, noIn, indent, line) {\n  if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) return left\n  var prec = this.tok.type.binop\n  if (prec != null && (!noIn || this.tok.type !== __acorn.tokTypes._in)) {\n    if (prec > minPrec) {\n      var node = this.startNodeAt(start)\n      node.left = left\n      node.operator = this.tok.value\n      this.next()\n      if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) {\n        node.right = this.dummyIdent()\n      } else {\n        var rightStart = this.storeCurrentPos()\n        node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line)\n      }\n      this.finishNode(node, /&&|\\|\\|/.test(node.operator) ? \"LogicalExpression\" : \"BinaryExpression\")\n      return this.parseExprOp(node, start, minPrec, noIn, indent, line)\n    }\n  }\n  return left\n}\n\nlp$2.parseMaybeUnary = function(sawUnary) {\n  var this$1 = this;\n\n  var start = this.storeCurrentPos(), expr\n  if (this.options.ecmaVersion >= 8 && this.inAsync && this.toks.isContextual(\"await\")) {\n    expr = this.parseAwait()\n    sawUnary = true\n  } else if (this.tok.type.prefix) {\n    var node = this.startNode(), update = this.tok.type === __acorn.tokTypes.incDec\n    if (!update) sawUnary = true\n    node.operator = this.tok.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary(true)\n    if (update) node.argument = this.checkLVal(node.argument)\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  } else if (this.tok.type === __acorn.tokTypes.ellipsis) {\n    var node$1 = this.startNode()\n    this.next()\n    node$1.argument = this.parseMaybeUnary(sawUnary)\n    expr = this.finishNode(node$1, \"SpreadElement\")\n  } else {\n    expr = this.parseExprSubscripts()\n    while (this.tok.type.postfix && !this.canInsertSemicolon()) {\n      var node$2 = this$1.startNodeAt(start)\n      node$2.operator = this$1.tok.value\n      node$2.prefix = false\n      node$2.argument = this$1.checkLVal(expr)\n      this$1.next()\n      expr = this$1.finishNode(node$2, \"UpdateExpression\")\n    }\n  }\n\n  if (!sawUnary && this.eat(__acorn.tokTypes.starstar)) {\n    var node$3 = this.startNodeAt(start)\n    node$3.operator = \"**\"\n    node$3.left = expr\n    node$3.right = this.parseMaybeUnary(false)\n    return this.finishNode(node$3, \"BinaryExpression\")\n  }\n\n  return expr\n}\n\nlp$2.parseExprSubscripts = function() {\n  var start = this.storeCurrentPos()\n  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart)\n}\n\nlp$2.parseSubscripts = function(base, start, noCalls, startIndent, line) {\n  var this$1 = this;\n\n  for (;;) {\n    if (this$1.curLineStart != line && this$1.curIndent <= startIndent && this$1.tokenStartsLine()) {\n      if (this$1.tok.type == __acorn.tokTypes.dot && this$1.curIndent == startIndent)\n        --startIndent\n      else\n        return base\n    }\n\n    var maybeAsyncArrow = base.type === \"Identifier\" && base.name === \"async\" && !this$1.canInsertSemicolon()\n\n    if (this$1.eat(__acorn.tokTypes.dot)) {\n      var node = this$1.startNodeAt(start)\n      node.object = base\n      if (this$1.curLineStart != line && this$1.curIndent <= startIndent && this$1.tokenStartsLine())\n        node.property = this$1.dummyIdent()\n      else\n        node.property = this$1.parsePropertyAccessor() || this$1.dummyIdent()\n      node.computed = false\n      base = this$1.finishNode(node, \"MemberExpression\")\n    } else if (this$1.tok.type == __acorn.tokTypes.bracketL) {\n      this$1.pushCx()\n      this$1.next()\n      var node$1 = this$1.startNodeAt(start)\n      node$1.object = base\n      node$1.property = this$1.parseExpression()\n      node$1.computed = true\n      this$1.popCx()\n      this$1.expect(__acorn.tokTypes.bracketR)\n      base = this$1.finishNode(node$1, \"MemberExpression\")\n    } else if (!noCalls && this$1.tok.type == __acorn.tokTypes.parenL) {\n      var exprList = this$1.parseExprList(__acorn.tokTypes.parenR)\n      if (maybeAsyncArrow && this$1.eat(__acorn.tokTypes.arrow))\n        return this$1.parseArrowExpression(this$1.startNodeAt(start), exprList, true)\n      var node$2 = this$1.startNodeAt(start)\n      node$2.callee = base\n      node$2.arguments = exprList\n      base = this$1.finishNode(node$2, \"CallExpression\")\n    } else if (this$1.tok.type == __acorn.tokTypes.backQuote) {\n      var node$3 = this$1.startNodeAt(start)\n      node$3.tag = base\n      node$3.quasi = this$1.parseTemplate()\n      base = this$1.finishNode(node$3, \"TaggedTemplateExpression\")\n    } else {\n      return base\n    }\n  }\n}\n\nlp$2.parseExprAtom = function() {\n  var node\n  switch (this.tok.type) {\n  case __acorn.tokTypes._this:\n  case __acorn.tokTypes._super:\n    var type = this.tok.type === __acorn.tokTypes._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case __acorn.tokTypes.name:\n    var start = this.storeCurrentPos()\n    var id = this.parseIdent()\n    var isAsync = false\n    if (id.name === \"async\" && !this.canInsertSemicolon()) {\n      if (this.eat(__acorn.tokTypes._function))\n        return this.parseFunction(this.startNodeAt(start), false, true)\n      if (this.tok.type === __acorn.tokTypes.name) {\n        id = this.parseIdent()\n        isAsync = true\n      }\n    }\n    return this.eat(__acorn.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id\n\n  case __acorn.tokTypes.regexp:\n    node = this.startNode()\n    var val = this.tok.value\n    node.regex = {pattern: val.pattern, flags: val.flags}\n    node.value = val.value\n    node.raw = this.input.slice(this.tok.start, this.tok.end)\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case __acorn.tokTypes.num: case __acorn.tokTypes.string:\n    node = this.startNode()\n    node.value = this.tok.value\n    node.raw = this.input.slice(this.tok.start, this.tok.end)\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case __acorn.tokTypes._null: case __acorn.tokTypes._true: case __acorn.tokTypes._false:\n    node = this.startNode()\n    node.value = this.tok.type === __acorn.tokTypes._null ? null : this.tok.type === __acorn.tokTypes._true\n    node.raw = this.tok.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case __acorn.tokTypes.parenL:\n    var parenStart = this.storeCurrentPos()\n    this.next()\n    var inner = this.parseExpression()\n    this.expect(__acorn.tokTypes.parenR)\n    if (this.eat(__acorn.tokTypes.arrow)) {\n      // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.\n      var params = inner.expressions || [inner]\n      if (params.length && isDummy(params[params.length - 1]))\n        params.pop()\n      return this.parseArrowExpression(this.startNodeAt(parenStart), params)\n    }\n    if (this.options.preserveParens) {\n      var par = this.startNodeAt(parenStart)\n      par.expression = inner\n      inner = this.finishNode(par, \"ParenthesizedExpression\")\n    }\n    return inner\n\n  case __acorn.tokTypes.bracketL:\n    node = this.startNode()\n    node.elements = this.parseExprList(__acorn.tokTypes.bracketR, true)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case __acorn.tokTypes.braceL:\n    return this.parseObj()\n\n  case __acorn.tokTypes._class:\n    return this.parseClass(false)\n\n  case __acorn.tokTypes._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case __acorn.tokTypes._new:\n    return this.parseNew()\n\n  case __acorn.tokTypes.backQuote:\n    return this.parseTemplate()\n\n  default:\n    return this.dummyIdent()\n  }\n}\n\nlp$2.parseNew = function() {\n  var node = this.startNode(), startIndent = this.curIndent, line = this.curLineStart\n  var meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(__acorn.tokTypes.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var start = this.storeCurrentPos()\n  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line)\n  if (this.tok.type == __acorn.tokTypes.parenL) {\n    node.arguments = this.parseExprList(__acorn.tokTypes.parenR)\n  } else {\n    node.arguments = []\n  }\n  return this.finishNode(node, \"NewExpression\")\n}\n\nlp$2.parseTemplateElement = function() {\n  var elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.tok.start, this.tok.end).replace(/\\r\\n?/g, '\\n'),\n    cooked: this.tok.value\n  }\n  this.next()\n  elem.tail = this.tok.type === __acorn.tokTypes.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\nlp$2.parseTemplate = function() {\n  var this$1 = this;\n\n  var node = this.startNode()\n  this.next()\n  node.expressions = []\n  var curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this$1.next()\n    node.expressions.push(this$1.parseExpression())\n    if (this$1.expect(__acorn.tokTypes.braceR)) {\n      curElt = this$1.parseTemplateElement()\n    } else {\n      curElt = this$1.startNode()\n      curElt.value = {cooked: '', raw: ''}\n      curElt.tail = true\n      this$1.finishNode(curElt, \"TemplateElement\")\n    }\n    node.quasis.push(curElt)\n  }\n  this.expect(__acorn.tokTypes.backQuote)\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\nlp$2.parseObj = function() {\n  var this$1 = this;\n\n  var node = this.startNode()\n  node.properties = []\n  this.pushCx()\n  var indent = this.curIndent + 1, line = this.curLineStart\n  this.eat(__acorn.tokTypes.braceL)\n  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart }\n  while (!this.closes(__acorn.tokTypes.braceR, indent, line)) {\n    var prop = this$1.startNode(), isGenerator, isAsync, start\n    if (this$1.options.ecmaVersion >= 6) {\n      start = this$1.storeCurrentPos()\n      prop.method = false\n      prop.shorthand = false\n      isGenerator = this$1.eat(__acorn.tokTypes.star)\n    }\n    this$1.parsePropertyName(prop)\n    if (!prop.computed &&\n        prop.key.type === \"Identifier\" && prop.key.name === \"async\" && this$1.tok.type !== __acorn.tokTypes.parenL &&\n        this$1.tok.type !== __acorn.tokTypes.colon && !this$1.canInsertSemicolon()) {\n      this$1.parsePropertyName(prop)\n      isAsync = true\n    } else {\n      isAsync = false\n    }\n    if (isDummy(prop.key)) { if (isDummy(this$1.parseMaybeAssign())) this$1.next(); this$1.eat(__acorn.tokTypes.comma); continue }\n    if (this$1.eat(__acorn.tokTypes.colon)) {\n      prop.kind = \"init\"\n      prop.value = this$1.parseMaybeAssign()\n    } else if (this$1.options.ecmaVersion >= 6 && (this$1.tok.type === __acorn.tokTypes.parenL || this$1.tok.type === __acorn.tokTypes.braceL)) {\n      prop.kind = \"init\"\n      prop.method = true\n      prop.value = this$1.parseMethod(isGenerator, isAsync)\n    } else if (this$1.options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n               !prop.computed && (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this$1.tok.type != __acorn.tokTypes.comma && this$1.tok.type != __acorn.tokTypes.braceR)) {\n      prop.kind = prop.key.name\n      this$1.parsePropertyName(prop)\n      prop.value = this$1.parseMethod(false)\n    } else {\n      prop.kind = \"init\"\n      if (this$1.options.ecmaVersion >= 6) {\n        if (this$1.eat(__acorn.tokTypes.eq)) {\n          var assign = this$1.startNodeAt(start)\n          assign.operator = \"=\"\n          assign.left = prop.key\n          assign.right = this$1.parseMaybeAssign()\n          prop.value = this$1.finishNode(assign, \"AssignmentExpression\")\n        } else {\n          prop.value = prop.key\n        }\n      } else {\n        prop.value = this$1.dummyIdent()\n      }\n      prop.shorthand = true\n    }\n    node.properties.push(this$1.finishNode(prop, \"Property\"))\n    this$1.eat(__acorn.tokTypes.comma)\n  }\n  this.popCx()\n  if (!this.eat(__acorn.tokTypes.braceR)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start\n    if (this.options.locations) this.last.loc.end = this.tok.loc.start\n  }\n  return this.finishNode(node, \"ObjectExpression\")\n}\n\nlp$2.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(__acorn.tokTypes.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseExpression()\n      this.expect(__acorn.tokTypes.bracketR)\n      return\n    } else {\n      prop.computed = false\n    }\n  }\n  var key = (this.tok.type === __acorn.tokTypes.num || this.tok.type === __acorn.tokTypes.string) ? this.parseExprAtom() : this.parseIdent()\n  prop.key = key || this.dummyIdent()\n}\n\nlp$2.parsePropertyAccessor = function() {\n  if (this.tok.type === __acorn.tokTypes.name || this.tok.type.keyword) return this.parseIdent()\n}\n\nlp$2.parseIdent = function() {\n  var name = this.tok.type === __acorn.tokTypes.name ? this.tok.value : this.tok.type.keyword\n  if (!name) return this.dummyIdent()\n  var node = this.startNode()\n  this.next()\n  node.name = name\n  return this.finishNode(node, \"Identifier\")\n}\n\nlp$2.initFunction = function(node) {\n  node.id = null\n  node.params = []\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n  if (this.options.ecmaVersion >= 8)\n    node.async = false\n}\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\nlp$2.toAssignable = function(node, binding) {\n  var this$1 = this;\n\n  if (!node || node.type == \"Identifier\" || (node.type == \"MemberExpression\" && !binding)) {\n    // Okay\n  } else if (node.type == \"ParenthesizedExpression\") {\n    node.expression = this.toAssignable(node.expression, binding)\n  } else if (this.options.ecmaVersion < 6) {\n    return this.dummyIdent()\n  } else if (node.type == \"ObjectExpression\") {\n    node.type = \"ObjectPattern\"\n    var props = node.properties\n    for (var i = 0; i < props.length; i++)\n      props[i].value = this$1.toAssignable(props[i].value, binding)\n  } else if (node.type == \"ArrayExpression\") {\n    node.type = \"ArrayPattern\"\n    this.toAssignableList(node.elements, binding)\n  } else if (node.type == \"SpreadElement\") {\n    node.type = \"RestElement\"\n    node.argument = this.toAssignable(node.argument, binding)\n  } else if (node.type == \"AssignmentExpression\") {\n    node.type = \"AssignmentPattern\"\n    delete node.operator\n  } else {\n    return this.dummyIdent()\n  }\n  return node\n}\n\nlp$2.toAssignableList = function(exprList, binding) {\n  var this$1 = this;\n\n  for (var i = 0; i < exprList.length; i++)\n    exprList[i] = this$1.toAssignable(exprList[i], binding)\n  return exprList\n}\n\nlp$2.parseFunctionParams = function(params) {\n  params = this.parseExprList(__acorn.tokTypes.parenR)\n  return this.toAssignableList(params, true)\n}\n\nlp$2.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInAsync = this.inAsync\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = !!isGenerator\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n  this.inAsync = node.async\n  node.params = this.parseFunctionParams()\n  node.expression = this.options.ecmaVersion >= 6 && this.tok.type !== __acorn.tokTypes.braceL\n  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock()\n  this.inAsync = oldInAsync\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\nlp$2.parseArrowExpression = function(node, params, isAsync) {\n  var oldInAsync = this.inAsync\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n  this.inAsync = node.async\n  node.params = this.toAssignableList(params, true)\n  node.expression = this.tok.type !== __acorn.tokTypes.braceL\n  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock()\n  this.inAsync = oldInAsync\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\nlp$2.parseExprList = function(close, allowEmpty) {\n  var this$1 = this;\n\n  this.pushCx()\n  var indent = this.curIndent, line = this.curLineStart, elts = []\n  this.next() // Opening bracket\n  while (!this.closes(close, indent + 1, line)) {\n    if (this$1.eat(__acorn.tokTypes.comma)) {\n      elts.push(allowEmpty ? null : this$1.dummyIdent())\n      continue\n    }\n    var elt = this$1.parseMaybeAssign()\n    if (isDummy(elt)) {\n      if (this$1.closes(close, indent, line)) break\n      this$1.next()\n    } else {\n      elts.push(elt)\n    }\n    this$1.eat(__acorn.tokTypes.comma)\n  }\n  this.popCx()\n  if (!this.eat(close)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start\n    if (this.options.locations) this.last.loc.end = this.tok.loc.start\n  }\n  return elts\n}\n\nlp$2.parseAwait = function() {\n  var node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeUnary()\n  return this.finishNode(node, \"AwaitExpression\")\n}\n\n// Acorn: Loose parser\n//\n// This module provides an alternative parser (`parse_dammit`) that\n// exposes that same interface as `parse`, but will try to parse\n// anything as JavaScript, repairing syntax error the best it can.\n// There are circumstances in which it will raise an error and give\n// up, but they are very rare. The resulting AST will be a mostly\n// valid JavaScript AST (as per the [Mozilla parser API][api], except\n// that:\n//\n// - Return outside functions is allowed\n//\n// - Label consistency (no conflicts, break only to existing labels)\n//   is not enforced.\n//\n// - Bogus Identifier nodes with a name of `\"✖\"` are inserted whenever\n//   the parser got too confused to return anything meaningful.\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n//\n// The expected use for this is to *first* try `acorn.parse`, and only\n// if that fails switch to `parse_dammit`. The loose parser might\n// parse badly indented code incorrectly, so **don't** use it as\n// your default parser.\n//\n// Quite a lot of acorn.js is duplicated here. The alternative was to\n// add a *lot* of extra cruft to that file, making it less readable\n// and slower. Copying and editing the code allowed me to make\n// invasive changes and simplifications without creating a complicated\n// tangle.\n\n__acorn.defaultOptions.tabSize = 4\n\nfunction parse_dammit(input, options) {\n  var p = new LooseParser(input, options)\n  p.next()\n  return p.parseTopLevel()\n}\n\n__acorn.addLooseExports(parse_dammit, LooseParser, pluginsLoose)\n\nexports.parse_dammit = parse_dammit;\nexports.LooseParser = LooseParser;\nexports.pluginsLoose = pluginsLoose;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.acorn = global.acorn || {}, global.acorn.walk = global.acorn.walk || {})));\n}(this, (function (exports) { 'use strict';\n\n// AST walker module for Mozilla Parser API compatible trees\n\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All Parser API node types\n// can be used to identify node types, as well as Expression,\n// Statement, and ScopeBody, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\n\nfunction simple(node, visitors, base, state, override) {\n  if (!base) base = exports.base\n  ;(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type]\n    base[type](node, st, c)\n    if (found) found(node, st)\n  })(node, state, override)\n}\n\n// An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callback as third parameter\n// (and also as state parameter when no other state is present).\nfunction ancestor(node, visitors, base, state) {\n  if (!base) base = exports.base\n  var ancestors = []\n  ;(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type]\n    var isNew = node != ancestors[ancestors.length - 1]\n    if (isNew) ancestors.push(node)\n    base[type](node, st, c)\n    if (found) found(node, st || ancestors, ancestors)\n    if (isNew) ancestors.pop()\n  })(node, state)\n}\n\n// A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\nfunction recursive(node, state, funcs, base, override) {\n  var visitor = funcs ? exports.make(funcs, base) : base\n  ;(function c(node, st, override) {\n    visitor[override || node.type](node, st, c)\n  })(node, state, override)\n}\n\nfunction makeTest(test) {\n  if (typeof test == \"string\")\n    return function (type) { return type == test; }\n  else if (!test)\n    return function () { return true; }\n  else\n    return test\n}\n\nvar Found = function Found(node, state) { this.node = node; this.state = state };\n\n// Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\nfunction findNodeAt(node, start, end, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  try {\n    ;(function c(node, st, override) {\n      var type = override || node.type\n      if ((start == null || node.start <= start) &&\n          (end == null || node.end >= end))\n        base[type](node, st, c)\n      if ((start == null || node.start == start) &&\n          (end == null || node.end == end) &&\n          test(type, node))\n        throw new Found(node, st)\n    })(node, state)\n  } catch (e) {\n    if (e instanceof Found) return e\n    throw e\n  }\n}\n\n// Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\nfunction findNodeAround(node, pos, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  try {\n    ;(function c(node, st, override) {\n      var type = override || node.type\n      if (node.start > pos || node.end < pos) return\n      base[type](node, st, c)\n      if (test(type, node)) throw new Found(node, st)\n    })(node, state)\n  } catch (e) {\n    if (e instanceof Found) return e\n    throw e\n  }\n}\n\n// Find the outermost matching node after a given position.\nfunction findNodeAfter(node, pos, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  try {\n    ;(function c(node, st, override) {\n      if (node.end < pos) return\n      var type = override || node.type\n      if (node.start >= pos && test(type, node)) throw new Found(node, st)\n      base[type](node, st, c)\n    })(node, state)\n  } catch (e) {\n    if (e instanceof Found) return e\n    throw e\n  }\n}\n\n// Find the outermost matching node before a given position.\nfunction findNodeBefore(node, pos, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  var max\n  ;(function c(node, st, override) {\n    if (node.start > pos) return\n    var type = override || node.type\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n      max = new Found(node, st)\n    base[type](node, st, c)\n  })(node, state)\n  return max\n}\n\n// Fallback to an Object.create polyfill for older environments.\nvar create = Object.create || function(proto) {\n  function Ctor() {}\n  Ctor.prototype = proto\n  return new Ctor\n}\n\n// Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\nfunction make(funcs, base) {\n  if (!base) base = exports.base\n  var visitor = create(base)\n  for (var type in funcs) visitor[type] = funcs[type]\n  return visitor\n}\n\nfunction skipThrough(node, st, c) { c(node, st) }\nfunction ignore(_node, _st, _c) {}\n\n// Node walkers.\n\nvar base = {}\n\nbase.Program = base.BlockStatement = function (node, st, c) {\n  for (var i = 0; i < node.body.length; ++i)\n    c(node.body[i], st, \"Statement\")\n}\nbase.Statement = skipThrough\nbase.EmptyStatement = ignore\nbase.ExpressionStatement = base.ParenthesizedExpression =\n  function (node, st, c) { return c(node.expression, st, \"Expression\"); }\nbase.IfStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\")\n  c(node.consequent, st, \"Statement\")\n  if (node.alternate) c(node.alternate, st, \"Statement\")\n}\nbase.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); }\nbase.BreakStatement = base.ContinueStatement = ignore\nbase.WithStatement = function (node, st, c) {\n  c(node.object, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.SwitchStatement = function (node, st, c) {\n  c(node.discriminant, st, \"Expression\")\n  for (var i = 0; i < node.cases.length; ++i) {\n    var cs = node.cases[i]\n    if (cs.test) c(cs.test, st, \"Expression\")\n    for (var j = 0; j < cs.consequent.length; ++j)\n      c(cs.consequent[j], st, \"Statement\")\n  }\n}\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n  if (node.argument) c(node.argument, st, \"Expression\")\n}\nbase.ThrowStatement = base.SpreadElement =\n  function (node, st, c) { return c(node.argument, st, \"Expression\"); }\nbase.TryStatement = function (node, st, c) {\n  c(node.block, st, \"Statement\")\n  if (node.handler) c(node.handler, st)\n  if (node.finalizer) c(node.finalizer, st, \"Statement\")\n}\nbase.CatchClause = function (node, st, c) {\n  c(node.param, st, \"Pattern\")\n  c(node.body, st, \"ScopeBody\")\n}\nbase.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.ForStatement = function (node, st, c) {\n  if (node.init) c(node.init, st, \"ForInit\")\n  if (node.test) c(node.test, st, \"Expression\")\n  if (node.update) c(node.update, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.ForInStatement = base.ForOfStatement = function (node, st, c) {\n  c(node.left, st, \"ForInit\")\n  c(node.right, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.ForInit = function (node, st, c) {\n  if (node.type == \"VariableDeclaration\") c(node, st)\n  else c(node, st, \"Expression\")\n}\nbase.DebuggerStatement = ignore\n\nbase.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); }\nbase.VariableDeclaration = function (node, st, c) {\n  for (var i = 0; i < node.declarations.length; ++i)\n    c(node.declarations[i], st)\n}\nbase.VariableDeclarator = function (node, st, c) {\n  c(node.id, st, \"Pattern\")\n  if (node.init) c(node.init, st, \"Expression\")\n}\n\nbase.Function = function (node, st, c) {\n  if (node.id) c(node.id, st, \"Pattern\")\n  for (var i = 0; i < node.params.length; i++)\n    c(node.params[i], st, \"Pattern\")\n  c(node.body, st, node.expression ? \"ScopeExpression\" : \"ScopeBody\")\n}\n// FIXME drop these node types in next major version\n// (They are awkward, and in ES6 every block can be a scope.)\nbase.ScopeBody = function (node, st, c) { return c(node, st, \"Statement\"); }\nbase.ScopeExpression = function (node, st, c) { return c(node, st, \"Expression\"); }\n\nbase.Pattern = function (node, st, c) {\n  if (node.type == \"Identifier\")\n    c(node, st, \"VariablePattern\")\n  else if (node.type == \"MemberExpression\")\n    c(node, st, \"MemberPattern\")\n  else\n    c(node, st)\n}\nbase.VariablePattern = ignore\nbase.MemberPattern = skipThrough\nbase.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); }\nbase.ArrayPattern =  function (node, st, c) {\n  for (var i = 0; i < node.elements.length; ++i) {\n    var elt = node.elements[i]\n    if (elt) c(elt, st, \"Pattern\")\n  }\n}\nbase.ObjectPattern = function (node, st, c) {\n  for (var i = 0; i < node.properties.length; ++i)\n    c(node.properties[i].value, st, \"Pattern\")\n}\n\nbase.Expression = skipThrough\nbase.ThisExpression = base.Super = base.MetaProperty = ignore\nbase.ArrayExpression = function (node, st, c) {\n  for (var i = 0; i < node.elements.length; ++i) {\n    var elt = node.elements[i]\n    if (elt) c(elt, st, \"Expression\")\n  }\n}\nbase.ObjectExpression = function (node, st, c) {\n  for (var i = 0; i < node.properties.length; ++i)\n    c(node.properties[i], st)\n}\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration\nbase.SequenceExpression = base.TemplateLiteral = function (node, st, c) {\n  for (var i = 0; i < node.expressions.length; ++i)\n    c(node.expressions[i], st, \"Expression\")\n}\nbase.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n  c(node.argument, st, \"Expression\")\n}\nbase.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n  c(node.left, st, \"Expression\")\n  c(node.right, st, \"Expression\")\n}\nbase.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n  c(node.left, st, \"Pattern\")\n  c(node.right, st, \"Expression\")\n}\nbase.ConditionalExpression = function (node, st, c) {\n  c(node.test, st, \"Expression\")\n  c(node.consequent, st, \"Expression\")\n  c(node.alternate, st, \"Expression\")\n}\nbase.NewExpression = base.CallExpression = function (node, st, c) {\n  c(node.callee, st, \"Expression\")\n  if (node.arguments) for (var i = 0; i < node.arguments.length; ++i)\n    c(node.arguments[i], st, \"Expression\")\n}\nbase.MemberExpression = function (node, st, c) {\n  c(node.object, st, \"Expression\")\n  if (node.computed) c(node.property, st, \"Expression\")\n}\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n  if (node.declaration)\n    c(node.declaration, st, node.type == \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\")\n  if (node.source) c(node.source, st, \"Expression\")\n}\nbase.ExportAllDeclaration = function (node, st, c) {\n  c(node.source, st, \"Expression\")\n}\nbase.ImportDeclaration = function (node, st, c) {\n  for (var i = 0; i < node.specifiers.length; i++)\n    c(node.specifiers[i], st)\n  c(node.source, st, \"Expression\")\n}\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore\n\nbase.TaggedTemplateExpression = function (node, st, c) {\n  c(node.tag, st, \"Expression\")\n  c(node.quasi, st)\n}\nbase.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); }\nbase.Class = function (node, st, c) {\n  if (node.id) c(node.id, st, \"Pattern\")\n  if (node.superClass) c(node.superClass, st, \"Expression\")\n  for (var i = 0; i < node.body.body.length; i++)\n    c(node.body.body[i], st)\n}\nbase.MethodDefinition = base.Property = function (node, st, c) {\n  if (node.computed) c(node.key, st, \"Expression\")\n  c(node.value, st, \"Expression\")\n}\n\nexports.simple = simple;\nexports.ancestor = ancestor;\nexports.recursive = recursive;\nexports.findNodeAt = findNodeAt;\nexports.findNodeAround = findNodeAround;\nexports.findNodeAfter = findNodeAfter;\nexports.findNodeBefore = findNodeBefore;\nexports.make = make;\nexports.base = base;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}"],"names":["mod","exports","infer","hop","obj","prop","Object","prototype","hasOwnProperty","call","TypeParser","spec","start","base","forceNew","this","pos","unwrapType","type","self","args","extractProp","retval","rv","AVal","propagate","IsCallee","ANull","getProp","addArgCallEffects","Fn","i","length","arg","addArgCallEffect","argNum","addEffect","_self","cx","topScope","parseType","name","types","forEach","fn","handler","replaceRet","oldCmp","computeRet","argNodes","handled","old","eat","str","charAt","indexOf","word","re","ch","test","error","Error","parseFnType","comp","top","generator","retType","computeRetStart","names","computed","argname","colon","slice","push","argType","retStart","cArgs","realArgs","computedFunc","computeRetSource","main","parseTypeMaybeProp","next","union","maxWeight","computedUnion","result","parseTypeInner","extendWithProp","propName","apply","gen","inner","Arr","map","tp","computedTuple","computedArray","propType","Obj","defProp","addType","computedObject","path","localDefs","parsePath","proto","descendProps","getObjType","parsePoly","hasCtor","getInstance","getSymbol","Number","fname","customFunctions","fromWord","num","bool","match","value","instance","currentTopScope","parseEffect","effect","m","origin","p","target","andRet","getCallee","getSelf","getArgs","callee","slf","as","customFunc","getFrom","getTo","from","to","forAllProps","val","local","DefProp","scope","cached","paths","origPath","split","parts","getFunctionType","getType","hasProp","propVal","isEmpty","emptyObj","ctor","empty","create","props","isShell","isSimpleAnnotation","passOne","protos","charCodeAt","passTwo","effects","doc","url","span","metaData","copyInfo","known","innerPath","load","data","oldScope","server","parent","addOrigin","curOrigin","origins","definitions","signal","def","doLoadEnvironment","parse","registerFunction","f","IsCreated","constraint","construct","created","derived","cur","vtp","PropSpec","connect","IsBound","argNames","Math","min","makePromise","defs","ecmascript","arr","hasType","content","valProp","valArg","exec","reject","Promise_reject","PromiseResolvesTo","output","constructor","ty","_val","_args","init","acorn","acorn_loose","walk","toString","maxDepth","mixin","getSymbolType","gatherProperties","propagatesTo","typeHint","propHint","extend","forward","similarAVal","a","b","depth","typeA","typeB","similarType","propsA","propsB","same","max","every","innerA","innerB","weight","withWorklist","add","Type","Muffle","ignoredProp","found","GetProp","c","ForAllProps","seen","Sym","guess","makeupType","canonicalType","simplified","simplifyTypes","join","makeupPropType","propertyName","protoProp","fromProto","computedProp","propertyOf","hint","guessing","foundProp","completingProperty","objs","objsWithProp","matches","search","canon","guessProperties","guessed","outer","j","similar","arrays","fns","prim","Prim","maxScore","maxTp","score","methods","arguments","pathExt","PropHasSubset","originNode","disabled","disabledComputing","isArrowFn","compute","d","prev","maybeIterator","HasMethodCall","IsCtor","noReuse","options","reuseInstances","IsProto","instances","o","_weight","count","Array","FnPrototype","adder","SpeculativeThis","_prop","IsAdded","other","IfObj","t","HasProto","replaceProto","w","isInteger","c0","maybeProps","etc","sort","searchProto","normalizeIntegerProp","av","maybeUnregProtoPropHandler","broadcastProp","ensureMaybeProps","_","Scope","registerProp","onNewProp","h","onProtoProp","_local","maybe","unregPropHandler","removeProp","_n","splice","geckoIterators","StopIteration","Function","contentType","isArray","tuple","String","Symbol","symName","asPropName","cleanName","replace","symbols","Context","purgeGen","workList","curSuperCtor","curSuper","withContext","RegExp","Boolean","startAnalysis","timeout","list","ret","Date","TimedOut","withSuper","oldCtor","oldObj","context","message","stack","withTimeout","ms","end","oldEnd","isBlock","isCatch","functionScope","arrow","fnType","maybeInstantiate","instantiateScore","defVar","s","NotSmaller","maybeTagAsInstantiated","node","n","simple","Expression","e","nodeSmallerThan","body","withDisabledComputing","oldOrigin","scopeCopy","v","argset","recursive","scopeGatherer","inferWrapper","setFunctionInstantiated","maybeTagAsGeneric","targetInner","asArray","foundPath","explore","parsed","aval","dest","newPath","addVar","nameNode","patternName","left","properties","elements","argument","isBlockScopedDecl","kind","patternScopes","make","VariablePattern","scopes","AssignmentPattern","right","AssignmentExpression","MemberPattern","argVals","params","param","id","expression","BlockStatement","some","CatchClause","ecma","VariableDeclaration","targetScope","declarations","decl","ClassDeclaration","superClass","ForInStatement","ForStatement","ImportDeclaration","specifiers","rmScope","ForOfStatement","scopeClearer","ForInStateMent","clearScopes","ast","inferInScope","key","property","symbolName","sym","unopResultType","op","binopIsBoolean","literalType","regex","connectParams","connectPattern","ensureVar","inferPatternVisitor","Identifier","source","MemberExpression","object","pName","RestElement","ObjectPattern","ArrayPattern","joined","connecter","getThis","fnScope","maybeAddPhantomObj","inferClass","supCtor","delayed","sup","supProto","supVal","objType","inst","method","static","initializer","methodFn","arrayLiteralType","litType","homogenous","elt","eltVal","out","r","fill","inferExprVisitor","ArrayExpression","ObjectExpression","waitForProto","protoVal","FunctionExpression","ClassExpression","SequenceExpression","l","expressions","UnaryExpression","operator","UpdateExpression","BinaryExpression","lhs","rhs","over","iteratesOver","fromRight","LogicalExpression","ConditionalExpression","consequent","alternate","NewExpression","CallExpression","outerFn","superType","knownFn","wg","ThisExpression","_node","Super","Literal","TemplateLiteral","TaggedTemplateExpression","quasi","tag","YieldExpression","yieldval","delegate","loopPattern","ArrowFunctionExpression","FunctionDeclaration","Statement","ReturnStatement","pattern","text","thirdArg","parse_dammit","generatorResult","input","retObj","generator_prototype","computeReturnType","funcNode","findType","analyze","purge","makePredicate","typeFinder","propN","findByPropertyName","MethodDefinition","finder","searchVisitor","_st","Property","st","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","fullVisitor","findExpressionAt","defaultScope","filter","_t","findNodeAt","findExpressionAround","findNodeAround","expressionType","state","parentNode","child","override","pop","findTypeFromContext","get","calleeType","_parent","fnNode","sourceFile","VariableDeclarator","typeFromContext","fromContext","resetGuessing","didGuess","forAllPropertiesOf","findRefs","baseScope","refScope","handleId","ancestors","ancestor","simpleWalker","_scope","findPropRefs","isObjTypeProto","scopeAt","forAllLocalsAt","require","on","handlers","_handlers","off","noHandlers","getHandlers","emitter","a1","a2","a3","a4","signalReturnFirst","hasHandler","plugins","registerPlugin","defaultOptions","debug","async","getFile","_f","normalizeFilename","fetchTimeout","dependencyBudget","stripCRs","ecmaVersion","projectDir","queryTypes","completions","takesFile","run","srv","query","file","ternError","fromPlugin","wordStart","resolvePos","wordEnd","isIdentifierChar","expandWordForward","ignoreObj","hookname","isKey","gather","addInfo","objLit","omitObjectPrototype","caseInsensitive","toLowerCase","addCompletion","memberExpr","exprAt","exprNode","inLiteral","outputPos","objProp","pointInProp","pathStart","includeKeywords","jsKeywordsES6","jsKeywords","kw","rec","isKeyword","compareCompletions","isProperty","isObjectKey","prefix","exprName","expr","findExpr","findExprType","exprType","preferFunction","storeTypeDocs","clean","documentation","parseDoc","definition","getSpan","spanFile","fileMap","cxStart","contextOffset","storeSpan","refs","fullFile","findExprOrThrow","findRefsToVariable","findRefsToProperty","k","rename","newName","files","changes","use","isShorthand","File","lineOffsets","parseFile","directSourceFile","allowReturnOutsideFunction","allowImportExportEverywhere","allowHashBang","defineQueryType","desc","asLineChar","astral","updateText","hasAstral","analyzeFile","ensureFile","findFile","needsPurge","parentDepth","excluded","startAsyncAction","err","finishAsyncAction","waitOnFetch","timeBudget","done","clearTimeout","analyzeAll","setTimeout","pending","fetchError","toAnalyze","chargeOnBudget","startTime","scopeDepth","msg","bName","budgetName","size","astSize","budgets","isPosition","line","forwardCharacters","chars","lastIndex","index","Server","plugin","uses","asyncError","loadPlugin","reset","addFile","delFile","request","inv","offset","offsetLines","invalidDoc","queryType","localFiles","isRef","inObject","atFunction","realFile","backing","firstLine","foundPos","near","closest","abs","findMatchingPosition","lastIndexOf","objNode","cut","white","scopeStart","scopeEnd","tieTogether","newInner","fOld","fNew","resolveFile","console","doRequest","flush","addDefs","toFront","unshift","deleteDefs","loadFirst","passes","norm","tolerant","lineStart","offsets","curLine","storePos","floor","findLineStart","charDistanceBetween","diff","eol","lineCharPositions","maybeSet","aUp","point","curProp","concat","typeInfo","docs","urls","wrapAsObjs","depths","findQueryExpr","wide","variable","around","inBody","ensureObj","typeHandlers","fromCx","fromLocal","docFormat","parabreak","sentenceEnd","boring","isRename","storeRef","scopeHere","exists","onlySourceFile","version","reservedWords","strict","strictBind","ecma5AndLessKeywords","keywords","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","code","set","isIdentifierStart","fromCharCode","TokenType","label","conf","keyword","beforeExpr","startsExpr","isLoop","isAssign","postfix","binop","updateContext","prec","keywordTypes","tt","regexp","string","eof","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","dot","question","template","ellipsis","backQuote","dollarBraceL","eq","assign","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","starstar","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","lineBreak","lineBreakG","isNewLine","nonASCIIwhitespace","skipWhiteSpace","has","Position","col","column","SourceLocation","getLineInfo","sourceType","onInsertedSemicolon","onTrailingComma","allowReserved","locations","onToken","onComment","ranges","program","preserveParens","getOptions","opts","opt","tokens","token","pushComment","array","block","startLoc","endLoc","comment","loc","range","keywordRegexp","words","Parser","startPos","reserved","reservedStrict","reservedWordsStrict","reservedWordsStrictBind","containsEsc","loadPlugins","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","inFunction","inGenerator","inAsync","yieldPos","awaitPos","labels","skipLineComment","isReservedWord","pluginConfigs","this$1","startNode","nextToken","parseTopLevel","pp","literal","isContextual","eatContextual","expectContextual","unexpected","canInsertSemicolon","insertSemicolon","semicolon","afterTrailingComma","tokType","notNext","expect","raise","DestructuringErrors","shorthandAssign","trailingComma","parenthesizedAssign","parenthesizedBind","checkPatternErrors","refDestructuringErrors","raiseRecoverable","parens","checkExpressionErrors","andThrow","checkYieldAwaitInDefaultParams","isSimpleAssignTarget","pp$1","stmt","parseStatement","finishNode","loopLabel","switchLabel","isLet","skip","nextCh","ident","isAsyncFunction","declaration","topLevel","starttype","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseFunctionStatement","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","parseImport","parseExport","maybeName","parseExpression","parseLabeledStatement","parseExpressionStatement","isBreak","parseIdent","lab","parseParenExpression","parseFor","init$1","parseVar","parseForIn","toAssignable","checkLVal","isAsync","parseFunction","isFunction","discriminant","cases","sawDefault","isCase","clause","parseBindingAtom","finalizer","i$1","statementStart","update","isFor","parseVarId","parseMaybeAssign","isStatement","allowExpressionBody","initFunction","oldInGen","oldInAsync","oldYieldPos","oldAwaitPos","oldInFunc","parseFunctionParams","parseFunctionBody","parseBindingList","parseClassId","parseClassSuper","classBody","hadConstructor","isGenerator","isMaybeStatic","parsePropertyName","isGetSet","parseClassMethod","paramCount","parseMethod","parseExprSubscripts","parseExprAtom","checkExport","fNode","cNode","shouldParseExportStatement","checkVariableExport","parseExportSpecifiers","checkPatternExport","pat","decls","nodes","first","exported","parseImportSpecifiers","node$1","node$2","imported","pp$2","isBinding","toAssignableList","exprList","last","parseSpread","parseRest","allowNonIdent","parseObj","close","allowEmpty","allowTrailingComma","elts","rest","parseBindingListItem","elem","parseMaybeDefault","startNodeAt","checkClashes","pp$3","checkPropClash","propHash","shorthand","noIn","afterLeftParse","parseYield","ownDestructuringErrors","oldParenAssign","parseMaybeConditional","parseExprOps","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","logical","buildBinary","sawUnary","parseAwait","skipArrowSubscripts","parseSubscripts","noCalls","maybeAsyncArrow","parseExprList","parseArrowExpression","parseTemplate","canBeArrow","parseLiteral","flags","raw","parseParenAndDistinguishExpression","parseNew","spreadStart","innerParenStart","innerStartPos","innerStartLoc","lastIsComma","parseParenItem","innerEndPos","innerEndLoc","parseParenArrowList","finishNodeAt","par","item","empty$1","meta","parseTemplateElement","cooked","tail","curElt","quasis","isPattern","parsePropertyValue","isArrowFunction","isExpression","oldStrict","useStrict","nonSimple","isSimpleParamList","oldLabels","checkParams","nameHash","liberal","pp$4","SyntaxError","raisedAt","Node","parser","pp$5","TokContext","isExpr","preserveSpace","b_stat","b_expr","b_tmpl","p_stat","p_expr","q_tmpl","readTmplToken","f_expr","pp$6","braceIsBlock","prevType","curContext","statementParens","Token","pp$7","isRhino","Packages","tryCreateRegexp","src","throwErrorAt","undefined","getToken","iterator","skipSpace","finishToken","readToken","fullCharCodeAtPos","readWord","getTokenFromCode","skipBlockComment","startSkip","loop","readToken_dot","readNumber","next2","readToken_slash","readRegexp","finishOp","readToken_mult_modulo_exp","tokentype","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readRadixNumber","readString","codePointToString","regexpUnicodeSupport","escaped","inClass","mods","readWord1","tmp","tmpFlags","validFlags","_match","readInt","radix","len","total","Infinity","startsWithDot","isFloat","octal","parseFloat","parseInt","readCodePoint","codePos","readHexChar","quote","chunkStart","readEscapedChar","inTemplate","octalStr","substr","escStart","esc","parseExpressionAt","tokenizer","addLooseExports","LooseParser","pluginsLoose","tokTypes","tokContexts","defineProperty","factory","__acorn","toks","tok","here","ahead","curIndent","curLineStart","nextLineStart","lineEnd","storeCurrentPos","dummyNode","dummy","dummyIdent","dummyString","lookAhead","pushCx","popCx","indentationAfter","tabSize","closes","closeTok","indent","blockHeuristic","tokenStartsLine","lp","isSpace","isDummy","shift","resetTo","lp$1","blockIndent","decl$1","parseExportSpecifierList","parseImportSpecifierList","continuedLine","elt$1","lp$2","rightStart","node$3","startIndent","parsePropertyAccessor","parenStart","binding","visitors","isNew","funcs","visitor","makeTest","Found","findNodeAfter","findNodeBefore","Ctor","skipThrough","ignore","_c","Program","EmptyStatement","ExpressionStatement","ParenthesizedExpression","IfStatement","LabeledStatement","BreakStatement","ContinueStatement","WithStatement","SwitchStatement","cs","AwaitExpression","ThrowStatement","SpreadElement","TryStatement","WhileStatement","DoWhileStatement","ForInit","DebuggerStatement","ScopeBody","ScopeExpression","Pattern","MetaProperty","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration","Class","_defineProperty","enumerable","configurable","writable","ownKeys","enumerableOnly","keys","getOwnPropertySymbols","getOwnPropertyDescriptor","_objectSpread2","getOwnPropertyDescriptors","defineProperties","_toPropertyKey","toPrimitive","res","TypeError"],"sourceRoot":""}