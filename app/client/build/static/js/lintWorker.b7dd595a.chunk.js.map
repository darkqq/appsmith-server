{"version":3,"file":"static/js/lintWorker.b7dd595a.chunk.js","mappings":";2OAqCYA,0DAKX,SALWA,GAAAA,EAAiB,UAAjBA,EAAiB,gBAAjBA,EAAiB,YAAjBA,EAAiB,YAK5B,CALWA,IAAAA,EAAiB,KAuCtB,SAASC,EACdC,GAKA,IAAMC,EAAkBD,EAASE,QAAQ,KACzC,OAAyB,IAArBD,EAEK,CACLE,WAAYH,EACZI,aAAc,IAKX,CAAED,WAFUH,EAASK,UAAU,EAAGJ,GAEpBG,aADAJ,EAASK,UAAUJ,EAAkB,GAE5D,CAsQO,SAASK,EACdC,GAEA,MACoB,kBAAXA,GACP,gBAAiBA,GACjBA,EAAOC,cAAgBA,EAAAA,GAAYC,MAEvC,CAQO,SAASC,EACdH,GAEA,MACoB,kBAAXA,GACP,gBAAiBA,GACjBA,EAAOC,cAAgBA,EAAAA,GAAYG,MAEvC,CAEO,SAASC,EACdL,GAEA,MACoB,kBAAXA,GACP,gBAAiBA,GACjBA,EAAOC,cAAgBA,EAAAA,GAAYK,QAEvC,CAEO,SAASC,EAAWP,GACzB,MACoB,kBAAXA,GACP,gBAAiBA,GACjBA,EAAOC,cAAgBA,EAAAA,GAAYO,QAEvC,CAoKO,IAoDMC,EAAe,SAC1BC,GAEA,MAAgD,oBAAzCC,OAAOC,UAAUC,SAASC,KAAKJ,EACxC,EA0NO,IAAMK,EAAiB,SAC5Bf,EACAH,GAEA,OAAOE,EAASC,KAAWgB,EAAAA,EAAAA,IAAqBhB,EAAQH,EAC1D,yBCx0BO,IAAKoB,EAKAC,kCADX,SAJWD,GAAAA,EAAe,0BAAfA,EAAe,sCAAfA,EAAe,4BAI1B,CAJWA,IAAAA,EAAe,KAO1B,SAFWC,GAAAA,EAAgB,0BAE3B,CAFWA,IAAAA,EAAgB,yOCsBhBC,YAvBCC,EAAsB,CACjCC,KAAM,mCACNC,KACE,6FAOSC,EAAsB,CAAC,OAAQ,QAM/BC,EAAsD,CACjE,0BACE,gHAQH,SAHWL,GAAAA,EAAoB,YAApBA,EAAoB,cAG/B,CAHWA,IAAAA,EAAoB,KAIzB,IAWKM,EAXCC,EAA4B,iBAC5BC,EAAgC,6BAAAC,OAAgCF,EAAyB,KAMzFG,GAFPH,EAA0BI,OAEE,CAChCC,SAAS,EACTC,QAAQ,KAIT,SAFWP,GAAAA,EAAmB,kDAE9B,CAFWA,IAAAA,EAAmB,KAGxB,IAAMQ,GAGZC,EAAAA,EAAAA,GAAA,GACET,EAAoBU,yBAA0B,SAC7CvC,EACAwC,GAAoB,UAAAR,OACbQ,EAAY,wBAAAR,OAAsBhC,EAAU,6HCyK1CyC,EAAkB,SAC7BC,GAIA,OADEA,KAAQlB,EAAAA,GAAsBmB,EAAAA,GAASC,QAAUD,EAAAA,GAASE,KAE9D,EAkBaC,EAAsB,SAACC,GAClC,OAAOA,KAAUnB,EAAAA,GACbA,EAAAA,GAA4BmB,GAC5BA,CACN,6BClIYC,4BAGX,SAHWA,GAAAA,EAAS,YAATA,EAAS,sBAGpB,CAHWA,IAAAA,EAAS,KAKd,IA8KKC,EAMAC,EAKAC,GAPX,SAJWF,GAAAA,EAAsB,cAAtBA,EAAsB,gBAAtBA,EAAsB,gBAIjC,CAJWA,IAAAA,EAAsB,KASjC,SAHWC,GAAAA,EAAmB,gBAAnBA,EAAmB,cAG9B,CAHWA,IAAAA,EAAmB,KAU9B,SALWC,GAAAA,EAAuB,sBAAvBA,EAAuB,oBAAvBA,EAAuB,UAAvBA,EAAuB,cAKlC,CALWA,IAAAA,EAAuB,yECjQvBC,0FAmEX,SAnEWA,GAAAA,EAAS,oBAATA,EAAS,4BAATA,EAAS,4BAATA,EAAS,4BAATA,EAAS,0CAATA,EAAS,oBAATA,EAAS,wBAATA,EAAS,kCAATA,EAAS,sBAATA,EAAS,oBAATA,EAAS,0CAATA,EAAS,sCAATA,EAAS,oBAATA,EAAS,sBAATA,EAAS,kBAATA,EAAS,gCAATA,EAAS,gCAATA,EAAS,sBAATA,EAAS,kCAATA,EAAS,oCAATA,EAAS,sBAATA,EAAS,oCAATA,EAAS,gDAATA,EAAS,oCAATA,EAAS,sCAATA,EAAS,oCAATA,EAAS,oCAATA,EAAS,oCAATA,EAAS,kCAATA,EAAS,oCAATA,EAAS,8BAATA,EAAS,gCAATA,EAAS,4BAATA,EAAS,8BAATA,EAAS,gCAATA,EAAS,gCAATA,EAAS,4BAATA,EAAS,8BAATA,EAAS,gCAATA,EAAS,kCAATA,EAAS,8CAATA,EAAS,sDAATA,EAAS,wDAATA,EAAS,wCAATA,EAAS,kBAATA,EAAS,wEAATA,EAAS,0CAATA,EAAS,wCAATA,EAAS,8CAATA,EAAS,oEAATA,EAAS,gDAATA,EAAS,kDAATA,EAAS,4CAATA,EAAS,kEAATA,EAAS,gEAATA,EAAS,gEAATA,EAAS,wCAATA,EAAS,kBAATA,EAAS,oBAATA,EAAS,4BAATA,EAAS,kCAATA,EAAS,0BAATA,EAAS,gCAATA,EAAS,oCAATA,EAAS,0CAATA,EAAS,gDAmEpB,CAnEWA,IAAAA,EAAS,KA8Fd,IAEMC,EAAsB,kBAYwBC,EAAA,IAAAhB,EAAAA,EAAAA,GAAAgB,EACxDC,EAAAA,GAAWC,IAAMC,EAAAA,IAAuBnB,EAAAA,EAAAA,GAAAgB,EACxCC,EAAAA,GAAWG,GAAKC,EAAAA,IAAyBrB,EAAAA,EAAAA,GAAAgB,EACzCC,EAAAA,GAAWK,KAAOC,EAAAA,IAAwBvB,EAAAA,EAAAA,GAAAgB,EAC1CC,EAAAA,GAAWO,OAASD,EAAAA,IAAwBvB,EAAAA,EAAAA,GAAAgB,EAC5CC,EAAAA,GAAWQ,GAAK,IAG6CC,EAAA,IAAA1B,EAAAA,EAAAA,GAAA0B,EAC7DT,EAAAA,GAAWC,IAAMS,EAAAA,IAAqB3B,EAAAA,EAAAA,GAAA0B,EACtCT,EAAAA,GAAWG,GAAK,KAAEpB,EAAAA,EAAAA,GAAA0B,EAClBT,EAAAA,GAAWK,KAAO,KAAEtB,EAAAA,EAAAA,GAAA0B,EACpBT,EAAAA,GAAWO,OAAS,KAAExB,EAAAA,EAAAA,GAAA0B,EACtBT,EAAAA,GAAWQ,GAAK,IAMlBG,EAAA,IAAA5B,EAAAA,EAAAA,GAAA4B,EACEX,EAAAA,GAAWC,IAAMW,EAAAA,IAAyB7B,EAAAA,EAAAA,GAAA4B,EAC1CX,EAAAA,GAAWG,GAAK,CAAC,IAACpB,EAAAA,EAAAA,GAAA4B,EAClBX,EAAAA,GAAWK,KAAO,CAAC,IAACtB,EAAAA,EAAAA,GAAA4B,EACpBX,EAAAA,GAAWO,OAAS,CAAC,IAACxB,EAAAA,EAAAA,GAAA4B,EACtBX,EAAAA,GAAWQ,GAAK,CAAC,GAGwDK,EAAA,IAAA9B,EAAAA,EAAAA,GAAA8B,EACzEb,EAAAA,GAAWC,IAAMa,EAAAA,EAAoCb,MAAGlB,EAAAA,EAAAA,GAAA8B,EACxDb,EAAAA,GAAWG,GAAKW,EAAAA,EAAoCX,KAAEpB,EAAAA,EAAAA,GAAA8B,EACtDb,EAAAA,GAAWK,KAAOS,EAAAA,EAAoCT,OAAItB,EAAAA,EAAAA,GAAA8B,EAC1Db,EAAAA,GAAWO,OAASO,EAAAA,EAAoCP,SAAMxB,EAAAA,EAAAA,GAAA8B,EAC9Db,EAAAA,GAAWQ,GAAK,4DChMZ,IAAMO,EAAkB,qGCwBnBC,wDAKZ,SALYA,GAAAA,EAAa,kBAAbA,EAAa,kBAKzB,CALYA,IAAAA,EAAa,KAQlB,IAAMC,EAAuB,SAACC,GAenC,IATA,IACEC,EAIED,EAJFC,SACAC,EAGEF,EAHFE,aACAC,EAEEH,EAFFG,eAAcC,EAEZJ,EADFK,oBAAAA,OAAmB,IAAAD,GAAQA,EAGvBE,EAAqE,CAAC,EAE5EC,EAAA,EAAAC,EAHwBlE,OAAOmE,QAAQR,GAGWM,EAAAC,EAAA/C,OAAA8C,IAAE,CAA/C,IAAAG,GAAAC,EAAAA,EAAAA,GAAAH,EAAAD,GAAA,GAAOhF,EAAUmF,EAAA,GAAE/E,EAAM+E,EAAA,GAE5B,GADAR,EAAa3E,GAAcI,GACvB0E,GAAwBF,EAA5B,CAAqD,IACrBS,EADqBC,GAAAC,EAAAA,EAAAA,GAC9BC,EAAAA,IAAS,IAAhC,IAAAF,EAAAG,MAAAJ,EAAAC,EAAAI,KAAAC,MAAkC,CAAC,IAAxBC,EAAQP,EAAAQ,MACjB,GAAKD,EAASE,UAAU1F,GAAxB,CACA,IAAM2F,EAAOH,EAASI,GAAG5F,GACnBP,EAAQ,GAAAmC,OAAM4D,EAASK,MAAI,GAAAjE,OAAOhC,EAAU,KAAAgC,OAAI4D,EAASM,QAC/DC,EAAAA,EAAAA,KAAIpB,EAA0BlF,EAAUkG,EAHC,CAI3C,CAAC,OAAAK,GAAAd,EAAAe,EAAAD,EAAA,SAAAd,EAAAgB,GAAA,CANmD,CAOtD,CAGA,GAAK1B,EAEL,QAAA2B,EAAA,EAAAC,EAAoCzF,OAAOmE,QACzCH,GACDwB,EAAAC,EAAAtE,OAAAqE,IAAE,CAFE,IAAAE,GAAArB,EAAAA,EAAAA,GAAAoB,EAAAD,GAAA,GAAOvG,EAAUyG,EAAA,GAAEC,EAAOD,EAAA,GAG7B9B,EAAa3E,GAAce,OAAO4F,OAAO,CAAC,EAAGjC,EAAS1E,GAAa0G,EACrE,CACF,EAQaE,EAAuB,SAAClC,GAGnC,IAFA,IAAMmC,EAA6C,CAAC,EAEpDC,EAAA,EAAAC,EADwBhG,OAAOmE,QAAQR,GACWoC,EAAAC,EAAA7E,OAAA4E,IAAE,CAA/C,IAC6BE,EAD7BC,GAAA7B,EAAAA,EAAAA,GAAA2B,EAAAD,GAAA,GAAO9G,EAAUiH,EAAA,GAAE7G,EAAM6G,EAAA,GAACC,GAAA3B,EAAAA,EAAAA,GACNC,EAAAA,IAAS,IAAhC,IAAA0B,EAAAzB,MAAAuB,EAAAE,EAAAxB,KAAAC,MAAkC,CAAC,IAAxBC,EAAQoB,EAAAnB,MACjB,GAAKD,EAASE,UAAU1F,GAExByG,EADc,GAAA7E,OAAM4D,EAASK,MAAI,GAAAjE,OAAOhC,EAAU,KAAAgC,OAAI4D,EAASM,SAC9B,CACnC,CAAC,OAAAE,GAAAc,EAAAb,EAAAD,EAAA,SAAAc,EAAAZ,GAAA,CACH,CAAC,IACgEa,EADhEC,GAAA7B,EAAAA,EAAAA,IACwB8B,EAAAA,EAAAA,IAAqBC,KAAKC,gBAAc,IAAjE,IAAAH,EAAA3B,MAAA0B,EAAAC,EAAA1B,KAAAC,MAAmE,CACjEkB,EADmBM,EAAAtB,MACaK,OAAQ,CAC1C,CAAC,OAAAE,GAAAgB,EAAAf,EAAAD,EAAA,SAAAgB,EAAAd,GAAA,CACD,OAAOO,CACT,qGCxFYW,EAkBAC,aAFX,SAhBWD,GAAAA,EAAuB,cAAvBA,EAAuB,sBAAvBA,EAAuB,4CAAvBA,EAAuB,0BAAvBA,EAAuB,sCAAvBA,EAAuB,YAAvBA,EAAuB,YAAvBA,EAAuB,4CAAvBA,EAAuB,gDAAvBA,EAAuB,gCAAvBA,EAAuB,kCAAvBA,EAAuB,kCAAvBA,EAAuB,sCAAvBA,EAAuB,gCAAvBA,EAAuB,sBAgBlC,CAhBWA,IAAAA,EAAuB,KAqBlC,SAHWC,GAAAA,EAAwB,4BAAxBA,EAAwB,kCAGnC,CAHWA,IAAAA,EAAwB,KAK7B,IAKKC,GALoBC,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GAC3BH,GACAC,IAUJ,SAPWC,GAAAA,EAAkB,kCAAlBA,EAAkB,oDAAlBA,EAAkB,8CAAlBA,EAAkB,4BAAlBA,EAAkB,sBAAlBA,EAAkB,8DAO7B,CAPWA,IAAAA,EAAkB,KCzBvB,IAAMA,GAAkBC,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GAC1BC,GAAqB,IACxBC,0BAA2B,kcCiEhBR,EAAuB,SAACS,GACnC,OAAOC,CACT,EAEMA,EAAc,CAClB,CACE7B,KAAM,aACNF,GAAIgC,EAAAA,GAEN,CACE9B,KAAM,YACNF,GAAIiC,EAAAA,GAEN,CACE/B,KAAM,YACNF,GAAIkC,EAAAA,GAEN,CACEhC,KAAM,aACNF,GAAImC,EAAAA,GAEN,CACEjC,KAAM,WACNF,GAAIoC,EAAAA,GAEN,CACElC,KAAM,oBACNF,GAAIqC,EAAAA,GAEN,CACEnC,KAAM,kBACNF,GAAIsC,EAAAA,GAEN,CACEpC,KAAM,cACNF,GAAIuC,EAAAA,GAEN,CACErC,KAAM,aACNF,GAAIwC,EAAAA,IAEN,CACEtC,KAAM,cACNF,GAAIyC,EAAAA,IAEN,CACEvC,KAAM,aACNF,GAAI0C,EAAAA,KAIKlD,EAAY,CACvB,CACEU,KAAM,MACNJ,UAAW,SAAC1F,GAAsB,OAAKG,EAAAA,EAAAA,IAASH,EAAO,EACvD4F,GAAI,SAAC5F,GAAsB,OACzBuI,EAAAA,EAAAA,GAAaC,EAAAA,EAAIC,KAAKzI,GAAQ,GAAD4B,OAAM5B,EAA0B8F,KAAI,QAAO,GAE5E,CACEA,KAAM,QACNJ,UAAW,SAAC1F,GAAsB,OAAKG,EAAAA,EAAAA,IAASH,EAAO,EACvD4F,GAAI,SAAC5F,GAAsB,OACzBuI,EAAAA,EAAAA,GACEG,EAAAA,EAAMD,KAAKzI,GAAQ,GAAD4B,OACd5B,EAA0B8F,KAAI,UACnC,GAEL,CACEA,KAAM,iBACND,KAAM,0CACNH,UAAW,SAAC1F,GAAsB,OAAKK,EAAAA,EAAAA,IAAiBL,EAAO,EAC/D4F,GAAI,kBACF2C,EAAAA,EAAAA,GAAaI,EAAAA,GAAgB,0CAA0C,GAE3E,CACE7C,KAAM,mBACND,KAAM,qCACNH,UAAW,SAAC1F,GAAsB,OAAKK,EAAAA,EAAAA,IAAiBL,EAAO,EAC/D4F,GAAI,kBACF2C,EAAAA,EAAAA,GAAaK,EAAAA,GAAkB,qCAAqC,GAExE,CACE9C,KAAM,uBACND,KAAM,kCACNH,UAAW,SAAC1F,GAAsB,OAAKK,EAAAA,EAAAA,IAAiBL,EAAO,EAC/D4F,GAAI,kBACF2C,EAAAA,EAAAA,GAAaM,EAAAA,GAAsB,kCAAkC,IAoB9DC,EAAgC,SAG3CpB,GAEA,OAAOqB,CACT,EAEMA,EAAqD,CACzDC,eAAgB,gBAChBC,oBAAqB,eACrBC,YAAa,aACbC,kBAAmB,kBACnBC,SAAU,WACVC,YAAa,aACbC,oCAAqC,cACrCC,kBAAmB,aACnBC,aAAc,cACdC,WAAY,YACZC,mBAAoB,YACpBC,YAAa,aACbC,aAAc,cACdC,YAAa,aACbC,qBAAsB,qBACtBC,uBAAwB,gBACxBC,+BAAgC,YAChCC,aAAc,oBACdC,YAAa,aACbC,cAAe,uCClMV,IAAKlK,EAOAmK,EA0EAC,mFA5EX,SALWpK,GAAAA,EAAW,gBAAXA,EAAW,gBAAXA,EAAW,oBAAXA,EAAW,oBAKtB,CALWA,IAAAA,EAAW,KAavB,SANYmK,GAAAA,EAA0B,oBAA1BA,EAA0B,sBAA1BA,EAA0B,oCAMtC,CANYA,IAAAA,EAA0B,KA6ErC,SAHWC,GAAAA,EAAsB,YAAtBA,EAAsB,kBAGjC,CAHWA,IAAAA,EAAsB,8TCpErBC,qBAAiB,SAAC7E,GAAa,OAC1CvB,EAAAA,GAAgBqG,KAAK9E,EAAO,GAGvB,SAAS+E,EAAyBC,GACvC,IAAIC,EAAiB,GACfC,EAA0BF,EAAc9K,QAAQ,MACtD,IAAiC,IAA7BgL,EACF,MAAO,CAACF,GAGV,IAAMG,EAAcH,EAAc3K,UAAU,EAAG6K,GAC/CC,GAAeF,EAAeG,KAAKD,GAOnC,IANA,IAAIE,EAAOL,EAAc3K,UACvB6K,EACAF,EAAc3I,QAGZiJ,EAAM,EACDC,EAAI,EAAGA,GAAKF,EAAKhJ,OAAS,EAAGkJ,IAAK,CACzC,IAAMC,EAAOH,EAAKE,GACZE,EAAWJ,EAAKE,EAAI,GAE1B,GAAa,MAATC,EACFF,SACK,GAAa,MAATE,IACTF,IACiB,MAAbG,GAA4B,IAARH,IACtBL,EAAeG,KAAKC,EAAKhL,UAAU,EAAGkL,EAAI,IAC1CF,EAAOA,EAAKhL,UAAUkL,EAAI,EAAGF,EAAKhJ,UACxB,CACR4I,EAAiBA,EAAe9I,OAC9B4I,EAAyBM,IAE3B,KACF,CAGN,CACA,OAAY,IAARC,GAA+B,KAAlBN,EACR,CAACA,GAEHC,CACT,CAGO,IA4CKS,EA5CCC,EAAqB,SAChCX,EACAzK,GAGA,IAAKyK,IAAkBY,IAAAA,SAAWZ,GAChC,MAAO,CAAEC,eAAgB,GAAIY,WAAY,IAE3C,IACIZ,EAAgBa,EADdC,EAAkBf,EAAcgB,OAkBtC,OAhBIzL,IAAUO,EAAAA,EAAAA,IAAWP,IACvB0K,EAAiB,CAACc,GAClBD,EAAQ,CAACC,IAKTD,GAFAb,EAAiBF,EAAyBgB,IAEnBE,KAAI,SAACC,GAC1B,IAAM7J,EAAS6J,EAAQ7J,OAEvB,OADgBwI,EAAeqB,GAEtBA,EAAQ7L,UAAU,EAAGgC,EAAS,GAEhC,EACT,IAEK,CAAE4I,eAAgBA,EAAgBY,WAAYC,EACvD,GA0BC,SATWJ,GAAAA,EAAc,sDAAdA,EAAc,0CAAdA,EAAc,kCAAdA,EAAc,8BAAdA,EAAc,8CAAdA,EAAc,gCAAdA,EAAc,oDAAdA,EAAc,0BASzB,CATWA,IAAAA,EAAc,KAgCnB,IA8MKS,EA9MCC,EAAkC,SAC7C7L,GAEA,OACEA,GACAA,EAAO8L,wBACPC,MAAMC,QAAQhM,EAAO8L,yBAErBG,EAAAA,EAAAA,GAAWjM,EAAO8L,wBAEb,EACT,EAEaI,EAAwB,SACnClM,EACA6F,GAEA,SACE7F,GACAA,EAAO8L,wBACPC,MAAMC,QAAQhM,EAAO8L,+BAE2CK,IAAzDd,IAAAA,KAAOrL,EAAO8L,uBAAwB,CAAEM,IAAKvG,GAGxD,EAwBa7E,EAAuB,SAClCqL,EACAxG,GAEA,SACEwG,GACAA,EAAOC,wBACPP,MAAMC,QAAQK,EAAOC,+BAE2CH,IAAzDd,IAAAA,KAAOgB,EAAOC,uBAAwB,CAAEF,IAAKvG,GAGxD,EAmEa0G,EAAkB,iBACH,GAAA3K,OAAM2K,EAAe,WACrB,GAAA3K,OAAM2K,EAAe,qBAgFhD,SAJWX,GAAAA,EAA2B,wBAA3BA,EAA2B,cAA3BA,EAA2B,YAItC,CAJWA,IAAAA,EAA2B,KAsCtCY,EAAA,IAAAtK,EAAAA,EAAAA,GAAAsK,EACEZ,EAA4Ba,YAAa,SAAC5M,GAAoB,sBAAA+B,OAC7C/B,EAAY,mBAAaqC,EAAAA,EAAAA,GAAAsK,EAC1CZ,EAA4Bc,OAAQ,mDAAmCxK,EAAAA,EAAAA,GAAAsK,EACvEZ,EAA4Be,MAAO,2EClY/B,IAAKC,EAmCL,SAASC,EAEdC,GAEAC,KAAKC,YAAYF,EACnB,wDApCC,SAJWF,GAAAA,EAAW,kBAAXA,EAAW,oBAAXA,EAAW,kBAItB,CAJWA,IAAAA,EAAW,gCCLXK,UAWX,SAXWA,GAAAA,EAAK,UAALA,EAAK,gBAALA,EAAK,gBAALA,EAAK,kBAALA,EAAK,gBAALA,EAAK,cAALA,EAAK,oBAALA,EAAK,sBAALA,EAAK,YAALA,EAAK,kBAWhB,CAXWA,IAAAA,EAAK,uGCoQV,SAASC,EAAUzH,GACxB,OAAO0H,QAAQ1H,GAA+B,oBAAfA,EAAM2H,KACvC,wECrQaC,EAAW1M,OAAO2M,KAAKC,GAAcC,QAAO,SAACC,EAAKrB,GAE7D,OADAqB,EAAIrB,IAAO,EACJqB,CACT,GAAG,CAAC,4LCHEC,EACJ,qLAoCWC,EAAgB,IAlCV,oBAAAC,KAAAC,EAAAA,EAAAA,GAAA,KAAAD,GAAA,KACTE,iBAAmB,CAAC,iBAAkB,aAC9C,KAEQC,sBAA8C,CAAC,CAAE,CA2BxD,OA3BuDC,EAAAA,EAAAA,GAAAJ,EAAA,EAAAxB,IAAA,uBAAA3G,MAExD,SAAqBnB,GACnByI,KAAKgB,uBAAwBvH,EAAAA,EAAAA,IAAqBlC,EACpD,GAAC,CAAA8H,IAAA,MAAA3G,MAED,SAAIwI,GACF,IAAMC,EAAeC,EAAgBF,GAErC,IAAKlB,KAAKe,iBAAiBM,SAASH,EAAMnI,MAAO,OAAOoI,EAExD,QAAAtJ,EAAA,EAAAyJ,EAAoC1N,OAAO2M,KACzCP,KAAKgB,uBACNnJ,EAAAyJ,EAAAvM,OAAA8C,IAAE,CAFE,IAAM0J,EAAqBD,EAAAzJ,GAGxB2J,EAA6B,IAAMD,EAAwB,IACjE,GAAIE,EAAwBP,GAAOQ,MAAMF,GACvC,MAAO,CACLzI,KAAM,kBACNgH,QAASY,EAAoCgB,WAC3C,iBACAJ,EAAwB,MAIhC,CAEA,OAAOJ,CACT,KAACN,CAAA,CA/BgB,IAoCNe,EAA2B,SAAAC,IAAAC,EAAAA,EAAAA,GAAAF,EAAAC,GAAA,IAAAE,GAAAC,EAAAA,EAAAA,GAAAJ,GACtC,SAAAA,IAAe,IAADK,EAI2E,OAJ3EnB,EAAAA,EAAAA,GAAA,KAAAc,IACZK,EAAAF,EAAAhO,KAAA,OACKgF,KAAO,GACZkJ,EAAKlC,QACH,qFAAqFkC,CACzF,CAAC,OAAAhB,EAAAA,EAAAA,GAAAW,EAAA,CANqC,EAMrCM,EAAAA,EAAAA,GAN8CC,QASpCC,EAA4B,SAAAC,IAAAP,EAAAA,EAAAA,GAAAM,EAAAC,GAAA,IAAAC,GAAAN,EAAAA,EAAAA,GAAAI,GACvC,SAAAA,EAAYG,GAAqB,IAADC,EAG9B,OAH8B1B,EAAAA,EAAAA,GAAA,KAAAsB,GAC9BI,EAAAF,EAAAvO,KAAA,KAAMwO,GAEDA,GAKLC,EAAKzJ,KAAO,GACZyJ,EAAKzC,QAAUY,EAAoCgB,WACjD,iBACAY,EAAa,MACbC,IARAA,EAAKzC,QAAU,yCACf0C,EAAAA,EAAAA,GAAAD,GAQJ,CAAC,OAAAvB,EAAAA,EAAAA,GAAAmB,EAAA,CAdsC,EActCF,EAAAA,EAAAA,GAd+CC,QAiBrCf,EAAkB,SAACF,GAC9B,OAAOA,EAAMnI,KACT,CACEA,KAAMmI,EAAMnI,KACZgH,QAASmB,EAAMnB,SAEjB,CACEhH,KAAM,kBACNgH,QAASmB,EAAMnB,QAEvB,EAEa0B,EAA0B,SAACP,GACtC,OAAOA,EAAMnI,KAAI,GAAAlE,OAAMqM,EAAMnI,KAAI,MAAAlE,OAAKqM,EAAMnB,SAAYmB,EAAMnB,OAChE,wOC5DY2C,wHAKX,SALWA,GAAAA,EAAoB,wBAApBA,EAAoB,wCAApBA,EAAoB,oDAApBA,EAAoB,oBAK/B,CALWA,IAAAA,EAAoB,KAOzB,IAAMC,EAAiB,aAEjBC,GAAuDC,EAAA,IAAA1N,EAAAA,EAAAA,GAAA0N,EACjEH,EAAqBI,WAAU,sDAAAjO,OAEX8N,EAAc,qEAAAxN,EAAAA,EAAAA,GAAA0N,EAKlCH,EAAqBK,mBAAkB,wLAAAlO,OAM3B8N,EAAc,WAAAxN,EAAAA,EAAAA,GAAA0N,EAE1BH,EAAqBM,yBAAwB,qMAAAnO,OAMjC8N,EAAc,WAAAxN,EAAAA,EAAAA,GAAA0N,EAE1BH,EAAqBO,SAAQ,4DAAApO,OAET8N,EAAc,2EAAAE,GAO/BK,EAAqBtP,OAAO2M,KAAKpG,MAAMsG,QAAO,SAACC,EAAKrB,GAExD,OADAqB,EAAIrB,IAAO,EACJqB,CACT,GAAG,CAAC,GAEJ,SAASyC,IACPhJ,KAAKiJ,cAAe,EACpB,IAD0B,IAAAC,EAAA,WACrB,IAAMhE,EAAGiC,EAAAzJ,GACZ,GAAIqL,EAAmB7D,IAAQiB,EAAAA,EAASjB,GAAK,MAAD,WAE5C,GAAI,CAAC,oBAAqB,SAAU,WAAY,YAAYgC,SAAShC,GAAK,MAAD,WAEzE,GAAIiE,EAAAA,GAAYC,MAAK,SAACC,GAAG,OAAKA,EAAIC,SAASpC,SAAShC,EAAI,IAAE,MAAD,WACzD,GAAIqE,EAAAA,GAA2BrE,GAAK,MAAD,WACnC,WAESlF,KAAKkF,EAId,CAHE,MAAOnG,GAEPiB,KAAKkF,QAAOD,CACd,CACF,EAdAvH,EAAA,EAAAyJ,EAAkB1N,OAAO2M,KAAKpG,MAAKtC,EAAAyJ,EAAAvM,OAAA8C,IAAAwL,GAerC,CAEO,IAAMM,EAAgB,WAGD,IAF1BC,EAAkBC,UAAA9O,OAAA,QAAAqK,IAAAyE,UAAA,IAAAA,UAAA,GAClBpM,EAAcoM,UAAA9O,OAAA,QAAAqK,IAAAyE,UAAA,IAAAA,UAAA,GAEVC,EAAapB,EAAqBI,WAQtC,OAPIc,GAAsBnM,EACxBqM,EAAapB,EAAqBM,yBACzBY,IAAuBnM,EAChCqM,EAAapB,EAAqBK,mBACzBtL,IAAmBmM,IAC5BE,EAAapB,EAAqBO,UAE7Ba,CACT,EAIaC,EAAkB,SAC7BC,EACAC,GAGA,IAAMC,EAAStB,EAAkBqB,GAAME,MAAMxB,GAC7C,MAAM,GAAN9N,OAAUqP,EAAO,IAAErP,OAAGmP,GAAUnP,OAAGqP,EAAO,GAC5C,EAEME,EAA2B,YAmBpBC,EAA0B,SAAC/M,GACtC,IACEgN,EAMEhN,EANFgN,QACA/M,EAKED,EALFC,SACAgN,EAIEjN,EAJFiN,cACA9M,EAGEH,EAHFG,eACA+M,EAEElN,EAFFkN,kBACA7M,EACEL,EADFK,oBAGIH,EAA4B,CAAC,EAmBnC,OAjBAA,EAAaiN,UAAYF,EAEzB/M,EAAakN,cAAsB,OAAPJ,QAAO,IAAPA,OAAO,EAAPA,EAASK,cAAe,CAAC,EAE1C,OAAPL,QAAO,IAAPA,GAAAA,EAASM,eACXhR,OAAO4F,OAAOhC,EAAc8M,EAAQM,gBAGtCvN,EAAAA,EAAAA,IAAqB,CACnBG,aAAAA,EACAD,SAAAA,EACAI,sBAAuBA,EACvBF,eAAAA,IAGFoN,EAA2BrN,EAAcgN,EAAmB/M,GAErDD,CACT,EAEaqN,EAA6B,SACxCrN,EACAgN,EACA/M,GAGA,IADA,IACA2B,EAAA,EAAA0L,EADsBlR,OAAO2M,KAAKiE,GAAqB,CAAC,GAChBpL,EAAA0L,EAAA/P,OAAAqE,IAAE,CAArC,IAAM2L,EAAYD,EAAA1L,GACf4L,EAAiBR,EAAkBO,GACnCE,EAAWzN,EAAauN,GACxBG,EAA4D,CAAC,EACnE,GAAKD,EAAL,CACA,QAAAtL,EAAA,EAAAwL,EAAqBvR,OAAO2M,KAAKyE,GAAerL,EAAAwL,EAAApQ,OAAA4E,IAAE,CAAC,IAADyL,EAAvCC,EAAMF,EAAAxL,GACTd,EAAKmM,EAAeK,GAC1B,GAAkB,oBAAPxM,EAAX,CAIA,IAAMyM,EAAuB,QAAnBF,EAAGH,EAASI,UAAO,IAAAD,OAAA,EAAhBA,EAAkBE,KAC/BJ,EAAiBG,GAAU5N,GACvB8N,EAAAA,EAAAA,GAAwB1M,EAAIkM,EAAe,IAAMM,GACjDxM,EACEyM,IACJJ,EAAiBG,GAAc,KAAIC,EATC,CAWxC,CAEA9N,EAAauN,GAAgBnR,OAAO4F,OAAO,CAAC,EAAGyL,EAAUC,EAhBlC,CAiBzB,CACF,EAuBO,IAAMM,EAA0B,SACrCxB,EACAvM,EACA8M,GAEA,IAAMkB,EA1BD,SAAwBC,GAI7B,IAAMC,EAAYD,EAAGE,QAAQxB,EAA0B,IACvD,OAAOjK,KAAK0L,kBAAoB,EAAIF,EAAYG,IAAWH,EAC7D,CAoBsBI,CAAe/B,GAEnC,IAAKyB,EAAY1Q,OACf,MAAO,CACLiR,OAAQ,IAGZ,IAAMlC,EAAaH,IAAgBY,EAAe9M,GAElD,MAAO,CAAEuO,OADMjC,EAAgB0B,EAAa3B,GAE9C,EAEe,SAASmC,EACtBjC,EACAzM,EACAiN,EACA0B,EACA5B,EACAC,GAEA,OAAQ,WACNpB,IACA,IACIgD,EADEC,EAA4B,GAM5BC,EAA2BhC,EAAwB,CACvD9M,SAAAA,EACAiN,kBAAAA,EACAF,QAAAA,EACAC,cAAAA,EACA9M,eAAgByO,IAGlBG,EAA0B,cAAI,EAE9B,IAAQL,EAAWR,EACjBxB,GACA,EACAO,GAHMyB,OAOR,IAAKA,EAAOjR,OACV,MAAO,CACLqR,OAAQ,GACRD,YAAQ/G,EACRkH,SAAU,IAOd1S,OAAO4F,OAAOW,KAAMkM,GAEpB,IAEE,IADAF,GAASI,EAAAA,EAAAA,GAAaP,cACAQ,QAKpB,MAAM,IAAI5E,EAAAA,EAkBd,CAhBE,MAAOV,GACPkF,EAAOtI,KAAK,CACVqD,aAAcP,EAAAA,GAAcnF,IAAIyF,GAChCuF,SAAUjR,EAAAA,GAASE,MACnBgR,IAAKV,EACLW,UAAW9H,EAAAA,GAA4Bc,MACvCiH,gBAAiB5C,GAErB,CAAC,QACC,IAAK,IAAMnR,KAAcwT,EACnBA,EAAYQ,eAAehU,WAEtBsH,KAAKtH,GAGhBsH,KAAmB,cAAI,CACzB,CACA,MAAO,CAAEgM,OAAAA,EAAQC,OAAAA,EACnB,CAjEQ,EAkEV,wICpSMU,EAAO,oBAAAA,KAAAhG,EAAAA,EAAAA,GAAA,KAAAgG,GAAA,KACHC,WAAY,EAAK,KAOjBC,aAAO,OAiEPC,UAAY,SAACC,GAA6C,IAADC,EAAAC,EAAAC,EACzDpD,GAAkB,OAAXiD,QAAW,IAAXA,GAAmB,QAARC,EAAXD,EAAaI,cAAM,IAAAH,OAAR,EAAXA,EAAqBI,aAAcrU,EAAAA,GAAYO,SACtDsF,GACO,OAAXmO,QAAW,IAAXA,GAAmB,QAARE,EAAXF,EAAaI,cAAM,IAAAF,OAAR,EAAXA,EAAqBrO,QAAmB,OAAXmO,QAAW,IAAXA,OAAW,EAAXA,EAAaM,sBAAuB,GAC7D1U,GAA0B,OAAXoU,QAAW,IAAXA,OAAW,EAAXA,EAAaM,sBAAuB,GAGzD,MAAO,CAAEvD,KAAAA,EAAMlL,KAAAA,EAAM0O,IAFC,OAAXP,QAAW,IAAXA,GAAmB,QAARG,EAAXH,EAAaI,cAAM,IAAAD,OAAR,EAAXA,EAAqBI,KAAM,GAEb3U,aAAAA,EAC3B,CAAE,CA6BD,OA7BAmO,EAAAA,EAAAA,GAAA6F,EAAA,EAAAzH,IAAA,SAAA3G,MA/ED,WACEsH,KAAK+G,WAAY,CACnB,GAAC,CAAA1H,IAAA,UAAA3G,MACD,WACEsH,KAAK+G,WAAY,CACnB,GAAC,CAAA1H,IAAA,UAAA3G,MAGD,SAAgBgP,EAAiBpC,GAAc,IAADqC,EACtCC,EAAS5H,KAAK6H,UAAUH,EAAQpC,GAC1B,QAAZqC,EAAA3H,KAAKgH,eAAO,IAAAW,GAAZA,EAAcG,KAAK,eAAgBF,EACrC,GAAC,CAAAvI,IAAA,qBAAA3G,MAED,WAA6B,IAADuJ,EAAA,KAC1BjC,KAAKgH,QAAUe,EAAAA,GACf,IAAAC,EAAiDhT,QAAzCiT,EAAKD,EAALC,MAAO/G,EAAK8G,EAAL9G,MAAOgH,EAAIF,EAAJE,KAAMC,EAAGH,EAAHG,IAAKC,EAAKJ,EAALI,MAAOC,EAAIL,EAAJK,KACxCrT,SAAOwF,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACFxF,SAAO,IACVoT,MAAO,WACL,GAAKnG,EAAK8E,UAAV,CAA4B,QAAAuB,EAAAzE,UAAA9O,OADnBuC,EAAI,IAAA0H,MAAAsJ,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJjR,EAAIiR,GAAA1E,UAAA0E,GAEbH,EAAMrU,KAAKkO,EAAM3K,GACjB2K,EAAKuG,QAAQ,QAASlR,EAFK,CAG7B,EACA4J,MAAO,WACL,GAAKe,EAAK8E,UAAV,CAA4B,QAAA0B,EAAA5E,UAAA9O,OADnBuC,EAAI,IAAA0H,MAAAyJ,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJpR,EAAIoR,GAAA7E,UAAA6E,GAEbxH,EAAMyH,MAAM1G,EAAM3K,GAClB2K,EAAKuG,QAAQ,QAASlR,EAFK,CAG7B,EACA6Q,IAAK,WACH,GAAKlG,EAAK8E,UAAV,CAA4B,QAAA6B,EAAA/E,UAAA9O,OADrBuC,EAAI,IAAA0H,MAAA4J,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJvR,EAAIuR,GAAAhF,UAAAgF,GAEXV,EAAIQ,MAAM1G,EAAM3K,GAChB2K,EAAKuG,QAAQ,MAAOlR,EAFO,CAG7B,EACA2Q,MAAO,WACL,GAAKhG,EAAK8E,UAAV,CAA4B,QAAA+B,EAAAjF,UAAA9O,OADnBuC,EAAI,IAAA0H,MAAA8J,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJzR,EAAIyR,GAAAlF,UAAAkF,GAEbd,EAAMU,MAAM1G,EAAM3K,GAClB2K,EAAKuG,QAAQ,QAASlR,EAFK,CAG7B,EACA+Q,KAAM,WACJ,GAAKpG,EAAK8E,UAAV,CAA4B,QAAAiC,EAAAnF,UAAA9O,OADpBuC,EAAI,IAAA0H,MAAAgK,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJ3R,EAAI2R,GAAApF,UAAAoF,GAEZZ,EAAKM,MAAM1G,EAAM3K,GACjB2K,EAAKuG,QAAQ,OAAQlR,EAFM,CAG7B,EACA4Q,KAAM,WACJ,GAAKjG,EAAK8E,UAAV,CAA4B,QAAAmC,EAAArF,UAAA9O,OADpBuC,EAAI,IAAA0H,MAAAkK,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAJ7R,EAAI6R,GAAAtF,UAAAsF,GAEZjB,EAAKS,MAAM1G,EAAM3K,GACjB2K,EAAKuG,QAAQ,OAAQlR,EAFM,CAG7B,GAEJ,GAAC,CAAA+H,IAAA,sCAAA3G,MACD,SAA4C4M,GAAY,IAAD9C,EAAA,KACrD,GAAoB,oBAAT8C,EAAqB,MAAM,UAANzQ,OAAiByQ,EAAKvM,MACtD,IAAKuM,GAAwB,kBAATA,EAAmB,OAAOA,EAC9C,GAAIA,aAAgBkB,QAAS,MAAO,UACpC,IAAM9F,EACqC,mBAAzC9M,OAAOC,UAAUC,SAASC,KAAKuR,GAA6B,GAAK,CAAC,EACpE,OAAO1R,OAAO2M,KAAK+E,GAAM7E,QAAO,SAACC,EAAKrB,GAEpC,OADAqB,EAAIrB,GAAOmD,EAAK4G,oCAAoC9D,EAAKjG,IAClDqB,CACT,GAAGA,EACL,GACA,CAAArB,IAAA,eAAA3G,MACA,SAAqB4M,GACnB,IAEE,OADmBtF,KAAKoJ,oCAAoC9D,EAI9D,CAFE,MAAOpM,GACP,MAAO,CAAC,yBAADrE,OAA0BqE,EAAC,KAAArE,OAAIwU,KAAKC,UAAUhE,IACvD,CACF,GAAC,CAAAjG,IAAA,YAAA3G,MAaD,SAAkBgP,EAAiBpC,GAEjC,IAAMmC,GAAK8B,EAAAA,EAAAA,MACLC,EAAYC,MAASC,OAAO,YAE9BC,EAASrE,EAETmB,EAAWjR,EAAAA,GAASoU,KACT,UAAXlC,GACFjB,EAAWjR,EAAAA,GAASE,MACpBiU,EAASrE,EAAK3G,KAAI,SAACuC,GACjB,OAAY,OAALA,QAAK,IAALA,OAAK,EAALA,EAAO2I,QAAS3I,CACzB,KACoB,SAAXwG,IACTjB,EAAWjR,EAAAA,GAASC,SAGtB,IAAQyR,EAAgB4C,EAAAA,EAAkBC,uBAAlC7C,YACR,MAAO,CACLQ,OAAAA,EACAD,GAAAA,EACAnC,KAAMtF,KAAKgK,cAAaC,EAAAA,EAAAA,GAAMN,IAC9BH,UAAAA,EACA/C,SAAAA,EACAa,OAAQtH,KAAKiH,UAAUC,GAE3B,KAACJ,CAAA,CA9GU,GAiHPoD,EAAW,IAAIpD,EAErB,wDC9H6B3M,KAAKgQ,YACHhQ,KAAKiQ,cAEd,IAAIC,0ICO1B,SAASC,EAAgBC,GACvB,OAAO,IAAI/D,SAAQ,SAACgE,GAQlBrQ,KAAKsQ,iBAAiB,WAPL,SAAXC,EAAYC,GAChB,IAAAC,EAAyCD,EAAMrF,KAAvCuF,EAAID,EAAJC,KAAMC,EAASF,EAATE,UAAWC,EAAWH,EAAXG,YACrBD,IAAcP,GAAaQ,IAAgBlL,EAAAA,EAAYmL,WACzDR,EAAQK,EAAKvF,MACbnL,KAAK8Q,oBAAoB,UAAWP,GAExC,GAEF,GACF,CAEO,IAAMQ,EAAe,oBAAAA,KAAApK,EAAAA,EAAAA,GAAA,KAAAoK,EAAA,CA6CzB,OA7CyBjK,EAAAA,EAAAA,GAAAiK,EAAA,OAAA7L,IAAA,UAAA3G,MAAA,eAAAyS,GAAAC,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,KAAAC,MAC1B,SAAAC,EAAqBC,GAAY,IAAAV,EAAAW,EAAA,OAAAJ,EAAAA,EAAAA,KAAAK,MAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,OAM5B,OALGf,GAAYgB,EAAAA,EAAAA,UAAS,WAADjX,OAAY2W,EAAQ9D,OAAM,MACpD5H,EAAAA,EAAY/L,KAAKoG,KAAM,CACrB2Q,UAAAA,EACAC,YAAalL,EAAAA,EAAYkM,QACzBlB,KAAMW,IACLG,EAAAE,KAAA,EACoBvB,EAAgBQ,GAAW,KAAD,EAAnC,OAARW,EAAQE,EAAAK,KAAAL,EAAAM,OAAA,SACPR,GAAQ,wBAAAE,EAAAO,OAAA,GAAAX,EAAA,KAChB,gBAAAY,GAAA,OAAAhB,EAAAxC,MAAA,KAAA9E,UAAA,EAVyB,IAUzB,CAAAxE,IAAA,OAAA3G,MAED,SAAY8S,GACV1L,EAAAA,EAAY/L,KAAKoG,KAAM,CACrB4Q,YAAalL,EAAAA,EAAYuM,QACzBvB,KAAMW,GAEV,GAAC,CAAAnM,IAAA,UAAA3G,MAED,SAAeoS,EAAmBxF,EAAe+G,GAC/C,IACEvM,EAAAA,EAAY/L,KAAKoG,KAAM,CACrB2Q,UAAAA,EACAC,YAAalL,EAAAA,EAAYmL,SACzBH,KAAM,CAAEvF,KAAAA,EAAM+G,UAAAA,IAoBlB,CAlBE,MAAOnT,GACPlE,QAAQkM,MAAMhI,GACd4G,EAAAA,EAAY/L,KAAKoG,KAAM,CACrB2Q,UAAAA,EACAC,YAAalL,EAAAA,EAAYmL,SACzBH,KAAM,CACJwB,UAAWA,EAAUC,QAAQ,GAC7BhH,KAAM,CACJc,OAAQ,CACN,CACEnC,KAAM9P,EAAAA,EAAiBoY,YACvBxM,QAAW,OAAD7G,QAAC,IAADA,OAAC,EAADA,EAAa6G,QACvBuE,QAAS+E,KAAKC,UAAUhE,QAMpC,CACF,KAAC4F,CAAA,CA7CyB,yECNrB,SAAS1P,EACd3C,EACAwM,GAEA,OAAO,WACL,IAAKlL,KAAKiJ,aAAc,OAAOvK,EAAE8P,WAAC,EAAD9E,WAEjC,MADA1J,KAAe,UAAI,EACb,IAAIiI,EAAAA,GAA6BiD,EACzC,CACF,0JCiBC,+FCgKsD7K,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GAClDgS,EAAAA,IACAC,EAAAA,IACAC,EAAAA,aC/DE,gDC9IDC,EAAkB,oBAAAA,KAAA7L,EAAAA,EAAAA,GAAA,KAAA6L,GAAA,KACdtG,YAA2B,CAAC,CAAE,CA6DrC,OA7DoCpF,EAAAA,EAAAA,GAAA0L,EAAA,EAAAtN,IAAA,YAAA3G,MAErC,SAAUnB,EAAoBiN,GAE5B,IAAM6B,EAA2B,CAC/BjD,cAAc,EACdwJ,UAAU,IAGZvV,EAAAA,EAAAA,IAAqB,CACnBE,SAAAA,EACAC,aAAc6O,EACd5O,gBAAgB,KAGlBoN,EAAAA,EAAAA,IAA2BwB,EAAa7B,GAAmB,GAK3D5Q,OAAO4F,OAAOW,KAAMkM,GAEpBrG,KAAKqG,YAAcA,EACnB6D,EAAAA,EAAS2C,SACX,GAAC,CAAAxN,IAAA,QAAA3G,MAED,WAEE,IAAK,IAAM7F,KADXqX,EAAAA,EAAS4C,SACgB9M,KAAKqG,YACxBrG,KAAKqG,YAAYQ,eAAehU,WAE3BsH,KAAKtH,EAGlB,GAAC,CAAAwM,IAAA,kBAAA3G,MAED,SAAgBqU,GAA8C,IAAvBC,EAAenJ,UAAA9O,OAAA,QAAAqK,IAAAyE,UAAA,GAAAA,UAAA,GAAG,GAGvD,OAFA1J,KAAe,UAAI,EAEX,WACN,IACE,GAA4B,oBAAjB4S,EACT,GAAsC,kBAAlCA,EAAaE,YAAYlU,KAE3BoB,KAAe,UAAI,MACd,CACL,IAAM+S,EAAcH,IACdG,GAAeA,aAAuB1G,UAC1CrM,KAAe,UAAI,EAEvB,CAMJ,CAJE,MAAOjB,GAGP8T,EAAKlP,KAAK,CAAEoD,MAAO,wCAA0ChI,GAC/D,CAGA,QAFkBiB,KAAe,QAGnC,CArBQ,EAsBV,KAACwS,CAAA,CA9DqB,GAiEU,IAAIA,MCzC3BQ,0NCCLC,EAA0B,IAC1BC,EAAyB,yCAAAxY,OAA4CuY,EAAuB,wDAE5FE,EAAO,SAAPA,EAAQC,EAA8BC,GAC1C,IAAIrH,EAA8B,GAOlC,OANAoH,EAAME,SAAQ,SAACC,GACbvH,EAAOrI,KAAK,CAAEpF,MAAOgV,EAAEF,KACnBxO,MAAMC,QAAQyO,EAAEC,YAClBxH,EAASA,EAAOtR,OAAOyY,EAAKI,EAAEC,SAAUH,IAE5C,IACOrH,CACT,EAeA,SAASyH,EACPC,EACAnV,EACAoV,EACAhb,GACC,IAADib,EACA,GAAiB,QAAjBA,EAAIF,EAAOG,cAAM,IAAAD,GAAbA,EAAeE,YAAa,CAAC,IAADC,EAC1BC,GAAS,EACPC,EAAqB,GA+B3B,OA9BAP,EAAOG,OAAOC,YAAYR,SAAQ,SAACY,GAAW,IAADC,EAAAC,EAAAC,EACrCC,IAA2B,QAAbH,EAACD,EAAML,cAAM,IAAAM,IAAZA,EAAcG,YAC7BC,EAxBZ,SACEC,EACA5V,GAGA,GAFU8K,UAAA9O,OAAA,QAAAqK,IAAAyE,UAAA,IAAAA,UAAA,GAIH,CAEL,OADajQ,OAAOgb,oBAAoBD,GAC5BpL,MAAK,SAAClE,GAAG,OAAKA,EAAIwP,gBAAkB9V,EAAK8V,aAAa,KAAK9V,CACzE,CAJE,OAAOA,CAKX,CAawB+V,CAAiBpW,EAAO2V,EAAMtV,KAAM0V,GAEtD,GAAI/V,EAAMmO,eAAe6H,GAAY,CACnC,IAAAK,EAAsCC,EACpCX,EACA3V,EAAMgW,GACNZ,EACAhb,GAJMmc,EAAOF,EAAPE,QAASC,EAAQH,EAARG,SAAUtH,EAAMmH,EAANnH,OAMtBqH,IACHvW,EAAMgW,GAAa9G,EACnBuG,EAASc,EACTC,GACEA,EAASvQ,KAAI,SAACoB,GACZqO,EAAUtQ,KAAK,CACb/E,KAAMgH,EAAQhH,KACdgH,QAAQ,iBAADlL,OAAmB6Z,EAAS,iBAAA7Z,OAAgBkL,EAAQA,UAE/D,IAEN,MAAuB,QAAZwO,EAAAF,EAAML,cAAM,IAAAO,GAAZA,EAAcY,UAAwB,QAAhBX,EAAIH,EAAML,cAAM,IAAAQ,GAAZA,EAAcY,eACjDjB,GAAS,EACTC,EAAUtQ,KAAK,CACb/E,KAAM,kBACNgH,QAAQ,yBAADlL,OAA2B6Z,KAGxC,IACIP,EACK,CACLc,SAAS,EACTrH,OAAQlP,GAGL,CACLuW,SAAS,EACTrH,QAAqB,QAAbsG,EAAAL,EAAOG,cAAM,IAAAE,OAAA,EAAbA,EAAemB,UAAW3W,EAClCwW,SAAUd,EAEd,CACA,MAAO,CACLa,SAAS,EACTrH,OAAQlP,EAEZ,CAEA,SAAS4W,EACPzB,EACAnV,EACAoV,EACAhb,GACC,IAADyc,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EACIC,GAAW,EACT9B,EAAqB,GAIrB+B,EAAgB,IAAIC,KAAiB,QAAbb,EAAA1B,EAAOG,cAAM,IAAAuB,OAAA,EAAbA,EAAeY,gBAAiB,IAG1DE,EAA4B,GAC1BC,EAAiC,QAAhBd,EAAG3B,EAAOG,cAAM,IAAAwB,GAAU,QAAVC,EAAbD,EAAe7B,gBAAQ,IAAA8B,GAAQ,QAARC,EAAvBD,EAAyBzB,cAAM,IAAA0B,OAAlB,EAAbA,EAAiCzB,aAE5C,QAAb0B,EAAA9B,EAAOG,cAAM,IAAA2B,GAAU,QAAVC,EAAbD,EAAehC,gBAAQ,IAAAiC,OAAV,EAAbA,EAAyB3L,QAASsM,EAAAA,GAAgBC,QAClDxR,MAAMC,QAAQqR,IACdA,EAAkBvb,SAElBsb,GAAaI,EAAAA,EAAAA,SACXH,EAAkB3R,KAAI,SAAC+R,GAAsB,IAADC,EAO1C,GAA2B,QAA3BA,EAAID,EAAiB1C,cAAM,IAAA2C,GAAvBA,EAAyBC,OAAQ,OAAOF,EAAiB3X,IAC/D,MAKJsX,EAAarR,MAAMC,QAAqB,QAAd4Q,EAAChC,EAAOG,cAAM,IAAA6B,OAAA,EAAbA,EAAee,QACtCP,EAAWxb,OAAoB,QAAdib,EAACjC,EAAOG,cAAM,IAAA8B,OAAA,EAAbA,EAAec,QACjCP,EAGJ,IAgD6CQ,EAhDvCC,EAAwC,QAAhBf,EAAGlC,EAAOG,cAAM,IAAA+B,OAAA,EAAbA,EAAepC,SAG1CoD,IAA8BZ,EAAca,KAG5CC,IAA2BH,EAK3BI,GAAyD,KAAb,QAAblB,EAAAnC,EAAOG,cAAM,IAAAgC,OAAA,EAAbA,EAAeY,QAG9CO,IACFd,EAAWtb,SAAWmc,EAG1B,GAAIA,EAA8B,CAEhC,IAC2BE,EADrBC,GAAiBC,EAAAA,EAAAA,GAAmB5Y,GAC1C,IAAwB,IAApB2Y,EAGF,MAAO,CACLpC,SAAS,EACTrH,QAAqB,QAAbwJ,EAAAvD,EAAOG,cAAM,IAAAoD,OAAA,EAAbA,EAAe/B,UAAW,GAClCH,SAAU,CACR,CACEnW,KAAM,kBACNgH,QAAQ,0DAADlL,OAA4Dwc,KAK7E,CAEA,GAAIF,GAGoB7S,IAAAA,SACpB5F,GACA,SAACgV,EAA4B6D,GAE3B,OAAOlB,EAAWmB,MAAK,SAACnS,GAAG,OAAKqO,EAAErO,KAASkS,EAAElS,EAAI,GACnD,IAGgBtK,SAAW2D,EAAM3D,OAGjC,MAAO,CACLka,SAAS,EACTrH,QAAqB,QAAbiJ,EAAAhD,EAAOG,cAAM,IAAA6C,OAAA,EAAbA,EAAexB,UAAW,GAClCH,SAAU,CACR,CACEnW,KAAM,kBACNgH,QAAQ,qGAADlL,OAAuGwb,EAAWoB,KACvH,KACD,QAgDX,OAxCA/Y,EAAMgZ,OAAM,SAACrD,EAAOsD,GAWlB,GATIZ,IAA8BZ,EAAcyB,IAAIvD,KAClDD,EAAUtQ,KAAK,CACb/E,KAAM,kBACNgH,QAAQ,uCAADlL,OAAyCwZ,KAElD6B,GAAW,GAITe,GAA0BH,EAA0B,CAEtD,IAQoCe,EAR9BC,EAAwB9C,EAC5B8B,EACAzC,EACAP,EAAM,GAADjZ,OACF/B,EAAY,KAAA+B,OAAI8c,EAAK,MAI1B,IAAKG,EAAsB7C,QACzBiB,GAAW,EACmB,QAA9B2B,EAAAC,EAAsB5C,gBAAQ,IAAA2C,GAA9BA,EAAgCpE,SAAQ,SAAC1N,GAAO,OAC9CqO,EAAUtQ,KAAK,CACb/E,KAAMgH,EAAQhH,KACdgH,QAAQ,2BAADlL,OAA6B8c,EAAK,MAAA9c,OAAKkL,EAAQA,UACtD,GAGR,CAIA,QAAIqO,EAAUrZ,QAlO8B,KAkOiBmb,EAI/D,IAEO,CACLjB,QAASiB,EACTtI,OAAQsI,EAAWxX,GAAqB,QAAbuX,EAAApC,EAAOG,cAAM,IAAAiC,OAAA,EAAbA,EAAeZ,UAAW,GACrDH,SAAUd,EAEd,CAEA,SAAS2D,EAAyBrZ,GAKhC,IAAMsZ,GAAcC,EAAAA,EAAAA,UAASvZ,GAAS2Q,KAAKC,UAAU5Q,EAAO,KAAM,GAAKA,EAOvE,OAN+BwZ,EAAAA,EAAAA,GAC7BF,EACA,MACA,EACA5E,GAEsBA,CAC1B,CAeA,SAAS+E,EAAqBxD,GAC5B,GAAKA,EAUL,OATA/a,OAAO2M,KAAKoO,GAAKlB,SAAQ,SAACpO,GACA,kBAAbsP,EAAItP,IAAqBsP,EAAItP,GAAKtK,OAAS,IACpD4Z,EAAItP,GAAOsP,EAAItP,GAAKtM,UAAU,EAAG,MACxBkf,EAAAA,EAAAA,UAAStD,EAAItP,IACtBsP,EAAItP,GAAO8S,EAAqBxD,EAAItP,KAC3BJ,EAAAA,EAAAA,SAAQ0P,EAAItP,MACrBsP,EAAItP,GAAOsP,EAAItP,GAAKV,KAAI,SAAChL,GAAS,OAAKwe,EAAqBxe,EAAK,IAErE,IACOgb,CACT,CAGO,IAAMK,EAAW,SACtBnB,EACAnV,EACAoV,GAEwB,IADxBhb,EAAY+Q,UAAA9O,OAAA,QAAAqK,IAAAyE,UAAA,GAAAA,UAAA,GAAG,GAETuO,EAAaC,EAAWxE,EAAO5J,MAC/BqO,EAAc,CAClBrD,SAAS,EACTrH,OAAQlP,GAEV,OAAK0Z,GAEEA,EAAWvE,EAAQnV,EAAOoV,EAAOhb,IAFhBwf,CAG1B,EAEaC,EACX,uCAEK,SAASC,EAAgB3E,GAAgD,IAAD4E,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAC7E,IAAKxF,EAAQ,MA/SqB,uBAgTlC,OAAQA,EAAO5J,MACb,KAAKsM,EAAAA,GAAgB+C,SACnB,OAAoB,QAAbb,EAAA5E,EAAOG,cAAM,IAAAyE,GAAU,QAAVC,EAAbD,EAAec,gBAAQ,IAAAb,OAAV,EAAbA,EAAyBzO,OAAQ,UAC1C,KAAKsM,EAAAA,GAAgBiD,KACnB,IAK0BC,EALtBtN,EAAS,SACb,GAAiB,QAAjBwM,EAAI9E,EAAOG,cAAM,IAAA2E,GAAbA,EAAexC,cAAe,CAChC,IAAMuD,EAAU7F,EAAOG,OAAOmC,cAAcsB,KAAK,OACjDtL,GAAe,MAAAtR,OAAS6e,EAAO,KACjC,CACA,GAAiB,QAAjBd,EAAI/E,EAAOG,cAAM,IAAA4E,GAAbA,EAAee,MACjBxN,EAAsB,QAAhBsN,EAAG5F,EAAOG,cAAM,IAAAyF,OAAA,EAAbA,EAAeE,MAAMrM,OAGhC,OADiB,QAAjBuL,EAAIhF,EAAOG,cAAM,IAAA6E,GAAU,QAAVC,EAAbD,EAAeU,gBAAQ,IAAAT,GAAvBA,EAAyB7O,OAAMkC,EAAsB,QAAhB4M,EAAGlF,EAAOG,cAAM,IAAA+E,OAAA,EAAbA,EAAeQ,SAAStP,MAC7DkC,EACT,KAAKoK,EAAAA,GAAgBqD,MACnB,MAAO,SACT,KAAKrD,EAAAA,GAAgBsD,gBACnB,MAAO,uBACT,KAAKtD,EAAAA,GAAgBuD,QACnB,MAAO,UACT,KAAKvD,EAAAA,GAAgBwD,OACnB,IACwBC,EAGAC,EAJpBC,EAAiB,SACrB,GAAiB,QAAjBlB,EAAInF,EAAOG,cAAM,IAAAgF,GAAbA,EAAemB,IACjBD,EAAc,GAAArf,OAAMqf,EAAc,UAAArf,OAAsB,QAAtBmf,EAASnG,EAAOG,cAAM,IAAAgG,OAAA,EAAbA,EAAeG,KAE5D,GAAiB,QAAjBlB,EAAIpF,EAAOG,cAAM,IAAAiF,GAAbA,EAAemB,IACjBF,EAAc,GAAArf,OAAMqf,EAAc,UAAArf,OAAsB,QAAtBof,EAASpG,EAAOG,cAAM,IAAAiG,OAAA,EAAbA,EAAeG,KAM5D,OAJiB,QAAjBlB,EAAIrF,EAAOG,cAAM,IAAAkF,GAAbA,EAAe/D,WACjB+E,EAAc,GAAArf,OAAMqf,EAAc,cAG7BA,EACT,KAAK3D,EAAAA,GAAgBC,OACnB,IACgC6D,EAD5BC,EAAa,SACjB,OAAiB,QAAjBnB,EAAItF,EAAOG,cAAM,IAAAmF,GAAbA,EAAelF,aACjBqG,EAAa,IACA,QAAbD,EAAAxG,EAAOG,cAAM,IAAAqG,GAAbA,EAAepG,YAAYR,SAAQ,SAACiD,GAClC,IAAM6D,EAAY/B,EAAgB9B,GAClC4D,EAAU,GAAAzf,OAAMyf,EAAU,MAAAzf,OAAK6b,EAAiB3X,KAAI,QAAAlE,OAAO0f,EAAS,KACtE,IACAD,EAAU,GAAAzf,OAAMyf,EAAWvhB,UAAU,EAAGuhB,EAAWvf,OAAS,GAAE,OAGzDuf,EACT,KAAK/D,EAAAA,GAAgBiE,MACrB,KAAKjE,EAAAA,GAAgBkE,oBACnB,GAAiB,QAAjBrB,EAAIvF,EAAOG,cAAM,IAAAoF,GAAbA,EAAejD,cAAe,CAAC,IAADuE,EAC1BhB,EAAuB,QAAhBgB,EAAG7G,EAAOG,cAAM,IAAA0G,OAAA,EAAbA,EAAevE,cAAcsB,KAAK,SAClD,MAAM,UAAN5c,OAAiB6e,EAAO,KAC1B,CACA,GAAiB,QAAjBL,EAAIxF,EAAOG,cAAM,IAAAqF,GAAbA,EAAe1F,SAAU,CAC3B,IAAMA,EAAW6E,EAAgB3E,EAAOG,OAAOL,UAC/C,MAAM,SAAN9Y,OAAgB8Y,EAAQ,IAC1B,CACA,MAAO,QACT,KAAK4C,EAAAA,GAAgBoE,aACnB,MAAM,gBACR,KAAKpE,EAAAA,GAAgBqE,UACnB,MAAM,8CACR,KAAKrE,EAAAA,GAAgBsE,SACnB,MAAO,MAEb,CAEO,IAAMxC,GAA8CyC,EAAA,IAAA3f,EAAAA,EAAAA,GAAA2f,EACxDvE,EAAAA,GAAgBiD,MAAO,SACtB3F,EACAnV,EACAoV,GACwB,IAADiH,EAAAC,EAAAC,EAAAC,EAAAC,EACoCC,EACZC,EAD/C,QAAcjW,IAAV1G,GAAiC,OAAVA,GAA4B,KAAVA,EAC3C,OAAImV,EAAOG,QAAUH,EAAOG,OAAOmB,SAC1B,CACLF,SAAS,EACTrH,QAAqB,QAAbyN,EAAAxH,EAAOG,cAAM,IAAAqH,OAAA,EAAbA,EAAehG,UAAW,GAClCH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,KAAA1d,OAAI2d,EAC1C3E,OAOH,CACLoB,SAAS,EACTrH,QAAqB,QAAbwN,EAAAvH,EAAOG,cAAM,IAAAoH,OAAA,EAAbA,EAAe/F,UAAW,IAGtC,IAAIzH,EAASlP,EAEb,IAAIuZ,EAAAA,EAAAA,UAASvZ,GACX,OACEmV,EAAOG,QACPH,EAAOG,OAAOsH,iBACdvD,EAAyBrZ,GAElB,CACLuW,SAAS,EACTrH,OAAQyB,KAAKC,UAAU6I,EAAqBzZ,IAC5CwW,SAAU,CACR,CACEnW,KAAM,kBACNgH,QAASsN,KAKV,CACL4B,SAAS,EACTrH,OAAQyB,KAAKC,UAAU6I,EAAqBzZ,GAAQ,KAAM,GAC1DwW,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,KAAA1d,OAAI2d,EAC1C3E,OAOV,IAmCkC0H,EACuCC,EAcrBC,EAhO1BC,EAAcC,EAkPtCC,EApEI3G,GAAU4G,EAAAA,EAAAA,UAASjO,GACnBkO,EAAwB,CAC5B7G,SAAS,EACTrH,QAAqB,QAAbmN,EAAAlH,EAAOG,cAAM,IAAA+G,OAAA,EAAbA,EAAe1F,UAAW,GAClCH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,KAAA1d,OAAI2d,EAAgB3E,OAIlE,IAAKoB,EACH,IAAK,IAAD8G,EACF,GAAkB,QAAdA,EAAClI,EAAOG,cAAM,IAAA+H,GAAbA,EAAeC,OACf,OAAOF,EADgBlO,GAAS9T,EAAAA,EAAAA,UAAS8T,EAIhD,CAFE,MAAO1O,GACP,OAAO4c,CACT,CAEF,GACEjI,EAAOG,QACPH,EAAOG,OAAOsH,iBACdvD,EAAyBrZ,GAEzB,MAAO,CACLuW,SAAS,EACTrH,OAAQyB,KAAKC,UAAU5Q,GACvBwW,SAAU,CACR,CACEnW,KAAM,kBACNgH,QAASsN,KAKjB,GAAiB,QAAjB2H,EAAInH,EAAOG,cAAM,IAAAgH,GAAbA,EAAe7E,gBACC,QAAdoF,EAAC1H,EAAOG,cAAM,IAAAuH,IAAbA,EAAepF,cAAc9O,SAAUuG,EAAkBlJ,SAC5D,MAAO,CACLkJ,QAAqB,QAAb4N,EAAA3H,EAAOG,cAAM,IAAAwH,OAAA,EAAbA,EAAenG,UAAW,GAClCH,SAAU,CACR,CACEnW,KAAM,kBACNgH,QAAQ,qBAADlL,OAAuB+S,KAGlCqH,SAAS,GAKf,OAhO0ByG,EAgOD9N,EAhOe+N,EAgOG,IA3NnB,KADHzD,EAAAA,EAAAA,GAAiBwD,EAAM,MAAM,EAAO,IAC5BA,EAAK3gB,OAAS4gB,EA4NlC,CACL/N,OAAe,QAAT6N,EAAG7N,SAAM,IAAA6N,OAAA,EAAPA,EAAoB1iB,UAAU,EAAG,KACzCkc,SAAS,EACTC,SAAU,CACR,CACEnW,KAAM,kBACNgH,QACE,2FAOK,QAAbkV,EAAApH,EAAOG,cAAM,IAAAiH,IAAbA,EAAetB,SACfsC,EAAAA,EAAAA,UAAsB,QAAdf,EAACrH,EAAOG,cAAM,IAAAkH,OAAA,EAAbA,EAAevB,QACV,QAAdwB,EAACtH,EAAOG,cAAM,IAAAmH,GAAbA,EAAexB,MAAMnW,KAAKoK,GAgBtB,CACLqH,SAAS,EACTrH,OAAAA,GAhBO,CACLA,QAAqB,QAAbgO,EAAA/H,EAAOG,cAAM,IAAA4H,OAAA,EAAbA,EAAevG,UAAW,GAClCH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,KAAA1d,OAAI2d,EAC1C3E,MAINoB,SAAS,EAQf,KAAC9Z,EAAAA,EAAAA,GAAA2f,EAEAvE,EAAAA,GAAgBqD,OAAQ,SACvB/F,EACAnV,EACAoV,EACAhb,GAEA,IAAAojB,EAAsC7D,EAAW9B,EAAAA,GAAgBiD,MAC/D3F,EACAnV,EACAoV,EACAhb,GAJMmc,EAAOiH,EAAPjH,QAASC,EAAQgH,EAARhH,SAAUtH,EAAMsO,EAANtO,OAO3B,OAAKqH,EAeE,CAAEA,QAAAA,EAASrH,OAAAA,EAAQsH,SAAAA,GAdjB,CACLD,SAAS,EACTrH,OAAQ,IAAIuO,OAAOvO,GACnBsH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,KAAA1d,OAAI2d,EAC1C3E,MAQZ,KAAC1Y,EAAAA,EAAAA,GAAA2f,EACAvE,EAAAA,GAAgBwD,QAAS,SACxBlG,EACAnV,EACAoV,GACwB,IAADsI,EAAAC,EAAAC,EACoCC,EAC5BC,EAaXC,EAY6BC,EA1BjD,QAActX,IAAV1G,GAAiC,OAAVA,GAA4B,KAAVA,EAC3C,OAAiB,QAAjB6d,EAAI1I,EAAOG,cAAM,IAAAuI,GAAbA,EAAepH,SACV,CACLF,SAAS,EACTrH,QAAqB,QAAb4O,EAAA3I,EAAOG,cAAM,IAAAwI,OAAA,EAAbA,EAAenH,UAAW,EAClCH,SAAU,CACR,CACEnW,KAAM,kBACNgH,QAAS,4BAMH,KAAVrH,EACK,CACLuW,SAAS,EACTrH,QAAqB,QAAb6O,EAAA5I,EAAOG,cAAM,IAAAyI,OAAA,EAAbA,EAAepH,UAAW,GAI/B,CACLJ,SAAS,EACTrH,OAAQlP,GAGZ,IAAKie,OAAOC,SAASle,MAAWmd,EAAAA,EAAAA,UAASnd,GACvC,MAAO,CACLuW,SAAS,EACTrH,QAAqB,QAAb8O,EAAA7I,EAAOG,cAAM,IAAA0I,OAAA,EAAbA,EAAerH,UAAW,EAClCH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,KAAA1d,OAAI2d,EAC1C3E,OAQV,IAwB0CgJ,EAAAC,EAxBtClP,EAAiBlP,EACrB,IAAImd,EAAAA,EAAAA,UAASnd,GAAQ,CAGX,IAADqe,EAFP,IAAI,gBAAgBvZ,KAAK9E,GAGvB,MAAO,CACLuW,SAAS,EACTrH,OAAQlP,IAAsB,QAAjBqe,EAAIlJ,EAAOG,cAAM,IAAA+I,OAAA,EAAbA,EAAe1H,UAAW,EAC3CH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,KAAA1d,OAAI2d,EAC1C3E,OATRjG,EAAS+O,OAAOje,EAepB,CAEA,QACyB0G,KAAV,QAAbgX,EAAAvI,EAAOG,cAAM,IAAAoI,OAAA,EAAbA,EAAejC,MACfwC,OAAOC,SAAS/I,EAAOG,OAAOmG,MAE1BvM,EAAS+O,OAAO9I,EAAOG,OAAOmG,KAChC,MAAO,CACLlF,SAAS,EACTrH,QAGsC,IAApCiG,EAAOG,OAAOgJ,kBACVpP,GAAUiG,EAAOG,OAAOmG,KAAO,EACJ,QADK0C,EAC1B,QAD0BC,EAChClP,SAAM,IAAAkP,EAAAA,EAAIjJ,EAAOG,OAAOmG,WAAG,IAAA0C,EAAAA,EAAI,EACrC3H,SAAU,CACR,CACEnW,KAAM,aACNgH,QAAQ,0BAADlL,OAA4BgZ,EAAOG,OAAOmG,QAO3D,YACyB/U,KAAV,QAAbiX,EAAAxI,EAAOG,cAAM,IAAAqI,OAAA,EAAbA,EAAejC,MACfuC,OAAOC,SAAS/I,EAAOG,OAAOoG,MAE1BxM,EAAS+O,OAAO9I,EAAOG,OAAOoG,KACzB,CACLnF,SAAS,EACTrH,OAAQiG,EAAOG,OAAOoG,KAAOxM,GAAU,EACvCsH,SAAU,CACR,CACEnW,KAAM,aACNgH,QAAQ,0BAADlL,OAA4BgZ,EAAOG,OAAOoG,QAM1C,QAAbkC,EAAAzI,EAAOG,cAAM,IAAAsI,GAAbA,EAAeW,UAAYrP,EAAS,IAAM+O,OAAOO,UAAUtP,IACtD,CACLqH,SAAS,EACTrH,OAAQiG,EAAOG,OAAOqB,SAAWzH,GAAU,EAC3CsH,SAAU,CACR,CACEnW,KAAM,kBACNgH,QAAQ,wCAMT,CACLkP,SAAS,EACTrH,OAAAA,EAEJ,KAACzS,EAAAA,EAAAA,GAAA2f,EACAvE,EAAAA,GAAgBuD,SAAU,SACzBjG,EACAnV,EACAoV,GAE4D,IAADqJ,EACZC,EAe3BC,EAhBpB,QAAcjY,IAAV1G,GAAiC,OAAVA,GAA4B,KAAVA,EAC3C,OAAImV,EAAOG,QAAUH,EAAOG,OAAOmB,SAC1B,CACLF,SAAS,EACTrH,SAAuB,QAAdwP,EAACvJ,EAAOG,cAAM,IAAAoJ,IAAbA,EAAe/H,SACzBH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,KAAA1d,OAAI2d,EAC1C3E,OAOI,KAAVnV,EACK,CACLuW,SAAS,EACTrH,QAAqB,QAAbyP,EAAAxJ,EAAOG,cAAM,IAAAqJ,OAAA,EAAbA,EAAehI,WAAW,GAI/B,CAAEJ,SAAS,EAAMrH,QAAqB,QAAbuP,EAAAtJ,EAAOG,cAAM,IAAAmJ,OAAA,EAAbA,EAAe9H,UAAW3W,GAE5D,IAOc4e,EANRC,EAA8B,SAAV7e,GAA8B,UAAVA,EACxCuW,GAFuB,IAAVvW,IAA4B,IAAVA,GAEP6e,EAE1B3P,EAASlP,EAGb,OAFI6e,IAAmB3P,EAAmB,UAAVlP,GAE3BuW,EAeE,CAAEA,QAAAA,EAASrH,OAAAA,GAdT,CACLqH,SAAS,EACTrH,QAAqB,QAAb0P,EAAAzJ,EAAOG,cAAM,IAAAsJ,OAAA,EAAbA,EAAejI,WAAW,EAClCH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,KAAA1d,OAAI2d,EAC1C3E,MAQZ,KAAC1Y,EAAAA,EAAAA,GAAA2f,EACAvE,EAAAA,GAAgBC,QAAS,SACxB3C,EACAnV,EACAoV,EACAhb,GAMG,IAAD0kB,EAC6CC,EAL/C,QACYrY,IAAV1G,GACU,OAAVA,IACCmd,EAAAA,EAAAA,UAASnd,IAAkC,IAAxBA,EAAMgG,OAAO3J,OAEjC,OAAI8Y,EAAOG,QAAUH,EAAOG,OAAOmB,SAC1B,CACLF,SAAS,EACTrH,QAAqB,QAAb6P,EAAA5J,EAAOG,cAAM,IAAAyJ,OAAA,EAAbA,EAAepI,UAAW,CAAC,EACnCH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,MAAA1d,OAAK2d,EAC3C3E,OAMH,CACLoB,SAAS,EACTrH,QAAqB,QAAb4P,EAAA3J,EAAOG,cAAM,IAAAwJ,OAAA,EAAbA,EAAenI,UAAW3W,GAItC,IAAIgf,EAAAA,EAAAA,eAAchf,GAChB,OAAOkV,EACLC,EACAnV,EACAoV,EACAhb,GAIJ,IAAK,IAAD6kB,EACIxR,EAAS,CAAEyB,OAAQyB,KAAKuO,MAAMlf,GAAkBuW,SAAS,GAC/D,OAAIyI,EAAAA,EAAAA,eAAcvR,EAAOyB,QAChBgG,EAAoBC,EAAQ1H,EAAOyB,OAAQkG,EAAOhb,GAEpD,CACLmc,SAAS,EACTrH,QAAqB,QAAb+P,EAAA9J,EAAOG,cAAM,IAAA2J,OAAA,EAAbA,EAAetI,UAAW,CAAC,EACnCH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,MAAA1d,OAAK2d,EAC3C3E,MAkBV,CAbE,MAAO3U,GAAI,IAAD2e,EACV,MAAO,CACL5I,SAAS,EACTrH,QAAqB,QAAbiQ,EAAAhK,EAAOG,cAAM,IAAA6J,OAAA,EAAbA,EAAexI,UAAW,CAAC,EACnCH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,MAAA1d,OAAK2d,EAC3C3E,MAKV,CACF,KAAC1Y,EAAAA,EAAAA,GAAA2f,EACAvE,EAAAA,GAAgBiE,OAAQ,SACvB3G,EACAnV,EACAoV,EACAhb,GACwB,IAADglB,EA0BHC,EAMmCC,EA/BjDC,EAAkB,CACtBhJ,SAAS,EACTrH,QAAqB,QAAbkQ,EAAAjK,EAAOG,cAAM,IAAA8J,OAAA,EAAbA,EAAezI,UAAW,GAClCH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,KAAA1d,OAAI2d,EAAgB3E,OAIlE,QAAczO,IAAV1G,GAAiC,OAAVA,GAA4B,KAAVA,EAC3C,OACEmV,EAAOG,QACPH,EAAOG,OAAOmB,YACblQ,EAAAA,EAAAA,SAAQ4O,EAAOG,OAAOqB,UAEvB4I,EAAgB/I,SAAW,CACzB,CACEnW,KAAM,kBACNgH,QACE,mEAGCkY,GAEK,KAAVvf,EACK,CACLuW,SAAS,EACTrH,QAAqB,QAAbmQ,EAAAlK,EAAOG,cAAM,IAAA+J,OAAA,EAAbA,EAAe1I,UAAW,IAGlCxB,EAAOG,SAAU/O,EAAAA,EAAAA,SAAQ4O,EAAOG,OAAOqB,SAClC,CACLJ,SAAS,EACTrH,OAAqB,QAAfoQ,EAAEnK,EAAOG,cAAM,IAAAgK,OAAA,EAAbA,EAAe3I,SAIpB,CACLJ,SAAS,EACTrH,OAAQlP,GAIZ,IAAImd,EAAAA,EAAAA,UAASnd,GACX,IACE,IAAMwf,EAAS7O,KAAKuO,MAAMlf,GAC1B,GAAIsG,MAAMC,QAAQiZ,GAEhB,OADe5I,EAAczB,EAAQqK,EAAQpK,EAAOhb,EAKxD,CAFE,MAAOoG,GACP,OAAO+e,CACT,CAGF,OAAIjZ,MAAMC,QAAQvG,GACT4W,EAAczB,EAAQnV,EAAOoV,EAAOhb,GAGtCmlB,CACT,KAAC9iB,EAAAA,EAAAA,GAAA2f,EACAvE,EAAAA,GAAgBoE,cAAe,SAC9B9G,EACAnV,EACAoV,GACwB,IAADqK,EAWoCC,EAGvCC,EAbdJ,EAAkB,CACtBhJ,SAAS,EACTrH,QAAqB,QAAbuQ,EAAAtK,EAAOG,cAAM,IAAAmK,OAAA,EAAbA,EAAe9I,UAAW,CAAC,CAAC,GACpCH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,KAAA1d,OAAI2d,EAAgB3E,OAIlE,QAAczO,IAAV1G,GAAiC,OAAVA,GAA4B,KAAVA,EAC3C,OAAiB,QAAjB0f,EAAIvK,EAAOG,cAAM,IAAAoK,GAAbA,EAAejJ,SAAiB8I,EAEtB,KAAVvf,EACK,CACLuW,SAAS,EACTrH,QAAqB,QAAbyQ,EAAAxK,EAAOG,cAAM,IAAAqK,OAAA,EAAbA,EAAehJ,UAAW,CAAC,CAAC,IAIjC,CAAEJ,SAAS,EAAMrH,OAAQlP,GAElC,KAAKmd,EAAAA,EAAAA,UAASnd,KAAWsG,MAAMC,QAAQvG,GACrC,OAAOuf,EAGT,IAAIrQ,EAASlP,EAEb,IAAImd,EAAAA,EAAAA,UAASnd,GACX,IACEkP,EAASyB,KAAKuO,MAAMlf,EAGtB,CAFE,MAAOQ,GACP,OAAO+e,CACT,CAGF,GAAIjZ,MAAMC,QAAQ2I,GAAS,CACC,IAAD0Q,EAGhBC,EAHT,GAAsB,IAAlB3Q,EAAO7S,OACT,OAAiB,QAAjBujB,EAAIzK,EAAOG,cAAM,IAAAsK,GAAbA,EAAenJ,SACV8I,EAEA,CACLhJ,SAAS,EACTrH,QAAqB,QAAb2Q,EAAA1K,EAAOG,cAAM,IAAAuK,OAAA,EAAbA,EAAelJ,UAAW,CAAC,CAAC,IAGzC,IAEkDnX,EAFlDC,GAAAC,EAAAA,EAAAA,GAEkCwP,EAAO7P,WAAS,IAAnD,IAAAI,EAAAG,MAAAJ,EAAAC,EAAAI,KAAAC,MAAqD,CAAC,IAADggB,GAAAvgB,EAAAA,EAAAA,GAAAC,EAAAQ,MAAA,GAAzCiZ,EAAK6G,EAAA,GAAEC,EAAWD,EAAA,GAC5B,KAAKd,EAAAA,EAAAA,eAAce,GACjB,OAAAje,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACKyd,GAAe,IAClB/I,SAAU,CACR,CACEnW,KAAM,kBACNgH,QAAQ,2BAADlL,OAA6B8c,MAK9C,CAAC,OAAA1Y,GAAAd,EAAAe,EAAAD,EAAA,SAAAd,EAAAgB,GAAA,CACD,MAAO,CAAE8V,SAAS,EAAMrH,OAAAA,EAC1B,CACA,OAAOqQ,CACT,KAAC9iB,EAAAA,EAAAA,GAAA2f,EAEAvE,EAAAA,GAAgBkE,qBAAsB,SACrC5G,EACAnV,EACAoV,EACAhb,GACwB,IAAD4lB,EAAAC,EAiB8BC,EAhBjDnN,EAA+B,CACjCwD,SAAS,EACTrH,QAAqB,QAAb8Q,EAAA7K,EAAOG,cAAM,IAAA0K,OAAA,EAAbA,EAAerJ,UAAW,GAClCH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,KAAA1d,OAAI2d,EAAgB3E,OAMlE,KAFApC,EAAW4G,EAAWmC,MAAM3G,EAAQnV,EAAOoV,EAAOhb,IAEpCmc,QACZ,OAAOxD,EAGT,GAAiB,QAAbkN,EAAA9K,EAAOG,cAAM,IAAA2K,GAAbA,EAAe/H,QAAUnF,EAAS7D,OAAO7S,SACvCkK,EAAAA,EAAAA,SAAqB,QAAd2Z,EAAC/K,EAAOG,cAAM,IAAA4K,OAAA,EAAbA,EAAehI,QAAS,CAAC,IAADiI,EACOC,EADPC,GAAA3gB,EAAAA,EAAAA,GACD,QADCygB,EACdhL,EAAOG,cAAM,IAAA6K,OAAA,EAAbA,EAAejI,QAAM,QAAAvN,EAAA,WAAG,IAAjC2V,EAAKF,EAAApgB,MACRugB,EAAiB3L,EAAK7B,EAAS7D,OAAQoR,GACvCE,EAAiBD,EAAeta,KAAI,SAAC0P,GAAK,OAC9C8K,EAAAA,EAAAA,KAAI9K,EAAO2K,EAAO,GAAG,KAEnBI,EAAAA,EAAAA,MAAKF,GAAgBnkB,SAAWkkB,EAAelkB,SACjD0W,GAAQjR,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACHiR,GAAQ,IACXwD,SAAS,EACTC,SAAU,CACR,CACEnW,KAAM,kBACNgH,QAAQ,QAADlL,OAAUmkB,EAAK,+CAKhC,EAjBA,IAAAD,EAAAzgB,MAAAwgB,EAAAC,EAAAxgB,KAAAC,MAAA6K,GAiBC,OAAApK,GAAA8f,EAAA7f,EAAAD,EAAA,SAAA8f,EAAA5f,GAAA,CACH,CAEF,OAAOsS,CACT,KAACtW,EAAAA,EAAAA,GAAA2f,EACAvE,EAAAA,GAAgBsD,iBAAkB,SACjChG,EACAnV,EACAoV,GAEA,IAIoCuL,EAAAC,EAJhCrK,GAAU,EACVrH,EAASlP,EACTqH,EAAU,CAAEhH,KAAM,GAAIgH,QAAS,IAEnC,GAAIzB,IAAAA,MAAQ5F,IAAoB,KAAVA,EACpBkP,EAAsB,QAAhByR,EAAGxL,EAAOG,cAAM,IAAAqL,OAAA,EAAbA,EAAehK,QAEP,QAAjBiK,EAAIzL,EAAOG,cAAM,IAAAsL,GAAbA,EAAenK,UACjBF,GAAU,EACVlP,EAAU,CACRhH,KAAM,YACNgH,QAAQ,yBAADlL,OAA2B2d,EAAgB3E,MAGpDoB,GAAU,OAEP,GAAqB,kBAAVvW,GAAsB+Q,IAAO/Q,GAAOuW,UAEpDA,GAAU,EACVrH,EAAS6B,IAAO/Q,GAAO6gB,aAAY,QAC9B,IAAI1D,EAAAA,EAAAA,UAASnd,GAAQ,CAE1B,GACEA,IAAU+Q,IAAO/Q,GAAO6gB,eACxB7gB,IAAU+Q,IAAO/Q,GAAO6gB,aAAY,GAEpC,MAAO,CACLtK,SAAS,EACTrH,OAAQlP,GAKJ,IAAD8gB,EAHI/P,IAAO/Q,GAAOuW,WACvBA,GAAU,EACVrH,EAAS6B,IAAO/Q,GAAO6gB,aAAY,KAEnCtK,GAAU,EACVlP,EAAU,CACRhH,KAAM,YACNgH,QAAQ,yBAADlL,OAA2B2d,EAAgB3E,KAEpDjG,EAAsB,QAAhB4R,EAAG3L,EAAOG,cAAM,IAAAwL,OAAA,EAAbA,EAAenK,QAE5B,MACEJ,GAAU,EACVlP,EAAU,CACRhH,KAAM,YACNgH,QAAQ,yBAADlL,OAA2B2d,EAAgB3E,KAItD,IAAM1H,EAA6B,CACjC8I,QAAAA,EACArH,OAAAA,GAOF,OAJI7H,IACFoG,EAAO+I,SAAW,CAACnP,IAGdoG,CACT,KAAChR,EAAAA,EAAAA,GAAA2f,EACAvE,EAAAA,GAAgB+C,UAAW,SAC1BzF,EACAnV,EACAoV,EACAhb,GACwB,IAAD2mB,EAAAC,EACjBzB,EAAkB,CACtBhJ,SAAS,EACTrH,YAAQxI,EACR8P,SAAU,CACR,CACEnW,KAAM,kBACNgH,QAAS,wBAIf,GAAiB,QAAb0Z,EAAA5L,EAAOG,cAAM,IAAAyL,GAAbA,EAAeE,WAAY9D,EAAAA,EAAAA,UAAsB,QAAd6D,EAAC7L,EAAOG,cAAM,IAAA0L,OAAA,EAAbA,EAAeC,UACrD,IASE,OARmBC,EAAAA,EAAAA,IACjB/L,EAAOG,OAAO2L,SACd,CAAC,EACD,CAAC,GACD,OACAva,EACA,CAAC1G,EAAOoV,EAAOxP,IAAGmL,IAAQ3W,EAAc+a,IANlC1H,MAWV,CAFE,MAAOjN,GACPiP,EAAAA,MAAU,8BAA+B,CAAEjP,EAAAA,GAC7C,CAEF,OAAO+e,CACT,KAAC9iB,EAAAA,EAAAA,GAAA2f,EACAvE,EAAAA,GAAgBqE,WAAY,SAC3B/G,EACAnV,EACAoV,GACwB,IAAD+L,EACjB5B,EAAkB,CACtBhJ,SAAS,EACTrH,QAAqB,QAAbiS,EAAAhM,EAAOG,cAAM,IAAA6L,OAAA,EAAbA,EAAexK,UAAW,GAClCH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,MAAA1d,OAAK2d,EAC3C3E,OAQR,QACYzO,IAAV1G,GACU,OAAVA,IACCmd,EAAAA,EAAAA,UAASnd,IAAkC,IAAxBA,EAAMgG,OAAO3J,OAEjC,OAAI8Y,EAAOG,QAAUH,EAAOG,OAAOmB,SAAiB8I,EAC7C,CAAEhJ,SAAS,EAAMrH,OAAQlP,GAElC,IAAImd,EAAAA,EAAAA,UAASnd,GAAQ,CACnB,GAVoB,0EAUF8E,KAAK9E,EAAMgG,QAC3B,MAAO,CAAEuQ,SAAS,EAAMrH,OAAQlP,EAAMgG,QAExC,GAduB,yBAcFlB,KAAK9E,GACxB,MAAO,CACLuW,SAAS,EACTrH,OAAQlP,GAGZ,GArBkB,0EAqBF8E,KAAK9E,IAAUohB,KAAKC,KAAKrhB,MAAYA,EACnD,MAAO,CAAEuW,SAAS,EAAMrH,OAAO,yBAAD/S,OAA2B6D,GAE7D,CACA,OAAOuf,CACT,KAAC9iB,EAAAA,EAAAA,GAAA2f,EACAvE,EAAAA,GAAgBsE,UAAW,SAC1BhH,EACAnV,GACwB,IAADshB,EACjB/B,EAAkB,CACtBhJ,SAAS,EACTrH,QAAc,OAANiG,QAAM,IAANA,GAAc,QAARmM,EAANnM,EAAQG,cAAM,IAAAgM,OAAR,EAANA,EAAgB3K,UAAW,GACnCH,SAAU,CACR,CACEnW,KAAM,YACNgH,QAAQ,GAADlL,OAAK0d,EAA4B,MAAA1d,OAAK2d,EAC3C3E,OAMR,MAAqB,kBAAVnV,IAAsBuhB,EAAAA,EAAAA,GAAavhB,GACrC,CACLuW,SAAS,EACTrH,OAAQlP,GAGHuf,CAEX,KAAC9iB,EAAAA,EAAAA,GAAA2f,EAaAvE,EAAAA,GAAgB2J,uBAAwB,SACvCrM,EACAnV,EACAoV,EACAhb,GACwB,IAADqnB,EACvB,GAAkB,QAAdA,EAACtM,EAAOG,cAAM,IAAAmM,IAAbA,EAAelW,KAClB,MAAO,CACLgL,SAAS,EACTrH,YAAQxI,EACR8P,SAAU,CACR,CACEnW,KAAM,kBACNgH,QAAS,wBAMjB,IAAMoG,EAASkM,EAAWxE,EAAOG,OAAO/J,MACtC4J,EAAOG,OACPtV,EACAoV,EACAhb,GAEF,GAAIqT,EAAO8I,QAAS,OAAO9I,EAG3B,IAYOiU,EAAAC,EAZDC,EAAc,GACpB,IAAIhc,IAAAA,QAAU5F,GAYZ,MAAO,CACLuW,SAAS,EACTrH,OAAqB,QAAfwS,EAAEvM,EAAOG,cAAM,IAAAoM,GAAQ,QAARC,EAAbD,EAAepM,cAAM,IAAAqM,OAAR,EAAbA,EAAuBhL,QAC/BH,SAAU/I,EAAO+I,UAfE,IACGrV,EADJE,GAAA3B,EAAAA,EAAAA,GACDM,GAAK,IAAxB,IAAAqB,EAAAzB,MAAAuB,EAAAE,EAAAxB,KAAAC,MAA0B,CAAC,IAAhB7E,EAAIkG,EAAAnB,MACPyN,EAASkM,EAAWxE,EAAOG,OAAO/J,MACtC4J,EAAOG,OACPra,EACAma,EACAhb,GAEF,IAAKqT,EAAO8I,QAAS,OAAO9I,EAC5BmU,EAAYxc,KAAKqI,EAAOyB,OAC1B,CAAC,OAAA3O,GAAAc,EAAAb,EAAAD,EAAA,SAAAc,EAAAZ,GAAA,CASH,MAAO,CACL8V,SAAS,EACTrH,OAAQ0S,EAEZ,IAACxF,8BCxtCSyF,uDAGX,SAHWA,GAAAA,EAAmB,sBAAnBA,EAAmB,0CAG9B,CAHWA,IAAAA,EAAmB,SCQD1hB,uBA8F9BsB,KAAKqgB,WA9FyB3hB,EA4C9B,SAA4Bge,GAMI,IAL9BnP,EAAMmP,EAANnP,OACA+S,EAAW5D,EAAX4D,YAKA,OAAQ/S,GACN,KAAK6S,EAAoBG,UACvB,IAAMC,EAAqC,CAAEvU,OAAQ,CAAC,GACtD,IACE,IAAAwU,EAIIH,EAHF9f,EAAYigB,EAAZjgB,aACAkgB,EAAWD,EAAXC,YACAC,EAAUF,EAAVE,WAEIC,GAAaC,EAAAA,EAAAA,IACjBH,EACAC,EACAngB,GAEFggB,EAAiBvU,OAAS2U,CACf,CAAX,MAAO7hB,GAAI,CACb,OAAOyhB,EAET,KAAKJ,EAAoBU,oBACvB,IAAQC,EAAcT,EAAdS,IAAKC,EAASV,EAATU,KACb,GAAID,EACF5X,EAAAA,GAAYxF,KAAI6K,MAAhBrF,EAAAA,IAAWpE,EAAAA,EAAAA,GAASic,SACf,IAAY,IAARD,EAAe,CAAC,IACHhjB,EADEC,GAAAC,EAAAA,EAAAA,GACN+iB,GAAI,QAAA9X,EAAA,WAAG,IAAdG,EAAGtL,EAAAQ,MACN0iB,EAAM9X,EAAAA,GAAY+X,WAAU,SAACC,GAAC,OAClCC,EAAAA,EAAAA,SAAQD,EAAE7X,SAAS+X,OAAQhY,EAAIC,SAAS+X,OAAO,IAEjD,IAAa,IAATJ,EAAW,MAAD,CAAAK,OAAA,GACdnY,EAAAA,GAAYoY,OAAON,EAAK,EAC1B,EANA,IAAAjjB,EAAAG,MAAAJ,EAAAC,EAAAI,KAAAC,MAAA,KAAAmjB,EAAAtY,IAAA,qBAAAsY,EAAA,OAAAA,EAAAF,CAAA,CAMC,OAAAxiB,GAAAd,EAAAe,EAAAD,EAAA,SAAAd,EAAAgB,GAAA,CACH,MACEyiB,EAAAA,EAAAA,MACAtY,EAAAA,GAAYxF,KAAI6K,MAAhBrF,EAAAA,IAAWpE,EAAAA,EAAAA,GAASic,IAEtB,OAAO,EAET,QAEEnmB,QAAQkM,MAAM,uCAAwCwG,GAG5D,EA3FS,SAACiD,GAEN,GADwBA,EAAMrF,KAAtByF,cACYlL,EAAAA,EAAYkM,QAAhC,CACA,IAAAnB,EAA4BD,EAAMrF,KAA1BuF,EAAID,EAAJC,KAAMC,EAASF,EAATE,UACNxF,EAAiBuF,EAAjBvF,KAAMoC,EAAWmD,EAAXnD,OACd,GAAKA,EAAL,CAEA,IAAMmU,EAAYC,YAAYC,MACxBC,EAAenjB,EAAG,CAAE6O,OAAAA,EAAQ+S,YAAanV,IACzC2W,EAAUH,YAAYC,MAC5B,GAAKC,EAEL,IACElc,EAAAA,EAAY/L,KAAKoG,KAAM,CACrB2Q,UAAAA,EACAC,YAAalL,EAAAA,EAAYmL,SACzBH,KAAM,CACJvF,KAAM0W,EACN3P,WAAY4P,EAAUJ,GAAWvP,QAAQ,KAqB/C,CAlBE,MAAOpT,GAEPlE,QAAQkM,MAAMhI,GACd4G,EAAAA,EAAY/L,KAAKoG,KAAM,CACrB2Q,UAAAA,EACAC,YAAalL,EAAAA,EAAYmL,SACzBH,KAAM,CACJvF,KAAM,CACJc,OAAQ,CACN,CACEnC,KAAM9P,EAAAA,EAAiBoY,YACvBxM,QAAW,OAAD7G,QAAC,IAADA,OAAC,EAADA,EAAa6G,WAI7BsM,WAAY4P,EAAUJ,GAAWvP,QAAQ,KAG/C,CAlCmB,CAH4B,CAsCjD,sOCIK,SAAS0O,EACdH,EACAqB,EACAvhB,GAEA,IAAMwhB,EAA6B,CAAC,EAE9B9V,GAAchC,EAAAA,EAAAA,IAAwB,CAC1C9M,SAAU2kB,EACV1X,kBAAmB,CAAC,EACpB/M,gBAAgB,EAChBE,qBAAqB,IAGjBykB,EAAqBxoB,OAAOyoB,QAChCtgB,EAAAA,EAAAA,IAA8BpB,IAC9B8F,QACA,SAACC,EAAK3H,GAAI,OAAAyB,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GAAWkG,GAAG,IAAAvL,EAAAA,EAAAA,GAAA,GAAG4D,GAAO,GAAI,GACtC,CAAC,GAEHnF,OAAO4F,OAAO6M,EAAa+V,GAE3B,IAAME,GAA8BjY,EAAAA,EAAAA,IAAwB,CAC1D9M,SAAU2kB,EACV1X,kBAAmB,CAAC,EACpB/M,gBAAgB,EAChBE,qBAAqB,IAIjB4kB,EAAe,IAAInM,IAEnBoM,EAAiC,IAAIpM,IA2E3C,OAzEAyK,EAAYpN,SAAQ,SAACgP,GACnB,IAAAC,GAAqCjqB,EAAAA,EAAAA,IACnCgqB,GADM5pB,EAAU6pB,EAAV7pB,WAAYC,EAAY4pB,EAAZ5pB,aAGdG,EAASipB,EAAWrpB,GACpB8pB,GAAuBxD,EAAAA,EAAAA,KAC3B+C,EACAO,GAMF,IAHAzjB,EAAAA,EAAAA,KAAImjB,EAAe,KAADtnB,OAAO4nB,EAAgB,MAAM,IAiJ5C,SACLllB,EACAtE,EACAwpB,GAEA,IAAQ3pB,GAAiBL,EAAAA,EAAAA,IAA6BgqB,GAA9C3pB,aACF6pB,GAAuBxD,EAAAA,EAAAA,KAC3B5hB,EACAklB,GAGF,IAAIzoB,EAAAA,EAAAA,IAAef,EAAQH,GACzB,OAAOyK,EAAAA,EAAAA,IAAeof,GAQxB,QALGvpB,EAAAA,EAAAA,IAASH,KAAWD,EAAAA,EAAAA,IAASC,KAAWO,EAAAA,EAAAA,IAAWP,MACpDkM,EAAAA,EAAAA,IAAsBlM,EAAQH,KAEJyK,EAAAA,EAAAA,IAAeof,KACzCnpB,EAAAA,EAAAA,IAAWP,EAEf,CAnKS2pB,CAAoBV,EAAYjpB,EAAQwpB,GAA7C,CACA,IAAIzoB,EAAAA,EAAAA,IAAef,EAAQH,GACzB,OAAOypB,EAAarB,IAAIuB,GAC1B,IAAIjpB,EAAAA,EAAAA,IAAWP,GACb,OAAOupB,EAA+BtB,IAAI,GAADrmB,OAAIhC,EAAU,UACzD,IAAMkoB,EAAa8B,EACjBF,EACA1pB,EACAwpB,EACAH,IAEFtjB,EAAAA,EAAAA,KAAImjB,EAAe,KAADtnB,OAAO4nB,EAAgB,MAAM1B,EAXuB,CAYxE,KAEIwB,EAAavL,MAAQwL,EAA+BxL,QAKlDwL,EAA+BxL,MACjCwL,EAA+B/O,SAAQ,SAACgP,GACtC,IAAQ5pB,GAAeJ,EAAAA,EAAAA,IAA6BgqB,GAA5C5pB,WACFI,EAASipB,EAAWrpB,GACpB8pB,GAAuBxD,EAAAA,EAAAA,KAC3B+C,EACAO,IAGFzjB,EAAAA,EAAAA,KAAImjB,EAAe,KAADtnB,OAAO4nB,EAAgB,MAAM,IAC/C,IAAM1B,EAAa8B,EACjBF,EACA1pB,EACAwpB,EACApW,IAEFrN,EAAAA,EAAAA,KAAImjB,EAAe,KAADtnB,OAAO4nB,EAAgB,MAAM1B,EACjD,IAIEwB,EAAavL,MACfuL,EAAa9O,SAAQ,SAACqP,GACpB,IAAQjqB,GAAeJ,EAAAA,EAAAA,IAA6BqqB,GAA5CjqB,WACFI,EAASipB,EAAWrpB,GACpB8pB,GAAuBxD,EAAAA,EAAAA,KAC3B+C,EACAY,IAGF9jB,EAAAA,EAAAA,KAAImjB,EAAe,KAADtnB,OAAOioB,EAAW,MAAM,IAC1C,IAAM/B,EA4Ed,SACE/W,EACA/Q,EACA8pB,GAEA,IAAQxe,GAAeF,EAAAA,EAAAA,IAAmB2F,EAAY/Q,GAA9CsL,WAGR,OAAOye,GAFQjZ,EAAAA,EAAAA,IAAgBxF,EAAW,GAAImE,EAAAA,GAAqBO,UAIjE8Z,EACAxe,EAAW,GACXmE,EAAAA,GAAqBO,SAEzB,CA1F2Bga,CACjBN,EACA1pB,EACAoT,IAEFrN,EAAAA,EAAAA,KAAImjB,EAAe,KAADtnB,OAAOioB,EAAW,MAAM/B,EAC5C,KAIGoB,CACT,CAEA,SAASU,EACPK,EACAjqB,EACAwpB,EACAM,GAEA,IAAIhC,EAA0B,GAE9B,IAAIvnB,EAAAA,EAAAA,IAAWP,GAAS,CACtB,IAAKA,EAAO4X,KAAM,OAAOkQ,EACzB,IAAK9nB,EAAO4X,KAAKsS,WAAWxoB,EAAAA,IAC1B,OAAOomB,EAAWlmB,OAAO,CACvB,CACE8R,UAAW9H,EAAAA,GAA4Be,KACvCwd,aAAc,GACdxW,gBAAiB3T,EAAO4X,KACxBwS,KAAM,EACNC,GAAI,EACJ/nB,KAAMtC,EAAO4X,KACb0S,UAAW,GACX7W,IAAKzT,EAAO4X,KACZ1J,aAAc,CACZpI,KAAM,eACNgH,QAASnL,EAAAA,IAEX6R,SAAUjR,EAAAA,GAASE,QAI3B,CAEA,IAAQ5C,GAAiBL,EAAAA,EAAAA,IAA6BgqB,GAA9C3pB,aAER0qB,GAAuCnf,EAAAA,EAAAA,IACrC6e,EACAjqB,GAFMsL,EAAUif,EAAVjf,WAAYZ,EAAc6f,EAAd7f,eA2BpB,OAtBIA,GACFY,EAAWkP,SAAQ,SAACgQ,EAAW9L,GAC7B,GAAI8L,EAAW,CACb,IAAMC,EAAkBC,EAAY1qB,EAAQwqB,EAAW3qB,GAEjD8T,EAAkB+W,EACtB1qB,EACA0K,EAAegU,GACf7e,GAEIgR,GAAaH,EAAAA,EAAAA,KAAc,GAAO,GAElCia,EAAwBZ,GADTjZ,EAAAA,EAAAA,IAAgB2Z,EAAiB5Z,GAGpDiZ,EACAnW,EACA9C,GAEFiX,EAAaA,EAAWlmB,OAAO+oB,EACjC,CACF,IAEK7C,CACT,CA0CO,SAAS4C,EACd1qB,EACA4qB,EACA/qB,GAEA,OAAOG,IAAUO,EAAAA,EAAAA,IAAWP,IAA4B,SAAjBH,EACnC+qB,EAAQjY,QAAQ,kBAAmB,IACnCiY,CACN,CAeA,IAAMC,EAAsD,CAAC,EAE7D,SAASC,EAA4Bja,GAWnC,OAVIka,EAAAA,EAAAA,SAAQF,KAGVvd,EAAAA,EAAAA,MAAKqC,EAAAA,IAAmB6K,SAAQ,SAACxJ,GAC/B6Z,EAA0B7Z,GApBzB,SACLA,GAEA,IAAM+B,EAASpD,EAAAA,GAAkBqB,GAE3B0N,EAAQ3L,EAAOpT,QAAQ+P,EAAAA,IAEvBsb,EADSjY,EAAOkY,MAAM,GAAc,IAAXvM,EAAeA,EAAQ,GACjCxN,MAAM,MACrBga,GAAWC,EAAAA,EAAAA,MAAKH,IAAU,GAEhC,MAAO,CAAEZ,KAAMY,EAAMlpB,OAAQuoB,GAAIa,EAASppB,OAC5C,CASwCspB,CAChCpa,EAEJ,IAGK6Z,EAA0Bha,EACnC,CAEO,SAASkZ,EACdhX,EACAV,EAEAsB,EACA9C,GACc,IAAD+S,EACPyH,EAAYP,EAA4Bja,GACxCiZ,EAAsC,CAAC,EAC7C,IAAK,IAAMwB,KAAWjZ,EACpByX,EAAWwB,IAAW,GAGH1H,EAAC,IAAgBhiB,OAAM8T,MAAAkO,GAAA3X,EAAAA,EAAAA,GACvCoE,EAAAA,GAAY3E,KAAI,SAAC6E,GAAG,OAAKA,EAAIC,QAAQ,MAE7BgK,SAAQ,SAAChK,GAAQ,OAAMsZ,EAAWtZ,IAAY,CAAI,IAG/D7P,OAAO2M,KAAKzL,EAAAA,IAAoB2Y,SAC9B,SAAC+Q,GAAO,OAAMzB,EAAWyB,IAAW,CAAI,IAG1C,IAAMC,EAAuB,CAC3BC,OAAQ,EACRC,UAAWC,EAAAA,GACXC,QAAQ,EACRC,OAAO,EACPC,QAAQ,EACRC,OAAO,EACPC,OAAO,EACPC,SAAS,EACTlJ,QAAQ,EACRmJ,OAAQ,SACRC,KAAK,EACLC,MAAM,EACNC,MAAM,EACNC,WAAW,EACXC,KAAK,EACLC,MAAM,EAENC,SAAS,EACTC,QAAQ,EACRC,OAAO,EAEPC,QAAS9C,EACT+C,UAAU,IAGZC,EAAAA,EAAAA,QAAO/Z,EAAQyY,GAEf,IAAMuB,EA+BR,SACEjF,EACAuD,GAEA,OAAOvD,EAAWta,QAAO,SAAC0F,EAAuB8Z,GAE/C,GAAIzrB,EAAAA,GAAoB6M,SAAS4e,EAAU1qB,MAAO,OAAO4Q,EAMzD,IAAIpG,EAAUkgB,EAAUrqB,OAClBsqB,EAAengB,EAAQ2B,MAAM,aAC7Bye,EAA4B,IAAI/P,IAClCgQ,GAAwB,EAe5B,OAdIF,GACFA,EAAazS,SAAQ,SAAC4S,GACpB,IAAMC,EAAcD,EAAclc,MAAM,KAAK,GACvCoc,EAAQ5J,OAAO2J,IACjBE,EAAAA,EAAAA,UAASD,KACPA,EAAQjC,EAAUjB,KAEpB+C,GAAwB,EAExBD,EAA0BjF,IAAIqF,GAGpC,IAEEH,IACAD,EAA0BnP,MAC5BhS,MAAMyhB,KAAKN,GAA2B1S,SAAQ,SAACiT,GAC7C3gB,EAAUA,EAAQ4B,WAAW,QAAD9M,OAClB6rB,GAAU,QAAA7rB,OACV6rB,EAAapC,EAAUjB,KAAO,GAE1C,IAEFlX,EAAOrI,MAAItD,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAC,CAAC,EACRylB,GAAS,IACZrqB,OAAQmK,MAXwBoG,CAcpC,GAAG,GACL,CA5EoCwa,CAChCZ,EAAAA,OAAO3Z,OACPkY,GACA3f,KAAI,SAACshB,GACL,IAAM3C,EAAK2C,EAAUW,UACrB,MAAO,CACLja,UAAW9H,EAAAA,GAA4Be,KACvC8G,IAAKV,EACLS,UAAUnR,EAAAA,EAAAA,IAAgB2qB,EAAU1qB,MACpC4L,aAAc,CACZpI,KAAM,eACNgH,SAASpK,EAAAA,EAAAA,IAAoBsqB,EAAUrqB,SAEzCwnB,aAAc6C,EAAUY,SACxBja,gBAAAA,EAEA2W,UAAW,CAAC0C,EAAUvS,EAAGuS,EAAU1O,EAAG0O,EAAUa,EAAGb,EAAUc,GAC7DxrB,KAAM0qB,EAAU1qB,KAChB8nB,KAAM4C,EAAU5C,KAAOiB,EAAUjB,KACjCC,GAAI2C,EAAU5C,OAASiB,EAAUjB,KAAOC,EAAKgB,EAAUhB,GAAKA,EAEhE,IACM0D,EAwDR,SACEhb,EACAV,EACAgZ,EACA1X,GAEA,IAAIqa,EAA2D,GAC/D,IACEA,GAAmCC,EAAAA,EAAAA,IACjClb,EACAV,EACAnL,KAAK0L,kBAEI,CAAX,MAAO3M,GAAI,CAkCb,OAhC8B+nB,EAAiCtiB,KAC7D,SAAAic,GAAsC,IAAnCuG,EAAMvG,EAANuG,OAAQC,EAAQxG,EAARwG,SACH/rB,GAAegsB,EAAAA,EAAAA,IAAcD,GAC9BA,EAAS1oB,MACV0oB,EAASroB,KACPuoB,EAAkBH,EAAOI,IAAIC,MAAMnE,KAAO,EAE1CoE,GAAuBJ,EAAAA,EAAAA,IAAcD,GAEvCA,EAASG,IAAIC,MAAME,OAAS,EAD5BN,EAASG,IAAIC,MAAME,OAAS,EAEhC,MAAO,CACL/a,UAAW9H,EAAAA,GAA4Be,KACvC8G,IAAKV,EACLS,UAAUnR,EAAAA,EAAAA,IAAgBZ,EAAAA,GAAoBU,yBAC9C+L,aAAc,CACZpI,KAAM,eACNgH,QAAS7K,EAAAA,GACPR,EAAAA,GAAoBU,yBACpB+rB,EAAOpoB,KAAM1D,IAEjB+nB,aAAa,GAADvoB,OAAKssB,EAAOpoB,KAAI,KAAAlE,OAAIQ,GAChCuR,gBAAAA,EACA2W,UAAW,CAACloB,EAAc,KAAM,KAAM,MACtCE,KAAMb,EAAAA,GAAoBU,wBAC1BioB,KAAMiE,EAAkBhD,EAAUjB,KAClCC,GACEgE,IAAoBhD,EAAUjB,KAC1BoE,EAAsBnD,EAAUhB,GAChCmE,EAEV,GAGJ,CAxGgCE,CAC5B3b,EACAV,EACAgZ,EACA1X,GAEF,OAAOoZ,EAAanrB,OAAOmsB,EAC7B,mHChYYY,EAQAC,kJARAC,EAAAA,QAAA,GAAAF,EAAAE,EAAAA,KAAAA,EAAAA,GAGX,KAFC,gBACAF,EAAA,gBAMUE,EAAAA,QAAA,GAAAD,EAAAC,EAAAA,KAAAA,EAAAA,GAgBX,KAfC,wBACAD,EAAA,sCACAA,EAAA,kBACAA,EAAA,oBAEAA,EAAA,0CACAA,EAAA,oDACAA,EAAA,wCAEAA,EAAA,oCACAA,EAAA,wCACAA,EAAA,kDACAA,EAAA,oCACAA,EAAA,kCACAA,EAAA,mDC3BGE,OAAOC,eACV,WACA,IAAIC,EAAkB,WAErB,IACC,IAAId,EAAS,CAAC,EACVe,EAAkBtuB,OAAOquB,eACzB9b,EAAS+b,EAAgBf,EAAQA,EAAQA,IAAWe,CACzC,CAAd,MAAMhhB,GAAQ,CAChB,OAAOiF,CACV,CARwB,GASlBgc,EAAqBJ,OAAOK,aAC5BC,EAAQC,KAAKD,MACbL,EAAgB,SAAS1jB,GAC5B,IAEIikB,EACAC,EAHAC,EAAW,MACXC,EAAY,GAGZ/Q,GAAS,EACT5c,EAAS8O,UAAU9O,OACvB,IAAKA,EACJ,MAAO,GAGR,IADA,IAAIoR,EAAS,KACJwL,EAAQ5c,GAAQ,CACxB,IAAI4tB,EAAYhM,OAAO9S,UAAU8N,IACjC,IACEiF,SAAS+L,IACVA,EAAY,GACZA,EAAY,SACZN,EAAMM,IAAcA,EAEpB,MAAMC,WAAW,uBAAyBD,GAEvCA,GAAa,MAChBD,EAAU5kB,KAAK6kB,IAIfJ,EAAoC,QADpCI,GAAa,QACiB,IAC9BH,EAAgBG,EAAY,KAAS,MACrCD,EAAU5kB,KAAKykB,EAAeC,KAE3B7Q,EAAQ,GAAK5c,GAAU2tB,EAAU3tB,OAAS0tB,KAC7Ctc,GAAUgc,EAAmBxZ,MAAM,KAAM+Z,GACzCA,EAAU3tB,OAAS,EAExB,CACG,OAAOoR,CACV,EACM8b,EACHA,EAAeF,OAAQ,gBAAiB,CACvC,MAASC,EACT,cAAgB,EAChB,UAAY,IAGbD,OAAOC,cAAgBA,CAExB,CA1DA,iBCAFpuB,OAAOquB,eAAwBH,EAAA,aAAc,CAC3CppB,OAAO,IAETopB,EAAkBzS,aAAA,EAoBlB,IAAIwT,EAAgB,gIAChBC,EAAuB,CACzB,EAAK,KACL,EAAK,KACL,EAAK,KACL,EAAK,KACL,EAAK,KACL,EAAK,KACL,EAAK,KACL,IAAM,IACN,IAAK,IACL,KAAM,MAGJC,EAAU,SAAiB/Q,GAC7B,OAAO+P,OAAOC,cAAcgB,SAAShR,EAAK,IAC5C,EAwBA8P,EAAAzS,QAlBe,SAAkB4T,GAC/B,OAAOA,EAAOrd,QAAQid,GAAe,SAAUvkB,EAAG4kB,EAAIC,EAAQC,EAASC,EAAUC,EAAOC,EAAkBC,GACxG,YAAepkB,IAAX+jB,EACKJ,EAAQI,QACM/jB,IAAZgkB,EACFL,EAAQK,QACOhkB,IAAbikB,EACFN,EAAQM,QACIjkB,IAAVkkB,GAZgBtR,EAaVsR,EAZZvB,OAAOC,cAAcgB,SAAShR,EAAK,UAalB5S,IAAXokB,EACFT,EAAQS,GAERV,EAAqBS,GAjBpB,IAAiBvR,CAmB/B,GACA,EAGAyR,EAAiB3B,QAAAA,EAAQzS,yCChEnBjL,EAA2B,YAEjB,SAAA2B,EAAeL,EAAYG,GAKzCA,EAAoBA,GAAwC,EAC5D,IAAMF,EAAYD,EAAGE,QAAQxB,EAA0B,IACvD,OAAOyB,EAAoB,EAAIF,EAAYG,EAAWH,EACxD,CAIO,ICID+d,EACJ,oDAEWC,EAAsB,OAAH9uB,OAAU6uB,EAAoB,MCmGjDE,EAAmB,SAACC,GAC/B,OAAOA,EAAK5f,OAAS6d,EAAAA,GAAAA,UACvB,EAEMgC,EAAyB,SAACD,GAC9B,OAAOA,EAAK5f,OAAS6d,EAAAA,GAAAA,gBACvB,EAEaiC,EAAuB,SAClCF,GAEA,OAAOA,EAAK5f,OAAS6d,EAAAA,GAAAA,kBACvB,EAEMkC,EAAwB,SAACH,GAC7B,OAAOA,EAAK5f,OAAS6d,EAAAA,GAAAA,mBACvB,EAEMmC,EAAuB,SAACJ,GAC5B,OAAOA,EAAK5f,OAAS6d,EAAAA,GAAAA,kBACvB,EACMoC,EAA4B,SAChCL,GAEA,OAAOA,EAAK5f,OAAS6d,EAAAA,GAAAA,uBACvB,EAEaqC,EAAqB,SAACN,GACjC,OAAOA,EAAK5f,OAAS6d,EAAAA,GAAAA,gBACvB,EAEMsC,EAA0B,SAACP,GAC/B,OAAOA,EAAK5f,OAAS6d,EAAAA,GAAAA,iBACvB,EAEaT,EAAgB,SAACwC,GAC5B,OAAOA,EAAK5f,OAAS6d,EAAAA,GAAAA,OACvB,EAMauC,EAA0B,SACrCR,GAEA,OACEA,EAAK5f,OAAS6d,EAAAA,GAAAA,yBACd+B,EAAK5f,OAAS6d,EAAAA,GAAAA,kBAElB,EAEMwC,EAAsB,SAACT,GAC3B,OACEC,EAAuBD,IACvBA,EAAKU,UACLlD,EAAcwC,EAAKzC,WACnBoD,EAAA5N,SAASiN,EAAKzC,SAAS1oB,MAE3B,EAEM+rB,EAAW,SAAClvB,GAChB,MAAO,qCAAPV,OAEaU,EAAI,eAGnB,EASMmvB,EAAkC,SACtCb,GAKA,OAAO7kB,MAAMyhB,KAAKkE,EAA4Bd,IAAOllB,KACnD,SAACimB,GAAe,OAAKA,EAAgBC,SAAS,GAElD,EAKaC,EAASN,EAAAO,SAAQ,SAACxvB,EAAckpB,GAAoB,OAC/DuG,EAAApN,MAAMriB,EAAI3B,OAAA4F,OAAA5F,OAAA4F,OAAA,GAAOilB,GAAO,CAAEwG,YLrNA,KKqN4B,IAyK3CN,EAA8B,SACzCd,GAKsB,IADtBqB,EAASrhB,UAAA9O,OAAA,QAAAqK,IAAAyE,UAAA,IAAAA,UAAA,GAEHshB,EAAmB,IAAI/U,IAsB7B,OArBAyT,EAAK7V,OAAOP,SAAQ,SAAC2X,GACnB,GAAIxB,EAAiBwB,GACnBD,EAAiBjK,IAAI,CACnB2J,UAAWO,EAAUrsB,KACrBssB,kBAAcjmB,SAEX,GAAIglB,EAAwBgB,IAC7BxB,EAAiBwB,EAAUE,MAAO,CACpC,IAAMT,EAAYO,EAAUE,KAAKvsB,KAC5BmsB,GACHC,EAAiBjK,IAAI,CAAE2J,UAAAA,EAAWQ,kBAAcjmB,GAQnD,CAEL,IACO+lB,CACT,EAEMI,EAAoC,SAApCA,EACJ1B,GAEU,IADV2B,EAAK3hB,UAAA9O,OAAA,QAAAqK,IAAAyE,UAAA,GAAAA,UAAA,GAAG,GAEF4hB,EAAmBC,EAAoB7B,EAAKzC,UAClD,GAAIwC,EAAiBC,EAAK1C,QACxB,MAAO,GAAPtsB,OAAUgvB,EAAK1C,OAAOpoB,MAAIlE,OAAG4wB,GAAgB5wB,OAAG2wB,GAEhD,IAAMC,EAAmBC,EAAoB7B,EAAKzC,UAC5CuE,EAAc,GAAH9wB,OAAM4wB,GAAgB5wB,OAAG2wB,GAC1C,OAAOD,EAAkC1B,EAAK1C,OAAQwE,EAE1D,EAEMD,EAAsB,SAACE,GAC3B,OAAIhC,EAAiBgC,GACZ,IAAP/wB,OAAW+wB,EAAa7sB,MACfsoB,EAAcuE,IAAiBpB,EAAA3O,SAAS+P,EAAaltB,OAEvD,IAAP7D,OAAW+wB,EAAaltB,OACf2oB,EAAcuE,IAAiBpB,EAAA5N,SAASgP,EAAaltB,OAEvD,IAAP7D,OAAW+wB,EAAaltB,MAAK,UAFxB,CAIT,EA2HMmtB,EAAe,SAACC,GAEpB,IAAMC,EAAiB,IAAI/mB,MAErBgnB,EAAa,IAAI5V,IAEjB6V,EAAuB,IAAI7V,IAE7B+U,EAAmB,IAAI/U,IAgG3B,OAzFA8V,EAAAC,SAASL,EAAK,CACZM,WAAU,SAACvC,EAAYwC,GAUrB,IAHA,IAAIC,EACFzC,EACE0C,EAAQF,EAAUtxB,OAAS,EACxBwxB,EAAQ,GAAG,CAChB,IAAMC,EAASH,EAAUE,GACzB,IACEzC,EAAuB0C,IASrBA,EAAOjC,WAAYD,EAAoBkC,IACxCA,EAAOC,SAMR,MAJAH,EAAwBE,EACxBD,GAAgB,CAKnB,CAGD,IAAMG,EAAaL,EAAUA,EAAUtxB,OAAS,GAOhD,GANI+uB,EAAuB4C,GACzBX,EAAejoB,KAAIlK,OAAA4F,OAAA5F,OAAA4F,OAAC,CAAC,EACfqqB,GAAuB,CAC3BzC,SAAUsF,EAAWtF,YAElB2E,EAAejoB,KAAK+lB,GACvBD,EAAiB0C,GAEnBN,EAAW9K,IAAIoL,EAAsBvtB,UAChC,CAGL,IAAM4tB,EAAsBpB,EAC1Be,GAEFN,EAAW9K,IAAIyL,EAChB,GAEHC,mBAAkB,SAAC/C,GAGbE,EAAqBF,IACvBoC,EAAqB/K,IAAI2I,EAAKpc,GAAG1O,OAGrC8tB,oBAAmB,SAAChD,GAGbG,EAAsBH,KAC3BsB,EAAmB,IAAI/U,IAAI,GAADvb,OAAAqK,EACrBimB,GAAgBjmB,EAChBwlB,EAAgCb,QAGvCiD,mBAAkB,SAACjD,GAGZI,EAAqBJ,KAC1BsB,EAAmB,IAAI/U,IAAI,GAADvb,OAAAqK,EACrBimB,GAAgBjmB,EAChBwlB,EAAgCb,QAGvCkD,wBAAuB,SAAClD,GAGjBK,EAA0BL,KAC/BsB,EAAmB,IAAI/U,IAAI,GAADvb,OAAAqK,EACrBimB,GAAgBjmB,EAChBwlB,EAAgCb,UAIlC,CACLmC,WAAAA,EACAb,iBAAAA,EACAc,qBAAAA,EACAF,eAAAA,EAEJ,EAIMiB,EAAiB,SAAChhB,GACtB,OAAOA,EAAOJ,QAAQ,kBAAmB+d,EAC3C,EAIMsD,EAAiB,SAACjhB,GACtB,OAAOA,EAAOJ,QAAQ+d,EAAqB,iBAC7C,OL3qB4B,QKqdmC,SAC7DpuB,EACA+P,EACAO,GAEA,IAAMob,EAAmC,IAAI7Q,IACvC6V,EAAuB,IAAI7V,IAC7B+U,EAAmB,IAAI/U,IACvB0V,EAAY,CAAEoB,IAAK,EAAG1F,MAAO,EAAGvd,KAAM,IAC1C,IACE,IAAMkjB,EAAkBphB,EAAexQ,EAAMsQ,GACvCuhB,EAAc3C,EAAS0C,GAC7BrB,EAAMhB,EAAOsC,EAAa,CAAEC,WAAW,GAOxC,CANC,MAAOnuB,GACP,GAAIA,aAAaouB,YAEf,MAAO,GAET,MAAMpuB,CACP,CAsED,OArEAgtB,EAAAqB,OAAOzB,EAAK,CACV0B,iBAAgB,SAAC3D,GACf,IF1dJlwB,EE0dYwtB,EAA+B0C,EAA/B1C,OAAQC,EAAuByC,EAAvBzC,SAAUmD,EAAaV,EAAbU,SAGrBX,EAAiBzC,KAChBA,EAAOpoB,QAAQuM,IF9dzB3R,EE8dgD2R,EAAK6b,EAAOpoB,MF5dZ,oBAAzCnF,OAAOC,UAAUC,SAASC,KAAKJ,MEgehC0tB,EAAcD,IACdoD,EAAA3O,SAASuL,EAAS1oB,UAChB0oB,EAAS1oB,SAAS4M,EAAK6b,EAAOpoB,QAEhCkoB,EAAiC/F,IAAI,CACnCiG,OAAAA,EACAC,SAAAA,KAMFwC,EAAiBxC,IAChBmD,GACCnD,EAASroB,QAAQuM,EAAK6b,EAAOpoB,OAE/BkoB,EAAiC/F,IAAI,CACnCiG,OAAAA,EACAC,SAAAA,OAINwF,mBAAkB,SAAC/C,GACbE,EAAqBF,IACvBoC,EAAqB/K,IAAI2I,EAAKpc,GAAG1O,OAGrC8tB,oBAAmB,SAAChD,GACbG,EAAsBH,KAC3BsB,EAAmB,IAAI/U,IAAI,GAADvb,OAAAqK,EACrBimB,GAAgBjmB,EAChBwlB,EAAgCb,QAGvCiD,mBAAkB,SAACjD,GACZI,EAAqBJ,KAC1BsB,EAAmB,IAAI/U,IAAI,GAADvb,OAAAqK,EACrBimB,GAAgBjmB,EAChBwlB,EAAgCb,QAGvCkD,wBAAuB,SAAClD,GACjBK,EAA0BL,KAC/BsB,EAAmB,IAAI/U,IAAI,GAADvb,OAAAqK,EACrBimB,GAAgBjmB,EAChBwlB,EAAgCb,UAKK7kB,MAAMyhB,KAClDQ,GACAwG,QAAO,SAACD,GACR,QACEvB,EAAqBrU,IAAI4V,EAAiBrG,OAAOpoB,OACjDosB,EAAiBvT,IAAI4V,EAAiBrG,OAAOpoB,MAEjD,GAGF,WC9iBI2uB,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBxoB,IAAjByoB,EACH,OAAOA,EAAa/F,QAGrB,IAAI2B,EAASiE,EAAyBE,GAAY,CACjDngB,GAAImgB,EACJE,QAAQ,EACRhG,QAAS,CAAC,GAUX,OANAiG,EAAoBH,GAAU7zB,KAAK0vB,EAAO3B,QAAS2B,EAAQA,EAAO3B,QAAS6F,GAG3ElE,EAAOqE,QAAS,EAGTrE,EAAO3B,OACf,CAGA6F,EAAoBK,EAAID,EAGxBJ,EAAoBM,EAAI,WAGvB,IAAIC,EAAsBP,EAAoBQ,OAAE/oB,EAAW,CAAC,GAAG,IAAI,MAAM,WAAa,OAAOuoB,EAAoB,MAAQ,IAEzH,OADAO,EAAsBP,EAAoBQ,EAAED,EAE7C,aCrCA,IAAIE,EAAW,GACfT,EAAoBQ,EAAI,SAAShiB,EAAQkiB,EAAUxvB,EAAIyvB,GACtD,IAAGD,EAAH,CAMA,IAAIE,EAAeC,IACnB,IAASvqB,EAAI,EAAGA,EAAImqB,EAASrzB,OAAQkJ,IAAK,CACrCoqB,EAAWD,EAASnqB,GAAG,GACvBpF,EAAKuvB,EAASnqB,GAAG,GACjBqqB,EAAWF,EAASnqB,GAAG,GAE3B,IAJA,IAGIwqB,GAAY,EACPC,EAAI,EAAGA,EAAIL,EAAStzB,OAAQ2zB,MACpB,EAAXJ,GAAsBC,GAAgBD,IAAa10B,OAAO2M,KAAKonB,EAAoBQ,GAAGzW,OAAM,SAASrS,GAAO,OAAOsoB,EAAoBQ,EAAE9oB,GAAKgpB,EAASK,GAAK,IAChKL,EAAS3M,OAAOgN,IAAK,IAErBD,GAAY,EACTH,EAAWC,IAAcA,EAAeD,IAG7C,GAAGG,EAAW,CACbL,EAAS1M,OAAOzd,IAAK,GACrB,IAAI0qB,EAAI9vB,SACEuG,IAANupB,IAAiBxiB,EAASwiB,EAC/B,CACD,CACA,OAAOxiB,CArBP,CAJCmiB,EAAWA,GAAY,EACvB,IAAI,IAAIrqB,EAAImqB,EAASrzB,OAAQkJ,EAAI,GAAKmqB,EAASnqB,EAAI,GAAG,GAAKqqB,EAAUrqB,IAAKmqB,EAASnqB,GAAKmqB,EAASnqB,EAAI,GACrGmqB,EAASnqB,GAAK,CAACoqB,EAAUxvB,EAAIyvB,EAwB/B,KC5BAX,EAAoBpvB,EAAI,SAASkrB,GAChC,IAAImF,EAASnF,GAAUA,EAAOoF,WAC7B,WAAa,OAAOpF,EAAgB,OAAG,EACvC,WAAa,OAAOA,CAAQ,EAE7B,OADAkE,EAAoB5G,EAAE6H,EAAQ,CAAElb,EAAGkb,IAC5BA,CACR,ECNAjB,EAAoB5G,EAAI,SAASe,EAASgH,GACzC,IAAI,IAAIzpB,KAAOypB,EACXnB,EAAoBoB,EAAED,EAAYzpB,KAASsoB,EAAoBoB,EAAEjH,EAASziB,IAC5EzL,OAAOquB,eAAeH,EAASziB,EAAK,CAAE2pB,YAAY,EAAM7P,IAAK2P,EAAWzpB,IAG3E,ECPAsoB,EAAoBxuB,EAAI,CAAC,EAGzBwuB,EAAoBzuB,EAAI,SAAS+vB,GAChC,OAAOziB,QAAQ0iB,IAAIt1B,OAAO2M,KAAKonB,EAAoBxuB,GAAGsH,QAAO,SAAS0oB,EAAU9pB,GAE/E,OADAsoB,EAAoBxuB,EAAEkG,GAAK4pB,EAASE,GAC7BA,CACR,GAAG,IACJ,ECPAxB,EAAoByB,EAAI,SAASH,GAEhC,MAAO,aAAeA,EAAU,IAAM,CAAC,GAAK,WAAW,IAAM,WAAW,IAAM,YAAYA,GAAW,WACtG,ECHAtB,EAAoB0B,SAAW,SAASJ,GAGxC,ECJAtB,EAAoB2B,EAAI,WACvB,GAA0B,kBAAfC,WAAyB,OAAOA,WAC3C,IACC,OAAOvpB,MAAQ,IAAIwpB,SAAS,cAAb,EAGhB,CAFE,MAAOtwB,GACR,GAAsB,kBAAXuwB,OAAqB,OAAOA,MACxC,CACA,CAPuB,GCAxB9B,EAAoBoB,EAAI,SAASpa,EAAK+a,GAAQ,OAAO91B,OAAOC,UAAUgT,eAAe9S,KAAK4a,EAAK+a,EAAO,ECCtG/B,EAAoBgB,EAAI,SAAS7G,GACX,qBAAX6H,QAA0BA,OAAOC,aAC1Ch2B,OAAOquB,eAAeH,EAAS6H,OAAOC,YAAa,CAAElxB,MAAO,WAE7D9E,OAAOquB,eAAeH,EAAS,aAAc,CAAEppB,OAAO,GACvD,ECNAivB,EAAoBkC,IAAM,SAASpG,GAGlC,OAFAA,EAAOjlB,MAAQ,GACVilB,EAAO9V,WAAU8V,EAAO9V,SAAW,IACjC8V,CACR,ECJAkE,EAAoBmC,EAAI,ICAxB,WAEI,IAAIC,EAAepC,EAAoByB,EACnCY,EAAgBrC,EAAoBzuB,EACpC+wB,EAAW,CAAC,EACZC,EAAW,CAAC,EAIhBvC,EAAoByB,EAAI,SAAUH,GAEhC,OADac,EAAad,IAGvBgB,EAASpjB,eAAeoiB,GAAW,IAAMgB,EAAShB,GAAW,GAElE,EACAtB,EAAoBzuB,EAAI,SAAU+vB,GAEhC,OADae,EAAcf,GACbkB,OAAM,SAAUjpB,GAC5B,IAAIkpB,EAAUF,EAASrjB,eAAeoiB,GAAWiB,EAASjB,GAAW,EACrE,GAAImB,EAAU,EAAG,CACf,IAAIC,EAAUN,EAAad,GAS3B,MARA/nB,EAAMnB,QACJ,iBACAkpB,EACA,8BACAoB,EACA,IACFnpB,EAAMopB,QAAUD,EAChBZ,OAAOc,SAASC,KAAO,YACjBtpB,CACR,CACA,OAAO,IAAIsF,SAAQ,SAAUgE,GAC3B,IAAIigB,EAAe,EAAIL,EAAU,EACjCM,YAAW,WACT,IACIC,EAAY,mBADS,kBAAoBF,GAE7CR,EAAShB,GAAW0B,EACpBT,EAASjB,GAAWmB,EAAU,EAC9B5f,EAAQmd,EAAoBzuB,EAAE+vB,GAChC,GAjCG,IAkCL,GACF,GACF,CAEH,CA7CD,cCIA,IAAI2B,EAAkB,CACrB,IAAK,GAkBNjD,EAAoBxuB,EAAE8E,EAAI,SAASgrB,EAASE,GAEvCyB,EAAgB3B,IAElB4B,cAAclD,EAAoBmC,EAAInC,EAAoByB,EAAEH,GAG/D,EAEA,IAAI6B,EAAqB3wB,KAA2B,qBAAIA,KAA2B,sBAAK,GACpF4wB,EAA6BD,EAAmBhtB,KAAKpC,KAAKovB,GAC9DA,EAAmBhtB,KAzBA,SAASwH,GAC3B,IAAI+iB,EAAW/iB,EAAK,GAChB0lB,EAAc1lB,EAAK,GACnB2lB,EAAU3lB,EAAK,GACnB,IAAI,IAAIsiB,KAAYoD,EAChBrD,EAAoBoB,EAAEiC,EAAapD,KACrCD,EAAoBK,EAAEJ,GAAYoD,EAAYpD,IAIhD,IADGqD,GAASA,EAAQtD,GACdU,EAAStzB,QACd61B,EAAgBvC,EAAS6C,OAAS,EACnCH,EAA2BzlB,EAC5B,gBCtBA,IAAIuG,EAAO8b,EAAoBM,EAC/BN,EAAoBM,EAAI,WACvB,OAAOzhB,QAAQ0iB,IAAI,CAAC,GAAG,IAAI,KAAKvqB,IAAIgpB,EAAoBzuB,EAAGyuB,IAAsBtnB,KAAKwL,EACvF,KCF0B8b,EAAoBM","sources":["ce/workers/Evaluation/evaluationUtils.ts","ce/workers/common/types.ts","components/editorComponents/CodeEditor/constants.ts","components/editorComponents/CodeEditor/lintHelpers.ts","components/formControls/utils.ts","constants/AppsmithActionConstants/ActionConstants.tsx","constants/BindingsConstants.ts","ce/workers/Evaluation/Actions.ts","ce/workers/Evaluation/evalWorkerActions.ts","ee/workers/Evaluation/evalWorkerActions.ts","workers/Evaluation/fns/index.ts","entities/DataTree/types.ts","utils/DynamicBindingUtils.ts","utils/MessageUtil.ts","utils/TypeHelpers.ts","workers/Evaluation/JSObject/utils.ts","workers/Evaluation/SetupDOM.ts","workers/Evaluation/errorModifier.ts","workers/Evaluation/evaluate.ts","workers/Evaluation/fns/overrides/console.ts","workers/Evaluation/fns/overrides/interval.ts","workers/Evaluation/fns/utils/Messenger.ts","workers/Evaluation/fns/utils/fnGuard.ts","entities/Replay/ReplayEntity/ReplayCanvas.ts","workers/common/DependencyMap/utils.ts","workers/common/DependencyMap/index.ts","workers/Evaluation/functionDeterminer.ts","workers/Evaluation/handlers/evalTree.ts","workers/Evaluation/validations.ts","workers/Linting/types.ts","workers/Linting/lint.worker.ts","workers/Linting/utils.ts","../../shared/ast/src/constants/ast.ts","../../shared/ast/node_modules/string.fromcodepoint/fromcodepoint.js","../../shared/ast/node_modules/unescape-js/dist/index.js","../../shared/ast/src/utils.ts","../../shared/ast/src/jsObject/index.ts","../../shared/ast/src/index.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/compat","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import {\n  DependencyMap,\n  EVAL_ERROR_PATH,\n  EvaluationError,\n  isChildPropertyPath,\n  isDynamicValue,\n  PropertyEvaluationErrorType,\n  isPathDynamicTrigger,\n} from \"utils/DynamicBindingUtils\";\nimport { Diff } from \"deep-diff\";\nimport {\n  DataTree,\n  DataTreeAction,\n  DataTreeAppsmith,\n  DataTreeEntity,\n  DataTreeWidget,\n  ENTITY_TYPE,\n  DataTreeJSAction,\n} from \"entities/DataTree/dataTreeFactory\";\n\nimport _, { difference, find, get, has, set } from \"lodash\";\nimport { WidgetTypeConfigMap } from \"utils/WidgetFactory\";\nimport { PluginType } from \"entities/Action\";\nimport { klona } from \"klona/full\";\nimport { warn as logWarn } from \"loglevel\";\nimport { EvalMetaUpdates } from \"@appsmith/workers/common/DataTreeEvaluator/types\";\nimport { isObject } from \"lodash\";\nimport { DataTreeObjectEntity } from \"entities/DataTree/dataTreeFactory\";\nimport { validateWidgetProperty } from \"workers/common/DataTreeEvaluator/validationUtils\";\nimport { PrivateWidgets } from \"entities/DataTree/types\";\nimport { EvalProps } from \"workers/common/DataTreeEvaluator\";\n\n// Dropdown1.options[1].value -> Dropdown1.options[1]\n// Dropdown1.options[1] -> Dropdown1.options\n// Dropdown1.options -> Dropdown1\nexport const IMMEDIATE_PARENT_REGEX = /^(.*)(\\..*|\\[.*\\])$/;\n\nexport enum DataTreeDiffEvent {\n  NEW = \"NEW\",\n  DELETE = \"DELETE\",\n  EDIT = \"EDIT\",\n  NOOP = \"NOOP\",\n}\n\nexport type DataTreeDiff = {\n  payload: {\n    propertyPath: string;\n    value?: string;\n  };\n  event: DataTreeDiffEvent;\n};\n\nexport class CrashingError extends Error {}\n\nexport const convertPathToString = (arrPath: Array<string | number>) => {\n  let string = \"\";\n  arrPath.forEach((segment) => {\n    if (isInt(segment)) {\n      string = string + \"[\" + segment + \"]\";\n    } else {\n      if (string.length !== 0) {\n        string = string + \".\";\n      }\n      string = string + segment;\n    }\n  });\n  return string;\n};\n\n// Todo: improve the logic here\n// Right now NaN, Infinity, floats, everything works\nfunction isInt(val: string | number): boolean {\n  return Number.isInteger(val) || (_.isString(val) && /^\\d+$/.test(val));\n}\n\n// Removes the entity name from the property path\nexport function getEntityNameAndPropertyPath(\n  fullPath: string,\n): {\n  entityName: string;\n  propertyPath: string;\n} {\n  const indexOfFirstDot = fullPath.indexOf(\".\");\n  if (indexOfFirstDot === -1) {\n    // No dot was found so path is the entity name itself\n    return {\n      entityName: fullPath,\n      propertyPath: \"\",\n    };\n  }\n  const entityName = fullPath.substring(0, indexOfFirstDot);\n  const propertyPath = fullPath.substring(indexOfFirstDot + 1);\n  return { entityName, propertyPath };\n}\n\nfunction translateCollectionDiffs(\n  propertyPath: string,\n  data: unknown,\n  event: DataTreeDiffEvent,\n) {\n  const dataTreeDiffs: DataTreeDiff[] = [];\n  if (Array.isArray(data)) {\n    data.forEach((diff, idx) => {\n      dataTreeDiffs.push({\n        event,\n        payload: {\n          propertyPath: `${propertyPath}[${idx}]`,\n        },\n      });\n    });\n  } else if (isTrueObject(data)) {\n    Object.keys(data).forEach((diffKey) => {\n      const path = `${propertyPath}.${diffKey}`;\n      dataTreeDiffs.push({\n        event,\n        payload: {\n          propertyPath: path,\n        },\n      });\n    });\n  }\n  return dataTreeDiffs;\n}\n\n//these paths are not required to go through evaluate tree as these are internal properties\nconst ignorePathsForEvalRegex =\n  \".(reactivePaths|bindingPaths|triggerPaths|validationPaths|dynamicBindingPathList)\";\n\n//match if paths are part of ignorePathsForEvalRegex\nconst isUninterestingChangeForDependencyUpdate = (path: string) => {\n  return path.match(ignorePathsForEvalRegex);\n};\n\nexport const translateDiffEventToDataTreeDiffEvent = (\n  difference: Diff<any, any>,\n  unEvalDataTree: DataTree,\n): DataTreeDiff | DataTreeDiff[] => {\n  let result: DataTreeDiff | DataTreeDiff[] = {\n    payload: {\n      propertyPath: \"\",\n      value: \"\",\n    },\n    event: DataTreeDiffEvent.NOOP,\n  };\n  if (!difference.path) {\n    return result;\n  }\n  const propertyPath = convertPathToString(difference.path);\n\n  // add propertyPath to NOOP event\n  result.payload = {\n    propertyPath,\n    value: \"\",\n  };\n\n  //we do not need evaluate these paths because these are internal paths\n  const isUninterestingPathForUpdateTree = isUninterestingChangeForDependencyUpdate(\n    propertyPath,\n  );\n  if (!!isUninterestingPathForUpdateTree) {\n    return result;\n  }\n  const { entityName } = getEntityNameAndPropertyPath(propertyPath);\n  const entity = unEvalDataTree[entityName];\n  const isJsAction = isJSAction(entity);\n  switch (difference.kind) {\n    case \"N\": {\n      result.event = DataTreeDiffEvent.NEW;\n      result.payload = {\n        propertyPath,\n      };\n      break;\n    }\n    case \"D\": {\n      result.event = DataTreeDiffEvent.DELETE;\n      result.payload = { propertyPath };\n      break;\n    }\n    case \"E\": {\n      const rhsChange =\n        typeof difference.rhs === \"string\" &&\n        (isDynamicValue(difference.rhs) || isJsAction);\n\n      const lhsChange =\n        typeof difference.lhs === \"string\" &&\n        (isDynamicValue(difference.lhs) || isJsAction);\n\n      if (rhsChange || lhsChange) {\n        result = [\n          {\n            event: DataTreeDiffEvent.EDIT,\n            payload: {\n              propertyPath,\n              value: difference.rhs,\n            },\n          },\n        ];\n        /**\n         * If lhs is an array/object\n         * Add delete events for all memberExpressions\n         */\n\n        const dataTreeDeleteDiffs = translateCollectionDiffs(\n          propertyPath,\n          difference.lhs,\n          DataTreeDiffEvent.DELETE,\n        );\n        result = result.concat(dataTreeDeleteDiffs);\n      } else if (difference.lhs === undefined || difference.rhs === undefined) {\n        // Handle static value changes that change structure that can lead to\n        // old bindings being eligible\n        if (\n          difference.lhs === undefined &&\n          (isTrueObject(difference.rhs) || Array.isArray(difference.rhs))\n        ) {\n          result.event = DataTreeDiffEvent.NEW;\n          result.payload = { propertyPath };\n        }\n        if (\n          difference.rhs === undefined &&\n          (isTrueObject(difference.lhs) || Array.isArray(difference.lhs))\n        ) {\n          result = [\n            {\n              event: DataTreeDiffEvent.EDIT,\n              payload: {\n                propertyPath,\n                value: difference.rhs,\n              },\n            },\n          ];\n\n          const dataTreeDeleteDiffs = translateCollectionDiffs(\n            propertyPath,\n            difference.lhs,\n            DataTreeDiffEvent.DELETE,\n          );\n\n          result = dataTreeDeleteDiffs.concat(result);\n        }\n      } else if (\n        isTrueObject(difference.lhs) &&\n        !isTrueObject(difference.rhs)\n      ) {\n        // This will happen for static value changes where a property went\n        // from being an object to any other type like string or number\n        // in such a case we want to delete all nested paths of the\n        // original lhs object\n\n        result = translateCollectionDiffs(\n          propertyPath,\n          difference.lhs,\n          DataTreeDiffEvent.DELETE,\n        );\n\n        // when an object is being replaced by an array\n        // list all new array accessors that are being added\n        // so dependencies will be created based on existing bindings\n        if (Array.isArray(difference.rhs)) {\n          result = result.concat(\n            translateCollectionDiffs(\n              propertyPath,\n              difference.rhs,\n              DataTreeDiffEvent.NEW,\n            ),\n          );\n        }\n      } else if (\n        !isTrueObject(difference.lhs) &&\n        isTrueObject(difference.rhs)\n      ) {\n        // This will happen for static value changes where a property went\n        // from being any other type like string or number to an object\n        // in such a case we want to add all nested paths of the\n        // new rhs object\n        result = translateCollectionDiffs(\n          propertyPath,\n          difference.rhs,\n          DataTreeDiffEvent.NEW,\n        );\n\n        // when an array is being replaced by an object\n        // remove all array accessors that are deleted\n        // so dependencies by existing bindings are removed\n        if (Array.isArray(difference.lhs)) {\n          result = result.concat(\n            translateCollectionDiffs(\n              propertyPath,\n              difference.lhs,\n              DataTreeDiffEvent.DELETE,\n            ),\n          );\n        }\n      }\n      break;\n    }\n    case \"A\": {\n      return translateDiffEventToDataTreeDiffEvent(\n        {\n          ...difference.item,\n          path: [...difference.path, difference.index],\n        },\n        unEvalDataTree,\n      );\n    }\n    default: {\n      break;\n    }\n  }\n  return result;\n};\n\nexport const translateDiffArrayIndexAccessors = (\n  propertyPath: string,\n  array: unknown[],\n  event: DataTreeDiffEvent,\n) => {\n  const result: DataTreeDiff[] = [];\n  array.forEach((data, index) => {\n    const path = `${propertyPath}[${index}]`;\n    result.push({\n      event,\n      payload: {\n        propertyPath: path,\n      },\n    });\n  });\n  return result;\n};\n/*\n  Table1.selectedRow\n  Table1.selectedRow.email: [\"Input1.defaultText\"]\n */\n\nexport const addDependantsOfNestedPropertyPaths = (\n  parentPaths: Array<string>,\n  inverseMap: DependencyMap,\n): Set<string> => {\n  const withNestedPaths: Set<string> = new Set();\n  const dependantNodes = Object.keys(inverseMap);\n  parentPaths.forEach((propertyPath) => {\n    withNestedPaths.add(propertyPath);\n    dependantNodes\n      .filter((dependantNodePath) =>\n        isChildPropertyPath(propertyPath, dependantNodePath),\n      )\n      .forEach((dependantNodePath) => {\n        inverseMap[dependantNodePath].forEach((path) => {\n          withNestedPaths.add(path);\n        });\n      });\n  });\n  return withNestedPaths;\n};\n\nexport function isWidget(\n  entity: Partial<DataTreeEntity>,\n): entity is DataTreeWidget {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.WIDGET\n  );\n}\n\nexport const shouldSuppressAutoComplete = (widget: DataTreeWidget) =>\n  Boolean(widget.suppressAutoComplete);\n\nexport const shouldSuppressDebuggerError = (widget: DataTreeWidget) =>\n  Boolean(widget.suppressDebuggerError);\n\nexport function isAction(\n  entity: Partial<DataTreeEntity>,\n): entity is DataTreeAction {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.ACTION\n  );\n}\n\nexport function isAppsmithEntity(\n  entity: DataTreeEntity,\n): entity is DataTreeAppsmith {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.APPSMITH\n  );\n}\n\nexport function isJSAction(entity: DataTreeEntity): entity is DataTreeJSAction {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.JSACTION\n  );\n}\n\nexport function isJSObject(entity: DataTreeEntity): entity is DataTreeJSAction {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.JSACTION &&\n    \"pluginType\" in entity &&\n    entity.pluginType === PluginType.JS\n  );\n}\n\n// We need to remove functions from data tree to avoid any unexpected identifier while JSON parsing\n// Check issue https://github.com/appsmithorg/appsmith/issues/719\nexport const removeFunctions = (value: any) => {\n  if (_.isFunction(value)) {\n    return \"Function call\";\n  } else if (_.isObject(value)) {\n    return JSON.parse(\n      JSON.stringify(value, (_, v) =>\n        typeof v === \"bigint\" ? v.toString() : v,\n      ),\n    );\n  } else {\n    return value;\n  }\n};\n\nexport const makeParentsDependOnChildren = (\n  depMap: DependencyMap,\n  allkeys: Record<string, true>,\n): DependencyMap => {\n  //return depMap;\n  // Make all parents depend on child\n  Object.keys(depMap).forEach((key) => {\n    depMap = makeParentsDependOnChild(depMap, key, allkeys);\n    depMap[key].forEach((path) => {\n      depMap = makeParentsDependOnChild(depMap, path, allkeys);\n    });\n  });\n  return depMap;\n};\n\nexport const makeParentsDependOnChild = (\n  depMap: DependencyMap,\n  child: string,\n  allkeys: Record<string, true>,\n): DependencyMap => {\n  const result: DependencyMap = depMap;\n  let curKey = child;\n  if (!allkeys[curKey]) {\n    logWarn(\n      `makeParentsDependOnChild - ${curKey} is not present in dataTree.`,\n      \"This might result in a cyclic dependency.\",\n    );\n  }\n  let matches: Array<string> | null;\n  // Note: The `=` is intentional\n  // Stops looping when match is null\n  while ((matches = curKey.match(IMMEDIATE_PARENT_REGEX)) !== null) {\n    const parentKey = matches[1];\n    // Todo: switch everything to set.\n    const existing = new Set(result[parentKey] || []);\n    existing.add(curKey);\n    result[parentKey] = Array.from(existing);\n    curKey = parentKey;\n  }\n  return result;\n};\n\n// The idea is to find the immediate parents of the property paths\n// e.g. For Table1.selectedRow.email, the parent is Table1.selectedRow\nexport const getImmediateParentsOfPropertyPaths = (\n  propertyPaths: Array<string>,\n): Array<string> => {\n  // Use a set to ensure that we dont have duplicates\n  const parents: Set<string> = new Set();\n\n  propertyPaths.forEach((path) => {\n    const matches = path.match(IMMEDIATE_PARENT_REGEX);\n\n    if (matches !== null) {\n      parents.add(matches[1]);\n    }\n  });\n\n  return Array.from(parents);\n};\n\nexport const getAllPaths = (\n  records: any,\n  curKey = \"\",\n  result: Record<string, true> = {},\n): Record<string, true> => {\n  // Add the key if it exists\n  if (curKey) result[curKey] = true;\n  if (Array.isArray(records)) {\n    for (let i = 0; i < records.length; i++) {\n      const tempKey = curKey ? `${curKey}[${i}]` : `${i}`;\n      getAllPaths(records[i], tempKey, result);\n    }\n  } else if (typeof records === \"object\" && records) {\n    for (const key of Object.keys(records)) {\n      const tempKey = curKey ? `${curKey}.${key}` : `${key}`;\n      getAllPaths(records[key], tempKey, result);\n    }\n  }\n  return result;\n};\nexport const trimDependantChangePaths = (\n  changePaths: Set<string>,\n  dependencyMap: DependencyMap,\n): Array<string> => {\n  const trimmedPaths = [];\n  for (const path of changePaths) {\n    let foundADependant = false;\n    if (path in dependencyMap) {\n      const dependants = dependencyMap[path];\n      for (const dependantPath of dependants) {\n        if (changePaths.has(dependantPath)) {\n          foundADependant = true;\n          break;\n        }\n      }\n    }\n    if (!foundADependant) {\n      trimmedPaths.push(path);\n    }\n  }\n  return trimmedPaths;\n};\n\nexport function getSafeToRenderDataTree(\n  tree: DataTree,\n  widgetTypeConfigMap: WidgetTypeConfigMap,\n) {\n  return Object.keys(tree).reduce((tree, entityKey: string) => {\n    const entity = tree[entityKey] as DataTreeWidget;\n    if (!isWidget(entity)) {\n      return tree;\n    }\n    const safeToRenderEntity = { ...entity };\n    // Set user input values to their parsed values\n    Object.entries(entity.validationPaths).forEach(([property, validation]) => {\n      const value = _.get(entity, property);\n      // Pass it through parse\n      const { parsed } = validateWidgetProperty(\n        validation,\n        value,\n        entity,\n        property,\n      );\n      _.set(safeToRenderEntity, property, parsed);\n    });\n    // Set derived values to undefined or else they would go as bindings\n    Object.keys(widgetTypeConfigMap[entity.type].derivedProperties).forEach(\n      (property) => {\n        _.set(safeToRenderEntity, property, undefined);\n      },\n    );\n    return { ...tree, [entityKey]: safeToRenderEntity };\n  }, tree);\n}\n\nexport const addErrorToEntityProperty = ({\n  dataTree,\n  errors,\n  evalProps,\n  fullPropertyPath,\n}: {\n  errors: EvaluationError[];\n  dataTree: DataTree;\n  fullPropertyPath: string;\n  evalProps: EvalProps;\n}) => {\n  const { entityName, propertyPath } = getEntityNameAndPropertyPath(\n    fullPropertyPath,\n  );\n  const isPrivateEntityPath = getAllPrivateWidgetsInDataTree(dataTree)[\n    entityName\n  ];\n  const logBlackList = get(dataTree, `${entityName}.logBlackList`, {});\n  if (propertyPath && !(propertyPath in logBlackList) && !isPrivateEntityPath) {\n    const errorPath = `${entityName}.${EVAL_ERROR_PATH}['${propertyPath}']`;\n    const existingErrors = get(evalProps, errorPath, []) as EvaluationError[];\n    set(evalProps, errorPath, existingErrors.concat(errors));\n  }\n\n  return dataTree;\n};\n\nexport const resetValidationErrorsForEntityProperty = ({\n  evalProps,\n  fullPropertyPath,\n}: {\n  fullPropertyPath: string;\n  evalProps: EvalProps;\n}) => {\n  const { entityName, propertyPath } = getEntityNameAndPropertyPath(\n    fullPropertyPath,\n  );\n  if (propertyPath) {\n    const errorPath = `${entityName}.${EVAL_ERROR_PATH}['${propertyPath}']`;\n    const existingErrorsExceptValidation = (_.get(\n      evalProps,\n      errorPath,\n      [],\n    ) as EvaluationError[]).filter(\n      (error) => error.errorType !== PropertyEvaluationErrorType.VALIDATION,\n    );\n    _.set(evalProps, errorPath, existingErrorsExceptValidation);\n  }\n};\n\n// For the times when you need to know if something truly an object like { a: 1, b: 2}\n// typeof, lodash.isObject and others will return false positives for things like array, null, etc\nexport const isTrueObject = (\n  item: unknown,\n): item is Record<string, unknown> => {\n  return Object.prototype.toString.call(item) === \"[object Object]\";\n};\n\n/**\n * This function finds the datatype of the given value.\n * typeof, lodash and others will return false positives for things like array, wrapper objects, etc\n * @param value\n * @returns datatype of the received value as string\n */\nexport const findDatatype = (value: unknown) => {\n  return Object.prototype.toString\n    .call(value)\n    .slice(8, -1)\n    .toLowerCase();\n};\n\nexport const isDynamicLeaf = (unEvalTree: DataTree, propertyPath: string) => {\n  const [entityName, ...propPathEls] = _.toPath(propertyPath);\n  // Framework feature: Top level items are never leaves\n  if (entityName === propertyPath) return false;\n  // Ignore if this was a delete op\n  if (!unEvalTree.hasOwnProperty(entityName)) return false;\n\n  const entity = unEvalTree[entityName];\n  if (!isAction(entity) && !isWidget(entity) && !isJSAction(entity))\n    return false;\n  const relativePropertyPath = convertPathToString(propPathEls);\n  return (\n    relativePropertyPath in entity.reactivePaths ||\n    (isWidget(entity) && relativePropertyPath in entity.triggerPaths)\n  );\n};\n\nexport const addWidgetPropertyDependencies = ({\n  entity,\n  entityName,\n}: {\n  entity: DataTreeWidget;\n  entityName: string;\n}) => {\n  const dependencies: DependencyMap = {};\n\n  Object.entries(entity.propertyOverrideDependency).forEach(\n    ([overriddenPropertyKey, overridingPropertyKeyMap]) => {\n      const existingDependenciesSet = new Set(\n        dependencies[`${entityName}.${overriddenPropertyKey}`] || [],\n      );\n      // add meta dependency\n      overridingPropertyKeyMap.META &&\n        existingDependenciesSet.add(\n          `${entityName}.${overridingPropertyKeyMap.META}`,\n        );\n      // add default dependency\n      overridingPropertyKeyMap.DEFAULT &&\n        existingDependenciesSet.add(\n          `${entityName}.${overridingPropertyKeyMap.DEFAULT}`,\n        );\n\n      dependencies[`${entityName}.${overriddenPropertyKey}`] = [\n        ...existingDependenciesSet,\n      ];\n    },\n  );\n  return dependencies;\n};\n\nexport const isPrivateEntityPath = (\n  privateWidgets: PrivateWidgets,\n  fullPropertyPath: string,\n) => {\n  const entityName = fullPropertyPath.split(\".\")[0];\n  if (Object.keys(privateWidgets).indexOf(entityName) !== -1) {\n    return true;\n  }\n  return false;\n};\n\nexport const getAllPrivateWidgetsInDataTree = (\n  dataTree: DataTree,\n): PrivateWidgets => {\n  let privateWidgets: PrivateWidgets = {};\n\n  Object.keys(dataTree).forEach((entityName) => {\n    const entity = dataTree[entityName];\n    if (isWidget(entity) && !_.isEmpty(entity.privateWidgets)) {\n      privateWidgets = { ...privateWidgets, ...entity.privateWidgets };\n    }\n  });\n\n  return privateWidgets;\n};\n\nexport const getDataTreeWithoutPrivateWidgets = (\n  dataTree: DataTree,\n): DataTree => {\n  const privateWidgets = getAllPrivateWidgetsInDataTree(dataTree);\n  const privateWidgetNames = Object.keys(privateWidgets);\n  const treeWithoutPrivateWidgets = _.omit(dataTree, privateWidgetNames);\n  return treeWithoutPrivateWidgets;\n};\n\nconst getDataTreeWithoutSuppressedAutoComplete = (\n  dataTree: DataTree,\n): DataTree => {\n  const entityIds = Object.keys(dataTree).filter((entityName) => {\n    const entity = dataTree[entityName];\n    return isWidget(entity) && shouldSuppressAutoComplete(entity);\n  });\n\n  return _.omit(dataTree, entityIds);\n};\n\nexport const getDataTreeForAutocomplete = (dataTree: DataTree): DataTree => {\n  const treeWithoutPrivateWidgets = getDataTreeWithoutPrivateWidgets(dataTree);\n  const treeWithoutSuppressedAutoComplete = getDataTreeWithoutSuppressedAutoComplete(\n    treeWithoutPrivateWidgets,\n  );\n\n  return treeWithoutSuppressedAutoComplete;\n};\n\n/**\n *  overrideWidgetProperties method has logic to update overriddenPropertyPaths when overridingPropertyPaths are evaluated.\n *\n *  when we evaluate widget's overridingPropertyPaths for example defaultText of input widget,\n *  we override the values like text and meta.text in dataTree, these values are called as overriddenPropertyPaths\n *\n * @param {{\n *   entity: DataTreeWidget;\n *   propertyPath: string;\n *   value: unknown;\n *   currentTree: DataTree;\n *   evalMetaUpdates: EvalMetaUpdates;\n * }} params\n * @return {*}\n */\nexport const overrideWidgetProperties = (params: {\n  entity: DataTreeWidget;\n  propertyPath: string;\n  value: unknown;\n  currentTree: DataTree;\n  evalMetaUpdates: EvalMetaUpdates;\n  isNewWidget: boolean;\n}) => {\n  const {\n    currentTree,\n    entity,\n    evalMetaUpdates,\n    isNewWidget,\n    propertyPath,\n    value,\n  } = params;\n  const clonedValue = klona(value);\n  if (propertyPath in entity.overridingPropertyPaths) {\n    const overridingPropertyPaths =\n      entity.overridingPropertyPaths[propertyPath];\n\n    const pathsNotToOverride = widgetPathsNotToOverride(\n      isNewWidget,\n      entity,\n      propertyPath,\n    );\n\n    overridingPropertyPaths.forEach((overriddenPropertyPath) => {\n      const overriddenPropertyPathArray = overriddenPropertyPath.split(\".\");\n      if (pathsNotToOverride.includes(overriddenPropertyPath)) return;\n      _.set(\n        currentTree,\n        [entity.widgetName, ...overriddenPropertyPathArray],\n        clonedValue,\n      );\n      // evalMetaUpdates has all updates from property which overrides meta values.\n      if (\n        propertyPath.split(\".\")[0] !== \"meta\" &&\n        overriddenPropertyPathArray[0] === \"meta\"\n      ) {\n        const metaPropertyPath = overriddenPropertyPathArray.slice(1);\n        evalMetaUpdates.push({\n          widgetId: entity.widgetId,\n          metaPropertyPath,\n          value: clonedValue,\n        });\n      }\n    });\n  } else if (\n    propertyPath in entity.propertyOverrideDependency &&\n    clonedValue === undefined\n  ) {\n    // When a reset a widget its meta value becomes undefined, ideally they should reset to default value.\n    // below we handle logic to reset meta values to default values.\n    const propertyOverridingKeyMap =\n      entity.propertyOverrideDependency[propertyPath];\n    if (propertyOverridingKeyMap.DEFAULT) {\n      const defaultValue = entity[propertyOverridingKeyMap.DEFAULT];\n      const clonedDefaultValue = klona(defaultValue);\n      if (defaultValue !== undefined) {\n        const propertyPathArray = propertyPath.split(\".\");\n        _.set(\n          currentTree,\n          [entity.widgetName, ...propertyPathArray],\n          clonedDefaultValue,\n        );\n\n        return {\n          overwriteParsedValue: true,\n          newValue: clonedDefaultValue,\n        };\n      }\n    }\n  }\n};\nexport function isValidEntity(\n  entity: DataTreeEntity,\n): entity is DataTreeObjectEntity {\n  if (!isObject(entity)) {\n    return false;\n  }\n  return \"ENTITY_TYPE\" in entity;\n}\nexport const isATriggerPath = (\n  entity: DataTreeEntity,\n  propertyPath: string,\n) => {\n  return isWidget(entity) && isPathDynamicTrigger(entity, propertyPath);\n};\n\n// Checks if entity newly got added to the unevalTree\nexport const isNewEntity = (updates: DataTreeDiff[], entityName: string) => {\n  return !!find(updates, {\n    event: DataTreeDiffEvent.NEW,\n    payload: { propertyPath: entityName },\n  });\n};\n\nconst widgetPathsNotToOverride = (\n  isNewWidget: boolean,\n  entity: DataTreeWidget,\n  propertyPath: string,\n) => {\n  let pathsNotToOverride: string[] = [];\n  const overriddenPropertyPaths = entity.overridingPropertyPaths[propertyPath];\n\n  // Check if widget has pre-existing meta values (although newly added to the unevalTree)\n  if (isNewWidget && entity.isMetaPropDirty) {\n    const overriddenMetaPaths = overriddenPropertyPaths.filter(\n      (path) => path.split(\".\")[0] === \"meta\",\n    );\n    // If widget is newly added but has pre-existing meta values, this meta values take precedence and should not be overridden\n    pathsNotToOverride = [...overriddenMetaPaths];\n    // paths which these meta values override should also not get overridden\n    overriddenMetaPaths.forEach((path) => {\n      if (entity.overridingPropertyPaths.hasOwnProperty(path)) {\n        pathsNotToOverride = [\n          ...pathsNotToOverride,\n          ...entity.overridingPropertyPaths[path],\n        ];\n      }\n    });\n  }\n  return pathsNotToOverride;\n};\n\nconst isWidgetDefaultPropertyPath = (\n  widget: DataTreeWidget,\n  propertyPath: string,\n) => {\n  for (const property of Object.keys(widget.propertyOverrideDependency)) {\n    const overrideDependency = widget.propertyOverrideDependency[property];\n    if (overrideDependency.DEFAULT === propertyPath) return true;\n  }\n  return false;\n};\n\nconst isMetaWidgetTemplate = (widget: DataTreeWidget) => {\n  return !!widget.siblingMetaWidgets;\n};\n\n// When a default value changes in a template(widgets used to generate other widgets), meta values of metaWidgets not present in the unevalTree become stale\nexport function getStaleMetaStateIds(args: {\n  entity: DataTreeWidget;\n  propertyPath: string;\n  isNewWidget: boolean;\n  metaWidgets: string[];\n}) {\n  const { entity, isNewWidget, metaWidgets, propertyPath } = args;\n  return !isNewWidget &&\n    isWidgetDefaultPropertyPath(entity, propertyPath) &&\n    isMetaWidgetTemplate(entity)\n    ? difference(entity.siblingMetaWidgets, metaWidgets)\n    : [];\n}\n\nexport function convertJSFunctionsToString(\n  jscollections: Record<string, DataTreeJSAction>,\n) {\n  const collections = klona(jscollections);\n  Object.keys(collections).forEach((collectionName) => {\n    const jsCollection = collections[collectionName];\n    const jsFunctions = jsCollection.meta;\n    for (const funcName in jsFunctions) {\n      if (jsCollection[funcName] instanceof String) {\n        if (has(jsCollection, [funcName, \"data\"])) {\n          set(jsCollection, [`${funcName}.data`], jsCollection[funcName].data);\n        }\n        set(jsCollection, funcName, jsCollection[funcName].toString());\n      }\n    }\n  });\n\n  return collections;\n}\n","export enum AppsmithWorkers {\n  LINT_WORKER = \"LINT_WORKER\",\n  EVALUATION_WORKER = \"EVALUATION_WORKER\",\n  SETUP_WORKER = \"SETUP_WORKER\",\n}\nexport enum WorkerErrorTypes {\n  CLONE_ERROR = \"CLONE_ERROR\",\n}\n\nexport interface WorkerRequest<TData, TActions> {\n  method: TActions;\n  data: TData;\n}\n","import { Position } from \"codemirror\";\n\n// For these error types, we want to show a warning\n// All messages can be found here => https://github.com/jshint/jshint/blob/2.9.5/src/messages.js\nexport const WARNING_LINT_ERRORS = {\n  W098: \"'{a}' is defined but never used.\",\n  W014:\n    \"Misleading line break before '{a}'; readers may interpret this as an expression boundary.\",\n};\n\n/** These errors should be overlooked\n * E041 => Unrecoverable syntax error.\n * W032 => Unnecessary semicolon.\n */\nexport const IGNORED_LINT_ERRORS = [\"E041\", \"W032\"];\n\n// https://github.com/jshint/jshint/blob/d3d84ae1695359aef077ddb143f4be98001343b4/src/messages.js#L204\nexport const IDENTIFIER_NOT_DEFINED_LINT_ERROR_CODE = \"W117\";\n\n// Refined error messages\nexport const REFINED_LINT_ERROR_MESSAGES: Record<string, string> = {\n  \"'await' is not defined.\":\n    \"'await' expressions are only allowed within async functions. Did you mean to mark this function as 'async'?\",\n};\n\nexport const LINT_TOOLTIP_CLASS = \"CodeMirror-lint-tooltip\";\nexport const LINT_TOOLTIP_JUSTIFIED_LEFT_CLASS = \"CodeMirror-lint-tooltip-left\";\nexport enum LintTooltipDirection {\n  left = \"left\",\n  right = \"right\",\n}\nexport const JS_OBJECT_START_STATEMENT = \"export default\";\nexport const INVALID_JSOBJECT_START_STATEMENT = `JSObject must start with '${JS_OBJECT_START_STATEMENT}'`;\nexport const CODE_EDITOR_START_POSITION: Position = { line: 0, ch: 0 };\nexport const VALID_JS_OBJECT_BINDING_POSITION: Position = {\n  line: 0,\n  ch: JS_OBJECT_START_STATEMENT.length,\n};\nexport const SUPPORTED_WEB_APIS = {\n  console: true,\n  crypto: true,\n};\nexport enum CustomLintErrorCode {\n  INVALID_ENTITY_PROPERTY = \"INVALID_ENTITY_PROPERTY\",\n}\nexport const CUSTOM_LINT_ERRORS: Record<\n  CustomLintErrorCode,\n  (...args: any[]) => string\n> = {\n  [CustomLintErrorCode.INVALID_ENTITY_PROPERTY]: (\n    entityName: string,\n    propertyName: string,\n  ) => `\"${propertyName}\" doesn't exist in ${entityName}`,\n};\n","import { last, isNumber, isEmpty } from \"lodash\";\nimport { Annotation, Position } from \"codemirror\";\nimport { isDynamicValue, LintError } from \"utils/DynamicBindingUtils\";\nimport { Severity } from \"entities/AppsmithConsole\";\nimport {\n  CODE_EDITOR_START_POSITION,\n  CUSTOM_LINT_ERRORS,\n  IDENTIFIER_NOT_DEFINED_LINT_ERROR_CODE,\n  INVALID_JSOBJECT_START_STATEMENT,\n  JS_OBJECT_START_STATEMENT,\n  LintTooltipDirection,\n  REFINED_LINT_ERROR_MESSAGES,\n  VALID_JS_OBJECT_BINDING_POSITION,\n  WARNING_LINT_ERRORS,\n} from \"./constants\";\nimport { AdditionalDynamicDataTree } from \"utils/autocomplete/customTreeTypeDefCreator\";\nexport const getIndexOfRegex = (\n  str: string,\n  regex: RegExp,\n  start = 0,\n): number => {\n  const pos = str.slice(start).search(regex);\n  return pos > -1 ? pos + start : pos;\n};\n\ninterface LintAnnotationOptions {\n  isJSObject: boolean;\n  contextData: AdditionalDynamicDataTree;\n}\n\n/**\n *\n * @param error\n * @param contextData\n * @returns A boolean signifying the presence of an identifier which the linter records as been \"not defined\"\n * but is passed to the editor as additional dynamic data\n */\nconst hasUndefinedIdentifierInContextData = (\n  error: LintError,\n  contextData: LintAnnotationOptions[\"contextData\"],\n) => {\n  /**\n   * W117: \"'{a}' is not defined.\",\n   * error has only one variable \"a\", which is the name of the variable which is not defined.\n   *  */\n  return (\n    error.code === IDENTIFIER_NOT_DEFINED_LINT_ERROR_CODE &&\n    error.variables &&\n    error.variables[0] &&\n    error.variables[0] in contextData\n  );\n};\nconst buildBoundaryRegex = (key: string) => {\n  return key\n    .replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\")\n    .replace(/\\w+/g, \"\\\\b$&\\\\b\");\n};\n\nexport const getAllWordOccurrences = (str: string, key: string) => {\n  const indices = [];\n  let index, startIndex;\n  const regex = new RegExp(buildBoundaryRegex(key));\n  index = getIndexOfRegex(str, regex, startIndex);\n  while (index > -1) {\n    indices.push(index);\n    startIndex = index + key.length;\n    index = getIndexOfRegex(str, regex, startIndex);\n  }\n\n  return indices;\n};\n\nexport const getKeyPositionInString = (\n  str: string,\n  key: string,\n): Position[] => {\n  const indices = getAllWordOccurrences(str, key);\n  let positions: Position[] = [];\n  if (str.includes(\"\\n\")) {\n    for (const index of indices) {\n      const substr = str.slice(0, index);\n      const substrLines = substr.split(\"\\n\");\n      const ch = last(substrLines)?.length || 0;\n      const line = substrLines.length - 1;\n\n      positions.push({ line, ch });\n    }\n  } else {\n    positions = indices.map((index) => ({ line: 0, ch: index }));\n  }\n  return positions;\n};\n\nexport const getFirstNonEmptyPosition = (lines: string[]): Position => {\n  const lineNumber = lines.findIndex((line) => !isEmpty(line));\n  return lineNumber > -1\n    ? {\n        line: lineNumber,\n        ch: lines[lineNumber].length,\n      }\n    : CODE_EDITOR_START_POSITION;\n};\n\nexport const filterInvalidLintErrors = (\n  errors: LintError[],\n  contextData?: AdditionalDynamicDataTree,\n) => {\n  return errors.filter(\n    (error) =>\n      // Remove all errors where additional dynamic data is reported as undefined\n      !(contextData && hasUndefinedIdentifierInContextData(error, contextData)),\n  );\n};\n\nexport const getLintAnnotations = (\n  value: string,\n  errors: LintError[],\n  options: Partial<LintAnnotationOptions>,\n): Annotation[] => {\n  const { contextData, isJSObject } = options;\n  const annotations: Annotation[] = [];\n  const lintErrors = filterInvalidLintErrors(errors, contextData);\n  const lines = value.split(\"\\n\");\n\n  // The binding position of every valid JS Object is constant, so we need not\n  // waste time checking for position of binding.\n  // For JS Objects not starting with the expected \"export default\" statement, we return early\n  // with a \"invalid start statement\" lint error\n  if (\n    isJSObject &&\n    !isEmpty(lines) &&\n    !lines[0].startsWith(JS_OBJECT_START_STATEMENT)\n  ) {\n    return [\n      {\n        from: CODE_EDITOR_START_POSITION,\n        to: getFirstNonEmptyPosition(lines),\n        message: INVALID_JSOBJECT_START_STATEMENT,\n        severity: Severity.ERROR,\n      },\n    ];\n  }\n\n  lintErrors.forEach((error) => {\n    const {\n      ch,\n      errorMessage,\n      line,\n      originalBinding,\n      severity,\n      variables,\n    } = error;\n\n    if (!originalBinding) {\n      return annotations;\n    }\n\n    let variableLength = 1;\n    // Find the variable with minimal length\n    if (variables) {\n      for (const variable of variables) {\n        if (variable) {\n          variableLength =\n            variableLength === 1\n              ? String(variable).length\n              : Math.min(String(variable).length, variableLength);\n        }\n      }\n    }\n\n    const bindingPositions = isJSObject\n      ? [VALID_JS_OBJECT_BINDING_POSITION]\n      : getKeyPositionInString(value, originalBinding);\n\n    if (isNumber(line) && isNumber(ch)) {\n      for (const bindingLocation of bindingPositions) {\n        const currentLine = bindingLocation.line + line;\n        const lineContent = lines[currentLine] || \"\";\n        let currentCh: number;\n\n        // for case where \"{{\" is in the same line as the lint error\n        if (bindingLocation.line === currentLine) {\n          currentCh =\n            bindingLocation.ch +\n            ch +\n            // Add 2 to account for \"{{\", if binding is a dynamicValue (NB: JS Objects are dynamicValues without \"{{}}\")\n            (isDynamicValue(originalBinding) ? 2 : 0);\n        } else {\n          currentCh = ch;\n        }\n\n        // Jshint counts \\t as two characters and codemirror counts it as 1.\n        // So we need to subtract number of tabs to get accurate position.\n        // This is not needed for custom lint errors, since they are not generated by JSHint\n        const tabs =\n          error.code && error.code in CUSTOM_LINT_ERRORS\n            ? 0\n            : lineContent.slice(0, currentCh).match(/\\t/g)?.length || 0;\n        const from = {\n          line: currentLine,\n          ch: currentCh - tabs - 1,\n        };\n        const to = {\n          line: from.line,\n          ch: from.ch + variableLength,\n        };\n        annotations.push({\n          from,\n          to,\n          message: errorMessage.message,\n          severity,\n        });\n      }\n    } else {\n      // Don't show linting errors if code has parsing errors\n      return [];\n    }\n  });\n  return annotations;\n};\n\nexport const getLintSeverity = (\n  code: string,\n): Severity.WARNING | Severity.ERROR => {\n  const severity =\n    code in WARNING_LINT_ERRORS ? Severity.WARNING : Severity.ERROR;\n  return severity;\n};\n\n/* By default, lint tooltips are rendered to the right of the cursor\nif the tooltip overflows out of the page, we want to render it to the left of the cursor\n*/\nexport const getLintTooltipDirection = (\n  tooltip: Element,\n): LintTooltipDirection => {\n  if (\n    tooltip.getBoundingClientRect().right >\n    (window.innerWidth || document.documentElement.clientWidth)\n  ) {\n    return LintTooltipDirection.left;\n  } else {\n    return LintTooltipDirection.right;\n  }\n};\n\nexport const getLintErrorMessage = (reason: string): string => {\n  return reason in REFINED_LINT_ERROR_MESSAGES\n    ? REFINED_LINT_ERROR_MESSAGES[reason]\n    : reason;\n};\n","import { DATA_BIND_REGEX_GLOBAL } from \"constants/BindingsConstants\";\nimport { isBoolean, get, set, isString } from \"lodash\";\nimport {\n  ConditionalOutput,\n  FormConfigEvalObject,\n  FormEvalOutput,\n} from \"reducers/evaluationReducers/formEvaluationReducer\";\nimport { FormConfigType, HiddenType } from \"./BaseControl\";\nimport { diff, Diff } from \"deep-diff\";\nimport { MongoDefaultActionConfig } from \"constants/DatasourceEditorConstants\";\nimport { Action } from \"@sentry/react/dist/types\";\nimport { klona } from \"klona/full\";\n\nexport const evaluateCondtionWithType = (\n  conditions: Array<boolean> | undefined,\n  type: string | undefined,\n) => {\n  if (conditions) {\n    let flag;\n    //this is where each conditions gets evaluated\n    if (conditions.length > 1) {\n      if (type === \"AND\") {\n        flag = conditions.reduce((acc: any, item: boolean) => {\n          return acc && item;\n        }, conditions[0]);\n      } else if (type === \"OR\") {\n        flag = conditions.reduce((acc: any, item: boolean) => {\n          return acc || item;\n        }, undefined);\n      }\n    } else {\n      flag = conditions[0];\n    }\n    return flag;\n  }\n};\n\nexport const isHiddenConditionsEvaluation = (\n  values: any,\n  hidden?: HiddenType,\n): any => {\n  if (!!hidden && !isBoolean(hidden)) {\n    //if nested condtions are there recursively from bottom to top call this function on each condtion\n    let conditionType, conditions;\n    if (\"conditionType\" in hidden) {\n      conditionType = hidden.conditionType;\n    }\n    if (\"conditions\" in hidden) {\n      conditions = hidden.conditions;\n    }\n    if (Array.isArray(conditions)) {\n      conditions = conditions.map((rule: any) => {\n        return isHiddenConditionsEvaluation(values, rule);\n      });\n    } else {\n      return caculateIsHidden(values, hidden);\n    }\n    return evaluateCondtionWithType(conditions, conditionType);\n  }\n};\n\nexport const caculateIsHidden = (\n  values: any,\n  hiddenConfig?: HiddenType,\n  featureFlag?: boolean,\n) => {\n  if (!!hiddenConfig && !isBoolean(hiddenConfig)) {\n    let valueAtPath;\n    let value, comparison;\n    if (\"path\" in hiddenConfig) {\n      valueAtPath = get(values, hiddenConfig.path);\n    }\n    if (\"value\" in hiddenConfig) {\n      value = hiddenConfig.value;\n    }\n    if (\"comparison\" in hiddenConfig) {\n      comparison = hiddenConfig.comparison;\n    }\n\n    switch (comparison) {\n      case \"EQUALS\":\n        return valueAtPath === value;\n      case \"NOT_EQUALS\":\n        return valueAtPath !== value;\n      case \"GREATER\":\n        return valueAtPath > value;\n      case \"LESSER\":\n        return valueAtPath < value;\n      case \"IN\":\n        return Array.isArray(value) && value.includes(valueAtPath);\n      case \"NOT_IN\":\n        return Array.isArray(value) && !value.includes(valueAtPath);\n      case \"FEATURE_FLAG\":\n        // FEATURE_FLAG comparision is used to hide previous configs,\n        // and show new configs if feature flag is enabled, if disabled/ not present,\n        // previous config would be shown as is\n        return featureFlag === value;\n      default:\n        return true;\n    }\n  }\n};\n\nexport const isHidden = (\n  values: any,\n  hiddenConfig?: HiddenType,\n  featureFlag?: boolean,\n) => {\n  if (!!hiddenConfig && !isBoolean(hiddenConfig)) {\n    if (\"conditionType\" in hiddenConfig) {\n      //check if nested conditions exist\n      return isHiddenConditionsEvaluation(values, hiddenConfig);\n    } else {\n      return caculateIsHidden(values, hiddenConfig, featureFlag);\n    }\n  }\n  return !!hiddenConfig;\n};\n\nexport enum ViewTypes {\n  JSON = \"json\",\n  COMPONENT = \"component\",\n}\n\nexport const alternateViewTypeInputConfig = () => {\n  return {\n    label: \"\",\n    isValid: true,\n    controlType: \"QUERY_DYNAMIC_INPUT_TEXT\",\n    evaluationSubstitutionType: \"TEMPLATE\",\n    inputType: \"TEXT_WITH_BINDING\",\n    // showLineNumbers: true,\n  };\n};\n\nexport const getViewType = (values: any, configProperty: string) => {\n  if (\n    configProperty.startsWith(\"actionConfiguration.formData\") &&\n    configProperty.endsWith(\".data\")\n  ) {\n    const pathForViewType = configProperty.replace(\".data\", \".viewType\");\n    return get(values, pathForViewType, ViewTypes.COMPONENT);\n  } else {\n    return ViewTypes.COMPONENT;\n  }\n};\n\nexport const switchViewType = (\n  values: any,\n  configProperty: string,\n  viewType: string,\n  formName: string,\n  changeFormValue: (formName: string, path: string, value: any) => void,\n) => {\n  const newViewType =\n    viewType === ViewTypes.JSON ? ViewTypes.COMPONENT : ViewTypes.JSON;\n  const pathForJsonData = configProperty.replace(\".data\", \".jsonData\");\n  const pathForComponentData = configProperty.replace(\n    \".data\",\n    \".componentData\",\n  );\n  const componentData = get(values, pathForComponentData);\n  const currentData = get(values, configProperty, \"\");\n  const stringifiedCurrentData = JSON.stringify(currentData, null, \"\\t\");\n\n  if (newViewType === ViewTypes.JSON) {\n    changeFormValue(formName, pathForComponentData, currentData);\n\n    // when switching to JSON, we always want a form to json conversion of the data.\n    changeFormValue(\n      formName,\n      configProperty,\n      isString(currentData)\n        ? currentData\n        : stringifiedCurrentData.replace(/\\\\/g, \"\"),\n    );\n  } else {\n    changeFormValue(formName, pathForJsonData, currentData);\n    if (!!componentData) {\n      changeFormValue(formName, configProperty, componentData);\n    }\n  }\n\n  changeFormValue(\n    formName,\n    configProperty.replace(\".data\", \".viewType\"),\n    newViewType,\n  );\n};\n\n// Function that extracts the initial value from the JSON configs\nexport const getConfigInitialValues = (\n  config: Record<string, any>[],\n  multipleViewTypesSupported = false,\n) => {\n  const configInitialValues: Record<string, any> = {};\n\n  // We expect the JSON configs to be an array of objects\n  if (!Array.isArray(config)) return configInitialValues;\n\n  // Function to loop through the configs and extract the initial values\n  const parseConfig = (section: any): any => {\n    if (\"initialValue\" in section) {\n      if (section.controlType === \"KEYVALUE_ARRAY\") {\n        section.initialValue.forEach(\n          (initialValue: string | number, index: number) => {\n            const configProperty = section.configProperty.replace(\"*\", index);\n\n            set(configInitialValues, configProperty, initialValue);\n          },\n        );\n      } else {\n        set(configInitialValues, section.configProperty, section.initialValue);\n      }\n    } else if (section.controlType === \"WHERE_CLAUSE\") {\n      let logicalTypes = [];\n      if (\"logicalTypes\" in section && section.logicalTypes.length > 0) {\n        logicalTypes = section.logicalTypes;\n      } else {\n        logicalTypes = [\n          {\n            label: \"OR\",\n            value: \"OR\",\n          },\n          {\n            label: \"AND\",\n            value: \"AND\",\n          },\n        ];\n      }\n      set(\n        configInitialValues,\n        `${section.configProperty}.condition`,\n        logicalTypes[0].value,\n      );\n      if (\n        multipleViewTypesSupported &&\n        section.configProperty.includes(\".data\")\n      ) {\n        set(\n          configInitialValues,\n          section.configProperty.replace(\".data\", \".viewType\"),\n          \"component\",\n        );\n        set(\n          configInitialValues,\n          section.configProperty.replace(\".data\", \".componentData.condition\"),\n          logicalTypes[0].value,\n        );\n      }\n    }\n    if (\"children\" in section) {\n      section.children.forEach((childSection: any) => {\n        parseConfig(childSection);\n      });\n    } else if (\"schema\" in section) {\n      section.schema.forEach((childSection: any) => {\n        parseConfig(childSection);\n      });\n    } else if (\n      \"configProperty\" in section &&\n      multipleViewTypesSupported &&\n      section.configProperty.includes(\".data\")\n    ) {\n      set(\n        configInitialValues,\n        section.configProperty.replace(\".data\", \".viewType\"),\n        \"component\",\n      );\n      if (section.configProperty in configInitialValues) {\n        set(\n          configInitialValues,\n          section.configProperty.replace(\".data\", \".componentData\"),\n          configInitialValues[section.configProperty],\n        );\n      }\n    }\n  };\n\n  config.forEach((section: any) => {\n    parseConfig(section);\n  });\n\n  return configInitialValues;\n};\n\nexport const actionPathFromName = (\n  actionName: string,\n  name: string,\n): string => {\n  const ActionConfigStarts = \"actionConfiguration.\";\n  let path = name;\n  if (path.startsWith(ActionConfigStarts)) {\n    path = \"config.\" + path.slice(ActionConfigStarts.length);\n  }\n  return `${actionName}.${path}`;\n};\n\nexport enum PaginationSubComponent {\n  Limit = \"limit\",\n  Offset = \"offset\",\n  Cursor = \"cursor\",\n}\n\nexport enum SortingSubComponent {\n  Column = \"column\",\n  Order = \"order\",\n}\n\nexport enum WhereClauseSubComponent {\n  Condition = \"condition\",\n  Children = \"children\",\n  Key = \"key\",\n  Value = \"value\",\n}\n\nexport const allowedControlTypes = [\"DROP_DOWN\", \"QUERY_DYNAMIC_INPUT_TEXT\"];\n\nconst extractExpressionObject = (\n  config: string,\n  path: any,\n  parentPath: string,\n): FormConfigEvalObject => {\n  const bindingPaths: FormConfigEvalObject = {};\n  const expressions = config.match(DATA_BIND_REGEX_GLOBAL);\n  if (Array.isArray(expressions) && expressions.length > 0) {\n    const completePath = parentPath.length > 0 ? `${parentPath}.${path}` : path;\n    expressions.forEach((exp) => {\n      bindingPaths[completePath] = {\n        expression: exp,\n        output: \"\",\n      };\n    });\n  }\n  return bindingPaths;\n};\n\nexport const extractEvalConfigFromFormConfig = (\n  formConfig: FormConfigType,\n  paths: string[],\n  parentPath = \"\",\n  bindingsFound: FormConfigEvalObject = {},\n) => {\n  paths.forEach((path: string) => {\n    if (!(path in formConfig)) return;\n    const config = get(formConfig, path, \"\");\n    if (typeof config === \"string\") {\n      bindingsFound = {\n        ...bindingsFound,\n        ...extractExpressionObject(config, path, parentPath),\n      };\n    } else if (typeof config === \"object\") {\n      bindingsFound = {\n        ...bindingsFound,\n        ...extractEvalConfigFromFormConfig(\n          config,\n          Object.keys(config),\n          parentPath.length > 0 ? `${parentPath}.${path}` : path,\n          bindingsFound,\n        ),\n      };\n    }\n  });\n\n  return bindingsFound;\n};\n\n// Extract the output of conditionals attached to the form from the state\nexport const extractConditionalOutput = (\n  section: any,\n  formEvaluationState: FormEvalOutput,\n): ConditionalOutput => {\n  let conditionalOutput: ConditionalOutput = {};\n  if (\n    section.hasOwnProperty(\"propertyName\") &&\n    formEvaluationState.hasOwnProperty(section.propertyName)\n  ) {\n    conditionalOutput = formEvaluationState[section.propertyName];\n  } else if (\n    section.hasOwnProperty(\"configProperty\") &&\n    formEvaluationState.hasOwnProperty(section.configProperty)\n  ) {\n    conditionalOutput = formEvaluationState[section.configProperty];\n  } else if (\n    section.hasOwnProperty(\"identifier\") &&\n    !!section.identifier &&\n    formEvaluationState.hasOwnProperty(section.identifier)\n  ) {\n    conditionalOutput = formEvaluationState[section.identifier];\n  }\n  return conditionalOutput;\n};\n\n// Function to check if the section config is allowed to render (Only for UQI forms)\nexport const checkIfSectionCanRender = (\n  conditionalOutput: ConditionalOutput,\n) => {\n  // By default, allow the section to render. This is to allow for the case where no conditional is provided.\n  // The evaluation state disallows the section to render if the condition is not met. (Checkout formEval.ts)\n  let allowToRender = true;\n  if (\n    conditionalOutput.hasOwnProperty(\"visible\") &&\n    typeof conditionalOutput.visible === \"boolean\"\n  ) {\n    allowToRender = conditionalOutput.visible;\n  }\n\n  if (\n    conditionalOutput.hasOwnProperty(\"evaluateFormConfig\") &&\n    !!conditionalOutput.evaluateFormConfig &&\n    conditionalOutput.evaluateFormConfig.hasOwnProperty(\n      \"updateEvaluatedConfig\",\n    ) &&\n    typeof conditionalOutput.evaluateFormConfig.updateEvaluatedConfig ===\n      \"boolean\"\n  ) {\n    allowToRender = conditionalOutput.evaluateFormConfig.updateEvaluatedConfig;\n  }\n  return allowToRender;\n};\n\n// Function to check if the section config is enabled (Only for UQI forms)\nexport const checkIfSectionIsEnabled = (\n  conditionalOutput: ConditionalOutput,\n) => {\n  // By default, the section is enabled. This is to allow for the case where no conditional is provided.\n  // The evaluation state disables the section if the condition is not met. (Checkout formEval.ts)\n  let enabled = true;\n  if (\n    conditionalOutput.hasOwnProperty(\"enabled\") &&\n    typeof conditionalOutput.enabled === \"boolean\"\n  ) {\n    enabled = conditionalOutput.enabled;\n  }\n  return enabled;\n};\n\n// Function to modify the section config based on the output of evaluations\nexport const modifySectionConfig = (section: any, enabled: boolean): any => {\n  if (!enabled) {\n    section.disabled = true;\n  } else {\n    section.disabled = false;\n  }\n\n  return section;\n};\n\nexport const updateEvaluatedSectionConfig = (\n  section: any,\n  conditionalOutput: ConditionalOutput,\n  enabled = true,\n) => {\n  // we deep clone the section coming from the editorConfig to prevent any mutations of\n  // the editorConfig in the redux state.\n  // just spreading the object does a shallow clone(top level cloning), so we use the klona package to deep clone\n  // klona is faster than deepClone from lodash.\n\n  // leaving the commented code as a reminder of the above observation.\n  // const updatedSection = { ...section };\n  const updatedSection = klona(section);\n  let evaluatedConfig: FormConfigEvalObject = {};\n  if (\n    conditionalOutput.hasOwnProperty(\"evaluateFormConfig\") &&\n    !!conditionalOutput.evaluateFormConfig &&\n    conditionalOutput.evaluateFormConfig.hasOwnProperty(\n      \"updateEvaluatedConfig\",\n    ) &&\n    typeof conditionalOutput.evaluateFormConfig.updateEvaluatedConfig ===\n      \"boolean\" &&\n    conditionalOutput.evaluateFormConfig.updateEvaluatedConfig\n  ) {\n    evaluatedConfig =\n      conditionalOutput.evaluateFormConfig.evaluateFormConfigObject;\n\n    const paths = Object.keys(evaluatedConfig);\n    paths.forEach((path: string) => {\n      set(updatedSection, path, evaluatedConfig[path].output);\n    });\n  }\n\n  return modifySectionConfig(updatedSection, enabled);\n};\n\nexport function fixActionPayloadForMongoQuery(\n  action?: Action,\n): Action | undefined {\n  if (!action) return action;\n\n  /* eslint-disable */\n  //@ts-nocheck\n  try {\n    let actionObjectDiff: undefined | Diff<any, any>[] = diff(\n      action,\n      MongoDefaultActionConfig,\n    );\n    if (actionObjectDiff) {\n      actionObjectDiff = actionObjectDiff.filter((diff) => diff.kind === \"N\");\n      for (let i = 0; i < actionObjectDiff.length; i++) {\n        let path = \"\";\n        let value = \"\";\n        //kind = N indicates a newly added property/element\n        //This property is present in initialValues but not in action object\n        if (\n          actionObjectDiff &&\n          actionObjectDiff[i].hasOwnProperty(\"kind\") &&\n          actionObjectDiff[i].path &&\n          Array.isArray(actionObjectDiff[i].path) &&\n          actionObjectDiff[i]?.path?.length &&\n          actionObjectDiff[i]?.kind === \"N\"\n        ) {\n          // @ts-expect-error: Types are not available\n          if (typeof actionObjectDiff[i]?.path[0] === \"string\") {\n            // @ts-expect-error: Types are not available\n            path = actionObjectDiff[i]?.path?.join(\".\");\n          }\n          // @ts-expect-error: Types are not available\n          value = actionObjectDiff[i]?.rhs;\n          // @ts-expect-error: Types are not available\n          set(action, path, value);\n        }\n      }\n    }\n    return action;\n    //@ts-check\n  } catch (error) {\n    console.error(\"Error adding default paths in Mongo query\");\n    return action;\n  }\n}\n\n// Function to check if the config has KEYVALUE_ARRAY controlType with more than 1 dependent children\nexport function isKVArray(children: Array<any>) {\n  if (!Array.isArray(children) || children.length < 2) return false;\n  return (\n    children[0].controlType && children[0].controlType === \"KEYVALUE_ARRAY\"\n  );\n}\n","import { ErrorActionPayload } from \"sagas/ErrorSagas\";\nimport { ActionResponse } from \"api/ActionAPI\";\nimport { PluginType } from \"entities/Action\";\nimport queryActionSettingsConfig from \"constants/AppsmithActionConstants/formConfig/QuerySettingsConfig\";\nimport apiActionSettingsConfig from \"constants/AppsmithActionConstants/formConfig/ApiSettingsConfig\";\nimport apiActionEditorConfig from \"constants/AppsmithActionConstants/formConfig/ApiEditorConfigs\";\nimport saasActionSettingsConfig from \"constants/AppsmithActionConstants/formConfig/GoogleSheetsSettingsConfig\";\nimport apiActionDependencyConfig from \"constants/AppsmithActionConstants/formConfig/ApiDependencyConfigs\";\nimport apiActionDatasourceFormButtonConfig from \"constants/AppsmithActionConstants/formConfig/ApiDatasourceFormsButtonConfig\";\nimport { ENTITY_TYPE } from \"entities/DataTree/types\";\n\nexport type ExecuteActionPayloadEvent = {\n  type: EventType;\n  callback?: (result: ExecutionResult) => void;\n};\n\nexport type ExecutionResult = {\n  success: boolean;\n};\n\nexport type TriggerSource = {\n  id: string;\n  name: string;\n  entityType?: ENTITY_TYPE;\n  collectionId?: string;\n  isJSAction?: boolean;\n  actionId?: string;\n};\n\nexport type ExecuteTriggerPayload = {\n  dynamicString: string;\n  event: ExecuteActionPayloadEvent;\n  callbackData?: Array<any>;\n  triggerPropertyName?: string;\n  source?: TriggerSource;\n  widgetId?: string;\n  globalContext?: Record<string, unknown>;\n};\n\nexport type ContentType =\n  | \"application/json\"\n  | \"application/x-www-form-urlencoded\";\n\nexport interface APIHeaders {\n  \"Content-Type\": ContentType;\n  Accept?: string;\n}\n\nexport interface APIRequest {\n  requestId?: string;\n}\n\nexport enum EventType {\n  ON_RESET = \"ON_RESET\",\n  ON_PAGE_LOAD = \"ON_PAGE_LOAD\",\n  ON_PREV_PAGE = \"ON_PREV_PAGE\",\n  ON_NEXT_PAGE = \"ON_NEXT_PAGE\",\n  ON_PAGE_SIZE_CHANGE = \"ON_PAGE_SIZE_CHANGE\",\n  ON_ERROR = \"ON_ERROR\",\n  ON_SUCCESS = \"ON_SUCCESS\",\n  ON_ROW_SELECTED = \"ON_ROW_SELECTED\",\n  ON_SEARCH = \"ON_SEARCH\",\n  ON_CLICK = \"ON_CLICK\",\n  ON_DATA_POINT_CLICK = \"ON_DATA_POINT_CLICK\",\n  ON_FILES_SELECTED = \"ON_FILES_SELECTED\",\n  ON_HOVER = \"ON_HOVER\",\n  ON_TOGGLE = \"ON_TOGGLE\",\n  ON_LOAD = \"ON_LOAD\",\n  ON_MODAL_CLOSE = \"ON_MODAL_CLOSE\",\n  ON_TEXT_CHANGE = \"ON_TEXT_CHANGE\",\n  ON_SUBMIT = \"ON_SUBMIT\",\n  ON_CHECK_CHANGE = \"ON_CHECK_CHANGE\",\n  ON_SWITCH_CHANGE = \"ON_SWITCH_CHANGE\",\n  ON_SELECT = \"ON_SELECT\",\n  ON_DATE_SELECTED = \"ON_DATE_SELECTED\",\n  ON_DATE_RANGE_SELECTED = \"ON_DATE_RANGE_SELECTED\",\n  ON_DROPDOWN_OPEN = \"ON_DROPDOWN_OPEN\",\n  ON_DROPDOWN_CLOSE = \"ON_DROPDOWN_CLOSE\",\n  ON_OPTION_CHANGE = \"ON_OPTION_CHANGE\",\n  ON_FILTER_CHANGE = \"ON_FILTER_CHANGE\",\n  ON_FILTER_UPDATE = \"ON_FILTER_UPDATE\",\n  ON_MARKER_CLICK = \"ON_MARKER_CLICK\",\n  ON_CREATE_MARKER = \"ON_CREATE_MARKER\",\n  ON_TAB_CHANGE = \"ON_TAB_CHANGE\",\n  ON_VIDEO_START = \"ON_VIDEO_START\",\n  ON_VIDEO_END = \"ON_VIDEO_END\",\n  ON_VIDEO_PLAY = \"ON_VIDEO_PLAY\",\n  ON_VIDEO_PAUSE = \"ON_VIDEO_PAUSE\",\n  ON_AUDIO_START = \"ON_AUDIO_START\",\n  ON_AUDIO_END = \"ON_AUDIO_END\",\n  ON_AUDIO_PLAY = \"ON_AUDIO_PLAY\",\n  ON_AUDIO_PAUSE = \"ON_AUDIO_PAUSE\",\n  ON_RATE_CHANGED = \"ON_RATE_CHANGED\",\n  ON_IFRAME_URL_CHANGED = \"ON_IFRAME_URL_CHANGED\",\n  ON_IFRAME_SRC_DOC_CHANGED = \"ON_IFRAME_SRC_DOC_CHANGED\",\n  ON_IFRAME_MESSAGE_RECEIVED = \"ON_IFRAME_MESSAGE_RECEIVED\",\n  ON_SNIPPET_EXECUTE = \"ON_SNIPPET_EXECUTE\",\n  ON_SORT = \"ON_SORT\",\n  ON_CHECKBOX_GROUP_SELECTION_CHANGE = \"ON_CHECKBOX_GROUP_SELECTION_CHANGE\",\n  ON_LIST_PAGE_CHANGE = \"ON_LIST_PAGE_CHANGE\",\n  ON_RECORDING_START = \"ON_RECORDING_START\",\n  ON_RECORDING_COMPLETE = \"ON_RECORDING_COMPLETE\",\n  ON_SWITCH_GROUP_SELECTION_CHANGE = \"ON_SWITCH_GROUP_SELECTION_CHANGE\",\n  ON_JS_FUNCTION_EXECUTE = \"ON_JS_FUNCTION_EXECUTE\",\n  ON_CAMERA_IMAGE_CAPTURE = \"ON_CAMERA_IMAGE_CAPTURE\",\n  ON_CAMERA_IMAGE_SAVE = \"ON_CAMERA_IMAGE_SAVE\",\n  ON_CAMERA_VIDEO_RECORDING_START = \"ON_CAMERA_VIDEO_RECORDING_START\",\n  ON_CAMERA_VIDEO_RECORDING_STOP = \"ON_CAMERA_VIDEO_RECORDING_STOP\",\n  ON_CAMERA_VIDEO_RECORDING_SAVE = \"ON_CAMERA_VIDEO_RECORDING_SAVE\",\n  ON_ENTER_KEY_PRESS = \"ON_ENTER_KEY_PRESS\",\n  ON_BLUR = \"ON_BLUR\",\n  ON_FOCUS = \"ON_FOCUS\",\n  ON_BULK_SAVE = \"ON_BULK_SAVE\",\n  ON_BULK_DISCARD = \"ON_BULK_DISCARD\",\n  ON_ROW_SAVE = \"ON_ROW_SAVE\",\n  ON_ROW_DISCARD = \"ON_ROW_DISCARD\",\n  ON_CODE_DETECTED = \"ON_CODE_DETECTED\",\n  ON_ADD_NEW_ROW_SAVE = \"ON_ADD_NEW_ROW_SAVE\",\n  ON_ADD_NEW_ROW_DISCARD = \"ON_ADD_NEW_ROW_DISCARD\",\n}\n\nexport interface PageAction {\n  id: string;\n  pluginType: PluginType;\n  name: string;\n  jsonPathKeys: string[];\n  timeoutInMillisecond: number;\n  clientSideExecution?: boolean;\n  collectionId?: string;\n}\n\nexport interface ExecuteErrorPayload extends ErrorActionPayload {\n  actionId: string;\n  isPageLoad?: boolean;\n  data: ActionResponse;\n}\n\nexport interface LayoutOnLoadActionErrors {\n  errorType: string;\n  code: number;\n  message: string;\n}\n\n// Group 1 = datasource (https://www.domain.com)\n// Group 2 = path (/nested/path)\n// Group 3 = params (?param=123&param2=12)\nexport const urlGroupsRegexExp = /^(https?:\\/{2}\\S+?)(\\/[\\s\\S]*?)?(\\?(?![^{]*})[\\s\\S]*)?$/;\n\nexport const EXECUTION_PARAM_KEY = \"executionParams\";\nexport const EXECUTION_PARAM_REFERENCE_REGEX = /this.params|this\\?.params/g;\nexport const THIS_DOT_PARAMS_KEY = \"params\";\n\nexport const RESP_HEADER_DATATYPE = \"X-APPSMITH-DATATYPE\";\nexport const API_REQUEST_HEADERS: APIHeaders = {\n  \"Content-Type\": \"application/json\",\n};\nexport const POSTMAN = \"POSTMAN\";\nexport const CURL = \"CURL\";\nexport const Swagger = \"Swagger\";\n\nexport const defaultActionSettings: Record<PluginType, any> = {\n  [PluginType.API]: apiActionSettingsConfig,\n  [PluginType.DB]: queryActionSettingsConfig,\n  [PluginType.SAAS]: saasActionSettingsConfig,\n  [PluginType.REMOTE]: saasActionSettingsConfig,\n  [PluginType.JS]: [],\n};\n\nexport const defaultActionEditorConfigs: Record<PluginType, any> = {\n  [PluginType.API]: apiActionEditorConfig,\n  [PluginType.DB]: [],\n  [PluginType.SAAS]: [],\n  [PluginType.REMOTE]: [],\n  [PluginType.JS]: [],\n};\n\nexport const defaultActionDependenciesConfig: Record<\n  PluginType,\n  Record<string, string[]>\n> = {\n  [PluginType.API]: apiActionDependencyConfig,\n  [PluginType.DB]: {},\n  [PluginType.SAAS]: {},\n  [PluginType.REMOTE]: {},\n  [PluginType.JS]: {},\n};\n\nexport const defaultDatasourceFormButtonConfig: Record<PluginType, string[]> = {\n  [PluginType.API]: apiActionDatasourceFormButtonConfig.API,\n  [PluginType.DB]: apiActionDatasourceFormButtonConfig.DB,\n  [PluginType.SAAS]: apiActionDatasourceFormButtonConfig.SAAS,\n  [PluginType.REMOTE]: apiActionDatasourceFormButtonConfig.REMOTE,\n  [PluginType.JS]: [],\n};\n","export const DATA_BIND_REGEX = /{{([\\s\\S]*?)}}/;\nexport const DATA_BIND_REGEX_GLOBAL = /{{([\\s\\S]*?)}}/g;\nexport const AUTOCOMPLETE_MATCH_REGEX = /{{\\s*.*?\\s*}}/g;\nexport const QUOTED_BINDING_REGEX = /[\"']({{[\\s\\S]*?}})[\"']/g;\n","/* eslint-disable @typescript-eslint/ban-types */\nimport { DataTree } from \"entities/DataTree/dataTreeFactory\";\nimport { EvalContext } from \"workers/Evaluation/evaluate\";\nimport { EvaluationVersion } from \"api/ApplicationApi\";\nimport { addFn } from \"workers/Evaluation/fns/utils/fnGuard\";\nimport { set } from \"lodash\";\nimport {\n  entityFns,\n  getPlatformFunctions,\n} from \"@appsmith/workers/Evaluation/fns\";\ndeclare global {\n  /** All identifiers added to the worker global scope should also\n   * be included in the DEDICATED_WORKER_GLOBAL_SCOPE_IDENTIFIERS in\n   * app/client/src/constants/WidgetValidation.ts\n   * */\n\n  interface Window {\n    $isDataField: boolean;\n    $isAsync: boolean;\n    $evaluationVersion: EvaluationVersion;\n    $cloudHosting: boolean;\n  }\n}\n\nexport enum ExecutionType {\n  PROMISE = \"PROMISE\",\n  TRIGGER = \"TRIGGER\",\n}\n\n/**\n * This method returns new dataTree with entity function and platform function\n */\nexport const addDataTreeToContext = (args: {\n  EVAL_CONTEXT: EvalContext;\n  dataTree: Readonly<DataTree>;\n  skipEntityFunctions?: boolean;\n  isTriggerBased: boolean;\n}) => {\n  const {\n    dataTree,\n    EVAL_CONTEXT,\n    isTriggerBased,\n    skipEntityFunctions = false,\n  } = args;\n  const dataTreeEntries = Object.entries(dataTree);\n  const entityFunctionCollection: Record<string, Record<string, Function>> = {};\n\n  for (const [entityName, entity] of dataTreeEntries) {\n    EVAL_CONTEXT[entityName] = entity;\n    if (skipEntityFunctions || !isTriggerBased) continue;\n    for (const entityFn of entityFns) {\n      if (!entityFn.qualifier(entity)) continue;\n      const func = entityFn.fn(entity);\n      const fullPath = `${entityFn.path || `${entityName}.${entityFn.name}`}`;\n      set(entityFunctionCollection, fullPath, func);\n    }\n  }\n\n  // if eval is not trigger based i.e., sync eval then we skip adding entity and platform function to evalContext\n  if (!isTriggerBased) return;\n\n  for (const [entityName, funcObj] of Object.entries(\n    entityFunctionCollection,\n  )) {\n    EVAL_CONTEXT[entityName] = Object.assign({}, dataTree[entityName], funcObj);\n  }\n};\n\nexport const addPlatformFunctionsToEvalContext = (context: any) => {\n  for (const fnDef of getPlatformFunctions(self.$cloudHosting)) {\n    addFn(context, fnDef.name, fnDef.fn.bind(context));\n  }\n};\n\nexport const getAllAsyncFunctions = (dataTree: DataTree) => {\n  const asyncFunctionNameMap: Record<string, true> = {};\n  const dataTreeEntries = Object.entries(dataTree);\n  for (const [entityName, entity] of dataTreeEntries) {\n    for (const entityFn of entityFns) {\n      if (!entityFn.qualifier(entity)) continue;\n      const fullPath = `${entityFn.path || `${entityName}.${entityFn.name}`}`;\n      asyncFunctionNameMap[fullPath] = true;\n    }\n  }\n  for (const platformFn of getPlatformFunctions(self.$cloudHosting)) {\n    asyncFunctionNameMap[platformFn.name] = true;\n  }\n  return asyncFunctionNameMap;\n};\n","export enum EVAL_WORKER_SYNC_ACTION {\n  SETUP = \"SETUP\",\n  EVAL_TREE = \"EVAL_TREE\",\n  EVAL_ACTION_BINDINGS = \"EVAL_ACTION_BINDINGS\",\n  CLEAR_CACHE = \"CLEAR_CACHE\",\n  VALIDATE_PROPERTY = \"VALIDATE_PROPERTY\",\n  UNDO = \"undo\",\n  REDO = \"redo\",\n  UPDATE_REPLAY_OBJECT = \"UPDATE_REPLAY_OBJECT\",\n  SET_EVALUATION_VERSION = \"SET_EVALUATION_VERSION\",\n  INIT_FORM_EVAL = \"INIT_FORM_EVAL\",\n  EXECUTE_SYNC_JS = \"EXECUTE_SYNC_JS\",\n  INSTALL_LIBRARY = \"INSTALL_LIBRARY\",\n  UNINSTALL_LIBRARY = \"UNINSTALL_LIBRARY\",\n  LOAD_LIBRARIES = \"LOAD_LIBRARIES\",\n  LINT_TREE = \"LINT_TREE\",\n}\n\nexport enum EVAL_WORKER_ASYNC_ACTION {\n  EVAL_TRIGGER = \"EVAL_TRIGGER\",\n  EVAL_EXPRESSION = \"EVAL_EXPRESSION\",\n}\n\nexport const EVAL_WORKER_ACTIONS = {\n  ...EVAL_WORKER_SYNC_ACTION,\n  ...EVAL_WORKER_ASYNC_ACTION,\n};\n\nexport enum MAIN_THREAD_ACTION {\n  PROCESS_TRIGGER = \"PROCESS_TRIGGER\",\n  PROCESS_BATCHED_TRIGGERS = \"PROCESS_BATCHED_TRIGGERS\",\n  PROCESS_STORE_UPDATES = \"PROCESS_STORE_UPDATES\",\n  PROCESS_LOGS = \"PROCESS_LOGS\",\n  LINT_TREE = \"LINT_TREE\",\n  PROCESS_JS_FUNCTION_EXECUTION = \"PROCESS_JS_FUNCTION_EXECUTION\",\n}\n","export * from \"ce/workers/Evaluation/evalWorkerActions\";\nimport { MAIN_THREAD_ACTION as CE_MAIN_THREAD_ACTION } from \"ce/workers/Evaluation/evalWorkerActions\";\n\nexport const MAIN_THREAD_ACTION = {\n  ...CE_MAIN_THREAD_ACTION,\n  LOG_JS_FUNCTION_EXECUTION: \"LOG_JS_FUNCTION_EXECUTION\",\n};\n","import navigateTo, {\n  TNavigateToActionType,\n  TNavigateToDescription,\n} from \"./navigateTo\";\nimport showAlert, {\n  TShowAlertActionType,\n  TShowAlertDescription,\n} from \"./showAlert\";\nimport {\n  closeModal,\n  showModal,\n  TCloseModalActionType,\n  TCloseModalDescription,\n  TShowModalActionType,\n  TShowModalDescription,\n} from \"./modalFns\";\nimport download, {\n  TDownloadActionType,\n  TDownloadDescription,\n} from \"./download\";\nimport postWindowMessage, {\n  TPostWindowMessageActionType,\n  TPostWindowMessageDescription,\n} from \"./postWindowMessage\";\nimport copyToClipboard, {\n  TCopyToClipboardActionType,\n  TCopyToClipboardDescription,\n} from \"./copyToClipboard\";\nimport resetWidget, {\n  TResetWidgetActionType,\n  TResetWidgetDescription,\n} from \"./resetWidget\";\nimport {\n  clearStore,\n  removeValue,\n  storeValue,\n  TClearStoreDescription,\n  TRemoveValueDescription,\n  TStoreValueDescription,\n} from \"./storeFns\";\nimport run, {\n  clear,\n  TClearActionType,\n  TClearDescription,\n  TRunActionType,\n  TRunDescription,\n} from \"./actionFns\";\nimport {\n  isAction,\n  isAppsmithEntity,\n} from \"ce/workers/Evaluation/evaluationUtils\";\nimport {\n  DataTreeAction,\n  DataTreeEntity,\n} from \"entities/DataTree/dataTreeFactory\";\nimport {\n  getGeoLocation,\n  stopWatchGeoLocation,\n  TGetGeoLocationActionType,\n  TGetGeoLocationDescription,\n  TStopWatchGeoLocationActionType,\n  TStopWatchGeoLocationDescription,\n  TWatchGeoLocationActionType,\n  TWatchGeoLocationDescription,\n  watchGeoLocation,\n} from \"./geolocationFns\";\nimport { isAsyncGuard } from \"./utils/fnGuard\";\n\n// cloudHosting -> to use in EE\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getPlatformFunctions = (cloudHosting: boolean) => {\n  return platformFns;\n};\n\nconst platformFns = [\n  {\n    name: \"navigateTo\",\n    fn: navigateTo,\n  },\n  {\n    name: \"showAlert\",\n    fn: showAlert,\n  },\n  {\n    name: \"showModal\",\n    fn: showModal,\n  },\n  {\n    name: \"closeModal\",\n    fn: closeModal,\n  },\n  {\n    name: \"download\",\n    fn: download,\n  },\n  {\n    name: \"postWindowMessage\",\n    fn: postWindowMessage,\n  },\n  {\n    name: \"copyToClipboard\",\n    fn: copyToClipboard,\n  },\n  {\n    name: \"resetWidget\",\n    fn: resetWidget,\n  },\n  {\n    name: \"storeValue\",\n    fn: storeValue,\n  },\n  {\n    name: \"removeValue\",\n    fn: removeValue,\n  },\n  {\n    name: \"clearStore\",\n    fn: clearStore,\n  },\n];\n\nexport const entityFns = [\n  {\n    name: \"run\",\n    qualifier: (entity: DataTreeEntity) => isAction(entity),\n    fn: (entity: DataTreeEntity) =>\n      isAsyncGuard(run.bind(entity), `${(entity as DataTreeAction).name}.run`),\n  },\n  {\n    name: \"clear\",\n    qualifier: (entity: DataTreeEntity) => isAction(entity),\n    fn: (entity: DataTreeEntity) =>\n      isAsyncGuard(\n        clear.bind(entity),\n        `${(entity as DataTreeAction).name}.clear`,\n      ),\n  },\n  {\n    name: \"getGeoLocation\",\n    path: \"appsmith.geolocation.getCurrentPosition\",\n    qualifier: (entity: DataTreeEntity) => isAppsmithEntity(entity),\n    fn: () =>\n      isAsyncGuard(getGeoLocation, \"appsmith.geolocation.getCurrentPosition\"),\n  },\n  {\n    name: \"watchGeoLocation\",\n    path: \"appsmith.geolocation.watchPosition\",\n    qualifier: (entity: DataTreeEntity) => isAppsmithEntity(entity),\n    fn: () =>\n      isAsyncGuard(watchGeoLocation, \"appsmith.geolocation.watchPosition\"),\n  },\n  {\n    name: \"stopWatchGeoLocation\",\n    path: \"appsmith.geolocation.clearWatch\",\n    qualifier: (entity: DataTreeEntity) => isAppsmithEntity(entity),\n    fn: () =>\n      isAsyncGuard(stopWatchGeoLocation, \"appsmith.geolocation.clearWatch\"),\n  },\n];\n\nexport type ActionTriggerKeys =\n  | TClearActionType\n  | TRunActionType\n  | TDownloadActionType\n  | TShowModalActionType\n  | TCloseModalActionType\n  | TShowAlertActionType\n  | TDownloadActionType\n  | TNavigateToActionType\n  | TResetWidgetActionType\n  | TCopyToClipboardActionType\n  | TPostWindowMessageActionType\n  | TGetGeoLocationActionType\n  | TWatchGeoLocationActionType\n  | TStopWatchGeoLocationActionType;\n\nexport const getActionTriggerFunctionNames = (\n  // cloudHosting -> to use in ee\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  cloudHosting: boolean,\n): Record<string, string> => {\n  return ActionTriggerFunctionNames;\n};\n\nconst ActionTriggerFunctionNames: Record<string, string> = {\n  CLEAR_INTERVAL: \"clearInterval\",\n  CLEAR_PLUGIN_ACTION: \"action.clear\",\n  CLOSE_MODAL: \"closeModal\",\n  COPY_TO_CLIPBOARD: \"copyToClipboard\",\n  DOWNLOAD: \"download\",\n  NAVIGATE_TO: \"navigateTo\",\n  RESET_WIDGET_META_RECURSIVE_BY_NAME: \"resetWidget\",\n  RUN_PLUGIN_ACTION: \"action.run\",\n  SET_INTERVAL: \"setInterval\",\n  SHOW_ALERT: \"showAlert\",\n  SHOW_MODAL_BY_NAME: \"showModal\",\n  STORE_VALUE: \"storeValue\",\n  REMOVE_VALUE: \"removeValue\",\n  CLEAR_STORE: \"clearStore\",\n  GET_CURRENT_LOCATION: \"getCurrentLocation\",\n  WATCH_CURRENT_LOCATION: \"watchLocation\",\n  STOP_WATCHING_CURRENT_LOCATION: \"stopWatch\",\n  POST_MESSAGE: \"postWindowMessage\",\n  SET_TIMEOUT: \"setTimeout\",\n  CLEAR_TIMEOUT: \"clearTimeout\",\n};\n\nexport type ActionDescription =\n  | TRunDescription\n  | TClearDescription\n  | TShowModalDescription\n  | TCloseModalDescription\n  | TClearDescription\n  | TStoreValueDescription\n  | TClearStoreDescription\n  | TRemoveValueDescription\n  | TDownloadDescription\n  | TPostWindowMessageDescription\n  | TNavigateToDescription\n  | TShowAlertDescription\n  | TResetWidgetDescription\n  | TCopyToClipboardDescription\n  | TGetGeoLocationDescription\n  | TWatchGeoLocationDescription\n  | TStopWatchGeoLocationDescription;\n","import { ActionResponse } from \"api/ActionAPI\";\nimport { PluginId } from \"api/PluginApi\";\nimport { ValidationConfig } from \"constants/PropertyControlConstants\";\nimport { ActionConfig, PluginType } from \"entities/Action\";\nimport { ActionDescription } from \"@appsmith/workers/Evaluation/fns\";\nimport { Variable } from \"entities/JSCollection\";\nimport { DependencyMap, DynamicPath } from \"utils/DynamicBindingUtils\";\n\nexport type ActionDispatcher = (...args: any[]) => ActionDescription;\n\nexport enum ENTITY_TYPE {\n  ACTION = \"ACTION\",\n  WIDGET = \"WIDGET\",\n  APPSMITH = \"APPSMITH\",\n  JSACTION = \"JSACTION\",\n}\n\nexport enum EvaluationSubstitutionType {\n  TEMPLATE = \"TEMPLATE\",\n  PARAMETER = \"PARAMETER\",\n  SMART_SUBSTITUTE = \"SMART_SUBSTITUTE\",\n}\n\n// Action entity types\nexport interface ActionEntityEvalTree {\n  actionId: string;\n  isLoading: boolean;\n  data: ActionResponse[\"body\"];\n  run: ActionDispatcher | Record<string, unknown>;\n  clear: ActionDispatcher | Record<string, unknown>;\n  responseMeta: {\n    statusCode?: string;\n    isExecutionSuccess: boolean;\n    headers?: unknown;\n  };\n  ENTITY_TYPE: ENTITY_TYPE.ACTION;\n  config: Partial<ActionConfig>;\n  datasourceUrl: string;\n}\n\nexport interface ActionEntityConfig {\n  dynamicBindingPathList: DynamicPath[];\n  bindingPaths: Record<string, EvaluationSubstitutionType>;\n  reactivePaths: Record<string, EvaluationSubstitutionType>;\n  ENTITY_TYPE: ENTITY_TYPE.ACTION;\n  dependencyMap: DependencyMap;\n  logBlackList: Record<string, true>;\n  pluginType: PluginType;\n  pluginId: PluginId;\n  actionId: string;\n  name: string;\n}\n\n// JSAction (JSObject) entity Types\n\nexport interface MetaArgs {\n  arguments: Variable[];\n  isAsync: boolean;\n  confirmBeforeExecute: boolean;\n}\n\nexport interface JSActionEntityConfig {\n  meta: Record<string, MetaArgs>;\n  dynamicBindingPathList: DynamicPath[];\n  bindingPaths: Record<string, EvaluationSubstitutionType>;\n  reactivePaths: Record<string, EvaluationSubstitutionType>;\n  variables: Array<string>;\n  dependencyMap: DependencyMap;\n  pluginType: PluginType.JS;\n  name: string;\n  ENTITY_TYPE: ENTITY_TYPE.JSACTION;\n  actionId: string;\n}\n\nexport interface JSActionEvalTree {\n  [propName: string]: any;\n  body: string;\n}\n\n// Widget entity Types\n\n// Private widgets do not get evaluated\n// For example, for widget Button1 in a List widget List1, List1.template.Button1.text gets evaluated,\n// so there is no need to evaluate Button1.text\nexport type PrivateWidgets = Record<string, true>;\n\n/**\n *  Map of overriding property as key and overridden property as values\n */\nexport type OverridingPropertyPaths = Record<string, string[]>;\n\nexport enum OverridingPropertyType {\n  META = \"META\",\n  DEFAULT = \"DEFAULT\",\n}\nexport interface overrideDependency {\n  DEFAULT: string;\n  META: string;\n}\n/**\n *  Map of property name as key and value as object with defaultPropertyName and metaPropertyName which it depends on.\n */\nexport type PropertyOverrideDependency = Record<\n  string,\n  Partial<overrideDependency>\n>;\n\nexport type WidgetConfig = {\n  bindingPaths: Record<string, EvaluationSubstitutionType>;\n  reactivePaths: Record<string, EvaluationSubstitutionType>;\n  triggerPaths: Record<string, boolean>;\n  validationPaths: Record<string, ValidationConfig>;\n  ENTITY_TYPE: ENTITY_TYPE.WIDGET;\n  logBlackList: Record<string, true>;\n  propertyOverrideDependency: PropertyOverrideDependency;\n  overridingPropertyPaths: OverridingPropertyPaths;\n  privateWidgets: PrivateWidgets;\n};\n","import _, { get, isString } from \"lodash\";\nimport { DATA_BIND_REGEX } from \"constants/BindingsConstants\";\nimport { Action } from \"entities/Action\";\nimport { WidgetProps } from \"widgets/BaseWidget\";\nimport { Severity } from \"entities/AppsmithConsole\";\nimport {\n  getEntityNameAndPropertyPath,\n  isAction,\n  isJSAction,\n  isTrueObject,\n  isWidget,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport { DataTreeEntity } from \"entities/DataTree/dataTreeFactory\";\nimport { getType, Types } from \"./TypeHelpers\";\nimport { ViewTypes } from \"components/formControls/utils\";\n\nexport type DependencyMap = Record<string, Array<string>>;\nexport type FormEditorConfigs = Record<string, any[]>;\nexport type FormSettingsConfigs = Record<string, any[]>;\nexport type FormDependencyConfigs = Record<string, DependencyMap>;\nexport type FormDatasourceButtonConfigs = Record<string, string[]>;\n\n// referencing DATA_BIND_REGEX fails for the value \"{{Table1.tableData[Table1.selectedRowIndex]}}\" if you run it multiple times and don't recreate\nexport const isDynamicValue = (value: string): boolean =>\n  DATA_BIND_REGEX.test(value);\n\n//{{}}{{}}}\nexport function getDynamicStringSegments(dynamicString: string): string[] {\n  let stringSegments = [];\n  const indexOfDoubleParanStart = dynamicString.indexOf(\"{{\");\n  if (indexOfDoubleParanStart === -1) {\n    return [dynamicString];\n  }\n  //{{}}{{}}}\n  const firstString = dynamicString.substring(0, indexOfDoubleParanStart);\n  firstString && stringSegments.push(firstString);\n  let rest = dynamicString.substring(\n    indexOfDoubleParanStart,\n    dynamicString.length,\n  );\n  //{{}}{{}}}\n  let sum = 0;\n  for (let i = 0; i <= rest.length - 1; i++) {\n    const char = rest[i];\n    const prevChar = rest[i - 1];\n\n    if (char === \"{\") {\n      sum++;\n    } else if (char === \"}\") {\n      sum--;\n      if (prevChar === \"}\" && sum === 0) {\n        stringSegments.push(rest.substring(0, i + 1));\n        rest = rest.substring(i + 1, rest.length);\n        if (rest) {\n          stringSegments = stringSegments.concat(\n            getDynamicStringSegments(rest),\n          );\n          break;\n        }\n      }\n    }\n  }\n  if (sum !== 0 && dynamicString !== \"\") {\n    return [dynamicString];\n  }\n  return stringSegments;\n}\n\n//{{}}{{}}}\nexport const getDynamicBindings = (\n  dynamicString: string,\n  entity?: DataTreeEntity,\n): { stringSegments: string[]; jsSnippets: string[] } => {\n  // Protect against bad string parse\n  if (!dynamicString || !_.isString(dynamicString)) {\n    return { stringSegments: [], jsSnippets: [] };\n  }\n  const sanitisedString = dynamicString.trim();\n  let stringSegments, paths: any;\n  if (entity && isJSAction(entity)) {\n    stringSegments = [sanitisedString];\n    paths = [sanitisedString];\n  } else {\n    // Get the {{binding}} bound values\n    stringSegments = getDynamicStringSegments(sanitisedString);\n    // Get the \"binding\" path values\n    paths = stringSegments.map((segment) => {\n      const length = segment.length;\n      const matches = isDynamicValue(segment);\n      if (matches) {\n        return segment.substring(2, length - 2);\n      }\n      return \"\";\n    });\n  }\n  return { stringSegments: stringSegments, jsSnippets: paths };\n};\n\nexport const combineDynamicBindings = (\n  jsSnippets: string[],\n  stringSegments: string[],\n) => {\n  return stringSegments\n    .map((segment, index) => {\n      if (jsSnippets[index] && jsSnippets[index].length > 0) {\n        return jsSnippets[index];\n      } else {\n        return `'${segment}'`;\n      }\n    })\n    .join(\" + \");\n};\n\nexport enum EvalErrorTypes {\n  CYCLICAL_DEPENDENCY_ERROR = \"CYCLICAL_DEPENDENCY_ERROR\",\n  EVAL_PROPERTY_ERROR = \"EVAL_PROPERTY_ERROR\",\n  EVAL_TREE_ERROR = \"EVAL_TREE_ERROR\",\n  UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n  BAD_UNEVAL_TREE_ERROR = \"BAD_UNEVAL_TREE_ERROR\",\n  PARSE_JS_ERROR = \"PARSE_JS_ERROR\",\n  EXTRACT_DEPENDENCY_ERROR = \"EXTRACT_DEPENDENCY_ERROR\",\n  CLONE_ERROR = \"CLONE_ERROR\",\n}\n\nexport type EvalError = {\n  type: EvalErrorTypes;\n  message: string;\n  context?: Record<string, any>;\n};\n\nexport interface DynamicPath {\n  key: string;\n  value?: string;\n}\n\nexport interface WidgetDynamicPathListProps {\n  dynamicBindingPathList?: DynamicPath[];\n  dynamicTriggerPathList?: DynamicPath[];\n  dynamicPropertyPathList?: DynamicPath[];\n}\n\nexport interface EntityWithBindings {\n  dynamicBindingPathList?: DynamicPath[];\n}\n\nexport const getEntityDynamicBindingPathList = (\n  entity: EntityWithBindings,\n): DynamicPath[] => {\n  if (\n    entity &&\n    entity.dynamicBindingPathList &&\n    Array.isArray(entity.dynamicBindingPathList)\n  ) {\n    return [...entity.dynamicBindingPathList];\n  }\n  return [];\n};\n\nexport const isPathADynamicBinding = (\n  entity: EntityWithBindings,\n  path: string,\n): boolean => {\n  if (\n    entity &&\n    entity.dynamicBindingPathList &&\n    Array.isArray(entity.dynamicBindingPathList)\n  ) {\n    return _.find(entity.dynamicBindingPathList, { key: path }) !== undefined;\n  }\n  return false;\n};\n/**\n * Get property path from full property path\n * Input: \"Table1.meta.searchText\" => Output: \"meta.searchText\"\n * @param {string} fullPropertyPath\n * @return {*}\n */\nexport const getPropertyPath = (fullPropertyPath: string) => {\n  return fullPropertyPath.substring(fullPropertyPath.indexOf(\".\") + 1);\n};\n\nexport const getWidgetDynamicTriggerPathList = (\n  widget: WidgetProps,\n): DynamicPath[] => {\n  if (\n    widget &&\n    widget.dynamicTriggerPathList &&\n    Array.isArray(widget.dynamicTriggerPathList)\n  ) {\n    return [...widget.dynamicTriggerPathList];\n  }\n  return [];\n};\n\nexport const isPathDynamicTrigger = (\n  widget: WidgetProps,\n  path: string,\n): boolean => {\n  if (\n    widget &&\n    widget.dynamicTriggerPathList &&\n    Array.isArray(widget.dynamicTriggerPathList)\n  ) {\n    return _.find(widget.dynamicTriggerPathList, { key: path }) !== undefined;\n  }\n  return false;\n};\n\nexport const getWidgetDynamicPropertyPathList = (\n  widget: WidgetProps,\n): DynamicPath[] => {\n  if (\n    widget &&\n    widget.dynamicPropertyPathList &&\n    Array.isArray(widget.dynamicPropertyPathList)\n  ) {\n    return [...widget.dynamicPropertyPathList];\n  }\n  return [];\n};\n\nexport const isPathDynamicProperty = (\n  widget: WidgetProps,\n  path: string,\n): boolean => {\n  if (\n    widget &&\n    widget.dynamicPropertyPathList &&\n    Array.isArray(widget.dynamicPropertyPathList)\n  ) {\n    return _.find(widget.dynamicPropertyPathList, { key: path }) !== undefined;\n  }\n  return false;\n};\n\nexport const THEME_BINDING_REGEX = /{{.*appsmith\\.theme\\..*}}/;\n\nexport const isThemeBoundProperty = (\n  widget: WidgetProps,\n  path: string,\n): boolean => {\n  return widget && widget[path] && THEME_BINDING_REGEX.test(widget[path]);\n};\n\nexport const unsafeFunctionForEval = [\n  \"XMLHttpRequest\",\n  \"setImmediate\",\n  \"Navigator\",\n];\n\nexport const isChildPropertyPath = (\n  parentPropertyPath: string,\n  childPropertyPath: string,\n): boolean => {\n  return (\n    parentPropertyPath === childPropertyPath ||\n    childPropertyPath.startsWith(`${parentPropertyPath}.`) ||\n    childPropertyPath.startsWith(`${parentPropertyPath}[`)\n  );\n};\n\n/**\n * Paths set via evaluator on entities\n * During evaluation, the evaluator will set various data points\n * on the entity objects to describe their state while evaluating.\n * This information can be found on the following paths\n * These paths are meant to be objects with\n * information about the properties in\n * a single place\n *\n * Stored in a flattened object like\n * widget.__evaluation__.errors.primaryColumns.customColumn.computedValue = [...]\n **/\nexport const EVALUATION_PATH = \"__evaluation__\";\nexport const EVAL_ERROR_PATH = `${EVALUATION_PATH}.errors`;\nexport const EVAL_VALUE_PATH = `${EVALUATION_PATH}.evaluatedValues`;\n\n/**\n * non-populated object\n {\n   __evaluation__:{\n     evaluatedValues:{\n       primaryColumns: [...],\n       primaryColumns.status: {...},\n       primaryColumns.action: {...}\n     }\n   }\n }\n\n * Populated Object\n {\n   __evaluation__:{\n     evaluatedValues:{\n       primaryColumns: {\n         status: [...],\n         action:[...]\n        }\n     }\n   }\n }\n\n */\nconst getNestedEvalPath = (\n  fullPropertyPath: string,\n  pathType: string,\n  fullPath = true,\n  isPopulated = false,\n) => {\n  const { entityName, propertyPath } = getEntityNameAndPropertyPath(\n    fullPropertyPath,\n  );\n  const nestedPath = isPopulated\n    ? `${pathType}.${propertyPath}`\n    : `${pathType}.['${propertyPath}']`;\n\n  if (fullPath) {\n    return `${entityName}.${nestedPath}`;\n  }\n  return nestedPath;\n};\n\nexport const getEvalErrorPath = (\n  fullPropertyPath: string,\n  options = {\n    fullPath: true,\n    isPopulated: false,\n  },\n) => {\n  return getNestedEvalPath(\n    fullPropertyPath,\n    EVAL_ERROR_PATH,\n    options.fullPath,\n    options.isPopulated,\n  );\n};\n\nexport const getEvalValuePath = (\n  fullPropertyPath: string,\n  options = {\n    fullPath: true,\n    isPopulated: false,\n  },\n) => {\n  return getNestedEvalPath(\n    fullPropertyPath,\n    EVAL_VALUE_PATH,\n    options.fullPath,\n    options.isPopulated,\n  );\n};\n\nexport enum PropertyEvaluationErrorType {\n  VALIDATION = \"VALIDATION\",\n  PARSE = \"PARSE\",\n  LINT = \"LINT\",\n}\nexport interface DataTreeError {\n  raw: string;\n  errorMessage: Error;\n  severity: Severity.WARNING | Severity.ERROR;\n}\n\nexport interface EvaluationError extends DataTreeError {\n  errorType:\n    | PropertyEvaluationErrorType.PARSE\n    | PropertyEvaluationErrorType.VALIDATION;\n  originalBinding?: string;\n}\n\nexport interface LintError extends DataTreeError {\n  errorType: PropertyEvaluationErrorType.LINT;\n  errorSegment: string;\n  originalBinding: string;\n  variables: (string | undefined | null)[];\n  code: string;\n  line: number;\n  ch: number;\n}\n\nexport interface DataTreeEvaluationProps {\n  __evaluation__?: {\n    errors: Record<string, EvaluationError[]>;\n    evaluatedValues?: Record<string, unknown>;\n  };\n}\n\nexport const PropertyEvalErrorTypeDebugMessage: Record<\n  PropertyEvaluationErrorType,\n  (propertyPath: string) => string\n> = {\n  [PropertyEvaluationErrorType.VALIDATION]: (propertyPath: string) =>\n    `The value at ${propertyPath} is invalid`,\n  [PropertyEvaluationErrorType.PARSE]: () => `Could not parse the binding`,\n  [PropertyEvaluationErrorType.LINT]: () => `Errors found while evaluating`,\n};\n\n// this variable temporarily holds dynamic paths generated by the recursive function (getDynamicValuePaths - Line 468).\nlet temporaryDynamicPathStore: DynamicPath[] = [];\n\n// recursive function to get full key path of any object that has dynamic bindings.\nconst getDynamicValuePaths = (val: any, parentPath: string) => {\n  if (isString(val) && isDynamicValue(val)) {\n    return temporaryDynamicPathStore.push({ key: `${parentPath}` });\n  }\n\n  if (Array.isArray(val)) {\n    val.forEach((obj, index) => {\n      return getDynamicValuePaths(obj, `${parentPath}[${index}]`);\n    });\n  }\n\n  if (isTrueObject(val)) {\n    Object.entries(val).forEach(([key, value]) => {\n      getDynamicValuePaths(value, `${parentPath}.${key}`);\n    });\n  }\n};\n\nexport function getDynamicBindingsChangesSaga(\n  action: Action,\n  value: unknown,\n  field: string,\n) {\n  const bindingField = field.replace(\"actionConfiguration.\", \"\");\n  // we listen to any viewType changes.\n  const viewType = field.endsWith(\".viewType\");\n  let dynamicBindings: DynamicPath[] = action.dynamicBindingPathList || [];\n\n  if (field.endsWith(\".jsonData\") || field.endsWith(\".componentData\")) {\n    return dynamicBindings;\n  }\n\n  if (\n    action.datasource &&\n    \"datasourceConfiguration\" in action.datasource &&\n    field === \"datasource\"\n  ) {\n    // only the datasource.datasourceConfiguration.url can be a dynamic field\n    dynamicBindings = dynamicBindings.filter(\n      (binding) => binding.key !== \"datasourceUrl\",\n    );\n    const datasourceUrl = action.datasource.datasourceConfiguration.url;\n    isDynamicValue(datasourceUrl) &&\n      dynamicBindings.push({ key: \"datasourceUrl\" });\n    return dynamicBindings;\n  }\n\n  // When a key-value pair is added or deleted from a fieldArray\n  // Value is an Array representing the new fieldArray.\n\n  if (Array.isArray(value)) {\n    // first we clear the dynamic bindings of any paths that is a child of the current path.\n    dynamicBindings = dynamicBindings.filter(\n      (binding) => !isChildPropertyPath(bindingField, binding.key),\n    );\n\n    // then we recursively go through the value and find paths with dynamic bindings\n    temporaryDynamicPathStore = [];\n    if (!!value) {\n      getDynamicValuePaths(value, bindingField);\n    }\n    if (!!temporaryDynamicPathStore && temporaryDynamicPathStore.length > 0) {\n      dynamicBindings = [...dynamicBindings, ...temporaryDynamicPathStore];\n    }\n  } else if (getType(value) === Types.OBJECT) {\n    dynamicBindings = dynamicBindings.filter((dynamicPath) => {\n      if (isChildPropertyPath(bindingField, dynamicPath.key)) {\n        const childPropertyValue = _.get(value, dynamicPath.key);\n        return isDynamicValue(childPropertyValue);\n      }\n    });\n  } else if (typeof value === \"string\") {\n    const fieldExists = _.some(dynamicBindings, { key: bindingField });\n\n    const isDynamic = isDynamicValue(value);\n\n    if (!isDynamic && fieldExists) {\n      dynamicBindings = dynamicBindings.filter((d) => d.key !== bindingField);\n    }\n    if (isDynamic && !fieldExists) {\n      dynamicBindings.push({ key: bindingField });\n    }\n  }\n\n  // the reason this is done is to change the dynamicBindingsPathlist of a component when a user toggles the form control\n  // from component mode to json mode and vice versa.\n\n  // when in json mode, we want to get rid of all the existing componentData paths and replace it with a single path for the json mode\n  // for example: [{key: 'formData.sortBy.data[0].column'}, {key: 'formData.sortBy.data[1].column'}] will be replaced with just this [{key: 'formData.sortBy.data'}]\n\n  // when in component mode, we want to first remove all the paths for json mode and\n  //  get back all the paths in the componentData that have dynamic bindings and add them to the the dynamic bindings pathlist.\n  // for example: [{key: 'formData.sortBy.data'}] will be replaced with this [{key: 'formData.sortBy.data[0].column'}, {key: 'formData.sortBy.data[1].column'}]\n\n  // if the currently changing field is a component's view type\n  if (!!viewType) {\n    const dataBindingField = bindingField.replace(\".viewType\", \".data\");\n    // then we filter the field of any paths that includes the binding fields\n    dynamicBindings = dynamicBindings.filter(\n      (dynamicPath) => !dynamicPath?.key?.includes(dataBindingField),\n    );\n\n    // if the value of the viewType is of json and, we push in the field\n    if (value === ViewTypes.JSON) {\n      const jsonFieldPath = field.replace(\".viewType\", \".jsonData\");\n      const jsonFieldValue = get(action, jsonFieldPath);\n      if (isDynamicValue(jsonFieldValue)) {\n        dynamicBindings.push({ key: dataBindingField });\n      }\n    } else if (value === ViewTypes.COMPONENT) {\n      const componentFieldPath = field.replace(\".viewType\", \".componentData\");\n      const componentFieldValue = get(action, componentFieldPath);\n      temporaryDynamicPathStore = [];\n\n      if (!!componentFieldValue) {\n        getDynamicValuePaths(componentFieldValue, dataBindingField);\n      }\n      if (!!temporaryDynamicPathStore && temporaryDynamicPathStore.length > 0) {\n        dynamicBindings = [...dynamicBindings, ...temporaryDynamicPathStore];\n      }\n    }\n  }\n  return dynamicBindings;\n}\n\nexport function getEntityType(entity: DataTreeEntity) {\n  return \"ENTITY_TYPE\" in entity && entity.ENTITY_TYPE;\n}\n\nexport function getEntityId(entity: DataTreeEntity) {\n  if (isAction(entity)) return entity.actionId;\n  if (isWidget(entity)) return entity.widgetId;\n  if (isJSAction(entity)) return entity.actionId;\n}\n\nexport function getEntityName(entity: DataTreeEntity) {\n  if (isAction(entity)) return entity.name;\n  if (isWidget(entity)) return entity.widgetName;\n  if (isJSAction(entity)) return entity.name;\n}\n","/**\n * This file contains the utility function to send and receive messages from the worker.\n * TRequestMessage<TBody> is used to send a request to/from the worker.\n * TResponseMessage<TBody> is used to send a response to/from the worker.\n * TDefaultMessage<TBody> is used to send a message to/from worker. Does not expect a response.\n */\n\nexport enum MessageType {\n  REQUEST = \"REQUEST\",\n  RESPONSE = \"RESPONSE\",\n  DEFAULT = \"DEFAULT\",\n}\n\ntype TRequestMessage<TBody> = {\n  body: TBody;\n  messageId: string;\n  messageType: MessageType.REQUEST;\n};\n\ntype TResponseMessage<TBody> = {\n  body: TBody;\n  messageId: string;\n  messageType: MessageType.RESPONSE;\n};\n\nexport type TDefaultMessage<TBody> = {\n  messageId?: string;\n  body: TBody;\n  messageType: MessageType.DEFAULT;\n};\n\nexport type TMessage<TBody> =\n  | TRequestMessage<TBody>\n  | TResponseMessage<TBody>\n  | TDefaultMessage<TBody>;\n\n/** Avoid from using postMessage directly.\n * This function should be used to send messages to the worker and back.\n * Purpose: To have some standardization in the messages that are transferred.\n * TODO: Add support for window postMessage options\n * TODO: Add support for transferable objects.\n */\nexport function sendMessage(\n  this: Worker | typeof globalThis,\n  message: TMessage<unknown>,\n) {\n  this.postMessage(message);\n}\n","import _ from \"lodash\";\n\nexport enum Types {\n  URL = \"URL\",\n  STRING = \"STRING\",\n  NUMBER = \"NUMBER\",\n  BOOLEAN = \"BOOLEAN\",\n  OBJECT = \"OBJECT\",\n  ARRAY = \"ARRAY\",\n  FUNCTION = \"FUNCTION\",\n  UNDEFINED = \"UNDEFINED\",\n  NULL = \"NULL\",\n  UNKNOWN = \"UNKNOWN\",\n}\n\nexport const getType = (value: unknown) => {\n  if (_.isString(value)) return Types.STRING;\n  if (_.isNumber(value)) return Types.NUMBER;\n  if (_.isBoolean(value)) return Types.BOOLEAN;\n  if (Array.isArray(value)) return Types.ARRAY;\n  if (_.isFunction(value)) return Types.FUNCTION;\n  if (_.isObject(value)) return Types.OBJECT;\n  if (_.isUndefined(value)) return Types.UNDEFINED;\n  if (_.isNull(value)) return Types.NULL;\n  return Types.UNKNOWN;\n};\n\nexport function isURL(str: string) {\n  const pattern = new RegExp(\n    \"^((blob:)?https?:\\\\/\\\\/)?\" + // protocol\n    \"((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.)+[a-z]{2,}|\" + // domain name\n    \"((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))\" + // OR ip (v4) address\n    \"(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*\" + // port and path\n    \"(\\\\?[;&a-z\\\\d%_.~+=-]*)?\" + // query string\n      \"(\\\\#[-a-z\\\\d_]*)?$\",\n    \"i\",\n  ); // fragment locator\n  return !!pattern.test(str);\n}\n\nexport type TruthyPrimitiveTypes = number | string | boolean | bigint | symbol;\n","import {\n  DataTree,\n  DataTreeAppsmith,\n  DataTreeJSAction,\n  EvaluationSubstitutionType,\n} from \"entities/DataTree/dataTreeFactory\";\nimport { ParsedBody, ParsedJSSubAction } from \"utils/JSPaneUtils\";\nimport { unset, set, get, find } from \"lodash\";\nimport {\n  BatchedJSExecutionData,\n  BatchedJSExecutionErrors,\n  JSCollectionData,\n  JSExecutionData,\n  JSExecutionError,\n} from \"reducers/entityReducers/jsActionsReducer\";\nimport { select } from \"redux-saga/effects\";\nimport { JSAction } from \"entities/JSCollection\";\nimport { getJSCollectionsForCurrentPage } from \"selectors/entitiesSelector\";\nimport {\n  getEntityNameAndPropertyPath,\n  isJSAction,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport { APP_MODE } from \"entities/App\";\n\n/**\n * here we add/remove the properties (variables and actions) which got added/removed from the JSObject parsedBody.\n  NOTE: For other entity below logic is maintained in DataTreeFactory, for JSObject we handle it inside evaluations\n * \n * @param parsedBody \n * @param jsCollection \n * @param unEvalTree \n * @returns \n */\nexport const updateJSCollectionInUnEvalTree = (\n  parsedBody: ParsedBody,\n  jsCollection: DataTreeJSAction,\n  unEvalTree: DataTree,\n) => {\n  // jsCollection here means unEvalTree JSObject\n  const modifiedUnEvalTree = unEvalTree;\n  const functionsList: Array<string> = [];\n  const varList: Array<string> = jsCollection.variables;\n  Object.keys(jsCollection.meta).forEach((action) => {\n    functionsList.push(action);\n  });\n\n  const oldConfig = Object.getPrototypeOf(jsCollection) as DataTreeJSAction;\n\n  if (parsedBody.actions && parsedBody.actions.length > 0) {\n    for (let i = 0; i < parsedBody.actions.length; i++) {\n      const action = parsedBody.actions[i];\n      if (jsCollection.hasOwnProperty(action.name)) {\n        if (jsCollection[action.name] !== action.body) {\n          const data = get(\n            modifiedUnEvalTree,\n            `${jsCollection.name}.${action.name}.data`,\n            {},\n          );\n          set(\n            modifiedUnEvalTree,\n            `${jsCollection.name}.${action.name}`,\n            new String(action.body),\n          );\n\n          set(\n            modifiedUnEvalTree,\n            `${jsCollection.name}.${action.name}.data`,\n            data,\n          );\n        }\n      } else {\n        const reactivePaths = oldConfig.reactivePaths;\n\n        reactivePaths[action.name] =\n          EvaluationSubstitutionType.SMART_SUBSTITUTE;\n        reactivePaths[`${action.name}.data`] =\n          EvaluationSubstitutionType.TEMPLATE;\n\n        const dynamicBindingPathList = oldConfig.dynamicBindingPathList;\n        dynamicBindingPathList.push({ key: action.name });\n\n        const dependencyMap = oldConfig.dependencyMap;\n        dependencyMap[\"body\"].push(action.name);\n\n        const meta = oldConfig.meta;\n        meta[action.name] = {\n          arguments: action.arguments,\n          isAsync: false,\n          confirmBeforeExecute: false,\n        };\n\n        const data = get(\n          modifiedUnEvalTree,\n          `${jsCollection.name}.${action.name}.data`,\n          {},\n        );\n        set(\n          modifiedUnEvalTree,\n          `${jsCollection.name}.${action.name}`,\n          new String(action.body.toString()),\n        );\n        set(\n          modifiedUnEvalTree,\n          `${jsCollection.name}.${action.name}.data`,\n          data,\n        );\n      }\n    }\n  }\n  if (functionsList && functionsList.length > 0) {\n    for (let i = 0; i < functionsList.length; i++) {\n      const oldActionName = functionsList[i];\n      const existed = parsedBody.actions.find(\n        (js: ParsedJSSubAction) => js.name === oldActionName,\n      );\n      if (!existed) {\n        const reactivePaths = oldConfig.reactivePaths;\n        delete reactivePaths[oldActionName];\n\n        oldConfig.dynamicBindingPathList = oldConfig.dynamicBindingPathList.filter(\n          (path) => path[\"key\"] !== oldActionName,\n        );\n\n        const dependencyMap = oldConfig.dependencyMap[\"body\"];\n        const removeIndex = dependencyMap.indexOf(oldActionName);\n        if (removeIndex > -1) {\n          oldConfig.dependencyMap[\"body\"] = dependencyMap.filter(\n            (item) => item !== oldActionName,\n          );\n        }\n        const meta = oldConfig.meta;\n        delete meta[oldActionName];\n\n        unset(modifiedUnEvalTree[jsCollection.name], oldActionName);\n        unset(modifiedUnEvalTree[jsCollection.name], `${oldActionName}.data`);\n      }\n    }\n  }\n  if (parsedBody.variables.length) {\n    for (let i = 0; i < parsedBody.variables.length; i++) {\n      const newVar = parsedBody.variables[i];\n      const existedVar = varList.indexOf(newVar.name);\n      if (existedVar > -1) {\n        const existedVarVal = jsCollection[newVar.name];\n        if (\n          (!!existedVarVal && existedVarVal.toString()) !==\n            (newVar.value && newVar.value.toString()) ||\n          (!existedVarVal && !!newVar)\n        ) {\n          set(\n            modifiedUnEvalTree,\n            `${jsCollection.name}.${newVar.name}`,\n            newVar.value,\n          );\n        }\n      } else {\n        varList.push(newVar.name);\n        const reactivePaths = oldConfig.reactivePaths;\n        reactivePaths[newVar.name] =\n          EvaluationSubstitutionType.SMART_SUBSTITUTE;\n\n        const dynamicBindingPathList = oldConfig.dynamicBindingPathList;\n        dynamicBindingPathList.push({ key: newVar.name });\n\n        set(modifiedUnEvalTree, `${jsCollection.name}.variables`, varList);\n        set(\n          modifiedUnEvalTree,\n          `${jsCollection.name}.${newVar.name}`,\n          newVar.value,\n        );\n      }\n    }\n    let newVarList: Array<string> = varList;\n    for (let i = 0; i < varList.length; i++) {\n      const varListItem = varList[i];\n      const existsInParsed = parsedBody.variables.find(\n        (item) => item.name === varListItem,\n      );\n      if (!existsInParsed) {\n        const reactivePaths = oldConfig.reactivePaths;\n        delete reactivePaths[varListItem];\n\n        oldConfig.dynamicBindingPathList = oldConfig.dynamicBindingPathList.filter(\n          (path) => path[\"key\"] !== varListItem,\n        );\n\n        newVarList = newVarList.filter((item) => item !== varListItem);\n        unset(modifiedUnEvalTree[jsCollection.name], varListItem);\n      }\n    }\n    if (newVarList.length) {\n      set(modifiedUnEvalTree, `${jsCollection.name}.variables`, newVarList);\n    }\n  }\n  return modifiedUnEvalTree;\n};\n\n/**\n * When JSObject parseBody is empty we remove all variables and actions from unEvalTree\n * this will lead to removal of properties from the dataTree\n * @param unEvalTree\n * @param entity\n * @returns\n */\nexport const removeFunctionsAndVariableJSCollection = (\n  unEvalTree: DataTree,\n  entity: DataTreeJSAction,\n  jsEntityName: string,\n) => {\n  const oldConfig = Object.getPrototypeOf(entity) as DataTreeJSAction;\n  const modifiedDataTree: DataTree = unEvalTree;\n  const functionsList: Array<string> = [];\n  Object.keys(entity.meta).forEach((action) => {\n    functionsList.push(action);\n  });\n  //removed variables\n  const varList: Array<string> = entity.variables;\n  set(modifiedDataTree, `${jsEntityName}.variables`, []);\n  for (let i = 0; i < varList.length; i++) {\n    const varName = varList[i];\n    unset(modifiedDataTree[jsEntityName], varName);\n  }\n  //remove functions\n\n  const reactivePaths = entity.reactivePaths;\n  const meta = entity.meta;\n\n  for (let i = 0; i < functionsList.length; i++) {\n    const actionName = functionsList[i];\n    delete reactivePaths[actionName];\n    delete meta[actionName];\n    unset(modifiedDataTree[jsEntityName], actionName);\n\n    oldConfig.dynamicBindingPathList = oldConfig.dynamicBindingPathList.filter(\n      (path: any) => path[\"key\"] !== actionName,\n    );\n\n    entity.dependencyMap[\"body\"] = entity.dependencyMap[\"body\"].filter(\n      (item: any) => item !== actionName,\n    );\n  }\n\n  return modifiedDataTree;\n};\n\nexport function isJSObjectFunction(\n  dataTree: DataTree,\n  jsObjectName: string,\n  key: string,\n) {\n  const entity = dataTree[jsObjectName];\n  if (isJSAction(entity)) {\n    return entity.meta.hasOwnProperty(key);\n  }\n  return false;\n}\n\nexport function getAppMode(dataTree: DataTree) {\n  const appsmithObj = dataTree.appsmith as DataTreeAppsmith;\n  return appsmithObj.mode as APP_MODE;\n}\n\nexport function isPromise(value: any): value is Promise<unknown> {\n  return Boolean(value && typeof value.then === \"function\");\n}\n\nfunction updateJSExecutionError(\n  errors: BatchedJSExecutionErrors,\n  executionError: JSExecutionError,\n) {\n  const { collectionId } = executionError;\n  if (errors[collectionId]) {\n    errors[collectionId].push(executionError);\n  } else {\n    errors[collectionId] = [executionError];\n  }\n}\n\nfunction updateJSExecutionData(\n  sortedData: BatchedJSExecutionData,\n  executionData: JSExecutionData,\n) {\n  const { collectionId } = executionData;\n  if (sortedData[collectionId]) {\n    sortedData[collectionId].push(executionData);\n  } else {\n    sortedData[collectionId] = [executionData];\n  }\n}\n\nfunction getJSActionFromJSCollections(\n  jsCollections: JSCollectionData[],\n  jsfuncFullName: string,\n) {\n  const {\n    entityName: collectionName,\n    propertyPath: functionName,\n  } = getEntityNameAndPropertyPath(jsfuncFullName);\n\n  const jsCollection = find(\n    jsCollections,\n    (collection) => collection.config.name === collectionName,\n  );\n  if (!jsCollection) return;\n\n  const jsAction: JSAction | undefined = find(\n    jsCollection.config.actions,\n    (action) => action.name === functionName,\n  );\n  return jsAction;\n}\n\nexport function* sortJSExecutionDataByCollectionId(\n  data: Record<string, unknown>,\n  errors: Record<string, unknown>,\n) {\n  // Sorted data by collectionId\n  const sortedData: BatchedJSExecutionData = {};\n  // Sorted errors by collectionId\n  const sortedErrors: BatchedJSExecutionErrors = {};\n\n  const JSCollectionsForCurrentPage: JSCollectionData[] = yield select(\n    getJSCollectionsForCurrentPage,\n  );\n\n  for (const jsfuncFullName of Object.keys(data)) {\n    const jsAction = getJSActionFromJSCollections(\n      JSCollectionsForCurrentPage,\n      jsfuncFullName,\n    );\n    if (!(jsAction && jsAction.collectionId)) continue;\n    const { collectionId, id: actionId } = jsAction;\n\n    if (errors[jsfuncFullName]) {\n      updateJSExecutionError(sortedErrors, {\n        collectionId,\n        isDirty: true,\n        actionId,\n      });\n    }\n\n    updateJSExecutionData(sortedData, {\n      collectionId,\n      actionId,\n      data: get(data, jsfuncFullName),\n    });\n  }\n\n  return { sortedData, sortedErrors };\n}\n","//@ts-expect-error no types.\nimport * as documentMock from \"linkedom/worker\";\n\nexport const DOM_APIS = Object.keys(documentMock).reduce((acc, key) => {\n  acc[key] = true;\n  return acc;\n}, {} as Record<string, true>);\n\nexport default function() {\n  for (const [key, value] of Object.entries(documentMock)) {\n    //@ts-expect-error no types\n    self[key] = value;\n  }\n  const dom = documentMock.parseHTML(`<!DOCTYPE html><body></body>`);\n  self.window = dom.window;\n  self.document = dom.window.document;\n  self.window = self;\n}\n","import { DataTree } from \"entities/DataTree/dataTreeFactory\";\nimport { getAllAsyncFunctions } from \"@appsmith/workers/Evaluation/Actions\";\n\nconst UNDEFINED_ACTION_IN_SYNC_EVAL_ERROR =\n  \"Found a reference to {{actionName}} during evaluation. Sync fields cannot execute framework actions. Please remove any direct/indirect references to {{actionName}} and try again.\";\n\nclass ErrorModifier {\n  private errorNamesToScan = [\"ReferenceError\", \"TypeError\"];\n  // Note all regex below groups the async function name\n\n  private asyncFunctionsNameMap: Record<string, true> = {};\n\n  updateAsyncFunctions(dataTree: DataTree) {\n    this.asyncFunctionsNameMap = getAllAsyncFunctions(dataTree);\n  }\n\n  run(error: Error) {\n    const errorMessage = getErrorMessage(error);\n\n    if (!this.errorNamesToScan.includes(error.name)) return errorMessage;\n\n    for (const asyncFunctionFullPath of Object.keys(\n      this.asyncFunctionsNameMap,\n    )) {\n      const functionNameWithWhiteSpace = \" \" + asyncFunctionFullPath + \" \";\n      if (getErrorMessageWithType(error).match(functionNameWithWhiteSpace)) {\n        return {\n          name: \"ValidationError\",\n          message: UNDEFINED_ACTION_IN_SYNC_EVAL_ERROR.replaceAll(\n            \"{{actionName}}\",\n            asyncFunctionFullPath + \"()\",\n          ),\n        };\n      }\n    }\n\n    return errorMessage;\n  }\n}\n\nexport const errorModifier = new ErrorModifier();\n\nexport class FoundPromiseInSyncEvalError extends Error {\n  constructor() {\n    super();\n    this.name = \"\";\n    this.message =\n      \"Found a Promise() during evaluation. Sync fields cannot execute asynchronous code.\";\n  }\n}\n\nexport class ActionCalledInSyncFieldError extends Error {\n  constructor(actionName: string) {\n    super(actionName);\n\n    if (!actionName) {\n      this.message = \"Async function called in a sync field\";\n      return;\n    }\n\n    this.name = \"\";\n    this.message = UNDEFINED_ACTION_IN_SYNC_EVAL_ERROR.replaceAll(\n      \"{{actionName}}\",\n      actionName + \"()\",\n    );\n  }\n}\n\nexport const getErrorMessage = (error: Error) => {\n  return error.name\n    ? {\n        name: error.name,\n        message: error.message,\n      }\n    : {\n        name: \"ValidationError\",\n        message: error.message,\n      };\n};\n\nexport const getErrorMessageWithType = (error: Error) => {\n  return error.name ? `${error.name}: ${error.message}` : error.message;\n};\n","/* eslint-disable no-console */\nimport { DataTree } from \"entities/DataTree/dataTreeFactory\";\nimport {\n  EvaluationError,\n  PropertyEvaluationErrorType,\n} from \"utils/DynamicBindingUtils\";\nimport unescapeJS from \"unescape-js\";\nimport { Severity } from \"entities/AppsmithConsole\";\nimport { EventType } from \"constants/AppsmithActionConstants/ActionConstants\";\nimport { TriggerMeta } from \"@appsmith/sagas/ActionExecution/ActionExecutionSagas\";\nimport indirectEval from \"./indirectEval\";\nimport { jsObjectFunctionFactory } from \"./fns/utils/jsObjectFnFactory\";\nimport { DOM_APIS } from \"./SetupDOM\";\nimport { JSLibraries, libraryReservedIdentifiers } from \"../common/JSLibrary\";\nimport { errorModifier, FoundPromiseInSyncEvalError } from \"./errorModifier\";\nimport { addDataTreeToContext } from \"@appsmith/workers/Evaluation/Actions\";\n\nexport type EvalResult = {\n  result: any;\n  errors: EvaluationError[];\n};\n\nexport enum EvaluationScriptType {\n  EXPRESSION = \"EXPRESSION\",\n  ANONYMOUS_FUNCTION = \"ANONYMOUS_FUNCTION\",\n  ASYNC_ANONYMOUS_FUNCTION = \"ASYNC_ANONYMOUS_FUNCTION\",\n  TRIGGERS = \"TRIGGERS\",\n}\n\nexport const ScriptTemplate = \"<<string>>\";\n\nexport const EvaluationScripts: Record<EvaluationScriptType, string> = {\n  [EvaluationScriptType.EXPRESSION]: `\n  function $$closedFn () {\n    const $$result = ${ScriptTemplate}\n    return $$result\n  }\n  $$closedFn.call(THIS_CONTEXT)\n  `,\n  [EvaluationScriptType.ANONYMOUS_FUNCTION]: `\n  function $$closedFn (script) {\n    const $$userFunction = script;\n    const $$result = $$userFunction?.apply(THIS_CONTEXT, ARGUMENTS);\n    return $$result\n  }\n  $$closedFn(${ScriptTemplate})\n  `,\n  [EvaluationScriptType.ASYNC_ANONYMOUS_FUNCTION]: `\n  async function $$closedFn (script) {\n    const $$userFunction = script;\n    const $$result = $$userFunction?.apply(THIS_CONTEXT, ARGUMENTS);\n    return await $$result;\n  }\n  $$closedFn(${ScriptTemplate})\n  `,\n  [EvaluationScriptType.TRIGGERS]: `\n  async function $$closedFn () {\n    const $$result = ${ScriptTemplate};\n    return await $$result\n  }\n  $$closedFn.call(THIS_CONTEXT)\n  `,\n};\n\nconst topLevelWorkerAPIs = Object.keys(self).reduce((acc, key: string) => {\n  acc[key] = true;\n  return acc;\n}, {} as any);\n\nfunction resetWorkerGlobalScope() {\n  self.$isDataField = false;\n  for (const key of Object.keys(self)) {\n    if (topLevelWorkerAPIs[key] || DOM_APIS[key]) continue;\n    //TODO: Remove this once we have a better way to handle this\n    if ([\"evaluationVersion\", \"window\", \"document\", \"location\"].includes(key))\n      continue;\n    if (JSLibraries.find((lib) => lib.accessor.includes(key))) continue;\n    if (libraryReservedIdentifiers[key]) continue;\n    try {\n      // @ts-expect-error: Types are not available\n      delete self[key];\n    } catch (e) {\n      // @ts-expect-error: Types are not available\n      self[key] = undefined;\n    }\n  }\n}\n\nexport const getScriptType = (\n  evalArgumentsExist = false,\n  isTriggerBased = false,\n): EvaluationScriptType => {\n  let scriptType = EvaluationScriptType.EXPRESSION;\n  if (evalArgumentsExist && isTriggerBased) {\n    scriptType = EvaluationScriptType.ASYNC_ANONYMOUS_FUNCTION;\n  } else if (evalArgumentsExist && !isTriggerBased) {\n    scriptType = EvaluationScriptType.ANONYMOUS_FUNCTION;\n  } else if (isTriggerBased && !evalArgumentsExist) {\n    scriptType = EvaluationScriptType.TRIGGERS;\n  }\n  return scriptType;\n};\n\nexport const additionalLibrariesNames: string[] = [];\n\nexport const getScriptToEval = (\n  userScript: string,\n  type: EvaluationScriptType,\n): string => {\n  // Using replace here would break scripts with replacement patterns (ex: $&, $$)\n  const buffer = EvaluationScripts[type].split(ScriptTemplate);\n  return `${buffer[0]}${userScript}${buffer[1]}`;\n};\n\nconst beginsWithLineBreakRegex = /^\\s+|\\s+$/;\n\nexport type EvalContext = Record<string, any>;\ntype ResolvedFunctions = Record<string, any>;\nexport interface createEvaluationContextArgs {\n  dataTree: DataTree;\n  resolvedFunctions: ResolvedFunctions;\n  context?: EvaluateContext;\n  isTriggerBased: boolean;\n  evalArguments?: Array<unknown>;\n  // Whether not to add functions like \"run\", \"clear\" to entity in global data\n  skipEntityFunctions?: boolean;\n}\n/**\n * This method created an object with dataTree and appsmith's framework actions that needs to be added to worker global scope for the JS code evaluation to then consume it.\n *\n * Example:\n * - For `eval(\"Table1.tableData\")` code to work as expected, we define Table1.tableData in worker global scope and for that we use `createEvaluationContext` to get the object to set in global scope.\n */\nexport const createEvaluationContext = (args: createEvaluationContextArgs) => {\n  const {\n    context,\n    dataTree,\n    evalArguments,\n    isTriggerBased,\n    resolvedFunctions,\n    skipEntityFunctions,\n  } = args;\n\n  const EVAL_CONTEXT: EvalContext = {};\n  ///// Adding callback data\n  EVAL_CONTEXT.ARGUMENTS = evalArguments;\n  //// Adding contextual data not part of data tree\n  EVAL_CONTEXT.THIS_CONTEXT = context?.thisContext || {};\n\n  if (context?.globalContext) {\n    Object.assign(EVAL_CONTEXT, context.globalContext);\n  }\n\n  addDataTreeToContext({\n    EVAL_CONTEXT,\n    dataTree,\n    skipEntityFunctions: !!skipEntityFunctions,\n    isTriggerBased,\n  });\n\n  assignJSFunctionsToContext(EVAL_CONTEXT, resolvedFunctions, isTriggerBased);\n\n  return EVAL_CONTEXT;\n};\n\nexport const assignJSFunctionsToContext = (\n  EVAL_CONTEXT: EvalContext,\n  resolvedFunctions: ResolvedFunctions,\n  isTriggerBased: boolean,\n) => {\n  const jsObjectNames = Object.keys(resolvedFunctions || {});\n  for (const jsObjectName of jsObjectNames) {\n    const resolvedObject = resolvedFunctions[jsObjectName];\n    const jsObject = EVAL_CONTEXT[jsObjectName];\n    const jsObjectFunction: Record<string, Record<\"data\", unknown>> = {};\n    if (!jsObject) continue;\n    for (const fnName of Object.keys(resolvedObject)) {\n      const fn = resolvedObject[fnName];\n      if (typeof fn !== \"function\") continue;\n      // Investigate promisify of JSObject function confirmation\n      // Task: https://github.com/appsmithorg/appsmith/issues/13289\n      // Previous implementation commented code: https://github.com/appsmithorg/appsmith/pull/18471\n      const data = jsObject[fnName]?.data;\n      jsObjectFunction[fnName] = isTriggerBased\n        ? jsObjectFunctionFactory(fn, jsObjectName + \".\" + fnName)\n        : fn;\n      if (!!data) {\n        jsObjectFunction[fnName][\"data\"] = data;\n      }\n    }\n\n    EVAL_CONTEXT[jsObjectName] = Object.assign({}, jsObject, jsObjectFunction);\n  }\n};\n\nexport function sanitizeScript(js: string) {\n  // We remove any line breaks from the beginning of the script because that\n  // makes the final function invalid. We also unescape any escaped characters\n  // so that eval can happen\n  const trimmedJS = js.replace(beginsWithLineBreakRegex, \"\");\n  return self.evaluationVersion > 1 ? trimmedJS : unescapeJS(trimmedJS);\n}\n\n/** Define a context just for this script\n * thisContext will define it on the `this`\n * globalContext will define it globally\n * requestId is used for completing promises\n */\nexport type EvaluateContext = {\n  thisContext?: Record<string, any>;\n  globalContext?: Record<string, any>;\n  requestId?: string;\n  eventType?: EventType;\n  triggerMeta?: TriggerMeta;\n};\n\nexport const getUserScriptToEvaluate = (\n  userScript: string,\n  isTriggerBased: boolean,\n  evalArguments?: Array<any>,\n) => {\n  const unescapedJS = sanitizeScript(userScript);\n  // If nothing is present to evaluate, return\n  if (!unescapedJS.length) {\n    return {\n      script: \"\",\n    };\n  }\n  const scriptType = getScriptType(!!evalArguments, isTriggerBased);\n  const script = getScriptToEval(unescapedJS, scriptType);\n  return { script };\n};\n\nexport default function evaluateSync(\n  userScript: string,\n  dataTree: DataTree,\n  resolvedFunctions: Record<string, any>,\n  isJSCollection: boolean,\n  context?: EvaluateContext,\n  evalArguments?: Array<any>,\n): EvalResult {\n  return (function() {\n    resetWorkerGlobalScope();\n    const errors: EvaluationError[] = [];\n    let result;\n\n    // skipping log reset if the js collection is being evaluated without run\n    // Doing this because the promise execution is losing logs in the process due to resets\n    /**** Setting the eval context ****/\n    const evalContext: EvalContext = createEvaluationContext({\n      dataTree,\n      resolvedFunctions,\n      context,\n      evalArguments,\n      isTriggerBased: isJSCollection,\n    });\n\n    evalContext[\"$isDataField\"] = true;\n\n    const { script } = getUserScriptToEvaluate(\n      userScript,\n      false,\n      evalArguments,\n    );\n\n    // If nothing is present to evaluate, return instead of evaluating\n    if (!script.length) {\n      return {\n        errors: [],\n        result: undefined,\n        triggers: [],\n      };\n    }\n\n    // Set it to self so that the eval function can have access to it\n    // as global data. This is what enables access all appsmith\n    // entity properties from the global context\n    Object.assign(self, evalContext);\n\n    try {\n      result = indirectEval(script);\n      if (result instanceof Promise) {\n        /**\n         * If a promise is returned in sync field then show the error to help understand sync field doesn't await to resolve promise.\n         * NOTE: Awaiting for promise will make sync field evaluation slower.\n         */\n        throw new FoundPromiseInSyncEvalError();\n      }\n    } catch (error) {\n      errors.push({\n        errorMessage: errorModifier.run(error as Error),\n        severity: Severity.ERROR,\n        raw: script,\n        errorType: PropertyEvaluationErrorType.PARSE,\n        originalBinding: userScript,\n      });\n    } finally {\n      for (const entityName in evalContext) {\n        if (evalContext.hasOwnProperty(entityName)) {\n          // @ts-expect-error: Types are not available\n          delete self[entityName];\n        }\n      }\n      self[\"$isDataField\"] = false;\n    }\n    return { result, errors };\n  })();\n}\n\nexport async function evaluateAsync(\n  userScript: string,\n  dataTree: DataTree,\n  resolvedFunctions: Record<string, any>,\n  context?: EvaluateContext,\n  evalArguments?: Array<any>,\n) {\n  return (async function() {\n    resetWorkerGlobalScope();\n    const errors: EvaluationError[] = [];\n    let result;\n\n    /**** Setting the eval context ****/\n    const evalContext: EvalContext = createEvaluationContext({\n      dataTree,\n      resolvedFunctions,\n      context,\n      evalArguments,\n      isTriggerBased: true,\n    });\n\n    const { script } = getUserScriptToEvaluate(userScript, true, evalArguments);\n    evalContext[\"$isDataField\"] = false;\n\n    // Set it to self so that the eval function can have access to it\n    // as global data. This is what enables access all appsmith\n    // entity properties from the global context\n    Object.assign(self, evalContext);\n\n    try {\n      result = await indirectEval(script);\n    } catch (e) {\n      const error = e as Error;\n      const errorMessage = error.name\n        ? { name: error.name, message: error.message }\n        : {\n            name: \"UncaughtPromiseRejection\",\n            message: `${error.message}`,\n          };\n      errors.push({\n        errorMessage: errorMessage,\n        severity: Severity.ERROR,\n        raw: script,\n        errorType: PropertyEvaluationErrorType.PARSE,\n        originalBinding: userScript,\n      });\n    } finally {\n      return {\n        result,\n        errors,\n      };\n    }\n  })();\n}\n","import { uuid4 } from \"@sentry/utils\";\nimport {\n  ENTITY_TYPE,\n  LogObject,\n  Methods,\n  Severity,\n  SourceEntity,\n} from \"entities/AppsmithConsole\";\nimport { klona } from \"klona/lite\";\nimport moment from \"moment\";\nimport { TriggerMeta } from \"@appsmith/sagas/ActionExecution/ActionExecutionSagas\";\nimport TriggerEmitter from \"../utils/TriggerEmitter\";\nimport { EventEmitter } from \"events\";\nimport ExecutionMetaData from \"../utils/ExecutionMetaData\";\n\nclass UserLog {\n  private isEnabled = true;\n  enable() {\n    this.isEnabled = true;\n  }\n  disable() {\n    this.isEnabled = false;\n  }\n  private emitter?: EventEmitter;\n\n  private saveLog(method: Methods, data: any[]) {\n    const parsed = this.parseLogs(method, data);\n    this.emitter?.emit(\"process_logs\", parsed);\n  }\n\n  public overrideConsoleAPI() {\n    this.emitter = TriggerEmitter;\n    const { debug, error, info, log, table, warn } = console;\n    console = {\n      ...console,\n      table: (...args: any) => {\n        if (!this.isEnabled) return;\n        table.call(this, args);\n        this.saveLog(\"table\", args);\n      },\n      error: (...args: any) => {\n        if (!this.isEnabled) return;\n        error.apply(this, args);\n        this.saveLog(\"error\", args);\n      },\n      log: (...args: any) => {\n        if (!this.isEnabled) return;\n        log.apply(this, args);\n        this.saveLog(\"log\", args);\n      },\n      debug: (...args: any) => {\n        if (!this.isEnabled) return;\n        debug.apply(this, args);\n        this.saveLog(\"debug\", args);\n      },\n      warn: (...args: any) => {\n        if (!this.isEnabled) return;\n        warn.apply(this, args);\n        this.saveLog(\"warn\", args);\n      },\n      info: (...args: any) => {\n        if (!this.isEnabled) return;\n        info.apply(this, args);\n        this.saveLog(\"info\", args);\n      },\n    };\n  }\n  private replaceFunctionWithNamesFromObjects(data: any) {\n    if (typeof data === \"function\") return `func() ${data.name}`;\n    if (!data || typeof data !== \"object\") return data;\n    if (data instanceof Promise) return \"Promise\";\n    const acc: any =\n      Object.prototype.toString.call(data) === \"[object Array]\" ? [] : {};\n    return Object.keys(data).reduce((acc, key) => {\n      acc[key] = this.replaceFunctionWithNamesFromObjects(data[key]);\n      return acc;\n    }, acc);\n  }\n  // iterates over the data and if data is object/array, then it will remove any functions from it\n  private sanitizeData(data: any): any {\n    try {\n      const returnData = this.replaceFunctionWithNamesFromObjects(data);\n      return returnData;\n    } catch (e) {\n      return [`There was some error: ${e} ${JSON.stringify(data)}`];\n    }\n  }\n\n  private getSource = (triggerMeta?: TriggerMeta): SourceEntity => {\n    const type = triggerMeta?.source?.entityType || ENTITY_TYPE.JSACTION;\n    const name =\n      triggerMeta?.source?.name || triggerMeta?.triggerPropertyName || \"\";\n    const propertyPath = triggerMeta?.triggerPropertyName || \"\";\n    const id = triggerMeta?.source?.id || \"\";\n    //@ts-expect-error : we are not using the source entity in the console\n    return { type, name, id, propertyPath };\n  };\n\n  // parses the incoming log and converts it to the log object\n  private parseLogs(method: Methods, data: any[]): LogObject {\n    // Create an ID\n    const id = uuid4();\n    const timestamp = moment().format(\"hh:mm:ss\");\n    // Parse the methods\n    let output = data;\n    // For logs UI we only keep 3 levels of severity, info, warn, error\n    let severity = Severity.INFO;\n    if (method === \"error\") {\n      severity = Severity.ERROR;\n      output = data.map((error) => {\n        return error?.stack || error;\n      });\n    } else if (method === \"warn\") {\n      severity = Severity.WARNING;\n    }\n\n    const { triggerMeta } = ExecutionMetaData.getExecutionMetaData();\n    return {\n      method,\n      id,\n      data: this.sanitizeData(klona(output)),\n      timestamp,\n      severity,\n      source: this.getSource(triggerMeta),\n    };\n  }\n}\n\nconst userLogs = new UserLog();\n\nexport default userLogs;\n","import { createEvaluationContext } from \"../../evaluate\";\nimport { dataTreeEvaluator } from \"../../handlers/evalTree\";\nimport ExecutionMetaData from \"../utils/ExecutionMetaData\";\n\nconst _internalSetInterval = self.setInterval;\nconst _internalClearInterval = self.clearInterval;\n\nconst intervalIdMap = new Map<number | string, number>();\n\nexport function clearAllIntervals() {\n  intervalIdMap.forEach((intervalId) => _internalClearInterval(intervalId));\n  intervalIdMap.clear();\n}\n\nexport function clearInterval(intervalId: number | string) {\n  const runningIntervalId = intervalIdMap.get(intervalId);\n  intervalIdMap.delete(intervalId);\n  return _internalClearInterval(runningIntervalId);\n}\n\nexport function setInterval(\n  callback: (...args: any[]) => void,\n  delay = 300,\n  ...args: any[]\n) {\n  const metaData = ExecutionMetaData.getExecutionMetaData();\n  const runningIntervalId = intervalIdMap.get(args[0]);\n  if (runningIntervalId) {\n    _internalClearInterval(runningIntervalId);\n    intervalIdMap.delete(args[0]);\n  }\n  const _internalIntervalId = _internalSetInterval(\n    (...args: any[]) => {\n      const evalContext = createEvaluationContext({\n        dataTree: dataTreeEvaluator?.evalTree || {},\n        resolvedFunctions: dataTreeEvaluator?.resolvedFunctions || {},\n        isTriggerBased: true,\n      });\n      self[\"$isDataField\"] = false;\n      Object.assign(self, evalContext);\n      ExecutionMetaData.setExecutionMetaData(\n        metaData.triggerMeta,\n        metaData.eventType,\n      );\n      typeof callback === \"function\" && callback(...args);\n    },\n    delay,\n    ...args,\n  );\n  const customIntervalId = args[0] || _internalIntervalId;\n  intervalIdMap.set(customIntervalId, _internalIntervalId);\n  return _internalIntervalId;\n}\n","/* eslint-disable no-console */\nimport { WorkerErrorTypes } from \"ce/workers/common/types\";\nimport { uniqueId } from \"lodash\";\nimport { MessageType, sendMessage } from \"utils/MessageUtil\";\ntype TPromiseResponse =\n  | {\n      data: any;\n      error: null;\n    }\n  | {\n      error: { message: string; errorBody: unknown };\n      data: null;\n    };\n\nfunction responseHandler(requestId: string): Promise<TPromiseResponse> {\n  return new Promise((resolve) => {\n    const listener = (event: MessageEvent) => {\n      const { body, messageId, messageType } = event.data;\n      if (messageId === requestId && messageType === MessageType.RESPONSE) {\n        resolve(body.data);\n        self.removeEventListener(\"message\", listener);\n      }\n    };\n    self.addEventListener(\"message\", listener);\n  });\n}\n\nexport class WorkerMessenger {\n  static async request(payload: any) {\n    const messageId = uniqueId(`request-${payload.method}-`);\n    sendMessage.call(self, {\n      messageId,\n      messageType: MessageType.REQUEST,\n      body: payload,\n    });\n    const response = await responseHandler(messageId);\n    return response;\n  }\n\n  static ping(payload: any) {\n    sendMessage.call(self, {\n      messageType: MessageType.DEFAULT,\n      body: payload,\n    });\n  }\n\n  static respond(messageId: string, data: unknown, timeTaken: number) {\n    try {\n      sendMessage.call(self, {\n        messageId,\n        messageType: MessageType.RESPONSE,\n        body: { data, timeTaken },\n      });\n    } catch (e) {\n      console.error(e);\n      sendMessage.call(self, {\n        messageId,\n        messageType: MessageType.RESPONSE,\n        body: {\n          timeTaken: timeTaken.toFixed(2),\n          data: {\n            errors: [\n              {\n                type: WorkerErrorTypes.CLONE_ERROR,\n                message: (e as Error)?.message,\n                context: JSON.stringify(data),\n              },\n            ],\n          },\n        },\n      });\n    }\n  }\n}\n","import { ActionCalledInSyncFieldError } from \"workers/Evaluation/errorModifier\";\n\nexport function addFn(\n  ctx: any,\n  fnName: string,\n  fn: (...args: any[]) => any,\n  fnGuards = [isAsyncGuard],\n) {\n  Object.defineProperty(ctx, fnName, {\n    value: function(...args: any[]) {\n      for (const guard of fnGuards) {\n        fn = guard(fn, fnName);\n      }\n      return fn(...args);\n    },\n    enumerable: false,\n    writable: true,\n    configurable: true,\n  });\n}\n\nexport function isAsyncGuard<P extends ReadonlyArray<unknown>>(\n  fn: (...args: P) => unknown,\n  fnName: string,\n) {\n  return (...args: P) => {\n    if (!self.$isDataField) return fn(...args);\n    self[\"$isAsync\"] = true;\n    throw new ActionCalledInSyncFieldError(fnName);\n  };\n}\n","import { Diff } from \"deep-diff\";\nimport { CanvasWidgetsReduxState } from \"reducers/entityReducers/canvasWidgetsReducer\";\nimport ReplayEntity from \"../index\";\nimport { set } from \"lodash\";\nimport {\n  addToArray,\n  FOCUSES,\n  setPropertyUpdate,\n  TOASTS,\n  UPDATES,\n  WIDGETS,\n} from \"../replayUtils\";\nimport { AppTheme } from \"entities/AppTheming\";\nimport { ENTITY_TYPE } from \"entities/AppsmithConsole\";\n\nexport type Canvas = {\n  widgets: CanvasWidgetsReduxState;\n  theme: AppTheme;\n};\nexport type CanvasDiff = Diff<Canvas, Canvas>;\nexport type DSLDiff = Diff<CanvasWidgetsReduxState, CanvasWidgetsReduxState>;\n\nconst positionProps = [\n  \"leftColumn\",\n  \"rightColumn\",\n  \"topRow\",\n  \"bottomRow\",\n  \"minHeight\",\n  \"parentColumnSpace\",\n  \"parentRowSpace\",\n  \"children\",\n  \"parentId\",\n  \"renderMode\",\n  \"detachFromLayout\",\n  \"noContainerOffset\",\n  \"isCanvas\",\n  \"height\",\n];\n\n/**\n * checks property changed is a positional property\n *\n * @param widgetProperty\n * @returns\n */\nfunction isPositionUpdate(widgetProperty: string) {\n  return positionProps.indexOf(widgetProperty) !== -1;\n}\nexport default class ReplayCanvas extends ReplayEntity<Canvas> {\n  public constructor(entity: Canvas) {\n    super(entity, ENTITY_TYPE.WIDGET);\n  }\n\n  /**\n   * process the diff\n   *\n   * @param diff\n   * @param replay\n   * @param isUndo\n   * @returns\n   */\n  public processDiff(diff: CanvasDiff, replay: any, isUndo: boolean) {\n    if (!diff || !diff.path || !diff.path.length || diff.path[1] === \"0\")\n      return;\n\n    if (diff.path.indexOf(\"widgets\") > -1) {\n      return this.processDiffForWidgets(diff, replay, isUndo);\n    }\n\n    if (diff.path.indexOf(\"theme\") > -1) {\n      return this.processDiffForTheme(diff, replay);\n    }\n  }\n\n  /**\n   * process diff related to app theming\n   *\n   * @param diff\n   * @param replay\n   * @param isUndo\n   */\n  public processDiffForTheme(diff: CanvasDiff, replay: any) {\n    if (!diff || !diff.path || !diff.path.length || diff.path[1] === \"0\")\n      return;\n\n    set(replay, \"theme\", true);\n\n    if (diff.path.join(\".\") === \"theme.name\") {\n      set(replay, \"themeChanged\", true);\n    }\n  }\n\n  /**\n   * process diffs related to DSL ( widgets )\n   *\n   * @param diff\n   * @param replay\n   * @param isUndo\n   * @returns\n   */\n  public processDiffForWidgets(diff: CanvasDiff, replay: any, isUndo: boolean) {\n    if (!diff || !diff.path || !diff.path.length || diff.path[1] === \"0\")\n      return;\n\n    const widgetId = diff.path[1];\n\n    switch (diff.kind) {\n      // new elements is added in dsl\n      case \"N\":\n        if (diff.path.length == 2) {\n          const toast = this.createToast(\n            diff.rhs,\n            this.entity.widgets[widgetId],\n            widgetId,\n            isUndo,\n            !isUndo,\n          );\n          addToArray(replay, TOASTS, toast);\n        } else {\n          setPropertyUpdate(replay, [WIDGETS, widgetId, UPDATES], diff.path);\n        }\n        break;\n      // element is deleted in dsl\n      case \"D\":\n        if (diff.path.length == 2) {\n          const toast = this.createToast(\n            diff.lhs,\n            this.entity.widgets[widgetId],\n            widgetId,\n            isUndo,\n            isUndo,\n          );\n          addToArray(replay, TOASTS, toast);\n        } else {\n          setPropertyUpdate(replay, [WIDGETS, widgetId, UPDATES], diff.path);\n        }\n        break;\n      // element is edited\n      case \"E\":\n        if (isPositionUpdate(diff.path[diff.path.length - 2])) {\n          set(replay, [WIDGETS, widgetId, FOCUSES], true);\n        } else {\n          setPropertyUpdate(replay, [WIDGETS, widgetId, UPDATES], diff.path);\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  private createToast(\n    diffWidget: any,\n    dslWidget: CanvasWidgetsReduxState | undefined,\n    widgetId: string,\n    isUndo: boolean,\n    isCreated: boolean,\n  ) {\n    const widgetName = isCreated\n      ? diffWidget.widgetName\n      : dslWidget?.widgetName;\n    return {\n      isCreated,\n      isUndo,\n      widgetName,\n      widgetId,\n    };\n  }\n}\n","import { find, get, isEmpty, union } from \"lodash\";\nimport toPath from \"lodash/toPath\";\nimport {\n  EvalErrorTypes,\n  EvalError,\n  DependencyMap,\n  getDynamicBindings,\n  getEntityDynamicBindingPathList,\n} from \"utils/DynamicBindingUtils\";\nimport { extractIdentifierInfoFromCode } from \"@shared/ast\";\nimport {\n  addWidgetPropertyDependencies,\n  convertPathToString,\n  getEntityNameAndPropertyPath,\n  isAction,\n  isJSAction,\n  isWidget,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport {\n  DataTreeAction,\n  DataTreeEntity,\n  DataTreeJSAction,\n  DataTreeWidget,\n} from \"entities/DataTree/dataTreeFactory\";\nimport {\n  DEDICATED_WORKER_GLOBAL_SCOPE_IDENTIFIERS,\n  JAVASCRIPT_KEYWORDS,\n} from \"constants/WidgetValidation\";\nimport { APPSMITH_GLOBAL_FUNCTIONS } from \"components/editorComponents/ActionCreator/constants\";\nimport { libraryReservedIdentifiers } from \"workers/common/JSLibrary\";\n\n/** This function extracts validReferences and invalidReferences from a binding {{}}\n * @param script\n * @param allPaths\n * @returns validReferences - Valid references from bindings\n * invalidReferences- References which are currently invalid\n * @example - For binding {{unknownEntity.name + Api1.name}}, it returns\n * {\n * validReferences:[Api1.name],\n * invalidReferences: [unknownEntity.name]\n * }\n */\nexport const extractInfoFromBinding = (\n  script: string,\n  allPaths: Record<string, true>,\n): { validReferences: string[]; invalidReferences: string[] } => {\n  const { references } = extractIdentifierInfoFromCode(\n    script,\n    self.evaluationVersion,\n    { ...invalidEntityIdentifiers, ...libraryReservedIdentifiers },\n  );\n  return extractInfoFromReferences(references, allPaths);\n};\n\n/** This function extracts validReferences and invalidReferences from an Array of Identifiers\n * @param references\n * @param allPaths\n * @returns validReferences - Valid references from bindings\n * invalidReferences- References which are currently invalid\n *  @example - For identifiers [unknownEntity.name , Api1.name], it returns\n * {\n * validReferences:[Api1.name],\n * invalidReferences: [unknownEntity.name]\n * }\n */\nexport const extractInfoFromReferences = (\n  references: string[],\n  allPaths: Record<string, true>,\n): {\n  validReferences: string[];\n  invalidReferences: string[];\n} => {\n  const validReferences: Set<string> = new Set<string>();\n  const invalidReferences: string[] = [];\n  references.forEach((reference: string) => {\n    // If the identifier exists directly, add it and return\n    if (allPaths.hasOwnProperty(reference)) {\n      validReferences.add(reference);\n      return;\n    }\n    const subpaths = toPath(reference);\n    let current = \"\";\n    // We want to keep going till we reach top level, but not add top level\n    // Eg: Input1.text should not depend on entire Table1 unless it explicitly asked for that.\n    // This is mainly to avoid a lot of unnecessary evals, if we feel this is wrong\n    // we can remove the length requirement, and it will still work\n    while (subpaths.length > 1) {\n      current = convertPathToString(subpaths);\n      // We've found the dep, add it and return\n      if (allPaths.hasOwnProperty(current)) {\n        validReferences.add(current);\n        return;\n      }\n      subpaths.pop();\n    }\n    // If no valid reference is derived, add it to the list of invalidReferences\n    invalidReferences.push(reference);\n  });\n  return { validReferences: Array.from(validReferences), invalidReferences };\n};\n\ninterface BindingsInfo {\n  validReferences: string[];\n  invalidReferences: string[];\n  errors: EvalError[];\n}\nexport const extractInfoFromBindings = (\n  bindings: string[],\n  allPaths: Record<string, true>,\n) => {\n  return bindings.reduce(\n    (bindingsInfo: BindingsInfo, binding) => {\n      try {\n        const { invalidReferences, validReferences } = extractInfoFromBinding(\n          binding,\n          allPaths,\n        );\n        return {\n          ...bindingsInfo,\n          validReferences: union(bindingsInfo.validReferences, validReferences),\n          invalidReferences: union(\n            bindingsInfo.invalidReferences,\n            invalidReferences,\n          ),\n        };\n      } catch (error) {\n        const newEvalError: EvalError = {\n          type: EvalErrorTypes.EXTRACT_DEPENDENCY_ERROR,\n          message: (error as Error).message,\n          context: {\n            script: binding,\n          },\n        };\n        return {\n          ...bindingsInfo,\n          errors: union(bindingsInfo.errors, [newEvalError]),\n        };\n      }\n    },\n    { validReferences: [], invalidReferences: [], errors: [] },\n  );\n};\n\nexport function listTriggerFieldDependencies(\n  entity: DataTreeWidget,\n  entityName: string,\n): DependencyMap {\n  const triggerFieldDependency: DependencyMap = {};\n  if (isWidget(entity)) {\n    const dynamicTriggerPathlist = entity.dynamicTriggerPathList;\n    if (dynamicTriggerPathlist && dynamicTriggerPathlist.length) {\n      dynamicTriggerPathlist.forEach((dynamicPath) => {\n        const propertyPath = dynamicPath.key;\n        const unevalPropValue = get(entity, propertyPath);\n        const { jsSnippets } = getDynamicBindings(unevalPropValue);\n        const existingDeps =\n          triggerFieldDependency[`${entityName}.${propertyPath}`] || [];\n        triggerFieldDependency[\n          `${entityName}.${propertyPath}`\n        ] = existingDeps.concat(jsSnippets.filter((jsSnippet) => !!jsSnippet));\n      });\n    }\n  }\n  return triggerFieldDependency;\n}\n\nexport function listValidationDependencies(\n  entity: DataTreeWidget,\n  entityName: string,\n): DependencyMap {\n  const validationDependency: DependencyMap = {};\n  if (isWidget(entity)) {\n    const { validationPaths } = entity;\n\n    Object.entries(validationPaths).forEach(\n      ([propertyPath, validationConfig]) => {\n        if (validationConfig.dependentPaths) {\n          const dependencyArray = validationConfig.dependentPaths.map(\n            (path) => `${entityName}.${path}`,\n          );\n          validationDependency[\n            `${entityName}.${propertyPath}`\n          ] = dependencyArray;\n        }\n      },\n    );\n  }\n  return validationDependency;\n}\n\n/**This function returns a unique array containing a merge of both arrays\n * @param currentArr\n * @param updateArr\n * @returns A unique array containing a merge of both arrays\n */\nexport const mergeArrays = <T>(currentArr: T[], updateArr: T[]): T[] => {\n  if (!currentArr) return updateArr;\n  return union(currentArr, updateArr);\n};\n\n/**\n * Identifiers which can not be valid names of entities and are not dynamic in nature.\n * therefore should be removed from the list of references extracted from code.\n * NB: DATA_TREE_KEYWORDS in app/client/src/constants/WidgetValidation.ts isn't included, although they are not valid entity names,\n * they can refer to potentially dynamic entities.\n * Eg. \"appsmith\"\n */\nconst invalidEntityIdentifiers: Record<string, unknown> = {\n  ...JAVASCRIPT_KEYWORDS,\n  ...APPSMITH_GLOBAL_FUNCTIONS,\n  ...DEDICATED_WORKER_GLOBAL_SCOPE_IDENTIFIERS,\n};\n\nexport function listEntityDependencies(\n  entity: DataTreeWidget | DataTreeAction | DataTreeJSAction,\n  entityName: string,\n  allPaths: Record<string, true>,\n): DependencyMap {\n  let dependencies: DependencyMap = {};\n\n  if (isWidget(entity)) {\n    // Adding the dynamic triggers in the dependency list as they need linting whenever updated\n    // we don't make it dependent on anything else\n    if (entity.dynamicTriggerPathList) {\n      Object.values(entity.dynamicTriggerPathList).forEach(({ key }) => {\n        dependencies[`${entityName}.${key}`] = [];\n      });\n    }\n    const widgetDependencies = addWidgetPropertyDependencies({\n      entity,\n      entityName,\n    });\n\n    dependencies = {\n      ...dependencies,\n      ...widgetDependencies,\n    };\n  }\n\n  if (isAction(entity) || isJSAction(entity)) {\n    Object.entries(entity.dependencyMap).forEach(\n      ([path, entityDependencies]) => {\n        const actionDependentPaths: Array<string> = [];\n        const mainPath = `${entityName}.${path}`;\n        // Only add dependencies for paths which exist at the moment in appsmith world\n        if (allPaths.hasOwnProperty(mainPath)) {\n          // Only add dependent paths which exist in the data tree. Skip all the other paths to avoid creating\n          // a cyclical dependency.\n          entityDependencies.forEach((dependentPath) => {\n            const completePath = `${entityName}.${dependentPath}`;\n            if (allPaths.hasOwnProperty(completePath)) {\n              actionDependentPaths.push(completePath);\n            }\n          });\n          dependencies[mainPath] = actionDependentPaths;\n        }\n      },\n    );\n  }\n  if (isJSAction(entity)) {\n    // making functions dependent on their function body entities\n    if (entity.reactivePaths) {\n      Object.keys(entity.reactivePaths).forEach((propertyPath) => {\n        const existingDeps =\n          dependencies[`${entityName}.${propertyPath}`] || [];\n        const unevalPropValue = get(entity, propertyPath);\n        const unevalPropValueString =\n          !!unevalPropValue && unevalPropValue.toString();\n        const { jsSnippets } = getDynamicBindings(\n          unevalPropValueString,\n          entity,\n        );\n        dependencies[`${entityName}.${propertyPath}`] = existingDeps.concat(\n          jsSnippets.filter((jsSnippet) => !!jsSnippet),\n        );\n      });\n    }\n  }\n\n  if (isAction(entity) || isWidget(entity)) {\n    // add the dynamic binding paths to the dependency map\n    const dynamicBindingPathList = getEntityDynamicBindingPathList(entity);\n    if (dynamicBindingPathList.length) {\n      dynamicBindingPathList.forEach((dynamicPath) => {\n        const propertyPath = dynamicPath.key;\n        const unevalPropValue = get(entity, propertyPath);\n        const { jsSnippets } = getDynamicBindings(unevalPropValue);\n        const existingDeps =\n          dependencies[`${entityName}.${propertyPath}`] || [];\n        dependencies[`${entityName}.${propertyPath}`] = existingDeps.concat(\n          jsSnippets.filter((jsSnippet) => !!jsSnippet),\n        );\n      });\n    }\n  }\n  return dependencies;\n}\n\nexport function listEntityPathDependencies(\n  entity: DataTreeWidget | DataTreeAction | DataTreeJSAction,\n  fullPropertyPath: string,\n): {\n  isTrigger: boolean;\n  dependencies: string[];\n} {\n  let dependencies: string[] = [];\n  const isTrigger = false;\n  const { propertyPath } = getEntityNameAndPropertyPath(fullPropertyPath);\n  if (isWidget(entity)) {\n    if (isATriggerPath(entity, propertyPath)) {\n      return {\n        isTrigger: true,\n        dependencies: listEntityPathTriggerFieldDependencies(\n          entity,\n          fullPropertyPath,\n        ),\n      };\n    }\n  }\n\n  if (isJSAction(entity)) {\n    if (entity.bindingPaths.hasOwnProperty(propertyPath)) {\n      const unevalPropValue = get(entity, propertyPath);\n      const unevalPropValueString =\n        !!unevalPropValue && unevalPropValue.toString();\n      const { jsSnippets } = getDynamicBindings(unevalPropValueString, entity);\n      dependencies = dependencies.concat(\n        jsSnippets.filter((jsSnippet) => !!jsSnippet),\n      );\n    }\n  }\n\n  if (isAction(entity) || isWidget(entity)) {\n    if (\n      entity.bindingPaths.hasOwnProperty(propertyPath) ||\n      find(entity.dynamicBindingPathList, { key: propertyPath })\n    ) {\n      const unevalPropValue = get(entity, propertyPath);\n      const { jsSnippets } = getDynamicBindings(unevalPropValue);\n      dependencies = dependencies.concat(\n        jsSnippets.filter((jsSnippet) => !!jsSnippet),\n      );\n    }\n  }\n  return { isTrigger, dependencies };\n}\n\nexport function listEntityPathTriggerFieldDependencies(\n  entity: DataTreeWidget,\n  fullPath: string,\n) {\n  let triggerFieldDependencies: string[] = [];\n  const { propertyPath } = getEntityNameAndPropertyPath(fullPath);\n\n  if (isADynamicTriggerPath(entity, propertyPath)) {\n    const unevalPropValue = get(entity, propertyPath);\n    const { jsSnippets } = getDynamicBindings(unevalPropValue);\n    triggerFieldDependencies = jsSnippets.filter((jsSnippet) => !!jsSnippet);\n  }\n\n  return triggerFieldDependencies;\n}\n\nexport function isADynamicTriggerPath(\n  entity: DataTreeEntity,\n  propertyPath: string,\n) {\n  if (isWidget(entity)) {\n    const dynamicTriggerPathlist = entity.dynamicTriggerPathList;\n    const isTriggerPath = find(dynamicTriggerPathlist, { key: propertyPath });\n    if (isTriggerPath) {\n      return true;\n    }\n    return false;\n  }\n}\n\nfunction isATriggerPath(entity: DataTreeEntity, propertyPath: string) {\n  if (isWidget(entity)) {\n    const triggerPaths = entity.triggerPaths;\n    return triggerPaths.hasOwnProperty(propertyPath);\n  }\n  return false;\n}\n\nexport function updateMap(\n  map: DependencyMap,\n  path: string,\n  updates: string[],\n  options: Partial<{ deleteOnEmpty: boolean; replaceValue: boolean }> = {},\n) {\n  const { deleteOnEmpty, replaceValue } = options;\n  const oldValue = replaceValue ? [] : map[path];\n  const updatedEntries = mergeArrays(oldValue, updates);\n  if (deleteOnEmpty && isEmpty(updatedEntries)) {\n    delete map[path];\n  } else {\n    map[path] = updatedEntries;\n  }\n}\n","import {\n  DataTreeDiff,\n  getAllPaths,\n  DataTreeDiffEvent,\n  isWidget,\n  isAction,\n  isJSAction,\n  makeParentsDependOnChildren,\n  isValidEntity,\n  getEntityNameAndPropertyPath,\n  isDynamicLeaf,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport {\n  DataTree,\n  DataTreeAction,\n  DataTreeWidget,\n  DataTreeJSAction,\n} from \"entities/DataTree/dataTreeFactory\";\nimport {\n  DependencyMap,\n  isChildPropertyPath,\n  getPropertyPath,\n  isPathADynamicBinding,\n  getDynamicBindings,\n  isPathDynamicTrigger,\n  getEvalErrorPath,\n} from \"utils/DynamicBindingUtils\";\nimport {\n  extractInfoFromBindings,\n  extractInfoFromReferences,\n  isADynamicTriggerPath,\n  listEntityDependencies,\n  listEntityPathDependencies,\n  listTriggerFieldDependencies,\n  listValidationDependencies,\n  updateMap,\n} from \"./utils\";\nimport DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport { difference, isEmpty, set } from \"lodash\";\n\ninterface CreateDependencyMap {\n  dependencyMap: DependencyMap;\n  triggerFieldDependencyMap: DependencyMap;\n  /** Keeps track of all invalid references present in bindings throughout the page.\n   *  We keep this list so that we don't have to traverse the entire dataTree when\n   *  a new entity or path is added to the datatree in order to determine if an old invalid reference has become valid\n   *  because an entity or path is newly added.\n   * */\n  invalidReferencesMap: DependencyMap;\n  validationDependencyMap: DependencyMap;\n}\n\nexport function createDependencyMap(\n  dataTreeEvalRef: DataTreeEvaluator,\n  unEvalTree: DataTree,\n): CreateDependencyMap {\n  let dependencyMap: DependencyMap = {};\n  let triggerFieldDependencyMap: DependencyMap = {};\n  let validationDependencyMap: DependencyMap = {};\n  const invalidReferencesMap: DependencyMap = {};\n  Object.keys(unEvalTree).forEach((entityName) => {\n    const entity = unEvalTree[entityName];\n    if (isAction(entity) || isWidget(entity) || isJSAction(entity)) {\n      const entityListedDependencies = listEntityDependencies(\n        entity,\n        entityName,\n        dataTreeEvalRef.allKeys,\n      );\n      dependencyMap = { ...dependencyMap, ...entityListedDependencies };\n    }\n    if (isWidget(entity)) {\n      // only widgets have trigger paths\n      triggerFieldDependencyMap = {\n        ...triggerFieldDependencyMap,\n        ...listTriggerFieldDependencies(entity, entityName),\n      };\n      // only widgets have validation paths\n      validationDependencyMap = {\n        ...validationDependencyMap,\n        ...listValidationDependencies(entity, entityName),\n      };\n    }\n  });\n\n  Object.keys(dependencyMap).forEach((key) => {\n    const {\n      errors,\n      invalidReferences,\n      validReferences,\n    } = extractInfoFromBindings(dependencyMap[key], dataTreeEvalRef.allKeys);\n    dependencyMap[key] = validReferences;\n    // To keep invalidReferencesMap as minimal as possible, only paths with invalid references\n    // are stored.\n    if (invalidReferences.length) {\n      invalidReferencesMap[key] = invalidReferences;\n    }\n    errors.forEach((error) => {\n      dataTreeEvalRef.errors.push(error);\n    });\n  });\n\n  // extract references from bindings in trigger fields\n  Object.keys(triggerFieldDependencyMap).forEach((key) => {\n    const {\n      errors,\n      invalidReferences,\n      validReferences,\n    } = extractInfoFromBindings(\n      triggerFieldDependencyMap[key],\n      dataTreeEvalRef.allKeys,\n    );\n    triggerFieldDependencyMap[key] = validReferences;\n    // To keep invalidReferencesMap as minimal as possible, only paths with invalid references\n    // are stored.\n    if (invalidReferences.length) {\n      invalidReferencesMap[key] = invalidReferences;\n    }\n    errors.forEach((error) => {\n      dataTreeEvalRef.errors.push(error);\n    });\n  });\n\n  dependencyMap = makeParentsDependOnChildren(\n    dependencyMap,\n    dataTreeEvalRef.allKeys,\n  );\n\n  return {\n    dependencyMap,\n    triggerFieldDependencyMap,\n    invalidReferencesMap,\n    validationDependencyMap,\n  };\n}\n\ninterface UpdateDependencyMap {\n  dependenciesOfRemovedPaths: string[];\n  pathsToClearErrorsFor: any[];\n  removedPaths: string[];\n  /** Some paths do not need to go through evaluation, but require linting\n   *  For example:\n   *  1. For changes in paths that trigger fields depend on, the triggerFields need to be \"linted\" but not evaluated.\n   *  2. Paths containing invalid references - Eg. for binding {{Api1.unknown}} in button.text, although Api1.unknown\n   *     is not a valid reference, when Api1 is deleted button.text needs to be linted\n   */\n  extraPathsToLint: string[];\n}\nexport const updateDependencyMap = ({\n  dataTreeEvalRef,\n  translatedDiffs,\n  unEvalDataTree,\n}: {\n  dataTreeEvalRef: DataTreeEvaluator;\n  translatedDiffs: Array<DataTreeDiff>;\n  unEvalDataTree: DataTree;\n}): UpdateDependencyMap => {\n  const diffCalcStart = performance.now();\n  let didUpdateDependencyMap = false;\n  let didUpdateValidationDependencyMap = false;\n  const dependenciesOfRemovedPaths: Array<string> = [];\n  const removedPaths: Array<string> = [];\n  const extraPathsToLint = new Set<string>();\n  const pathsToClearErrorsFor: any[] = [];\n  const {\n    dependencyMap,\n    invalidReferencesMap,\n    oldUnEvalTree,\n    triggerFieldDependencyMap,\n  } = dataTreeEvalRef;\n\n  let { allKeys, errors: dataTreeEvalErrors } = dataTreeEvalRef;\n\n  // This is needed for NEW and DELETE events below.\n  // In worst case, it tends to take ~12.5% of entire diffCalc (8 ms out of 67ms for 132 array of NEW)\n  // TODO: Optimise by only getting paths of changed node\n  allKeys = getAllPaths(unEvalDataTree);\n  // Transform the diff library events to Appsmith evaluator events\n\n  translatedDiffs.forEach((dataTreeDiff) => {\n    const {\n      event,\n      payload: { propertyPath: fullPropertyPath, value },\n    } = dataTreeDiff;\n    const { entityName } = getEntityNameAndPropertyPath(fullPropertyPath);\n    const entity =\n      event === DataTreeDiffEvent.DELETE\n        ? oldUnEvalTree[entityName]\n        : unEvalDataTree[entityName];\n    const entityType = isValidEntity(entity) ? entity.ENTITY_TYPE : \"noop\";\n\n    if (entityType !== \"noop\") {\n      switch (event) {\n        case DataTreeDiffEvent.NEW: {\n          if (isWidget(entity) || isAction(entity) || isJSAction(entity)) {\n            if (!isDynamicLeaf(unEvalDataTree, fullPropertyPath)) {\n              const entityDependencyMap: DependencyMap = listEntityDependencies(\n                entity,\n                entityName,\n                allKeys,\n              );\n              if (!isEmpty(entityDependencyMap)) {\n                didUpdateDependencyMap = true;\n                // The entity might already have some dependencies,\n                // so we just want to update those\n                Object.entries(entityDependencyMap).forEach(\n                  ([entityDependent, entityDependencies]) => {\n                    const {\n                      errors: extractDependencyErrors,\n                      invalidReferences,\n                      validReferences,\n                    } = extractInfoFromBindings(entityDependencies, allKeys);\n                    // Update dependencyMap\n                    updateMap(dependencyMap, entityDependent, validReferences);\n                    // Update invalidReferencesMap\n                    updateMap(\n                      invalidReferencesMap,\n                      entityDependent,\n                      invalidReferences,\n                      { deleteOnEmpty: true, replaceValue: true },\n                    );\n                    dataTreeEvalErrors = dataTreeEvalErrors.concat(\n                      extractDependencyErrors,\n                    );\n                  },\n                );\n              }\n              if (isWidget(entity)) {\n                // For widgets,\n                // we need to update the triggerField dependencyMap and validation dependencyMap\n                const triggerFieldDependencies = listTriggerFieldDependencies(\n                  entity,\n                  entityName,\n                );\n                Object.entries(triggerFieldDependencies).forEach(\n                  ([triggerFieldDependent, triggerFieldDependencies]) => {\n                    const {\n                      errors: extractDependencyErrors,\n                      invalidReferences,\n                      validReferences,\n                    } = extractInfoFromBindings(\n                      triggerFieldDependencies,\n                      allKeys,\n                    );\n                    // Update triggerfield dependencyMap\n                    updateMap(\n                      triggerFieldDependencyMap,\n                      triggerFieldDependent,\n                      validReferences,\n                    );\n                    // Update invalidReferencesMap\n                    updateMap(\n                      invalidReferencesMap,\n                      triggerFieldDependent,\n                      invalidReferences,\n                      { deleteOnEmpty: true, replaceValue: true },\n                    );\n                    // update errors\n                    dataTreeEvalErrors = dataTreeEvalErrors.concat(\n                      extractDependencyErrors,\n                    );\n                  },\n                );\n                // update validation dependencies\n                dataTreeEvalRef.validationDependencyMap = {\n                  ...dataTreeEvalRef.validationDependencyMap,\n                  ...listValidationDependencies(entity, entityName),\n                };\n                didUpdateValidationDependencyMap = true;\n              }\n            } else {\n              didUpdateDependencyMap = true;\n              const {\n                dependencies: entityPathDependencies,\n                isTrigger,\n              } = listEntityPathDependencies(entity, fullPropertyPath);\n              if (isTrigger) {\n                // Trigger fields shouldn't depend on anything, in the dependencyMap\n                dependencyMap[fullPropertyPath] = [];\n                const {\n                  errors: extractDependencyErrors,\n                  invalidReferences,\n                  validReferences,\n                } = extractInfoFromBindings(entityPathDependencies, allKeys);\n                // Update trigger dependencyMap\n                updateMap(\n                  triggerFieldDependencyMap,\n                  fullPropertyPath,\n                  validReferences,\n                );\n                // Update invalidReferencesMap\n                updateMap(\n                  invalidReferencesMap,\n                  fullPropertyPath,\n                  invalidReferences,\n                  { replaceValue: true, deleteOnEmpty: true },\n                );\n                // update errors\n                dataTreeEvalErrors = dataTreeEvalErrors.concat(\n                  extractDependencyErrors,\n                );\n              } else {\n                didUpdateDependencyMap = true;\n                const {\n                  errors: extractDependencyErrors,\n                  invalidReferences,\n                  validReferences,\n                } = extractInfoFromBindings(entityPathDependencies, allKeys);\n                // Update dependencyMap\n                updateMap(dependencyMap, fullPropertyPath, validReferences);\n\n                // Update invalidReferencesMap\n                updateMap(\n                  invalidReferencesMap,\n                  fullPropertyPath,\n                  invalidReferences,\n                  { replaceValue: true, deleteOnEmpty: true },\n                );\n                dataTreeEvalErrors = dataTreeEvalErrors.concat(\n                  extractDependencyErrors,\n                );\n              }\n              if (isWidget(entity)) {\n                // update validation dependencies\n                dataTreeEvalRef.validationDependencyMap = {\n                  ...dataTreeEvalRef.validationDependencyMap,\n                  ...listValidationDependencies(entity, entityName),\n                };\n                didUpdateValidationDependencyMap = true;\n              }\n            }\n          }\n          // Either a new entity or a new property path has been added. Go through the list of invalid references and\n          // find out if a new dependency has to be created because the property path used in the binding just became\n          // eligible (a previously invalid reference has become valid because a new entity/path got added).\n\n          const newlyValidReferencesMap: DependencyMap = {};\n          Object.keys(invalidReferencesMap).forEach((path) => {\n            invalidReferencesMap[path].forEach((invalidReference) => {\n              if (isChildPropertyPath(fullPropertyPath, invalidReference)) {\n                updateMap(newlyValidReferencesMap, invalidReference, [path]);\n                if (!dependencyMap[invalidReference]) {\n                  extraPathsToLint.add(path);\n                }\n              }\n            });\n          });\n\n          // We have found some bindings which are related to the new property path and hence should be added to the\n          // global dependency map\n          if (!isEmpty(newlyValidReferencesMap)) {\n            didUpdateDependencyMap = true;\n            Object.keys(newlyValidReferencesMap).forEach(\n              (newlyValidReference) => {\n                const { validReferences } = extractInfoFromReferences(\n                  [newlyValidReference],\n                  allKeys,\n                );\n                newlyValidReferencesMap[newlyValidReference].forEach(\n                  (fullPath) => {\n                    const {\n                      entityName,\n                      propertyPath,\n                    } = getEntityNameAndPropertyPath(fullPath);\n                    const entity = unEvalDataTree[entityName];\n                    if (validReferences.length) {\n                      // For trigger paths, update the triggerfield dependency map\n                      // For other paths, update the dependency map\n                      updateMap(\n                        isADynamicTriggerPath(entity, propertyPath)\n                          ? triggerFieldDependencyMap\n                          : dependencyMap,\n                        fullPath,\n                        validReferences,\n                      );\n\n                      // Since the previously invalid reference has become valid,\n                      // remove it from the invalidReferencesMap\n                      if (invalidReferencesMap[fullPath]) {\n                        const newInvalidReferences = invalidReferencesMap[\n                          fullPath\n                        ].filter(\n                          (invalidReference) =>\n                            invalidReference !== newlyValidReference,\n                        );\n                        updateMap(\n                          invalidReferencesMap,\n                          fullPath,\n                          newInvalidReferences,\n                          { replaceValue: true, deleteOnEmpty: true },\n                        );\n                      }\n                    }\n                  },\n                );\n              },\n            );\n          }\n\n          // Add trigger paths that depend on the added path/entity to \"extrapathstolint\"\n          Object.keys(triggerFieldDependencyMap).forEach((triggerPath) => {\n            triggerFieldDependencyMap[triggerPath].forEach(\n              (triggerPathDependency) => {\n                if (\n                  isChildPropertyPath(fullPropertyPath, triggerPathDependency)\n                ) {\n                  extraPathsToLint.add(triggerPath);\n                }\n              },\n            );\n          });\n          break;\n        }\n        case DataTreeDiffEvent.DELETE: {\n          // Add to removedPaths as they have been deleted from the evalTree\n          removedPaths.push(fullPropertyPath);\n          // If an existing entity was deleted, remove all the bindings from the global dependency map\n\n          /**There are certain cases where the child paths of the entity could have errors and\n           *  need them to be cleared post evaluations. Therefore we store all the paths that are\n           * removed on deleting the entity and use that reference to clear the error logs post evaluation*/\n          if (isWidget(entity)) {\n            const propertyPaths = [fullPropertyPath];\n\n            if (dependencyMap[fullPropertyPath]) {\n              propertyPaths.push(...dependencyMap[fullPropertyPath]);\n            }\n\n            pathsToClearErrorsFor.push({\n              widgetId: entity?.widgetId,\n              paths: propertyPaths,\n            });\n          }\n\n          if (\n            (isWidget(entity) || isAction(entity) || isJSAction(entity)) &&\n            fullPropertyPath === entityName\n          ) {\n            const entityDependencies = listEntityDependencies(\n              entity,\n              entityName,\n              allKeys,\n            );\n            Object.keys(entityDependencies).forEach((widgetDep) => {\n              didUpdateDependencyMap = true;\n              delete dependencyMap[widgetDep];\n              delete invalidReferencesMap[widgetDep];\n            });\n\n            if (isWidget(entity)) {\n              const triggerFieldDependencies = listTriggerFieldDependencies(\n                entity,\n                entityName,\n              );\n              Object.keys(triggerFieldDependencies).forEach((triggerDep) => {\n                delete triggerFieldDependencyMap[triggerDep];\n                delete invalidReferencesMap[triggerDep];\n              });\n\n              // remove validation dependencies\n              const validationDependencies = listValidationDependencies(\n                entity,\n                entityName,\n              );\n              Object.keys(validationDependencies).forEach((validationDep) => {\n                delete dataTreeEvalRef.validationDependencyMap[validationDep];\n              });\n              didUpdateValidationDependencyMap = true;\n            }\n          }\n          // Either an existing entity or an existing property path has been deleted. Update the global dependency map\n          // by removing the bindings from the same.\n          Object.keys(dependencyMap).forEach((dependencyPath) => {\n            didUpdateDependencyMap = true;\n            if (isChildPropertyPath(fullPropertyPath, dependencyPath)) {\n              delete dependencyMap[dependencyPath];\n              delete invalidReferencesMap[dependencyPath];\n            } else {\n              const toRemove: Array<string> = [];\n              dependencyMap[dependencyPath].forEach((dependantPath) => {\n                if (isChildPropertyPath(fullPropertyPath, dependantPath)) {\n                  dependenciesOfRemovedPaths.push(dependencyPath);\n                  toRemove.push(dependantPath);\n                }\n              });\n              dependencyMap[dependencyPath] = difference(\n                dependencyMap[dependencyPath],\n                toRemove,\n              );\n              // If we find any invalid reference (untracked in the dependency map) for this path,\n              // which is a child of the deleted path, add it to the of paths to lint.\n              // Example scenario => For {{Api1.unknown}} in button.text, if Api1 is deleted, we need to lint button.text\n              // Although, \"Api1.unknown\" is not a valid reference\n\n              if (invalidReferencesMap[dependencyPath]) {\n                invalidReferencesMap[dependencyPath].forEach(\n                  (invalidReference) => {\n                    if (\n                      isChildPropertyPath(fullPropertyPath, invalidReference)\n                    ) {\n                      extraPathsToLint.add(dependencyPath);\n                    }\n                  },\n                );\n              }\n\n              // Since we are removing previously valid references,\n              // We also update the invalidReferenceMap for this path\n              if (toRemove.length) {\n                updateMap(invalidReferencesMap, dependencyPath, toRemove);\n              }\n            }\n          });\n          Object.keys(triggerFieldDependencyMap).forEach((dependencyPath) => {\n            if (isChildPropertyPath(fullPropertyPath, dependencyPath)) {\n              delete triggerFieldDependencyMap[dependencyPath];\n              delete invalidReferencesMap[dependencyPath];\n            } else {\n              const toRemove: Array<string> = [];\n              triggerFieldDependencyMap[dependencyPath].forEach(\n                (dependantPath) => {\n                  if (isChildPropertyPath(fullPropertyPath, dependantPath)) {\n                    toRemove.push(dependantPath);\n                  }\n                },\n              );\n              triggerFieldDependencyMap[dependencyPath] = difference(\n                triggerFieldDependencyMap[dependencyPath],\n                toRemove,\n              );\n              if (toRemove.length) {\n                updateMap(invalidReferencesMap, dependencyPath, toRemove);\n              }\n              if (invalidReferencesMap[dependencyPath]) {\n                invalidReferencesMap[dependencyPath].forEach(\n                  (invalidReference) => {\n                    if (\n                      isChildPropertyPath(fullPropertyPath, invalidReference)\n                    ) {\n                      extraPathsToLint.add(dependencyPath);\n                    }\n                  },\n                );\n              }\n            }\n          });\n\n          break;\n        }\n        case DataTreeDiffEvent.EDIT: {\n          // We only care if the difference is in dynamic bindings since static values do not need\n          // an evaluation.\n          if (\n            (isWidget(entity) || isAction(entity) || isJSAction(entity)) &&\n            typeof value === \"string\"\n          ) {\n            const entity:\n              | DataTreeAction\n              | DataTreeWidget\n              | DataTreeJSAction = unEvalDataTree[entityName] as\n              | DataTreeAction\n              | DataTreeWidget\n              | DataTreeJSAction;\n            const entityPropertyPath = getPropertyPath(fullPropertyPath);\n            const isADynamicBindingPath = isPathADynamicBinding(\n              entity,\n              entityPropertyPath,\n            );\n            if (isADynamicBindingPath) {\n              didUpdateDependencyMap = true;\n\n              const { jsSnippets } = getDynamicBindings(value, entity);\n              const correctSnippets = jsSnippets.filter(\n                (jsSnippet) => !!jsSnippet,\n              );\n              const {\n                errors: extractDependencyErrors,\n                invalidReferences,\n                validReferences,\n              } = extractInfoFromBindings(correctSnippets, allKeys);\n              updateMap(\n                invalidReferencesMap,\n                fullPropertyPath,\n                invalidReferences,\n                { replaceValue: true, deleteOnEmpty: true },\n              );\n\n              dataTreeEvalErrors = dataTreeEvalErrors.concat(\n                extractDependencyErrors,\n              );\n\n              // We found a new dynamic binding for this property path. We update the dependency map by overwriting the\n              // dependencies for this property path with the newly found dependencies\n\n              if (correctSnippets.length) {\n                dependencyMap[fullPropertyPath] = validReferences;\n              } else {\n                // The dependency on this property path has been removed. Delete this property path from the global\n                // dependency map\n                delete dependencyMap[fullPropertyPath];\n              }\n              if (isAction(entity) || isJSAction(entity)) {\n                // Actions have a defined dependency map that should always be maintained\n                if (entityPropertyPath in entity.dependencyMap) {\n                  const entityDependenciesName = entity.dependencyMap[\n                    entityPropertyPath\n                  ].map((dep) => `${entityName}.${dep}`);\n\n                  const {\n                    errors,\n                    invalidReferences,\n                    validReferences,\n                  } = extractInfoFromBindings(entityDependenciesName, allKeys);\n                  updateMap(\n                    invalidReferencesMap,\n                    fullPropertyPath,\n                    invalidReferences,\n                    { replaceValue: true, deleteOnEmpty: true },\n                  );\n\n                  errors.forEach((error) => {\n                    dataTreeEvalRef.errors.push(error);\n                  });\n\n                  // Now assign these existing dependent paths to the property path in dependencyMap\n                  if (fullPropertyPath in dependencyMap) {\n                    dependencyMap[fullPropertyPath] = dependencyMap[\n                      fullPropertyPath\n                    ].concat(validReferences);\n                  } else {\n                    dependencyMap[fullPropertyPath] = validReferences;\n                  }\n                }\n              }\n            }\n            // If the whole binding was removed, then the value at this path would be a string without any bindings.\n            // In this case, if the path exists in the dependency map and is a bindingPath, then remove it.\n            else if (\n              entity.bindingPaths[entityPropertyPath] &&\n              fullPropertyPath in dependencyMap\n            ) {\n              didUpdateDependencyMap = true;\n              delete dependencyMap[fullPropertyPath];\n              delete invalidReferencesMap[fullPropertyPath];\n            }\n          }\n          if (\n            isWidget(entity) &&\n            isPathDynamicTrigger(entity, getPropertyPath(fullPropertyPath))\n          ) {\n            const { jsSnippets } = getDynamicBindings(\n              dataTreeDiff.payload.value || \"\",\n              entity,\n            );\n            const entityDependencies = jsSnippets.filter(\n              (jsSnippet) => !!jsSnippet,\n            );\n\n            const {\n              errors: extractDependencyErrors,\n              invalidReferences,\n              validReferences,\n            } = extractInfoFromBindings(entityDependencies, allKeys);\n\n            dataTreeEvalErrors = dataTreeEvalErrors.concat(\n              extractDependencyErrors,\n            );\n            updateMap(\n              invalidReferencesMap,\n              fullPropertyPath,\n              invalidReferences,\n              {\n                replaceValue: true,\n                deleteOnEmpty: true,\n              },\n            );\n            updateMap(\n              triggerFieldDependencyMap,\n              fullPropertyPath,\n              validReferences,\n              { replaceValue: true },\n            );\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n    }\n  });\n\n  const diffCalcEnd = performance.now();\n  const subDepCalcStart = performance.now();\n  if (didUpdateDependencyMap) {\n    dataTreeEvalRef.dependencyMap = makeParentsDependOnChildren(\n      dataTreeEvalRef.dependencyMap,\n      allKeys,\n    );\n  }\n  const subDepCalcEnd = performance.now();\n  const updateChangedDependenciesStart = performance.now();\n  // If the global dependency map has changed, re-calculate the sort order for all entities and the\n  // global inverse dependency map\n  if (didUpdateDependencyMap) {\n    // This is being called purely to test for new circular dependencies that might have been added\n    dataTreeEvalRef.sortedDependencies = dataTreeEvalRef.sortDependencies(\n      dataTreeEvalRef.dependencyMap,\n      translatedDiffs,\n    );\n    dataTreeEvalRef.inverseDependencyMap = dataTreeEvalRef.getInverseDependencyTree();\n  }\n\n  if (didUpdateValidationDependencyMap) {\n    // This is being called purely to test for new circular dependencies that might have been added\n    dataTreeEvalRef.sortedValidationDependencies = dataTreeEvalRef.sortDependencies(\n      dataTreeEvalRef.validationDependencyMap,\n      translatedDiffs,\n    );\n\n    dataTreeEvalRef.inverseValidationDependencyMap = dataTreeEvalRef.getInverseDependencyTree(\n      {\n        dependencyMap: dataTreeEvalRef.validationDependencyMap,\n        sortedDependencies: dataTreeEvalRef.sortedValidationDependencies,\n      },\n    );\n  }\n\n  /** We need this in order clear out the paths that could have errors when a property is deleted */\n  if (pathsToClearErrorsFor.length) {\n    pathsToClearErrorsFor.forEach((error) => {\n      error.paths.forEach((path: string) => {\n        set(dataTreeEvalRef.evalProps, getEvalErrorPath(path), []);\n      });\n    });\n  }\n\n  const updateChangedDependenciesStop = performance.now();\n  dataTreeEvalRef.logs.push({\n    diffCalcDeps: (diffCalcEnd - diffCalcStart).toFixed(2),\n    subDepCalc: (subDepCalcEnd - subDepCalcStart).toFixed(2),\n    updateChangedDependencies: (\n      updateChangedDependenciesStop - updateChangedDependenciesStart\n    ).toFixed(2),\n  });\n\n  return {\n    pathsToClearErrorsFor,\n    dependenciesOfRemovedPaths,\n    removedPaths,\n    extraPathsToLint: Array.from(extraPathsToLint),\n  };\n};\n","import { addDataTreeToContext } from \"@appsmith/workers/Evaluation/Actions\";\nimport { EvalContext, assignJSFunctionsToContext } from \"./evaluate\";\nimport { DataTree } from \"entities/DataTree/dataTreeFactory\";\nimport userLogs from \"./fns/overrides/console\";\n\nclass FunctionDeterminer {\n  private evalContext: EvalContext = {};\n\n  setupEval(dataTree: DataTree, resolvedFunctions: Record<string, any>) {\n    /**** Setting the eval context ****/\n    const evalContext: EvalContext = {\n      $isDataField: true,\n      $isAsync: false,\n    };\n\n    addDataTreeToContext({\n      dataTree,\n      EVAL_CONTEXT: evalContext,\n      isTriggerBased: true,\n    });\n\n    assignJSFunctionsToContext(evalContext, resolvedFunctions, false);\n\n    // Set it to self so that the eval function can have access to it\n    // as global data. This is what enables access all appsmith\n    // entity properties from the global context\n    Object.assign(self, evalContext);\n\n    this.evalContext = evalContext;\n    userLogs.disable();\n  }\n\n  close() {\n    userLogs.enable();\n    for (const entityName in this.evalContext) {\n      if (this.evalContext.hasOwnProperty(entityName)) {\n        // @ts-expect-error: Types are not available\n        delete self[entityName];\n      }\n    }\n  }\n\n  isFunctionAsync(userFunction: unknown, logs: unknown[] = []) {\n    self[\"$isAsync\"] = false;\n\n    return (function() {\n      try {\n        if (typeof userFunction === \"function\") {\n          if (userFunction.constructor.name === \"AsyncFunction\") {\n            // functions declared with an async keyword\n            self[\"$isAsync\"] = true;\n          } else {\n            const returnValue = userFunction();\n            if (!!returnValue && returnValue instanceof Promise) {\n              self[\"$isAsync\"] = true;\n            }\n          }\n        }\n      } catch (e) {\n        // We do not want to throw errors for internal operations, to users.\n        // logLevel should help us in debugging this.\n        logs.push({ error: \"Error when determining async function\" + e });\n      }\n      const isAsync = !!self[\"$isAsync\"];\n\n      return isAsync;\n    })();\n  }\n}\n\nexport const functionDeterminer = new FunctionDeterminer();\n","import { DataTree } from \"entities/DataTree/dataTreeFactory\";\nimport ReplayEntity from \"entities/Replay\";\nimport ReplayCanvas from \"entities/Replay/ReplayEntity/ReplayCanvas\";\nimport { isEmpty } from \"lodash\";\nimport {\n  DependencyMap,\n  EvalError,\n  EvalErrorTypes,\n} from \"utils/DynamicBindingUtils\";\nimport { JSUpdate } from \"utils/JSPaneUtils\";\nimport DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport { EvalMetaUpdates } from \"@appsmith/workers/common/DataTreeEvaluator/types\";\nimport { initiateLinting } from \"workers/Linting/utils\";\nimport {\n  createUnEvalTreeForEval,\n  makeEntityConfigsAsObjProperties,\n} from \"@appsmith/workers/Evaluation/dataTreeUtils\";\nimport {\n  CrashingError,\n  DataTreeDiff,\n  getSafeToRenderDataTree,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport {\n  EvalTreeRequestData,\n  EvalTreeResponseData,\n  EvalWorkerSyncRequest,\n} from \"../types\";\nimport { clearAllIntervals } from \"../fns/overrides/interval\";\nexport let replayMap: Record<string, ReplayEntity<any>>;\nexport let dataTreeEvaluator: DataTreeEvaluator | undefined;\nexport const CANVAS = \"canvas\";\n\nexport default function(request: EvalWorkerSyncRequest) {\n  const { data } = request;\n  let evalOrder: string[] = [];\n  let lintOrder: string[] = [];\n  let jsUpdates: Record<string, JSUpdate> = {};\n  let unEvalUpdates: DataTreeDiff[] = [];\n  let nonDynamicFieldValidationOrder: string[] = [];\n  let isCreateFirstTree = false;\n  let dataTree: DataTree = {};\n  let errors: EvalError[] = [];\n  let logs: any[] = [];\n  let dependencies: DependencyMap = {};\n  let evalMetaUpdates: EvalMetaUpdates = [];\n  let staleMetaIds: string[] = [];\n  let pathsToClearErrorsFor: any[] = [];\n\n  const {\n    allActionValidationConfig,\n    forceEvaluation,\n    metaWidgets,\n    requiresLinting,\n    shouldReplay,\n    theme,\n    unevalTree: __unevalTree__,\n    widgets,\n    widgetTypeConfigMap,\n  } = data as EvalTreeRequestData;\n\n  const unevalTree = createUnEvalTreeForEval(__unevalTree__);\n\n  try {\n    if (!dataTreeEvaluator) {\n      isCreateFirstTree = true;\n      replayMap = replayMap || {};\n      replayMap[CANVAS] = new ReplayCanvas({ widgets, theme });\n      dataTreeEvaluator = new DataTreeEvaluator(\n        widgetTypeConfigMap,\n        allActionValidationConfig,\n      );\n      const setupFirstTreeResponse = dataTreeEvaluator.setupFirstTree(\n        unevalTree,\n      );\n      evalOrder = setupFirstTreeResponse.evalOrder;\n      lintOrder = setupFirstTreeResponse.lintOrder;\n      jsUpdates = setupFirstTreeResponse.jsUpdates;\n\n      initiateLinting(\n        lintOrder,\n        makeEntityConfigsAsObjProperties(dataTreeEvaluator.oldUnEvalTree, {\n          sanitizeDataTree: false,\n        }),\n        requiresLinting,\n      );\n\n      const dataTreeResponse = dataTreeEvaluator.evalAndValidateFirstTree();\n      dataTree = makeEntityConfigsAsObjProperties(dataTreeResponse.evalTree, {\n        evalProps: dataTreeEvaluator.evalProps,\n      });\n      staleMetaIds = dataTreeResponse.staleMetaIds;\n    } else if (dataTreeEvaluator.hasCyclicalDependency || forceEvaluation) {\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        //allActionValidationConfigs may not be set in dataTreeEvaluatior. Therefore, set it explicitly via setter method\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n      if (shouldReplay) {\n        replayMap[CANVAS]?.update({ widgets, theme });\n      }\n      dataTreeEvaluator = new DataTreeEvaluator(\n        widgetTypeConfigMap,\n        allActionValidationConfig,\n      );\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n      const setupFirstTreeResponse = dataTreeEvaluator.setupFirstTree(\n        unevalTree,\n      );\n      isCreateFirstTree = true;\n      evalOrder = setupFirstTreeResponse.evalOrder;\n      lintOrder = setupFirstTreeResponse.lintOrder;\n      jsUpdates = setupFirstTreeResponse.jsUpdates;\n\n      initiateLinting(\n        lintOrder,\n        makeEntityConfigsAsObjProperties(dataTreeEvaluator.oldUnEvalTree, {\n          sanitizeDataTree: false,\n        }),\n        requiresLinting,\n      );\n\n      const dataTreeResponse = dataTreeEvaluator.evalAndValidateFirstTree();\n      dataTree = makeEntityConfigsAsObjProperties(dataTreeResponse.evalTree, {\n        evalProps: dataTreeEvaluator.evalProps,\n      });\n      staleMetaIds = dataTreeResponse.staleMetaIds;\n    } else {\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n      isCreateFirstTree = false;\n      if (shouldReplay) {\n        replayMap[CANVAS]?.update({ widgets, theme });\n      }\n      const setupUpdateTreeResponse = dataTreeEvaluator.setupUpdateTree(\n        unevalTree,\n      );\n      evalOrder = setupUpdateTreeResponse.evalOrder;\n      lintOrder = setupUpdateTreeResponse.lintOrder;\n      jsUpdates = setupUpdateTreeResponse.jsUpdates;\n      unEvalUpdates = setupUpdateTreeResponse.unEvalUpdates;\n      pathsToClearErrorsFor = setupUpdateTreeResponse.pathsToClearErrorsFor;\n\n      initiateLinting(\n        lintOrder,\n        makeEntityConfigsAsObjProperties(dataTreeEvaluator.oldUnEvalTree, {\n          sanitizeDataTree: false,\n        }),\n        requiresLinting,\n      );\n\n      nonDynamicFieldValidationOrder =\n        setupUpdateTreeResponse.nonDynamicFieldValidationOrder;\n      const updateResponse = dataTreeEvaluator.evalAndValidateSubTree(\n        evalOrder,\n        nonDynamicFieldValidationOrder,\n        unEvalUpdates,\n        Object.keys(metaWidgets),\n      );\n      dataTree = makeEntityConfigsAsObjProperties(dataTreeEvaluator.evalTree, {\n        evalProps: dataTreeEvaluator.evalProps,\n      });\n      evalMetaUpdates = JSON.parse(\n        JSON.stringify(updateResponse.evalMetaUpdates),\n      );\n      staleMetaIds = updateResponse.staleMetaIds;\n    }\n    dataTreeEvaluator = dataTreeEvaluator as DataTreeEvaluator;\n    dependencies = dataTreeEvaluator.inverseDependencyMap;\n    errors = dataTreeEvaluator.errors;\n    dataTreeEvaluator.clearErrors();\n    logs = dataTreeEvaluator.logs;\n    if (shouldReplay) {\n      if (replayMap[CANVAS]?.logs) logs = logs.concat(replayMap[CANVAS]?.logs);\n      replayMap[CANVAS]?.clearLogs();\n    }\n\n    dataTreeEvaluator.clearLogs();\n  } catch (error) {\n    if (dataTreeEvaluator !== undefined) {\n      errors = dataTreeEvaluator.errors;\n      logs = dataTreeEvaluator.logs;\n    }\n    if (!(error instanceof CrashingError)) {\n      errors.push({\n        type: EvalErrorTypes.UNKNOWN_ERROR,\n        message: (error as Error).message,\n      });\n      // eslint-disable-next-line\n      console.error(error);\n    }\n    dataTree = getSafeToRenderDataTree(\n      makeEntityConfigsAsObjProperties(unevalTree, {\n        sanitizeDataTree: false,\n        evalProps: dataTreeEvaluator?.evalProps,\n      }),\n      widgetTypeConfigMap,\n    );\n    unEvalUpdates = [];\n  }\n\n  const evalTreeResponse: EvalTreeResponseData = {\n    dataTree,\n    dependencies,\n    errors,\n    evalMetaUpdates,\n    evaluationOrder: evalOrder,\n    jsUpdates,\n    logs,\n    unEvalUpdates,\n    isCreateFirstTree,\n    staleMetaIds,\n    pathsToClearErrorsFor,\n  };\n\n  return evalTreeResponse;\n}\n\nexport function clearCache() {\n  dataTreeEvaluator = undefined;\n  clearAllIntervals();\n  return true;\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport {\n  ValidationTypes,\n  ValidationResponse,\n  Validator,\n} from \"constants/WidgetValidation\";\nimport _, {\n  compact,\n  get,\n  isArray,\n  isObject,\n  isPlainObject,\n  isRegExp,\n  isString,\n  toString,\n  uniq,\n  __,\n} from \"lodash\";\n\nimport moment from \"moment\";\nimport { ValidationConfig } from \"constants/PropertyControlConstants\";\nimport evaluate from \"./evaluate\";\n\nimport getIsSafeURL from \"utils/validation/getIsSafeURL\";\nimport * as log from \"loglevel\";\nimport { countOccurrences, findDuplicateIndex } from \"./helpers\";\n\nexport const UNDEFINED_VALIDATION = \"UNDEFINED_VALIDATION\";\nexport const VALIDATION_ERROR_COUNT_THRESHOLD = 10;\nconst MAX_ALLOWED_LINE_BREAKS = 1000; // Rendering performance deteriorates beyond this number.\nconst LINE_BREAKS_ERROR_MESSAGE = `Warning: New lines in the text exceed ${MAX_ALLOWED_LINE_BREAKS}. The text displayed will not contain any new lines.`;\n\nconst flat = (array: Record<string, any>[], uniqueParam: string) => {\n  let result: { value: string }[] = [];\n  array.forEach((a) => {\n    result.push({ value: a[uniqueParam] });\n    if (Array.isArray(a.children)) {\n      result = result.concat(flat(a.children, uniqueParam));\n    }\n  });\n  return result;\n};\n\nfunction getPropertyEntry(\n  obj: Record<string, unknown>,\n  name: string,\n  ignoreCase = false,\n) {\n  if (!ignoreCase) {\n    return name;\n  } else {\n    const keys = Object.getOwnPropertyNames(obj);\n    return keys.find((key) => key.toLowerCase() === name.toLowerCase()) || name;\n  }\n}\n\nfunction validatePlainObject(\n  config: ValidationConfig,\n  value: Record<string, unknown>,\n  props: Record<string, unknown>,\n  propertyPath: string,\n) {\n  if (config.params?.allowedKeys) {\n    let _valid = true;\n    const _messages: Error[] = [];\n    config.params.allowedKeys.forEach((entry) => {\n      const ignoreCase = !!entry.params?.ignoreCase;\n      const entryName = getPropertyEntry(value, entry.name, ignoreCase);\n\n      if (value.hasOwnProperty(entryName)) {\n        const { isValid, messages, parsed } = validate(\n          entry,\n          value[entryName],\n          props,\n          propertyPath,\n        );\n        if (!isValid) {\n          value[entryName] = parsed;\n          _valid = isValid;\n          messages &&\n            messages.map((message) => {\n              _messages.push({\n                name: message.name,\n                message: `Value of key: ${entryName} is invalid: ${message.message}`,\n              });\n            });\n        }\n      } else if (entry.params?.required || entry.params?.requiredKey) {\n        _valid = false;\n        _messages.push({\n          name: \"ValidationError\",\n          message: `Missing required key: ${entryName}`,\n        });\n      }\n    });\n    if (_valid) {\n      return {\n        isValid: true,\n        parsed: value,\n      };\n    }\n    return {\n      isValid: false,\n      parsed: config.params?.default || value,\n      messages: _messages,\n    };\n  }\n  return {\n    isValid: true,\n    parsed: value,\n  };\n}\n\nfunction validateArray(\n  config: ValidationConfig,\n  value: unknown[],\n  props: Record<string, unknown>,\n  propertyPath: string,\n) {\n  let _isValid = true; // Let's first assume that this is valid\n  const _messages: Error[] = []; // Initialise messages array\n\n  // Values allowed in the array, converted into a set of unique values\n  // or an empty set\n  const allowedValues = new Set(config.params?.allowedValues || []);\n\n  // Keys whose values are supposed to be unique across all values in all objects in the array\n  let uniqueKeys: Array<string> = [];\n  const allowedKeyConfigs = config.params?.children?.params?.allowedKeys;\n  if (\n    config.params?.children?.type === ValidationTypes.OBJECT &&\n    Array.isArray(allowedKeyConfigs) &&\n    allowedKeyConfigs.length\n  ) {\n    uniqueKeys = compact(\n      allowedKeyConfigs.map((allowedKeyConfig) => {\n        // TODO(abhinav): This is concerning, we now have two ways,\n        // in which we can define unique keys in an array of objects\n        // We need to disable one option.\n\n        // If this key is supposed to be unique across all objects in the value array\n        // We include it in the uniqueKeys list\n        if (allowedKeyConfig.params?.unique) return allowedKeyConfig.name;\n      }),\n    );\n  }\n\n  // Concatenate unique keys from config.params?.unique\n  uniqueKeys = Array.isArray(config.params?.unique)\n    ? uniqueKeys.concat(config.params?.unique as Array<string>)\n    : uniqueKeys;\n\n  // Validation configuration for children\n  const childrenValidationConfig = config.params?.children;\n\n  // Should we validate against disallowed values in the value array?\n  const shouldVerifyAllowedValues = !!allowedValues.size; // allowedValues is a set\n\n  // Do we have validation config for array children?\n  const shouldValidateChildren = !!childrenValidationConfig;\n\n  // Should array values be unique? This should applies only to primitive values in array children\n  // If we have to validate children with their own validation config, this should be false (Needs verification)\n  // If this option is true, shouldArrayValuesHaveUniqueValuesForKeys will become false\n  const shouldArrayHaveUniqueEntries = config.params?.unique === true;\n\n  // Should we validate for unique values for properties in the array entries?\n  const shouldArrayValuesHaveUniqueValuesForKeys =\n    !!uniqueKeys.length && !shouldArrayHaveUniqueEntries;\n\n  // Verify if all values are unique\n  if (shouldArrayHaveUniqueEntries) {\n    // Find the index of a duplicate value in array\n    const duplicateIndex = findDuplicateIndex(value);\n    if (duplicateIndex !== -1) {\n      // Bail out early\n      // Because, we don't want to re-iterate, if this validation fails\n      return {\n        isValid: false,\n        parsed: config.params?.default || [],\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: `Array must be unique. Duplicate values found at index: ${duplicateIndex}`,\n          },\n        ],\n      };\n    }\n  }\n\n  if (shouldArrayValuesHaveUniqueValuesForKeys) {\n    // Loop\n    // Get only unique entries from the value array\n    const uniqueEntries = _.uniqWith(\n      value as Array<Record<string, unknown>>,\n      (a: Record<string, unknown>, b: Record<string, unknown>) => {\n        // If any of the keys are the same, we fail the uniqueness test\n        return uniqueKeys.some((key) => a[key] === b[key]);\n      },\n    );\n\n    if (uniqueEntries.length !== value.length) {\n      // Bail out early\n      // Because, we don't want to re-iterate, if this validation fails\n      return {\n        isValid: false,\n        parsed: config.params?.default || [],\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: `Duplicate values found for the following properties, in the array entries, that must be unique -- ${uniqueKeys.join(\n              \",\",\n            )}.`,\n          },\n        ],\n      };\n    }\n  }\n\n  // Loop\n  value.every((entry, index) => {\n    // Validate for allowed values\n    if (shouldVerifyAllowedValues && !allowedValues.has(entry)) {\n      _messages.push({\n        name: \"ValidationError\",\n        message: `Value is not allowed in this array: ${entry}`,\n      });\n      _isValid = false;\n    }\n\n    // validate using validation config\n    if (shouldValidateChildren && childrenValidationConfig) {\n      // Validate this entry\n      const childValidationResult = validate(\n        childrenValidationConfig,\n        entry,\n        props,\n        `${propertyPath}[${index}]`,\n      );\n\n      // If invalid, append to messages\n      if (!childValidationResult.isValid) {\n        _isValid = false;\n        childValidationResult.messages?.forEach((message) =>\n          _messages.push({\n            name: message.name,\n            message: `Invalid entry at index: ${index}. ${message.message}`,\n          }),\n        );\n      }\n    }\n\n    // Bail out, if the error count threshold has been overcome\n    // This way, debugger will not have to render too many errors\n    if (_messages.length >= VALIDATION_ERROR_COUNT_THRESHOLD && !_isValid) {\n      return false;\n    }\n    return true;\n  });\n\n  return {\n    isValid: _isValid,\n    parsed: _isValid ? value : config.params?.default || [],\n    messages: _messages,\n  };\n}\n\nfunction validateExcessLineBreaks(value: any): boolean {\n  /**\n   * Check if the value exceeds a threshold number of line breaks;\n   * beyond which the rendering performance starts deteriorating.\n   */\n  const str: string = isObject(value) ? JSON.stringify(value, null, 2) : value;\n  const lineBreakCount: number = countOccurrences(\n    str,\n    \"\\n\",\n    false,\n    MAX_ALLOWED_LINE_BREAKS,\n  );\n  return lineBreakCount > MAX_ALLOWED_LINE_BREAKS;\n}\n\nfunction validateExcessLength(text: string, maxLength: number): boolean {\n  /**\n   * Check if text is too long and without any line breaks.\n   */\n  const lineBreakCount = countOccurrences(text, \"\\n\", false, 0);\n  return lineBreakCount === 0 && text.length > maxLength;\n}\n\n/**\n * Iterate through an object,\n * Check for length of string values\n * and trim them in case they are too long.\n */\nfunction validateObjectValues(obj: any): any {\n  if (!obj) return;\n  Object.keys(obj).forEach((key) => {\n    if (typeof obj[key] === \"string\" && obj[key].length > 100000) {\n      obj[key] = obj[key].substring(0, 100000);\n    } else if (isObject(obj[key])) {\n      obj[key] = validateObjectValues(obj[key]);\n    } else if (isArray(obj[key])) {\n      obj[key] = obj[key].map((item: any) => validateObjectValues(item));\n    }\n  });\n  return obj;\n}\n\n//TODO: parameter props may not be in use\nexport const validate = (\n  config: ValidationConfig,\n  value: unknown,\n  props: Record<string, unknown>,\n  propertyPath = \"\",\n): ValidationResponse => {\n  const validateFn = VALIDATORS[config.type];\n  const staticValue = {\n    isValid: true,\n    parsed: value,\n  };\n  if (!validateFn) return staticValue;\n\n  return validateFn(config, value, props, propertyPath) || staticValue;\n};\n\nexport const WIDGET_TYPE_VALIDATION_ERROR =\n  \"This value does not evaluate to type\"; // TODO: Lot's of changes in validations.ts file\n\nexport function getExpectedType(config?: ValidationConfig): string | undefined {\n  if (!config) return UNDEFINED_VALIDATION; // basic fallback\n  switch (config.type) {\n    case ValidationTypes.FUNCTION:\n      return config.params?.expected?.type || \"unknown\";\n    case ValidationTypes.TEXT:\n      let result = \"string\";\n      if (config.params?.allowedValues) {\n        const allowed = config.params.allowedValues.join(\" | \");\n        result = result + ` ( ${allowed} )`;\n      }\n      if (config.params?.regex) {\n        result = config.params?.regex.source;\n      }\n      if (config.params?.expected?.type) result = config.params?.expected.type;\n      return result;\n    case ValidationTypes.REGEX:\n      return \"regExp\";\n    case ValidationTypes.DATE_ISO_STRING:\n      return \"ISO 8601 date string\";\n    case ValidationTypes.BOOLEAN:\n      return \"boolean\";\n    case ValidationTypes.NUMBER:\n      let validationType = \"number\";\n      if (config.params?.min) {\n        validationType = `${validationType} Min: ${config.params?.min}`;\n      }\n      if (config.params?.max) {\n        validationType = `${validationType} Max: ${config.params?.max}`;\n      }\n      if (config.params?.required) {\n        validationType = `${validationType} Required`;\n      }\n\n      return validationType;\n    case ValidationTypes.OBJECT:\n      let objectType = \"Object\";\n      if (config.params?.allowedKeys) {\n        objectType = \"{\";\n        config.params?.allowedKeys.forEach((allowedKeyConfig) => {\n          const _expected = getExpectedType(allowedKeyConfig);\n          objectType = `${objectType} \"${allowedKeyConfig.name}\": \"${_expected}\",`;\n        });\n        objectType = `${objectType.substring(0, objectType.length - 1)} }`;\n        return objectType;\n      }\n      return objectType;\n    case ValidationTypes.ARRAY:\n    case ValidationTypes.NESTED_OBJECT_ARRAY:\n      if (config.params?.allowedValues) {\n        const allowed = config.params?.allowedValues.join(\"' | '\");\n        return `Array<'${allowed}'>`;\n      }\n      if (config.params?.children) {\n        const children = getExpectedType(config.params.children);\n        return `Array<${children}>`;\n      }\n      return \"Array\";\n    case ValidationTypes.OBJECT_ARRAY:\n      return `Array<Object>`;\n    case ValidationTypes.IMAGE_URL:\n      return `base64 encoded image | data uri | image url`;\n    case ValidationTypes.SAFE_URL:\n      return \"URL\";\n  }\n}\n\nexport const VALIDATORS: Record<ValidationTypes, Validator> = {\n  [ValidationTypes.TEXT]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    if (value === undefined || value === null || value === \"\") {\n      if (config.params && config.params.required) {\n        return {\n          isValid: false,\n          parsed: config.params?.default || \"\",\n          messages: [\n            {\n              name: \"TypeError\",\n              message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n                config,\n              )}`,\n            },\n          ],\n        };\n      }\n\n      return {\n        isValid: true,\n        parsed: config.params?.default || \"\",\n      };\n    }\n    let parsed = value;\n\n    if (isObject(value)) {\n      if (\n        config.params &&\n        config.params.limitLineBreaks &&\n        validateExcessLineBreaks(value)\n      ) {\n        return {\n          isValid: false,\n          parsed: JSON.stringify(validateObjectValues(value)), // Parse without line breaks\n          messages: [\n            {\n              name: \"ValidationError\",\n              message: LINE_BREAKS_ERROR_MESSAGE,\n            },\n          ],\n        };\n      }\n      return {\n        isValid: false,\n        parsed: JSON.stringify(validateObjectValues(value), null, 2),\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n\n    const isValid = isString(parsed);\n    const stringValidationError = {\n      isValid: false,\n      parsed: config.params?.default || \"\",\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(config)}`,\n        },\n      ],\n    };\n    if (!isValid) {\n      try {\n        if (!config.params?.strict) parsed = toString(parsed);\n        else return stringValidationError;\n      } catch (e) {\n        return stringValidationError;\n      }\n    }\n    if (\n      config.params &&\n      config.params.limitLineBreaks &&\n      validateExcessLineBreaks(value)\n    ) {\n      return {\n        isValid: false,\n        parsed: JSON.stringify(value), // Parse without line breaks\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: LINE_BREAKS_ERROR_MESSAGE,\n          },\n        ],\n      };\n    }\n    if (config.params?.allowedValues) {\n      if (!config.params?.allowedValues.includes((parsed as string).trim())) {\n        return {\n          parsed: config.params?.default || \"\",\n          messages: [\n            {\n              name: \"ValidationError\",\n              message: `Disallowed value: ${parsed}`,\n            },\n          ],\n          isValid: false,\n        };\n      }\n    }\n\n    if (validateExcessLength(parsed as string, 200000)) {\n      return {\n        parsed: (parsed as string)?.substring(0, 200000),\n        isValid: false,\n        messages: [\n          {\n            name: \"ValidationError\",\n            message:\n              \"Excessive text length without a line break. Rendering a substring to avoid app crash.\",\n          },\n        ],\n      };\n    }\n\n    if (\n      config.params?.regex &&\n      isRegExp(config.params?.regex) &&\n      !config.params?.regex.test(parsed as string)\n    ) {\n      return {\n        parsed: config.params?.default || \"\",\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n        isValid: false,\n      };\n    }\n\n    return {\n      isValid: true,\n      parsed,\n    };\n  },\n  // TODO(abhinav): The original validation does not make sense fix this.\n  [ValidationTypes.REGEX]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    const { isValid, messages, parsed } = VALIDATORS[ValidationTypes.TEXT](\n      config,\n      value,\n      props,\n      propertyPath,\n    );\n\n    if (!isValid) {\n      return {\n        isValid: false,\n        parsed: new RegExp(parsed),\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n\n    return { isValid, parsed, messages };\n  },\n  [ValidationTypes.NUMBER]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    if (value === undefined || value === null || value === \"\") {\n      if (config.params?.required) {\n        return {\n          isValid: false,\n          parsed: config.params?.default || 0,\n          messages: [\n            {\n              name: \"ValidationError\",\n              message: \"This value is required\",\n            },\n          ],\n        };\n      }\n\n      if (value === \"\") {\n        return {\n          isValid: true,\n          parsed: config.params?.default || 0,\n        };\n      }\n\n      return {\n        isValid: true,\n        parsed: value,\n      };\n    }\n    if (!Number.isFinite(value) && !isString(value)) {\n      return {\n        isValid: false,\n        parsed: config.params?.default || 0,\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n\n    // check for min and max limits\n    let parsed: number = value as number;\n    if (isString(value)) {\n      if (/^-?\\d+\\.?\\d*$/.test(value)) {\n        parsed = Number(value);\n      } else {\n        return {\n          isValid: false,\n          parsed: value || config.params?.default || 0,\n          messages: [\n            {\n              name: \"TypeError\",\n              message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n                config,\n              )}`,\n            },\n          ],\n        };\n      }\n    }\n\n    if (\n      config.params?.min !== undefined &&\n      Number.isFinite(config.params.min)\n    ) {\n      if (parsed < Number(config.params.min)) {\n        return {\n          isValid: false,\n          parsed:\n            // passThroughOnZero is introduced to resolve a bug and to not break existing apps\n            // Refer: https://github.com/appsmithorg/appsmith/issues/17472#issuecomment-1281818238\n            config.params.passThroughOnZero === false\n              ? parsed || config.params.min || 0\n              : parsed ?? config.params.min ?? 0,\n          messages: [\n            {\n              name: \"RangeError\",\n              message: `Minimum allowed value: ${config.params.min}`,\n            },\n          ],\n        };\n      }\n    }\n\n    if (\n      config.params?.max !== undefined &&\n      Number.isFinite(config.params.max)\n    ) {\n      if (parsed > Number(config.params.max)) {\n        return {\n          isValid: false,\n          parsed: config.params.max || parsed || 0,\n          messages: [\n            {\n              name: \"RangeError\",\n              message: `Maximum allowed value: ${config.params.max}`,\n            },\n          ],\n        };\n      }\n    }\n    if (config.params?.natural && (parsed < 0 || !Number.isInteger(parsed))) {\n      return {\n        isValid: false,\n        parsed: config.params.default || parsed || 0,\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: `Value should be a positive integer`,\n          },\n        ],\n      };\n    }\n\n    return {\n      isValid: true,\n      parsed,\n    };\n  },\n  [ValidationTypes.BOOLEAN]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    if (value === undefined || value === null || value === \"\") {\n      if (config.params && config.params.required) {\n        return {\n          isValid: false,\n          parsed: !!config.params?.default,\n          messages: [\n            {\n              name: \"TypeError\",\n              message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n                config,\n              )}`,\n            },\n          ],\n        };\n      }\n\n      if (value === \"\") {\n        return {\n          isValid: true,\n          parsed: config.params?.default || false,\n        };\n      }\n\n      return { isValid: true, parsed: config.params?.default || value };\n    }\n    const isABoolean = value === true || value === false;\n    const isStringTrueFalse = value === \"true\" || value === \"false\";\n    const isValid = isABoolean || isStringTrueFalse;\n\n    let parsed = value;\n    if (isStringTrueFalse) parsed = value !== \"false\";\n\n    if (!isValid) {\n      return {\n        isValid: false,\n        parsed: config.params?.default || false,\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n\n    return { isValid, parsed };\n  },\n  [ValidationTypes.OBJECT]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    if (\n      value === undefined ||\n      value === null ||\n      (isString(value) && value.trim().length === 0)\n    ) {\n      if (config.params && config.params.required) {\n        return {\n          isValid: false,\n          parsed: config.params?.default || {},\n          messages: [\n            {\n              name: \"TypeError\",\n              message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n                config,\n              )}`,\n            },\n          ],\n        };\n      }\n      return {\n        isValid: true,\n        parsed: config.params?.default || value,\n      };\n    }\n\n    if (isPlainObject(value)) {\n      return validatePlainObject(\n        config,\n        value as Record<string, unknown>,\n        props,\n        propertyPath,\n      );\n    }\n\n    try {\n      const result = { parsed: JSON.parse(value as string), isValid: true };\n      if (isPlainObject(result.parsed)) {\n        return validatePlainObject(config, result.parsed, props, propertyPath);\n      }\n      return {\n        isValid: false,\n        parsed: config.params?.default || {},\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    } catch (e) {\n      return {\n        isValid: false,\n        parsed: config.params?.default || {},\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n  },\n  [ValidationTypes.ARRAY]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: config.params?.default || [],\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(config)}`,\n        },\n      ],\n    };\n    if (value === undefined || value === null || value === \"\") {\n      if (\n        config.params &&\n        config.params.required &&\n        !isArray(config.params.default)\n      ) {\n        invalidResponse.messages = [\n          {\n            name: \"ValidationError\",\n            message:\n              \"This property is required for the widget to function correctly\",\n          },\n        ];\n        return invalidResponse;\n      }\n      if (value === \"\") {\n        return {\n          isValid: true,\n          parsed: config.params?.default || [],\n        };\n      }\n      if (config.params && isArray(config.params.default)) {\n        return {\n          isValid: true,\n          parsed: config.params?.default,\n        };\n      }\n\n      return {\n        isValid: true,\n        parsed: value,\n      };\n    }\n\n    if (isString(value)) {\n      try {\n        const _value = JSON.parse(value);\n        if (Array.isArray(_value)) {\n          const result = validateArray(config, _value, props, propertyPath);\n          return result;\n        }\n      } catch (e) {\n        return invalidResponse;\n      }\n    }\n\n    if (Array.isArray(value)) {\n      return validateArray(config, value, props, propertyPath);\n    }\n\n    return invalidResponse;\n  },\n  [ValidationTypes.OBJECT_ARRAY]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: config.params?.default || [{}],\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(config)}`,\n        },\n      ],\n    };\n    if (value === undefined || value === null || value === \"\") {\n      if (config.params?.required) return invalidResponse;\n\n      if (value === \"\") {\n        return {\n          isValid: true,\n          parsed: config.params?.default || [{}],\n        };\n      }\n\n      return { isValid: true, parsed: value };\n    }\n    if (!isString(value) && !Array.isArray(value)) {\n      return invalidResponse;\n    }\n\n    let parsed = value;\n\n    if (isString(value)) {\n      try {\n        parsed = JSON.parse(value);\n      } catch (e) {\n        return invalidResponse;\n      }\n    }\n\n    if (Array.isArray(parsed)) {\n      if (parsed.length === 0) {\n        if (config.params?.required) {\n          return invalidResponse;\n        } else {\n          return {\n            isValid: true,\n            parsed: config.params?.default || [{}],\n          };\n        }\n      }\n\n      for (const [index, parsedEntry] of parsed.entries()) {\n        if (!isPlainObject(parsedEntry)) {\n          return {\n            ...invalidResponse,\n            messages: [\n              {\n                name: \"ValidationError\",\n                message: `Invalid object at index ${index}`,\n              },\n            ],\n          };\n        }\n      }\n      return { isValid: true, parsed };\n    }\n    return invalidResponse;\n  },\n\n  [ValidationTypes.NESTED_OBJECT_ARRAY]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    let response: ValidationResponse = {\n      isValid: false,\n      parsed: config.params?.default || [],\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(config)}`,\n        },\n      ],\n    };\n    response = VALIDATORS.ARRAY(config, value, props, propertyPath);\n\n    if (!response.isValid) {\n      return response;\n    }\n    // Check if all values and children values are unique\n    if (config.params?.unique && response.parsed.length) {\n      if (isArray(config.params?.unique)) {\n        for (const param of config.params?.unique) {\n          const flattenedArray = flat(response.parsed, param);\n          const shouldBeUnique = flattenedArray.map((entry) =>\n            get(entry, param, \"\"),\n          );\n          if (uniq(shouldBeUnique).length !== flattenedArray.length) {\n            response = {\n              ...response,\n              isValid: false,\n              messages: [\n                {\n                  name: \"ValidationError\",\n                  message: `path:${param} must be unique. Duplicate values found`,\n                },\n              ],\n            };\n          }\n        }\n      }\n    }\n    return response;\n  },\n  [ValidationTypes.DATE_ISO_STRING]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    let isValid = false;\n    let parsed = value;\n    let message = { name: \"\", message: \"\" };\n\n    if (_.isNil(value) || value === \"\") {\n      parsed = config.params?.default;\n\n      if (config.params?.required) {\n        isValid = false;\n        message = {\n          name: \"TypeError\",\n          message: `Value does not match: ${getExpectedType(config)}`,\n        };\n      } else {\n        isValid = true;\n      }\n    } else if (typeof value === \"object\" && moment(value).isValid()) {\n      //Date and moment object\n      isValid = true;\n      parsed = moment(value).toISOString(true);\n    } else if (isString(value)) {\n      //Date string\n      if (\n        value === moment(value).toISOString() ||\n        value === moment(value).toISOString(true)\n      ) {\n        return {\n          isValid: true,\n          parsed: value,\n        };\n      } else if (moment(value).isValid()) {\n        isValid = true;\n        parsed = moment(value).toISOString(true);\n      } else {\n        isValid = false;\n        message = {\n          name: \"TypeError\",\n          message: `Value does not match: ${getExpectedType(config)}`,\n        };\n        parsed = config.params?.default;\n      }\n    } else {\n      isValid = false;\n      message = {\n        name: \"TypeError\",\n        message: `Value does not match: ${getExpectedType(config)}`,\n      };\n    }\n\n    const result: ValidationResponse = {\n      isValid,\n      parsed,\n    };\n\n    if (message) {\n      result.messages = [message];\n    }\n\n    return result;\n  },\n  [ValidationTypes.FUNCTION]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: undefined,\n      messages: [\n        {\n          name: \"ValidationError\",\n          message: \"Failed to validate\",\n        },\n      ],\n    };\n    if (config.params?.fnString && isString(config.params?.fnString)) {\n      try {\n        const { result } = evaluate(\n          config.params.fnString,\n          {},\n          {},\n          false,\n          undefined,\n          [value, props, _, moment, propertyPath, config],\n        );\n        return result;\n      } catch (e) {\n        log.error(\"Validation function error: \", { e });\n      }\n    }\n    return invalidResponse;\n  },\n  [ValidationTypes.IMAGE_URL]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: config.params?.default || \"\",\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n            config,\n          )}`,\n        },\n      ],\n    };\n    const base64Regex = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\n    const base64ImageRegex = /^data:image\\/.*;base64/;\n    const imageUrlRegex = /(http(s?):)([/|.|\\w|\\s|-])*\\.(?:jpeg|jpg|gif|png)??(?:&?[^=&]*=[^=&]*)*/;\n    if (\n      value === undefined ||\n      value === null ||\n      (isString(value) && value.trim().length === 0)\n    ) {\n      if (config.params && config.params.required) return invalidResponse;\n      return { isValid: true, parsed: value };\n    }\n    if (isString(value)) {\n      if (imageUrlRegex.test(value.trim())) {\n        return { isValid: true, parsed: value.trim() };\n      }\n      if (base64ImageRegex.test(value)) {\n        return {\n          isValid: true,\n          parsed: value,\n        };\n      }\n      if (base64Regex.test(value) && btoa(atob(value)) === value) {\n        return { isValid: true, parsed: `data:image/png;base64,${value}` };\n      }\n    }\n    return invalidResponse;\n  },\n  [ValidationTypes.SAFE_URL]: (\n    config: ValidationConfig,\n    value: unknown,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: config?.params?.default || \"\",\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n            config,\n          )}`,\n        },\n      ],\n    };\n\n    if (typeof value === \"string\" && getIsSafeURL(value)) {\n      return {\n        isValid: true,\n        parsed: value,\n      };\n    } else {\n      return invalidResponse;\n    }\n  },\n\n  /**\n   *\n   * ARRAY_OF_TYPE_OR_TYPE can be used in scenarios where we wanted to validate\n   * using ValidationTypes.ARRAY or ValidationTypes.* at the same time.\n   *\n   * This is needed in case of properties inside\n   * 1. Table widget where we use COMPUTE_VALUE\n   * 2. Menu button widget where we use MENU_BUTTON_DYNAMIC_ITEMS\n   *\n   * For more info: https://github.com/appsmithorg/appsmith/pull/9396\n   */\n  [ValidationTypes.ARRAY_OF_TYPE_OR_TYPE]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    if (!config.params?.type)\n      return {\n        isValid: false,\n        parsed: undefined,\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: \"Invalid validation\",\n          },\n        ],\n      };\n\n    // Validate when JS mode is disabled\n    const result = VALIDATORS[config.params.type as ValidationTypes](\n      config.params as ValidationConfig,\n      value,\n      props,\n      propertyPath,\n    );\n    if (result.isValid) return result;\n\n    // Validate when JS mode is enabled\n    const resultValue = [];\n    if (_.isArray(value)) {\n      for (const item of value) {\n        const result = VALIDATORS[config.params.type](\n          config.params as ValidationConfig,\n          item,\n          props,\n          propertyPath,\n        );\n        if (!result.isValid) return result;\n        resultValue.push(result.parsed);\n      }\n    } else {\n      return {\n        isValid: false,\n        parsed: config.params?.params?.default,\n        messages: result.messages,\n      };\n    }\n\n    return {\n      isValid: true,\n      parsed: resultValue,\n    };\n  },\n};\n","import { DataTree } from \"entities/DataTree/dataTreeFactory\";\nimport { LintErrors } from \"reducers/lintingReducers/lintErrorsReducers\";\nimport { WorkerRequest } from \"@appsmith/workers/common/types\";\n\nexport enum LINT_WORKER_ACTIONS {\n  LINT_TREE = \"LINT_TREE\",\n  UPDATE_LINT_GLOBALS = \"UPDATE_LINT_GLOBALS\",\n}\n\nexport interface LintTreeResponse {\n  errors: LintErrors;\n}\n\nexport interface LintTreeRequest {\n  pathsToLint: string[];\n  unevalTree: DataTree;\n  cloudHosting: boolean;\n}\n\nexport type LintWorkerRequest = WorkerRequest<\n  LintTreeRequest,\n  LINT_WORKER_ACTIONS\n>;\n\nexport type LintTreeSagaRequestData = {\n  pathsToLint: string[];\n  unevalTree: DataTree;\n};\n","import { isEqual } from \"lodash\";\nimport { WorkerErrorTypes } from \"@appsmith/workers/common/types\";\nimport { JSLibraries, resetJSLibraries } from \"workers/common/JSLibrary\";\nimport {\n  LintWorkerRequest,\n  LintTreeResponse,\n  LINT_WORKER_ACTIONS,\n  LintTreeRequest,\n} from \"./types\";\nimport { getlintErrorsFromTree } from \"./utils\";\nimport { TMessage, MessageType, sendMessage } from \"utils/MessageUtil\";\n\nfunction messageEventListener(fn: typeof eventRequestHandler) {\n  return (event: MessageEvent<TMessage<LintWorkerRequest>>) => {\n    const { messageType } = event.data;\n    if (messageType !== MessageType.REQUEST) return;\n    const { body, messageId } = event.data;\n    const { data, method } = body;\n    if (!method) return;\n\n    const startTime = performance.now();\n    const responseData = fn({ method, requestData: data });\n    const endTime = performance.now();\n    if (!responseData) return;\n\n    try {\n      sendMessage.call(self, {\n        messageId,\n        messageType: MessageType.RESPONSE,\n        body: {\n          data: responseData,\n          timeTaken: (endTime - startTime).toFixed(2),\n        },\n      });\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.error(e);\n      sendMessage.call(self, {\n        messageId,\n        messageType: MessageType.RESPONSE,\n        body: {\n          data: {\n            errors: [\n              {\n                type: WorkerErrorTypes.CLONE_ERROR,\n                message: (e as Error)?.message,\n              },\n            ],\n          },\n          timeTaken: (endTime - startTime).toFixed(2),\n        },\n      });\n    }\n  };\n}\n\nfunction eventRequestHandler({\n  method,\n  requestData,\n}: {\n  method: LINT_WORKER_ACTIONS;\n  requestData: any;\n}): LintTreeResponse | unknown {\n  switch (method) {\n    case LINT_WORKER_ACTIONS.LINT_TREE: {\n      const lintTreeResponse: LintTreeResponse = { errors: {} };\n      try {\n        const {\n          cloudHosting,\n          pathsToLint,\n          unevalTree,\n        } = requestData as LintTreeRequest;\n        const lintErrors = getlintErrorsFromTree(\n          pathsToLint,\n          unevalTree,\n          cloudHosting,\n        );\n        lintTreeResponse.errors = lintErrors;\n      } catch (e) {}\n      return lintTreeResponse;\n    }\n    case LINT_WORKER_ACTIONS.UPDATE_LINT_GLOBALS: {\n      const { add, libs } = requestData;\n      if (add) {\n        JSLibraries.push(...libs);\n      } else if (add === false) {\n        for (const lib of libs) {\n          const idx = JSLibraries.findIndex((l) =>\n            isEqual(l.accessor.sort(), lib.accessor.sort()),\n          );\n          if (idx === -1) return;\n          JSLibraries.splice(idx, 1);\n        }\n      } else {\n        resetJSLibraries();\n        JSLibraries.push(...libs);\n      }\n      return true;\n    }\n    default: {\n      // eslint-disable-next-line no-console\n      console.error(\"Action not registered on lintWorker \", method);\n    }\n  }\n}\n\nself.onmessage = messageEventListener(eventRequestHandler);\n","import { DataTree, DataTreeEntity } from \"entities/DataTree/dataTreeFactory\";\n\nimport { Position } from \"codemirror\";\nimport {\n  isDynamicValue,\n  isPathADynamicBinding,\n  LintError,\n  PropertyEvaluationErrorType,\n} from \"utils/DynamicBindingUtils\";\nimport { MAIN_THREAD_ACTION } from \"@appsmith/workers/Evaluation/evalWorkerActions\";\nimport {\n  JSHINT as jshint,\n  LintError as JSHintError,\n  LintOptions,\n} from \"jshint\";\nimport { get, isEmpty, isNumber, keys, last, set } from \"lodash\";\nimport {\n  getLintErrorMessage,\n  getLintSeverity,\n} from \"components/editorComponents/CodeEditor/lintHelpers\";\nimport {\n  CustomLintErrorCode,\n  CUSTOM_LINT_ERRORS,\n  IGNORED_LINT_ERRORS,\n  INVALID_JSOBJECT_START_STATEMENT,\n  JS_OBJECT_START_STATEMENT,\n  SUPPORTED_WEB_APIS,\n} from \"components/editorComponents/CodeEditor/constants\";\nimport {\n  extractInvalidTopLevelMemberExpressionsFromCode,\n  isLiteralNode,\n  ECMA_VERSION,\n  MemberExpressionData,\n} from \"@shared/ast\";\nimport { getDynamicBindings } from \"utils/DynamicBindingUtils\";\n\nimport {\n  createEvaluationContext,\n  EvaluationScripts,\n  EvaluationScriptType,\n  getScriptToEval,\n  getScriptType,\n  ScriptTemplate,\n} from \"workers/Evaluation/evaluate\";\nimport {\n  getEntityNameAndPropertyPath,\n  isAction,\n  isATriggerPath,\n  isJSAction,\n  isWidget,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport { LintErrors } from \"reducers/lintingReducers/lintErrorsReducers\";\nimport { Severity } from \"entities/AppsmithConsole\";\nimport { JSLibraries } from \"workers/common/JSLibrary\";\nimport { getActionTriggerFunctionNames } from \"@appsmith/workers/Evaluation/fns/index\";\nimport { WorkerMessenger } from \"workers/Evaluation/fns/utils/Messenger\";\n\nexport function getlintErrorsFromTree(\n  pathsToLint: string[],\n  unEvalTree: DataTree,\n  cloudHosting: boolean,\n): LintErrors {\n  const lintTreeErrors: LintErrors = {};\n\n  const evalContext = createEvaluationContext({\n    dataTree: unEvalTree,\n    resolvedFunctions: {},\n    isTriggerBased: false,\n    skipEntityFunctions: true,\n  });\n\n  const platformFnNamesMap = Object.values(\n    getActionTriggerFunctionNames(cloudHosting),\n  ).reduce(\n    (acc, name) => ({ ...acc, [name]: true }),\n    {} as { [x: string]: boolean },\n  );\n  Object.assign(evalContext, platformFnNamesMap);\n\n  const evalContextWithOutFunctions = createEvaluationContext({\n    dataTree: unEvalTree,\n    resolvedFunctions: {},\n    isTriggerBased: true,\n    skipEntityFunctions: true,\n  });\n\n  // trigger paths\n  const triggerPaths = new Set<string>();\n  // Certain paths, like JS Object's body are binding paths where appsmith functions are needed in the global data\n  const bindingPathsRequiringFunctions = new Set<string>();\n\n  pathsToLint.forEach((fullPropertyPath) => {\n    const { entityName, propertyPath } = getEntityNameAndPropertyPath(\n      fullPropertyPath,\n    );\n    const entity = unEvalTree[entityName];\n    const unEvalPropertyValue = (get(\n      unEvalTree,\n      fullPropertyPath,\n    ) as unknown) as string;\n    // remove all lint errors from path\n    set(lintTreeErrors, `[\"${fullPropertyPath}\"]`, []);\n\n    // We are only interested in paths that require linting\n    if (!pathRequiresLinting(unEvalTree, entity, fullPropertyPath)) return;\n    if (isATriggerPath(entity, propertyPath))\n      return triggerPaths.add(fullPropertyPath);\n    if (isJSAction(entity))\n      return bindingPathsRequiringFunctions.add(`${entityName}.body`);\n    const lintErrors = lintBindingPath(\n      unEvalPropertyValue,\n      entity,\n      fullPropertyPath,\n      evalContextWithOutFunctions,\n    );\n    set(lintTreeErrors, `[\"${fullPropertyPath}\"]`, lintErrors);\n  });\n\n  if (triggerPaths.size || bindingPathsRequiringFunctions.size) {\n    // we only create GLOBAL_DATA_WITH_FUNCTIONS if there are paths requiring it\n    // In trigger based fields, functions such as showAlert, storeValue, etc need to be added to the global data\n\n    // lint binding paths that need GLOBAL_DATA_WITH_FUNCTIONS\n    if (bindingPathsRequiringFunctions.size) {\n      bindingPathsRequiringFunctions.forEach((fullPropertyPath) => {\n        const { entityName } = getEntityNameAndPropertyPath(fullPropertyPath);\n        const entity = unEvalTree[entityName];\n        const unEvalPropertyValue = (get(\n          unEvalTree,\n          fullPropertyPath,\n        ) as unknown) as string;\n        // remove all lint errors from path\n        set(lintTreeErrors, `[\"${fullPropertyPath}\"]`, []);\n        const lintErrors = lintBindingPath(\n          unEvalPropertyValue,\n          entity,\n          fullPropertyPath,\n          evalContext,\n        );\n        set(lintTreeErrors, `[\"${fullPropertyPath}\"]`, lintErrors);\n      });\n    }\n\n    // Lint triggerPaths\n    if (triggerPaths.size) {\n      triggerPaths.forEach((triggerPath) => {\n        const { entityName } = getEntityNameAndPropertyPath(triggerPath);\n        const entity = unEvalTree[entityName];\n        const unEvalPropertyValue = (get(\n          unEvalTree,\n          triggerPath,\n        ) as unknown) as string;\n        // remove all lint errors from path\n        set(lintTreeErrors, `[\"${triggerPath}\"]`, []);\n        const lintErrors = lintTriggerPath(\n          unEvalPropertyValue,\n          entity,\n          evalContext,\n        );\n        set(lintTreeErrors, `[\"${triggerPath}\"]`, lintErrors);\n      });\n    }\n  }\n\n  return lintTreeErrors;\n}\n\nfunction lintBindingPath(\n  dynamicBinding: string,\n  entity: DataTreeEntity,\n  fullPropertyPath: string,\n  globalData: ReturnType<typeof createEvaluationContext>,\n) {\n  let lintErrors: LintError[] = [];\n\n  if (isJSAction(entity)) {\n    if (!entity.body) return lintErrors;\n    if (!entity.body.startsWith(JS_OBJECT_START_STATEMENT)) {\n      return lintErrors.concat([\n        {\n          errorType: PropertyEvaluationErrorType.LINT,\n          errorSegment: \"\",\n          originalBinding: entity.body,\n          line: 0,\n          ch: 0,\n          code: entity.body,\n          variables: [],\n          raw: entity.body,\n          errorMessage: {\n            name: \"LintingError\",\n            message: INVALID_JSOBJECT_START_STATEMENT,\n          },\n          severity: Severity.ERROR,\n        },\n      ]);\n    }\n  }\n\n  const { propertyPath } = getEntityNameAndPropertyPath(fullPropertyPath);\n  // Get the {{binding}} bound values\n  const { jsSnippets, stringSegments } = getDynamicBindings(\n    dynamicBinding,\n    entity,\n  );\n\n  if (stringSegments) {\n    jsSnippets.forEach((jsSnippet, index) => {\n      if (jsSnippet) {\n        const jsSnippetToLint = getJSToLint(entity, jsSnippet, propertyPath);\n        // {{user's code}}\n        const originalBinding = getJSToLint(\n          entity,\n          stringSegments[index],\n          propertyPath,\n        );\n        const scriptType = getScriptType(false, false);\n        const scriptToLint = getScriptToEval(jsSnippetToLint, scriptType);\n        const lintErrorsFromSnippet = getLintingErrors(\n          scriptToLint,\n          globalData,\n          originalBinding,\n          scriptType,\n        );\n        lintErrors = lintErrors.concat(lintErrorsFromSnippet);\n      }\n    });\n  }\n  return lintErrors;\n}\n\nfunction lintTriggerPath(\n  userScript: string,\n  entity: DataTreeEntity,\n  globalData: ReturnType<typeof createEvaluationContext>,\n) {\n  const { jsSnippets } = getDynamicBindings(userScript, entity);\n  const script = getScriptToEval(jsSnippets[0], EvaluationScriptType.TRIGGERS);\n\n  return getLintingErrors(\n    script,\n    globalData,\n    jsSnippets[0],\n    EvaluationScriptType.TRIGGERS,\n  );\n}\n\nexport function pathRequiresLinting(\n  dataTree: DataTree,\n  entity: DataTreeEntity,\n  fullPropertyPath: string,\n): boolean {\n  const { propertyPath } = getEntityNameAndPropertyPath(fullPropertyPath);\n  const unEvalPropertyValue = (get(\n    dataTree,\n    fullPropertyPath,\n  ) as unknown) as string;\n\n  if (isATriggerPath(entity, propertyPath)) {\n    return isDynamicValue(unEvalPropertyValue);\n  }\n  const isADynamicBindingPath =\n    (isAction(entity) || isWidget(entity) || isJSAction(entity)) &&\n    isPathADynamicBinding(entity, propertyPath);\n  const requiresLinting =\n    (isADynamicBindingPath && isDynamicValue(unEvalPropertyValue)) ||\n    isJSAction(entity);\n  return requiresLinting;\n}\n\n// Removes \"export default\" statement from js Object\nexport function getJSToLint(\n  entity: DataTreeEntity,\n  snippet: string,\n  propertyPath: string,\n): string {\n  return entity && isJSAction(entity) && propertyPath === \"body\"\n    ? snippet.replace(/export default/g, \"\")\n    : snippet;\n}\n\nexport function getPositionInEvaluationScript(\n  type: EvaluationScriptType,\n): Position {\n  const script = EvaluationScripts[type];\n\n  const index = script.indexOf(ScriptTemplate);\n  const substr = script.slice(0, index !== -1 ? index : 0);\n  const lines = substr.split(\"\\n\");\n  const lastLine = last(lines) || \"\";\n\n  return { line: lines.length, ch: lastLine.length };\n}\n\nconst EvaluationScriptPositions: Record<string, Position> = {};\n\nfunction getEvaluationScriptPosition(scriptType: EvaluationScriptType) {\n  if (isEmpty(EvaluationScriptPositions)) {\n    // We are computing position of <<script>> in our templates.\n    // This will be used to get the exact location of error in linting\n    keys(EvaluationScripts).forEach((type) => {\n      EvaluationScriptPositions[type] = getPositionInEvaluationScript(\n        type as EvaluationScriptType,\n      );\n    });\n  }\n\n  return EvaluationScriptPositions[scriptType];\n}\n\nexport function getLintingErrors(\n  script: string,\n  data: Record<string, unknown>,\n  // {{user's code}}\n  originalBinding: string,\n  scriptType: EvaluationScriptType,\n): LintError[] {\n  const scriptPos = getEvaluationScriptPosition(scriptType);\n  const globalData: Record<string, boolean> = {};\n  for (const dataKey in data) {\n    globalData[dataKey] = true;\n  }\n  // Jshint shouldn't throw errors for additional libraries\n  const libAccessors = ([] as string[]).concat(\n    ...JSLibraries.map((lib) => lib.accessor),\n  );\n  libAccessors.forEach((accessor) => (globalData[accessor] = true));\n\n  // JSHint shouldn't throw errors for supported web apis\n  Object.keys(SUPPORTED_WEB_APIS).forEach(\n    (apiName) => (globalData[apiName] = true),\n  );\n\n  const options: LintOptions = {\n    indent: 2,\n    esversion: ECMA_VERSION,\n    eqeqeq: false, // Not necessary to use ===\n    curly: false, // Blocks can be added without {}, eg if (x) return true\n    freeze: true, // Overriding inbuilt classes like Array is not allowed\n    undef: true, // Undefined variables should be reported as error\n    forin: false, // Doesn't require filtering for..in loops with obj.hasOwnProperty()\n    noempty: false, // Empty blocks are allowed\n    strict: false, // We won't force strict mode\n    unused: \"strict\", // Unused variables are not allowed\n    asi: true, // Tolerate Automatic Semicolon Insertion (no semicolons)\n    boss: true, // Tolerate assignments where comparisons would be expected\n    evil: false, // Use of eval not allowed\n    funcscope: true, // Tolerate variable definition inside control statements\n    sub: true, // Don't force dot notation\n    expr: true, // suppresses warnings about the use of expressions where normally you would expect to see assignments or function calls\n    // environments\n    browser: true,\n    worker: true,\n    mocha: false,\n    // global values\n    globals: globalData,\n    loopfunc: true,\n  };\n\n  jshint(script, options);\n\n  const jshintErrors: LintError[] = getValidLintErrors(\n    jshint.errors,\n    scriptPos,\n  ).map((lintError) => {\n    const ch = lintError.character;\n    return {\n      errorType: PropertyEvaluationErrorType.LINT,\n      raw: script,\n      severity: getLintSeverity(lintError.code),\n      errorMessage: {\n        name: \"LintingError\",\n        message: getLintErrorMessage(lintError.reason),\n      },\n      errorSegment: lintError.evidence,\n      originalBinding,\n      // By keeping track of these variables we can highlight the exact text that caused the error.\n      variables: [lintError.a, lintError.b, lintError.c, lintError.d],\n      code: lintError.code,\n      line: lintError.line - scriptPos.line,\n      ch: lintError.line === scriptPos.line ? ch - scriptPos.ch : ch,\n    };\n  });\n  const invalidPropertyErrors = getInvalidPropertyErrorsFromScript(\n    script,\n    data,\n    scriptPos,\n    originalBinding,\n  );\n  return jshintErrors.concat(invalidPropertyErrors);\n}\n\nfunction getValidLintErrors(\n  lintErrors: JSHintError[],\n  scriptPos: Position,\n): JSHintError[] {\n  return lintErrors.reduce((result: JSHintError[], lintError) => {\n    // Ignored errors should not be reported\n    if (IGNORED_LINT_ERRORS.includes(lintError.code)) return result;\n    /** Some error messages reference line numbers,\n     * Eg. Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'\n     * these line numbers need to be re-calculated based on the binding location.\n     * Errors referencing line numbers outside the user's script should also be ignored\n     * */\n    let message = lintError.reason;\n    const matchedLines = message.match(/line \\d/gi);\n    const lineNumbersInErrorMessage = new Set<number>();\n    let isInvalidErrorMessage = false;\n    if (matchedLines) {\n      matchedLines.forEach((lineStatement) => {\n        const digitString = lineStatement.split(\" \")[1];\n        const digit = Number(digitString);\n        if (isNumber(digit)) {\n          if (digit < scriptPos.line) {\n            // referenced line number is outside the scope of user's script\n            isInvalidErrorMessage = true;\n          } else {\n            lineNumbersInErrorMessage.add(digit);\n          }\n        }\n      });\n    }\n    if (isInvalidErrorMessage) return result;\n    if (lineNumbersInErrorMessage.size) {\n      Array.from(lineNumbersInErrorMessage).forEach((lineNumber) => {\n        message = message.replaceAll(\n          `line ${lineNumber}`,\n          `line ${lineNumber - scriptPos.line + 1}`,\n        );\n      });\n    }\n    result.push({\n      ...lintError,\n      reason: message,\n    });\n    return result;\n  }, []);\n}\n\nfunction getInvalidPropertyErrorsFromScript(\n  script: string,\n  data: Record<string, unknown>,\n  scriptPos: Position,\n  originalBinding: string,\n): LintError[] {\n  let invalidTopLevelMemberExpressions: MemberExpressionData[] = [];\n  try {\n    invalidTopLevelMemberExpressions = extractInvalidTopLevelMemberExpressionsFromCode(\n      script,\n      data,\n      self.evaluationVersion,\n    );\n  } catch (e) {}\n\n  const invalidPropertyErrors = invalidTopLevelMemberExpressions.map(\n    ({ object, property }): LintError => {\n      const propertyName = isLiteralNode(property)\n        ? (property.value as string)\n        : property.name;\n      const objectStartLine = object.loc.start.line - 1;\n      // For computed member expressions (entity[\"property\"]), add an extra 1 to the start column to account for \"[\".\n      const propertyStartColumn = !isLiteralNode(property)\n        ? property.loc.start.column + 1\n        : property.loc.start.column + 2;\n      return {\n        errorType: PropertyEvaluationErrorType.LINT,\n        raw: script,\n        severity: getLintSeverity(CustomLintErrorCode.INVALID_ENTITY_PROPERTY),\n        errorMessage: {\n          name: \"LintingError\",\n          message: CUSTOM_LINT_ERRORS[\n            CustomLintErrorCode.INVALID_ENTITY_PROPERTY\n          ](object.name, propertyName),\n        },\n        errorSegment: `${object.name}.${propertyName}`,\n        originalBinding,\n        variables: [propertyName, null, null, null],\n        code: CustomLintErrorCode.INVALID_ENTITY_PROPERTY,\n        line: objectStartLine - scriptPos.line,\n        ch:\n          objectStartLine === scriptPos.line\n            ? propertyStartColumn - scriptPos.ch\n            : propertyStartColumn,\n      };\n    },\n  );\n  return invalidPropertyErrors;\n}\n\nexport function initiateLinting(\n  lintOrder: string[],\n  unevalTree: DataTree,\n  requiresLinting: boolean,\n) {\n  if (!requiresLinting) return;\n  WorkerMessenger.ping({\n    data: {\n      lintOrder,\n      unevalTree,\n    },\n    method: MAIN_THREAD_ACTION.LINT_TREE,\n  });\n}\n","export const ECMA_VERSION = 11;\n\n/* Indicates the mode the code should be parsed in. \nThis influences global strict mode and parsing of import and export declarations.\n*/\nexport enum SourceType {\n  script = 'script',\n  module = 'module',\n}\n\n// Each node has an attached type property which further defines\n// what all properties can the node have.\n// We will just define the ones we are working with\nexport enum NodeTypes {\n  Identifier = 'Identifier',\n  AssignmentPattern = 'AssignmentPattern',\n  Literal = 'Literal',\n  Property = 'Property',\n  // Declaration - https://github.com/estree/estree/blob/master/es5.md#declarations\n  FunctionDeclaration = 'FunctionDeclaration',\n  ExportDefaultDeclaration = 'ExportDefaultDeclaration',\n  VariableDeclarator = 'VariableDeclarator',\n  // Expression - https://github.com/estree/estree/blob/master/es5.md#expressions\n  MemberExpression = 'MemberExpression',\n  FunctionExpression = 'FunctionExpression',\n  ArrowFunctionExpression = 'ArrowFunctionExpression',\n  ObjectExpression = 'ObjectExpression',\n  ArrayExpression = 'ArrayExpression',\n  ThisExpression = 'ThisExpression',\n}\n","/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */\nif (!String.fromCodePoint) {\n\t(function() {\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\ttry {\n\t\t\t\tvar object = {};\n\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tvar stringFromCharCode = String.fromCharCode;\n\t\tvar floor = Math.floor;\n\t\tvar fromCodePoint = function(_) {\n\t\t\tvar MAX_SIZE = 0x4000;\n\t\t\tvar codeUnits = [];\n\t\t\tvar highSurrogate;\n\t\t\tvar lowSurrogate;\n\t\t\tvar index = -1;\n\t\t\tvar length = arguments.length;\n\t\t\tif (!length) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tvar result = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tvar codePoint = Number(arguments[index]);\n\t\t\t\tif (\n\t\t\t\t\t!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n\t\t\t\t\tcodePoint < 0 || // not a valid Unicode code point\n\t\t\t\t\tcodePoint > 0x10FFFF || // not a valid Unicode code point\n\t\t\t\t\tfloor(codePoint) != codePoint // not an integer\n\t\t\t\t) {\n\t\t\t\t\tthrow RangeError('Invalid code point: ' + codePoint);\n\t\t\t\t}\n\t\t\t\tif (codePoint <= 0xFFFF) { // BMP code point\n\t\t\t\t\tcodeUnits.push(codePoint);\n\t\t\t\t} else { // Astral code point; split in surrogate halves\n\t\t\t\t\t// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\t\thighSurrogate = (codePoint >> 10) + 0xD800;\n\t\t\t\t\tlowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t\t\t\t\tcodeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t\t}\n\t\t\t\tif (index + 1 == length || codeUnits.length > MAX_SIZE) {\n\t\t\t\t\tresult += stringFromCharCode.apply(null, codeUnits);\n\t\t\t\t\tcodeUnits.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String, 'fromCodePoint', {\n\t\t\t\t'value': fromCodePoint,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.fromCodePoint = fromCodePoint;\n\t\t}\n\t}());\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nrequire(\"string.fromcodepoint\");\n\n/**\n * \\\\ - matches the backslash which indicates the beginning of an escape sequence\n * (\n *   u\\{([0-9A-Fa-f]+)\\} - first alternative; matches the variable-length hexadecimal escape sequence (\\u{ABCD0})\n * |\n *   u([0-9A-Fa-f]{4}) - second alternative; matches the 4-digit hexadecimal escape sequence (\\uABCD)\n * |\n *   x([0-9A-Fa-f]{2}) - third alternative; matches the 2-digit hexadecimal escape sequence (\\xA5)\n * |\n *   ([1-7][0-7]{0,2}|[0-7]{2,3}) - fourth alternative; matches the up-to-3-digit octal escape sequence (\\5 or \\512)\n * |\n *   (['\"tbrnfv0\\\\]) - fifth alternative; matches the special escape characters (\\t, \\n and so on)\n * |\n *   \\U([0-9A-Fa-f]+) - sixth alternative; matches the 8-digit hexadecimal escape sequence used by python (\\U0001F3B5)\n * )\n */\nvar jsEscapeRegex = /\\\\(u\\{([0-9A-Fa-f]+)\\}|u([0-9A-Fa-f]{4})|x([0-9A-Fa-f]{2})|([1-7][0-7]{0,2}|[0-7]{2,3})|(['\"tbrnfv0\\\\]))|\\\\U([0-9A-Fa-f]{8})/g;\nvar usualEscapeSequences = {\n  '0': '\\0',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n  'v': '\\v',\n  '\\'': '\\'',\n  '\"': '\"',\n  '\\\\': '\\\\'\n};\n\nvar fromHex = function fromHex(str) {\n  return String.fromCodePoint(parseInt(str, 16));\n};\n\nvar fromOct = function fromOct(str) {\n  return String.fromCodePoint(parseInt(str, 8));\n};\n\nvar _default = function _default(string) {\n  return string.replace(jsEscapeRegex, function (_, __, varHex, longHex, shortHex, octal, specialCharacter, python) {\n    if (varHex !== undefined) {\n      return fromHex(varHex);\n    } else if (longHex !== undefined) {\n      return fromHex(longHex);\n    } else if (shortHex !== undefined) {\n      return fromHex(shortHex);\n    } else if (octal !== undefined) {\n      return fromOct(octal);\n    } else if (python !== undefined) {\n      return fromHex(python);\n    } else {\n      return usualEscapeSequences[specialCharacter];\n    }\n  });\n};\n\nexports.default = _default;\nmodule.exports = exports.default;","import unescapeJS from 'unescape-js';\n\nconst beginsWithLineBreakRegex = /^\\s+|\\s+$/;\n\nexport function sanitizeScript(js: string, evaluationVersion: number) {\n  // We remove any line breaks from the beginning of the script because that\n  // makes the final function invalid. We also unescape any escaped characters\n  // so that eval can happen\n  //default value of evalutaion version is 2\n  evaluationVersion = evaluationVersion ? evaluationVersion : 2;\n  const trimmedJS = js.replace(beginsWithLineBreakRegex, '');\n  return evaluationVersion > 1 ? trimmedJS : unescapeJS(trimmedJS);\n}\n\n// For the times when you need to know if something truly an object like { a: 1, b: 2}\n// typeof, lodash.isObject and others will return false positives for things like array, null, etc\nexport const isTrueObject = (\n  item: unknown\n): item is Record<string, unknown> => {\n  return Object.prototype.toString.call(item) === '[object Object]';\n};\n","import { Node } from \"acorn\";\nimport { getAST } from \"../index\";\nimport { generate } from \"astring\";\nimport { simple } from \"acorn-walk\";\nimport {\n  getFunctionalParamsFromNode,\n  isPropertyAFunctionNode,\n  isVariableDeclarator,\n  isObjectExpression,\n  PropertyNode,\n  functionParam,\n} from \"../index\";\n\ntype JsObjectProperty = {\n  key: string;\n  value: string;\n  type: string;\n  arguments?: Array<functionParam>;\n};\n\nconst jsObjectVariableName =\n  \"____INTERNAL_JS_OBJECT_NAME_USED_FOR_PARSING_____\";\n\nexport const jsObjectDeclaration = `var ${jsObjectVariableName} =`;\n\nexport const parseJSObjectWithAST = (\n  jsObjectBody: string\n): Array<JsObjectProperty> => {\n  /* \n      jsObjectVariableName value is added such actual js code would never name same variable name. \n      if the variable name will be same then also we won't have problem here as jsObjectVariableName will be last node in VariableDeclarator hence overriding the previous JSObjectProperties.\n      Keeping this just for sanity check if any caveat was missed.\n    */\n  const jsCode = `${jsObjectDeclaration} ${jsObjectBody}`;\n\n  const ast = getAST(jsCode);\n\n  const parsedObjectProperties = new Set<JsObjectProperty>();\n  let JSObjectProperties: Array<PropertyNode> = [];\n\n  simple(ast, {\n    VariableDeclarator(node: Node) {\n      if (\n        isVariableDeclarator(node) &&\n        node.id.name === jsObjectVariableName &&\n        node.init &&\n        isObjectExpression(node.init)\n      ) {\n        JSObjectProperties = node.init.properties;\n      }\n    },\n  });\n\n  JSObjectProperties.forEach((node) => {\n    let params = new Set<functionParam>();\n    const propertyNode = node;\n    let property: JsObjectProperty = {\n      key: generate(propertyNode.key),\n      value: generate(propertyNode.value),\n      type: propertyNode.value.type,\n    };\n\n    if (isPropertyAFunctionNode(propertyNode.value)) {\n      // if in future we need default values of each param, we could implement that in getFunctionalParamsFromNode\n      // currently we don't consume it anywhere hence avoiding to calculate that.\n      params = getFunctionalParamsFromNode(propertyNode.value);\n      property = {\n        ...property,\n        arguments: [...params],\n      };\n    }\n\n    // here we use `generate` function to convert our AST Node to JSCode\n    parsedObjectProperties.add(property);\n  });\n\n  return [...parsedObjectProperties];\n};\n","import { parse, Node, SourceLocation, Options, Comment } from \"acorn\";\nimport { ancestor, simple } from \"acorn-walk\";\nimport { ECMA_VERSION, NodeTypes } from \"./constants/ast\";\nimport { has, isFinite, isString, memoize, toPath } from \"lodash\";\nimport { isTrueObject, sanitizeScript } from \"./utils\";\nimport { jsObjectDeclaration } from \"./jsObject/index\";\n/*\n * Valuable links:\n *\n * * ESTree spec: Javascript AST is called ESTree.\n * Each es version has its md file in the repo to find features\n * implemented and their node type\n * https://github.com/estree/estree\n *\n * * Acorn: The parser we use to get the AST\n * https://github.com/acornjs/acorn\n *\n * * Acorn walk: The walker we use to traverse the AST\n * https://github.com/acornjs/acorn/tree/master/acorn-walk\n *\n * * AST Explorer: Helpful web tool to see ASTs and its parts\n * https://astexplorer.net/\n *\n */\n\ntype Pattern = IdentifierNode | AssignmentPatternNode;\ntype Expression = Node;\n// doc: https://github.com/estree/estree/blob/master/es5.md#memberexpression\ninterface MemberExpressionNode extends Node {\n  type: NodeTypes.MemberExpression;\n  object: MemberExpressionNode | IdentifierNode;\n  property: IdentifierNode | LiteralNode;\n  computed: boolean;\n  // doc: https://github.com/estree/estree/blob/master/es2020.md#chainexpression\n  optional?: boolean;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#identifier\ninterface IdentifierNode extends Node {\n  type: NodeTypes.Identifier;\n  name: string;\n}\n\n//Using this to handle the Variable property refactor\ninterface RefactorIdentifierNode extends Node {\n  type: NodeTypes.Identifier;\n  name: string;\n  property?: IdentifierNode;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#variabledeclarator\ninterface VariableDeclaratorNode extends Node {\n  type: NodeTypes.VariableDeclarator;\n  id: IdentifierNode;\n  init: Expression | null;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#functions\ninterface Function extends Node {\n  id: IdentifierNode | null;\n  params: Pattern[];\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#functiondeclaration\ninterface FunctionDeclarationNode extends Node, Function {\n  type: NodeTypes.FunctionDeclaration;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#functionexpression\ninterface FunctionExpressionNode extends Expression, Function {\n  type: NodeTypes.FunctionExpression;\n}\n\ninterface ArrowFunctionExpressionNode extends Expression, Function {\n  type: NodeTypes.ArrowFunctionExpression;\n}\n\nexport interface ObjectExpression extends Expression {\n  type: NodeTypes.ObjectExpression;\n  properties: Array<PropertyNode>;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es2015.md#assignmentpattern\ninterface AssignmentPatternNode extends Node {\n  type: NodeTypes.AssignmentPattern;\n  left: Pattern;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#literal\ninterface LiteralNode extends Node {\n  type: NodeTypes.Literal;\n  value: string | boolean | null | number | RegExp;\n}\n\ntype NodeList = {\n  references: Set<string>;\n  functionalParams: Set<string>;\n  variableDeclarations: Set<string>;\n  identifierList: Array<IdentifierNode>;\n};\n\n// https://github.com/estree/estree/blob/master/es5.md#property\nexport interface PropertyNode extends Node {\n  type: NodeTypes.Property;\n  key: LiteralNode | IdentifierNode;\n  value: Node;\n  kind: \"init\" | \"get\" | \"set\";\n}\n\n// Node with location details\ntype NodeWithLocation<NodeType> = NodeType & {\n  loc: SourceLocation;\n};\n\ntype AstOptions = Omit<Options, \"ecmaVersion\">;\n\ntype EntityRefactorResponse = {\n  isSuccess: boolean;\n  body: { script: string; refactorCount: number } | { error: string };\n};\n\n/* We need these functions to typescript casts the nodes with the correct types */\nexport const isIdentifierNode = (node: Node): node is IdentifierNode => {\n  return node.type === NodeTypes.Identifier;\n};\n\nconst isMemberExpressionNode = (node: Node): node is MemberExpressionNode => {\n  return node.type === NodeTypes.MemberExpression;\n};\n\nexport const isVariableDeclarator = (\n  node: Node,\n): node is VariableDeclaratorNode => {\n  return node.type === NodeTypes.VariableDeclarator;\n};\n\nconst isFunctionDeclaration = (node: Node): node is FunctionDeclarationNode => {\n  return node.type === NodeTypes.FunctionDeclaration;\n};\n\nconst isFunctionExpression = (node: Node): node is FunctionExpressionNode => {\n  return node.type === NodeTypes.FunctionExpression;\n};\nconst isArrowFunctionExpression = (\n  node: Node,\n): node is ArrowFunctionExpressionNode => {\n  return node.type === NodeTypes.ArrowFunctionExpression;\n};\n\nexport const isObjectExpression = (node: Node): node is ObjectExpression => {\n  return node.type === NodeTypes.ObjectExpression;\n};\n\nconst isAssignmentPatternNode = (node: Node): node is AssignmentPatternNode => {\n  return node.type === NodeTypes.AssignmentPattern;\n};\n\nexport const isLiteralNode = (node: Node): node is LiteralNode => {\n  return node.type === NodeTypes.Literal;\n};\n\nexport const isPropertyNode = (node: Node): node is PropertyNode => {\n  return node.type === NodeTypes.Property;\n};\n\nexport const isPropertyAFunctionNode = (\n  node: Node,\n): node is ArrowFunctionExpressionNode | FunctionExpressionNode => {\n  return (\n    node.type === NodeTypes.ArrowFunctionExpression ||\n    node.type === NodeTypes.FunctionExpression\n  );\n};\n\nconst isArrayAccessorNode = (node: Node): node is MemberExpressionNode => {\n  return (\n    isMemberExpressionNode(node) &&\n    node.computed &&\n    isLiteralNode(node.property) &&\n    isFinite(node.property.value)\n  );\n};\n\nconst wrapCode = (code: string) => {\n  return `\n    (function() {\n      return ${code}\n    })\n  `;\n};\n\n//Tech-debt: should upgrade this to better logic\n//Used slice for a quick resolve of critical bug\nconst unwrapCode = (code: string) => {\n  let unwrapedCode = code.slice(32);\n  return unwrapedCode.slice(0, -10);\n};\n\nconst getFunctionalParamNamesFromNode = (\n  node:\n    | FunctionDeclarationNode\n    | FunctionExpressionNode\n    | ArrowFunctionExpressionNode,\n) => {\n  return Array.from(getFunctionalParamsFromNode(node)).map(\n    (functionalParam) => functionalParam.paramName,\n  );\n};\n\n// Memoize the ast generation code to improve performance.\n// Since this will be used by both the server and the client, we want to prevent regeneration of ast\n// for the the same code snippet\nexport const getAST = memoize((code: string, options?: AstOptions) =>\n  parse(code, { ...options, ecmaVersion: ECMA_VERSION }),\n);\n\n/**\n * An AST based extractor that fetches all possible references in a given\n * piece of code. We use this to get any references to the global entities in Appsmith\n * and create dependencies on them. If the reference was updated, the given piece of code\n * should run again.\n * @param code: The piece of script where references need to be extracted from\n */\n\nexport interface IdentifierInfo {\n  references: string[];\n  functionalParams: string[];\n  variables: string[];\n}\nexport const extractIdentifierInfoFromCode = (\n  code: string,\n  evaluationVersion: number,\n  invalidIdentifiers?: Record<string, unknown>,\n): IdentifierInfo => {\n  let ast: Node = { end: 0, start: 0, type: \"\" };\n  try {\n    const sanitizedScript = sanitizeScript(code, evaluationVersion);\n    /* wrapCode - Wrapping code in a function, since all code/script get wrapped with a function during evaluation.\n       Some syntax won't be valid unless they're at the RHS of a statement.\n       Since we're assigning all code/script to RHS during evaluation, we do the same here.\n       So that during ast parse, those errors are neglected.\n    */\n    /* e.g. IIFE without braces\n      function() { return 123; }() -> is invalid\n      let result = function() { return 123; }() -> is valid\n    */\n    const wrappedCode = wrapCode(sanitizedScript);\n    ast = getAST(wrappedCode);\n    let { references, functionalParams, variableDeclarations }: NodeList =\n      ancestorWalk(ast);\n    const referencesArr = Array.from(references).filter((reference) => {\n      // To remove references derived from declared variables and function params,\n      // We extract the topLevelIdentifier Eg. Api1.name => Api1\n      const topLevelIdentifier = toPath(reference)[0];\n      return !(\n        functionalParams.has(topLevelIdentifier) ||\n        variableDeclarations.has(topLevelIdentifier) ||\n        has(invalidIdentifiers, topLevelIdentifier)\n      );\n    });\n    return {\n      references: referencesArr,\n      functionalParams: Array.from(functionalParams),\n      variables: Array.from(variableDeclarations),\n    };\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      // Syntax error. Ignore and return empty list\n      return {\n        references: [],\n        functionalParams: [],\n        variables: [],\n      };\n    }\n    throw e;\n  }\n};\n\nexport const entityRefactorFromCode = (\n  script: string,\n  oldName: string,\n  newName: string,\n  isJSObject: boolean,\n  evaluationVersion: number,\n  invalidIdentifiers?: Record<string, unknown>,\n): EntityRefactorResponse => {\n  //Sanitizing leads to removal of special charater.\n  //Hence we are not sanatizing the script. Fix(#18492)\n  //If script is a JSObject then replace export default to decalartion.\n  if (isJSObject) script = jsObjectToCode(script);\n  else script = wrapCode(script);\n  let ast: Node = { end: 0, start: 0, type: \"\" };\n  //Copy of script to refactor\n  let refactorScript = script;\n  //Difference in length of oldName and newName\n  const nameLengthDiff: number = newName.length - oldName.length;\n  //Offset index used for deciding location of oldName.\n  let refactorOffset: number = 0;\n  //Count of refactors on the script\n  let refactorCount: number = 0;\n  try {\n    ast = getAST(script);\n    let {\n      references,\n      functionalParams,\n      variableDeclarations,\n      identifierList,\n    }: NodeList = ancestorWalk(ast);\n    const identifierArray = Array.from(\n      identifierList,\n    ) as Array<RefactorIdentifierNode>;\n    //To handle if oldName has property (\"JSObject.myfunc\")\n    const oldNameArr = oldName.split(\".\");\n    const referencesArr = Array.from(references).filter((reference) => {\n      // To remove references derived from declared variables and function params,\n      // We extract the topLevelIdentifier Eg. Api1.name => Api1\n      const topLevelIdentifier = toPath(reference)[0];\n      return !(\n        functionalParams.has(topLevelIdentifier) ||\n        variableDeclarations.has(topLevelIdentifier) ||\n        has(invalidIdentifiers, topLevelIdentifier)\n      );\n    });\n    //Traverse through all identifiers in the script\n    identifierArray.forEach((identifier) => {\n      if (identifier.name === oldNameArr[0]) {\n        let index = 0;\n        while (index < referencesArr.length) {\n          if (identifier.name === referencesArr[index].split(\".\")[0]) {\n            //Replace the oldName by newName\n            //Get start index from node and get subarray from index 0 till start\n            //Append above with new name\n            //Append substring from end index from the node till end of string\n            //Offset variable is used to alter the position based on `refactorOffset`\n            //In case of nested JS action get end postion fro the property.\n            ///Default end index\n            let endIndex = identifier.end;\n            const propertyNode = identifier.property;\n            //Flag variable : true if property should be updated\n            //false if property should not be updated\n            let propertyCondFlag =\n              oldNameArr.length > 1 &&\n              propertyNode &&\n              oldNameArr[1] === propertyNode.name;\n            //Condition to validate if Identifier || Property should be updated??\n            if (oldNameArr.length === 1 || propertyCondFlag) {\n              //Condition to extend end index in case of property match\n              if (propertyCondFlag && propertyNode) {\n                endIndex = propertyNode.end;\n              }\n              refactorScript =\n                refactorScript.substring(0, identifier.start + refactorOffset) +\n                newName +\n                refactorScript.substring(endIndex + refactorOffset);\n              refactorOffset += nameLengthDiff;\n              ++refactorCount;\n              //We are only looking for one match in refrence for the identifier name.\n              break;\n            }\n          }\n          index++;\n        }\n      }\n    });\n    //If script is a JSObject then revert decalartion to export default.\n    if (isJSObject) refactorScript = jsCodeToObject(refactorScript);\n    else refactorScript = unwrapCode(refactorScript);\n    return {\n      isSuccess: true,\n      body: { script: refactorScript, refactorCount },\n    };\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      // Syntax error. Ignore and return empty list\n      return { isSuccess: false, body: { error: \"Syntax Error\" } };\n    }\n    throw e;\n  }\n};\n\nexport type functionParam = { paramName: string; defaultValue: unknown };\n\nexport const getFunctionalParamsFromNode = (\n  node:\n    | FunctionDeclarationNode\n    | FunctionExpressionNode\n    | ArrowFunctionExpressionNode,\n  needValue = false,\n): Set<functionParam> => {\n  const functionalParams = new Set<functionParam>();\n  node.params.forEach((paramNode) => {\n    if (isIdentifierNode(paramNode)) {\n      functionalParams.add({\n        paramName: paramNode.name,\n        defaultValue: undefined,\n      });\n    } else if (isAssignmentPatternNode(paramNode)) {\n      if (isIdentifierNode(paramNode.left)) {\n        const paramName = paramNode.left.name;\n        if (!needValue) {\n          functionalParams.add({ paramName, defaultValue: undefined });\n        } else {\n          // figure out how to get value of paramNode.right for each node type\n          // currently we don't use params value, hence skipping it\n          // functionalParams.add({\n          //   defaultValue: paramNode.right.value,\n          // });\n        }\n      }\n    }\n  });\n  return functionalParams;\n};\n\nconst constructFinalMemberExpIdentifier = (\n  node: MemberExpressionNode,\n  child = \"\",\n): string => {\n  const propertyAccessor = getPropertyAccessor(node.property);\n  if (isIdentifierNode(node.object)) {\n    return `${node.object.name}${propertyAccessor}${child}`;\n  } else {\n    const propertyAccessor = getPropertyAccessor(node.property);\n    const nestedChild = `${propertyAccessor}${child}`;\n    return constructFinalMemberExpIdentifier(node.object, nestedChild);\n  }\n};\n\nconst getPropertyAccessor = (propertyNode: IdentifierNode | LiteralNode) => {\n  if (isIdentifierNode(propertyNode)) {\n    return `.${propertyNode.name}`;\n  } else if (isLiteralNode(propertyNode) && isString(propertyNode.value)) {\n    // is string literal search a['b']\n    return `.${propertyNode.value}`;\n  } else if (isLiteralNode(propertyNode) && isFinite(propertyNode.value)) {\n    // is array index search - a[9]\n    return `[${propertyNode.value}]`;\n  }\n};\n\nexport const isTypeOfFunction = (type: string) => {\n  return (\n    type === NodeTypes.ArrowFunctionExpression ||\n    type === NodeTypes.FunctionExpression\n  );\n};\n\nexport interface MemberExpressionData {\n  property: NodeWithLocation<IdentifierNode | LiteralNode>;\n  object: NodeWithLocation<IdentifierNode>;\n}\n\n/** Function returns Invalid top-level member expressions from code\n * @param code\n * @param data\n * @param evaluationVersion\n * @returns information about all invalid property/method assessment in code\n * @example Given data {\n * JSObject1: {\n * name:\"JSObject\",\n * data:[]\n * },\n * Api1:{\n * name: \"Api1\",\n * data: []\n * }\n * },\n * For code {{Api1.name + JSObject.unknownProperty}}, function returns information about \"JSObject.unknownProperty\" node.\n */\nexport const extractInvalidTopLevelMemberExpressionsFromCode = (\n  code: string,\n  data: Record<string, any>,\n  evaluationVersion: number,\n): MemberExpressionData[] => {\n  const invalidTopLevelMemberExpressions = new Set<MemberExpressionData>();\n  const variableDeclarations = new Set<string>();\n  let functionalParams = new Set<string>();\n  let ast: Node = { end: 0, start: 0, type: \"\" };\n  try {\n    const sanitizedScript = sanitizeScript(code, evaluationVersion);\n    const wrappedCode = wrapCode(sanitizedScript);\n    ast = getAST(wrappedCode, { locations: true });\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      // Syntax error. Ignore and return empty list\n      return [];\n    }\n    throw e;\n  }\n  simple(ast, {\n    MemberExpression(node: Node) {\n      const { object, property, computed } = node as MemberExpressionNode;\n      // We are only interested in top-level MemberExpression nodes\n      // Eg. for Api1.data.name, we are only interested in Api1.data\n      if (!isIdentifierNode(object)) return;\n      if (!(object.name in data) || !isTrueObject(data[object.name])) return;\n      // For computed member expressions (assessed via [], eg. JSObject1[\"name\"] ),\n      // We are only interested in strings\n      if (\n        isLiteralNode(property) &&\n        isString(property.value) &&\n        !(property.value in data[object.name])\n      ) {\n        invalidTopLevelMemberExpressions.add({\n          object,\n          property,\n        } as MemberExpressionData);\n      }\n      // We ignore computed member expressions if property is an identifier (JSObject[name])\n      // This is because we can't statically determine what the value of the identifier might be.\n      if (\n        isIdentifierNode(property) &&\n        !computed &&\n        !(property.name in data[object.name])\n      ) {\n        invalidTopLevelMemberExpressions.add({\n          object,\n          property,\n        } as MemberExpressionData);\n      }\n    },\n    VariableDeclarator(node: Node) {\n      if (isVariableDeclarator(node)) {\n        variableDeclarations.add(node.id.name);\n      }\n    },\n    FunctionDeclaration(node: Node) {\n      if (!isFunctionDeclaration(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n    FunctionExpression(node: Node) {\n      if (!isFunctionExpression(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n    ArrowFunctionExpression(node: Node) {\n      if (!isArrowFunctionExpression(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n  });\n\n  const invalidTopLevelMemberExpressionsArray = Array.from(\n    invalidTopLevelMemberExpressions,\n  ).filter((MemberExpression) => {\n    return !(\n      variableDeclarations.has(MemberExpression.object.name) ||\n      functionalParams.has(MemberExpression.object.name)\n    );\n  });\n\n  return invalidTopLevelMemberExpressionsArray;\n};\n\nconst ancestorWalk = (ast: Node): NodeList => {\n  //List of all Identifier nodes with their property(if exists).\n  const identifierList = new Array<RefactorIdentifierNode>();\n  // List of all references found\n  const references = new Set<string>();\n  // List of variables declared within the script. All identifiers and member expressions derived from declared variables will be removed\n  const variableDeclarations = new Set<string>();\n  // List of functional params declared within the script. All identifiers and member expressions derived from functional params will be removed\n  let functionalParams = new Set<string>();\n\n  /*\n   * We do an ancestor walk on the AST in order to extract all references. For example, for member expressions and identifiers, we need to know\n   * what surrounds the identifier (its parent and ancestors), ancestor walk will give that information in the callback\n   * doc: https://github.com/acornjs/acorn/tree/master/acorn-walk\n   */\n  ancestor(ast, {\n    Identifier(node: Node, ancestors: Node[]) {\n      /*\n       * We are interested in identifiers. Due to the nature of AST, Identifier nodes can\n       * also be nested inside MemberExpressions. For deeply nested object references, there\n       * could be nesting of many MemberExpressions. To find the final reference, we will\n       * try to find the top level MemberExpression that does not have a MemberExpression parent.\n       * */\n      let candidateTopLevelNode: IdentifierNode | MemberExpressionNode =\n        node as IdentifierNode;\n      let depth = ancestors.length - 2; // start \"depth\" with first parent\n      while (depth > 0) {\n        const parent = ancestors[depth];\n        if (\n          isMemberExpressionNode(parent) &&\n          /* Member expressions that are \"computed\" (with [ ] search)\n             and the ones that have optional chaining ( a.b?.c )\n             will be considered top level node.\n             We will stop looking for further parents */\n          /* \"computed\" exception - isArrayAccessorNode\n             Member expressions that are array accessors with static index - [9]\n             will not be considered top level.\n             We will continue looking further. */\n          (!parent.computed || isArrayAccessorNode(parent)) &&\n          !parent.optional\n        ) {\n          candidateTopLevelNode = parent;\n          depth = depth - 1;\n        } else {\n          // Top level found\n          break;\n        }\n      }\n      //If parent is a Member expression then attach property to the Node.\n      //else push Identifier Node.\n      const parentNode = ancestors[ancestors.length - 2];\n      if (isMemberExpressionNode(parentNode)) {\n        identifierList.push({\n          ...(node as IdentifierNode),\n          property: parentNode.property as IdentifierNode,\n        });\n      } else identifierList.push(node as RefactorIdentifierNode);\n      if (isIdentifierNode(candidateTopLevelNode)) {\n        // If the node is an Identifier, just save that\n        references.add(candidateTopLevelNode.name);\n      } else {\n        // For MemberExpression Nodes, we will construct a final reference string and then add\n        // it to the references list\n        const memberExpIdentifier = constructFinalMemberExpIdentifier(\n          candidateTopLevelNode,\n        );\n        references.add(memberExpIdentifier);\n      }\n    },\n    VariableDeclarator(node: Node) {\n      // keep a track of declared variables so they can be\n      // removed from the final list of references\n      if (isVariableDeclarator(node)) {\n        variableDeclarations.add(node.id.name);\n      }\n    },\n    FunctionDeclaration(node: Node) {\n      // params in function declarations are also counted as references so we keep\n      // track of them and remove them from the final list of references\n      if (!isFunctionDeclaration(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n    FunctionExpression(node: Node) {\n      // params in function expressions are also counted as references so we keep\n      // track of them and remove them from the final list of references\n      if (!isFunctionExpression(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n    ArrowFunctionExpression(node: Node) {\n      // params in arrow function expressions are also counted as references so we keep\n      // track of them and remove them from the final list of references\n      if (!isArrowFunctionExpression(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n  });\n  return {\n    references,\n    functionalParams,\n    variableDeclarations,\n    identifierList,\n  };\n};\n\n//Replace export default by a variable declaration.\n//This is required for acorn to parse code into AST.\nconst jsObjectToCode = (script: string) => {\n  return script.replace(/export default/g, jsObjectDeclaration);\n};\n\n//Revert the string replacement from 'jsObjectToCode'.\n//variable declaration is replaced back by export default.\nconst jsCodeToObject = (script: string) => {\n  return script.replace(jsObjectDeclaration, \"export default\");\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [72,243,998], function() { return __webpack_require__(47534); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"72\":\"1f61a85c\",\"243\":\"8369a8e9\",\"998\":\"c73b6c4d\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","(function () {\n  if (typeof __webpack_require__ !== 'undefined') {\n    var oldGetScript = __webpack_require__.u;\n    var oldLoadScript = __webpack_require__.e;\n    var queryMap = {};\n    var countMap = {};\n    var getRetryDelay = function () {\n      return 3000;\n    };\n    __webpack_require__.u = function (chunkId) {\n      var result = oldGetScript(chunkId);\n      return (\n        result +\n        (queryMap.hasOwnProperty(chunkId) ? '?' + queryMap[chunkId] : '')\n      );\n    };\n    __webpack_require__.e = function (chunkId) {\n      var result = oldLoadScript(chunkId);\n      return result.catch(function (error) {\n        var retries = countMap.hasOwnProperty(chunkId) ? countMap[chunkId] : 2;\n        if (retries < 1) {\n          var realSrc = oldGetScript(chunkId);\n          error.message =\n            'Loading chunk ' +\n            chunkId +\n            ' failed after 2 retries.\\n(' +\n            realSrc +\n            ')';\n          error.request = realSrc;\n          window.location.href = '/404.html';\n          throw error;\n        }\n        return new Promise(function (resolve) {\n          var retryAttempt = 2 - retries + 1;\n          setTimeout(function () {\n            var retryAttemptString = '&retry-attempt=' + retryAttempt;\n            var cacheBust = 'cache-bust=true' + retryAttemptString;\n            queryMap[chunkId] = cacheBust;\n            countMap[chunkId] = retries - 1;\n            resolve(__webpack_require__.e(chunkId));\n          }, getRetryDelay(retryAttempt));\n        });\n      });\n    };\n  }\n})();\n","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t396: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkappsmith\"] = self[\"webpackChunkappsmith\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([72,243,998].map(__webpack_require__.e, __webpack_require__)).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["DataTreeDiffEvent","getEntityNameAndPropertyPath","fullPath","indexOfFirstDot","indexOf","entityName","propertyPath","substring","isWidget","entity","ENTITY_TYPE","WIDGET","isAction","ACTION","isAppsmithEntity","APPSMITH","isJSAction","JSACTION","isTrueObject","item","Object","prototype","toString","call","isATriggerPath","isPathDynamicTrigger","AppsmithWorkers","WorkerErrorTypes","LintTooltipDirection","WARNING_LINT_ERRORS","W098","W014","IGNORED_LINT_ERRORS","REFINED_LINT_ERROR_MESSAGES","CustomLintErrorCode","JS_OBJECT_START_STATEMENT","INVALID_JSOBJECT_START_STATEMENT","concat","SUPPORTED_WEB_APIS","length","console","crypto","CUSTOM_LINT_ERRORS","_defineProperty","INVALID_ENTITY_PROPERTY","propertyName","getLintSeverity","code","Severity","WARNING","ERROR","getLintErrorMessage","reason","ViewTypes","PaginationSubComponent","SortingSubComponent","WhereClauseSubComponent","EventType","EXECUTION_PARAM_KEY","_defaultActionSetting","PluginType","API","apiActionSettingsConfig","DB","queryActionSettingsConfig","SAAS","saasActionSettingsConfig","REMOTE","JS","_defaultActionEditorC","apiActionEditorConfig","_defaultActionDepende","apiActionDependencyConfig","_defaultDatasourceFor","apiActionDatasourceFormButtonConfig","DATA_BIND_REGEX","ExecutionType","addDataTreeToContext","args","dataTree","EVAL_CONTEXT","isTriggerBased","_args$skipEntityFunct","skipEntityFunctions","entityFunctionCollection","_i","_dataTreeEntries","entries","_dataTreeEntries$_i","_slicedToArray","_step","_iterator","_createForOfIteratorHelper","entityFns","s","n","done","entityFn","value","qualifier","func","fn","path","name","set","err","e","f","_i2","_Object$entries","_Object$entries$_i","funcObj","assign","getAllAsyncFunctions","asyncFunctionNameMap","_i3","_dataTreeEntries2","_step3","_dataTreeEntries2$_i","_iterator3","_step4","_iterator4","getPlatformFunctions","self","$cloudHosting","EVAL_WORKER_SYNC_ACTION","EVAL_WORKER_ASYNC_ACTION","MAIN_THREAD_ACTION","_objectSpread","CE_MAIN_THREAD_ACTION","LOG_JS_FUNCTION_EXECUTION","cloudHosting","platformFns","navigateTo","showAlert","showModal","closeModal","download","postWindowMessage","copyToClipboard","resetWidget","storeValue","removeValue","clearStore","isAsyncGuard","run","bind","clear","getGeoLocation","watchGeoLocation","stopWatchGeoLocation","getActionTriggerFunctionNames","ActionTriggerFunctionNames","CLEAR_INTERVAL","CLEAR_PLUGIN_ACTION","CLOSE_MODAL","COPY_TO_CLIPBOARD","DOWNLOAD","NAVIGATE_TO","RESET_WIDGET_META_RECURSIVE_BY_NAME","RUN_PLUGIN_ACTION","SET_INTERVAL","SHOW_ALERT","SHOW_MODAL_BY_NAME","STORE_VALUE","REMOVE_VALUE","CLEAR_STORE","GET_CURRENT_LOCATION","WATCH_CURRENT_LOCATION","STOP_WATCHING_CURRENT_LOCATION","POST_MESSAGE","SET_TIMEOUT","CLEAR_TIMEOUT","EvaluationSubstitutionType","OverridingPropertyType","isDynamicValue","test","getDynamicStringSegments","dynamicString","stringSegments","indexOfDoubleParanStart","firstString","push","rest","sum","i","char","prevChar","EvalErrorTypes","getDynamicBindings","_","jsSnippets","paths","sanitisedString","trim","map","segment","PropertyEvaluationErrorType","getEntityDynamicBindingPathList","dynamicBindingPathList","Array","isArray","_toConsumableArray","isPathADynamicBinding","undefined","key","widget","dynamicTriggerPathList","EVALUATION_PATH","_PropertyEvalErrorTyp","VALIDATION","PARSE","LINT","MessageType","sendMessage","message","this","postMessage","Types","isPromise","Boolean","then","DOM_APIS","keys","documentMock","reduce","acc","UNDEFINED_ACTION_IN_SYNC_EVAL_ERROR","errorModifier","ErrorModifier","_classCallCheck","errorNamesToScan","asyncFunctionsNameMap","_createClass","error","errorMessage","getErrorMessage","includes","_Object$keys","asyncFunctionFullPath","functionNameWithWhiteSpace","getErrorMessageWithType","match","replaceAll","FoundPromiseInSyncEvalError","_Error","_inherits","_super","_createSuper","_this","_wrapNativeSuper","Error","ActionCalledInSyncFieldError","_Error2","_super2","actionName","_this2","_possibleConstructorReturn","EvaluationScriptType","ScriptTemplate","EvaluationScripts","_EvaluationScripts","EXPRESSION","ANONYMOUS_FUNCTION","ASYNC_ANONYMOUS_FUNCTION","TRIGGERS","topLevelWorkerAPIs","resetWorkerGlobalScope","$isDataField","_loop","JSLibraries","find","lib","accessor","libraryReservedIdentifiers","getScriptType","evalArgumentsExist","arguments","scriptType","getScriptToEval","userScript","type","buffer","split","beginsWithLineBreakRegex","createEvaluationContext","context","evalArguments","resolvedFunctions","ARGUMENTS","THIS_CONTEXT","thisContext","globalContext","assignJSFunctionsToContext","_jsObjectNames","jsObjectName","resolvedObject","jsObject","jsObjectFunction","_Object$keys2","_jsObject$fnName","fnName","data","jsObjectFunctionFactory","getUserScriptToEvaluate","unescapedJS","js","trimmedJS","replace","evaluationVersion","unescapeJS","sanitizeScript","script","evaluateSync","isJSCollection","result","errors","evalContext","triggers","indirectEval","Promise","severity","raw","errorType","originalBinding","hasOwnProperty","UserLog","isEnabled","emitter","getSource","triggerMeta","_triggerMeta$source","_triggerMeta$source2","_triggerMeta$source3","source","entityType","triggerPropertyName","id","method","_this$emitter","parsed","parseLogs","emit","TriggerEmitter","_console","debug","info","log","table","warn","_len","_key","saveLog","_len2","_key2","apply","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","replaceFunctionWithNamesFromObjects","JSON","stringify","uuid4","timestamp","moment","format","output","INFO","stack","ExecutionMetaData","getExecutionMetaData","sanitizeData","klona","userLogs","setInterval","clearInterval","Map","responseHandler","requestId","resolve","addEventListener","listener","event","_event$data","body","messageId","messageType","RESPONSE","removeEventListener","WorkerMessenger","_request","_asyncToGenerator","_regeneratorRuntime","mark","_callee","payload","response","wrap","_context","prev","next","uniqueId","REQUEST","sent","abrupt","stop","_x","DEFAULT","timeTaken","toFixed","CLONE_ERROR","JAVASCRIPT_KEYWORDS","APPSMITH_GLOBAL_FUNCTIONS","DEDICATED_WORKER_GLOBAL_SCOPE_IDENTIFIERS","FunctionDeterminer","$isAsync","disable","enable","userFunction","logs","constructor","returnValue","dataTreeEvaluator","MAX_ALLOWED_LINE_BREAKS","LINE_BREAKS_ERROR_MESSAGE","flat","array","uniqueParam","forEach","a","children","validatePlainObject","config","props","_config$params","params","allowedKeys","_config$params2","_valid","_messages","entry","_entry$params","_entry$params2","_entry$params3","ignoreCase","entryName","obj","getOwnPropertyNames","toLowerCase","getPropertyEntry","_validate","validate","isValid","messages","required","requiredKey","default","validateArray","_config$params3","_config$params4","_config$params4$child","_config$params4$child2","_config$params5","_config$params5$child","_config$params6","_config$params7","_config$params8","_config$params9","_config$params12","_isValid","allowedValues","Set","uniqueKeys","allowedKeyConfigs","ValidationTypes","OBJECT","compact","allowedKeyConfig","_allowedKeyConfig$par","unique","_config$params11","childrenValidationConfig","shouldVerifyAllowedValues","size","shouldValidateChildren","shouldArrayHaveUniqueEntries","shouldArrayValuesHaveUniqueValuesForKeys","_config$params10","duplicateIndex","findDuplicateIndex","b","some","join","every","index","has","_childValidationResul","childValidationResult","validateExcessLineBreaks","str","isObject","countOccurrences","validateObjectValues","validateFn","VALIDATORS","staticValue","WIDGET_TYPE_VALIDATION_ERROR","getExpectedType","_config$params13","_config$params13$expe","_config$params14","_config$params15","_config$params17","_config$params17$expe","_config$params18","_config$params19","_config$params21","_config$params23","_config$params24","_config$params26","_config$params28","FUNCTION","expected","TEXT","_config$params16","allowed","regex","REGEX","DATE_ISO_STRING","BOOLEAN","NUMBER","_config$params20","_config$params22","validationType","min","max","_config$params25","objectType","_expected","ARRAY","NESTED_OBJECT_ARRAY","_config$params27","OBJECT_ARRAY","IMAGE_URL","SAFE_URL","_VALIDATORS","_config$params31","_config$params33","_config$params36","_config$params37","_config$params38","_config$params30","_config$params29","limitLineBreaks","_config$params34","_config$params35","_parsed","text","maxLength","_config$params39","isString","stringValidationError","_config$params32","strict","isRegExp","_VALIDATORS$Validatio","RegExp","_config$params45","_config$params46","_config$params47","_config$params40","_config$params41","_config$params42","_config$params43","Number","isFinite","_ref","_parsed2","_config$params44","passThroughOnZero","natural","isInteger","_config$params50","_config$params48","_config$params49","_config$params51","isStringTrueFalse","_config$params53","_config$params52","isPlainObject","_config$params54","parse","_config$params55","_config$params56","_config$params57","_config$params58","invalidResponse","_value","_config$params59","_config$params60","_config$params61","_config$params62","_config$params63","_step$value","parsedEntry","_config$params64","_config$params65","_config$params66","_config$params67","_step2","_iterator2","param","flattenedArray","shouldBeUnique","get","uniq","_config$params68","_config$params69","toISOString","_config$params70","_config$params71","_config$params72","fnString","evaluate","_config$params73","btoa","atob","_config$params74","getIsSafeURL","ARRAY_OF_TYPE_OR_TYPE","_config$params75","_config$params76","_config$params76$para","resultValue","LINT_WORKER_ACTIONS","onmessage","requestData","LINT_TREE","lintTreeResponse","_ref2","pathsToLint","unevalTree","lintErrors","getlintErrorsFromTree","UPDATE_LINT_GLOBALS","add","libs","idx","findIndex","l","isEqual","sort","v","splice","_ret","resetJSLibraries","startTime","performance","now","responseData","endTime","unEvalTree","lintTreeErrors","platformFnNamesMap","values","evalContextWithOutFunctions","triggerPaths","bindingPathsRequiringFunctions","fullPropertyPath","_getEntityNameAndProp","unEvalPropertyValue","pathRequiresLinting","lintBindingPath","triggerPath","globalData","getLintingErrors","lintTriggerPath","dynamicBinding","startsWith","errorSegment","line","ch","variables","_getDynamicBindings","jsSnippet","jsSnippetToLint","getJSToLint","lintErrorsFromSnippet","snippet","EvaluationScriptPositions","getEvaluationScriptPosition","isEmpty","lines","slice","lastLine","last","getPositionInEvaluationScript","scriptPos","dataKey","apiName","options","indent","esversion","ECMA_VERSION","eqeqeq","curly","freeze","undef","forin","noempty","unused","asi","boss","evil","funcscope","sub","expr","browser","worker","mocha","globals","loopfunc","jshint","jshintErrors","lintError","matchedLines","lineNumbersInErrorMessage","isInvalidErrorMessage","lineStatement","digitString","digit","isNumber","from","lineNumber","getValidLintErrors","character","evidence","c","d","invalidPropertyErrors","invalidTopLevelMemberExpressions","extractInvalidTopLevelMemberExpressionsFromCode","object","property","isLiteralNode","objectStartLine","loc","start","propertyStartColumn","column","getInvalidPropertyErrorsFromScript","SourceType","NodeTypes","exports","String","fromCodePoint","defineProperty","$defineProperty","stringFromCharCode","fromCharCode","floor","Math","highSurrogate","lowSurrogate","MAX_SIZE","codeUnits","codePoint","RangeError","jsEscapeRegex","usualEscapeSequences","fromHex","parseInt","string","__","varHex","longHex","shortHex","octal","specialCharacter","python","module","jsObjectVariableName","jsObjectDeclaration","isIdentifierNode","node","isMemberExpressionNode","isVariableDeclarator","isFunctionDeclaration","isFunctionExpression","isArrowFunctionExpression","isObjectExpression","isAssignmentPatternNode","isPropertyAFunctionNode","isArrayAccessorNode","computed","lodash","wrapCode","getFunctionalParamNamesFromNode","getFunctionalParamsFromNode","functionalParam","paramName","getAST","memoize","acorn","ecmaVersion","needValue","functionalParams","paramNode","defaultValue","left","constructFinalMemberExpIdentifier","child","propertyAccessor","getPropertyAccessor","nestedChild","propertyNode","ancestorWalk","ast","identifierList","references","variableDeclarations","acornWalk","ancestor","Identifier","ancestors","candidateTopLevelNode","depth","parent","optional","parentNode","memberExpIdentifier","VariableDeclarator","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","jsObjectToCode","jsCodeToObject","end","sanitizedScript","wrappedCode","locations","SyntaxError","simple","MemberExpression","filter","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","loaded","__webpack_modules__","m","x","__webpack_exports__","O","deferred","chunkIds","priority","notFulfilled","Infinity","fulfilled","j","r","getter","__esModule","definition","o","enumerable","chunkId","all","promises","u","miniCssF","g","globalThis","Function","window","prop","Symbol","toStringTag","nmd","p","oldGetScript","oldLoadScript","queryMap","countMap","catch","retries","realSrc","request","location","href","retryAttempt","setTimeout","cacheBust","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","moreModules","runtime","pop"],"sourceRoot":""}