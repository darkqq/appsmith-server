{"version":3,"file":"static/js/evalWorker.d8f5bff3.chunk.js","mappings":"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","sources":["ce/workers/Evaluation/evaluationUtils.ts","ce/workers/common/types.ts","components/editorComponents/CodeEditor/constants.ts","components/formControls/utils.ts","constants/AppsmithActionConstants/ActionConstants.tsx","constants/BindingsConstants.ts","ce/workers/Evaluation/Actions.ts","ce/workers/Evaluation/dataTreeUtils.ts","ce/workers/Evaluation/evalWorkerActions.ts","ee/workers/Evaluation/evalWorkerActions.ts","workers/Evaluation/fns/index.ts","entities/DataTree/types.ts","entities/Replay/index.ts","entities/Replay/replayUtils.ts","utils/DynamicBindingUtils.ts","utils/MessageUtil.ts","utils/TypeHelpers.ts","workers/Evaluation/JSObject/utils.ts","workers/Evaluation/SetupDOM.ts","workers/Evaluation/errorModifier.ts","workers/Evaluation/evaluate.ts","workers/Evaluation/handlers/evalTrigger.ts","ce/constants/messages.ts","workers/common/JSLibrary/ternDefinitionGenerator.ts","workers/Evaluation/handlers/jsLibrary.ts","entities/Replay/ReplayEntity/ReplayEditor.ts","workers/Evaluation/fns/overrides/timeout.ts","workers/Evaluation/fns/overrides/fetch.ts","workers/Evaluation/fns/overrides/localStorage.ts","workers/Evaluation/fns/overrides/index.ts","workers/Evaluation/handlers/index.ts","workers/Evaluation/handlers/evalActionBindings.ts","workers/Evaluation/handlers/executeSyncJS.ts","workers/Evaluation/handlers/replay.ts","workers/Evaluation/handlers/validateProperty.ts","workers/Evaluation/handlers/setupEvalEnv.ts","workers/Evaluation/handlers/initFormEval.ts","workers/Evaluation/handlers/evalExpression.ts","workers/Evaluation/evaluation.worker.ts","workers/Evaluation/fns/overrides/console.ts","workers/Evaluation/fns/overrides/interval.ts","workers/Evaluation/fns/utils/Messenger.ts","workers/Evaluation/fns/utils/fnGuard.ts","workers/Evaluation/formEval.ts","entities/Replay/ReplayEntity/ReplayCanvas.ts","workers/Evaluation/evaluationSubstitution.ts","workers/common/DependencyMap/utils.ts","workers/common/DependencyMap/index.ts","workers/Evaluation/functionDeterminer.ts","workers/Evaluation/JSObject/index.ts","workers/Evaluation/handlers/evalTree.ts","workers/common/DataTreeEvaluator/index.ts","workers/Evaluation/validations.ts","workers/Linting/utils.ts","workers/common/DataTreeEvaluator/utils.ts","workers/common/DataTreeEvaluator/validationUtils.ts","../../shared/ast/src/constants/ast.ts","../../shared/ast/node_modules/string.fromcodepoint/fromcodepoint.js","../../shared/ast/node_modules/unescape-js/dist/index.js","../../shared/ast/src/utils.ts","../../shared/ast/src/jsObject/index.ts","../../shared/ast/src/index.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/harmony module decorator","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/compat","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import {\n  DependencyMap,\n  EVAL_ERROR_PATH,\n  EvaluationError,\n  isChildPropertyPath,\n  isDynamicValue,\n  PropertyEvaluationErrorType,\n  isPathDynamicTrigger,\n} from \"utils/DynamicBindingUtils\";\nimport { Diff } from \"deep-diff\";\nimport {\n  DataTree,\n  DataTreeAction,\n  DataTreeAppsmith,\n  DataTreeEntity,\n  DataTreeWidget,\n  ENTITY_TYPE,\n  DataTreeJSAction,\n} from \"entities/DataTree/dataTreeFactory\";\n\nimport _, { difference, find, get, has, set } from \"lodash\";\nimport { WidgetTypeConfigMap } from \"utils/WidgetFactory\";\nimport { PluginType } from \"entities/Action\";\nimport { klona } from \"klona/full\";\nimport { warn as logWarn } from \"loglevel\";\nimport { EvalMetaUpdates } from \"@appsmith/workers/common/DataTreeEvaluator/types\";\nimport { isObject } from \"lodash\";\nimport { DataTreeObjectEntity } from \"entities/DataTree/dataTreeFactory\";\nimport { validateWidgetProperty } from \"workers/common/DataTreeEvaluator/validationUtils\";\nimport { PrivateWidgets } from \"entities/DataTree/types\";\nimport { EvalProps } from \"workers/common/DataTreeEvaluator\";\n\n// Dropdown1.options[1].value -> Dropdown1.options[1]\n// Dropdown1.options[1] -> Dropdown1.options\n// Dropdown1.options -> Dropdown1\nexport const IMMEDIATE_PARENT_REGEX = /^(.*)(\\..*|\\[.*\\])$/;\n\nexport enum DataTreeDiffEvent {\n  NEW = \"NEW\",\n  DELETE = \"DELETE\",\n  EDIT = \"EDIT\",\n  NOOP = \"NOOP\",\n}\n\nexport type DataTreeDiff = {\n  payload: {\n    propertyPath: string;\n    value?: string;\n  };\n  event: DataTreeDiffEvent;\n};\n\nexport class CrashingError extends Error {}\n\nexport const convertPathToString = (arrPath: Array<string | number>) => {\n  let string = \"\";\n  arrPath.forEach((segment) => {\n    if (isInt(segment)) {\n      string = string + \"[\" + segment + \"]\";\n    } else {\n      if (string.length !== 0) {\n        string = string + \".\";\n      }\n      string = string + segment;\n    }\n  });\n  return string;\n};\n\n// Todo: improve the logic here\n// Right now NaN, Infinity, floats, everything works\nfunction isInt(val: string | number): boolean {\n  return Number.isInteger(val) || (_.isString(val) && /^\\d+$/.test(val));\n}\n\n// Removes the entity name from the property path\nexport function getEntityNameAndPropertyPath(\n  fullPath: string,\n): {\n  entityName: string;\n  propertyPath: string;\n} {\n  const indexOfFirstDot = fullPath.indexOf(\".\");\n  if (indexOfFirstDot === -1) {\n    // No dot was found so path is the entity name itself\n    return {\n      entityName: fullPath,\n      propertyPath: \"\",\n    };\n  }\n  const entityName = fullPath.substring(0, indexOfFirstDot);\n  const propertyPath = fullPath.substring(indexOfFirstDot + 1);\n  return { entityName, propertyPath };\n}\n\nfunction translateCollectionDiffs(\n  propertyPath: string,\n  data: unknown,\n  event: DataTreeDiffEvent,\n) {\n  const dataTreeDiffs: DataTreeDiff[] = [];\n  if (Array.isArray(data)) {\n    data.forEach((diff, idx) => {\n      dataTreeDiffs.push({\n        event,\n        payload: {\n          propertyPath: `${propertyPath}[${idx}]`,\n        },\n      });\n    });\n  } else if (isTrueObject(data)) {\n    Object.keys(data).forEach((diffKey) => {\n      const path = `${propertyPath}.${diffKey}`;\n      dataTreeDiffs.push({\n        event,\n        payload: {\n          propertyPath: path,\n        },\n      });\n    });\n  }\n  return dataTreeDiffs;\n}\n\n//these paths are not required to go through evaluate tree as these are internal properties\nconst ignorePathsForEvalRegex =\n  \".(reactivePaths|bindingPaths|triggerPaths|validationPaths|dynamicBindingPathList)\";\n\n//match if paths are part of ignorePathsForEvalRegex\nconst isUninterestingChangeForDependencyUpdate = (path: string) => {\n  return path.match(ignorePathsForEvalRegex);\n};\n\nexport const translateDiffEventToDataTreeDiffEvent = (\n  difference: Diff<any, any>,\n  unEvalDataTree: DataTree,\n): DataTreeDiff | DataTreeDiff[] => {\n  let result: DataTreeDiff | DataTreeDiff[] = {\n    payload: {\n      propertyPath: \"\",\n      value: \"\",\n    },\n    event: DataTreeDiffEvent.NOOP,\n  };\n  if (!difference.path) {\n    return result;\n  }\n  const propertyPath = convertPathToString(difference.path);\n\n  // add propertyPath to NOOP event\n  result.payload = {\n    propertyPath,\n    value: \"\",\n  };\n\n  //we do not need evaluate these paths because these are internal paths\n  const isUninterestingPathForUpdateTree = isUninterestingChangeForDependencyUpdate(\n    propertyPath,\n  );\n  if (!!isUninterestingPathForUpdateTree) {\n    return result;\n  }\n  const { entityName } = getEntityNameAndPropertyPath(propertyPath);\n  const entity = unEvalDataTree[entityName];\n  const isJsAction = isJSAction(entity);\n  switch (difference.kind) {\n    case \"N\": {\n      result.event = DataTreeDiffEvent.NEW;\n      result.payload = {\n        propertyPath,\n      };\n      break;\n    }\n    case \"D\": {\n      result.event = DataTreeDiffEvent.DELETE;\n      result.payload = { propertyPath };\n      break;\n    }\n    case \"E\": {\n      const rhsChange =\n        typeof difference.rhs === \"string\" &&\n        (isDynamicValue(difference.rhs) || isJsAction);\n\n      const lhsChange =\n        typeof difference.lhs === \"string\" &&\n        (isDynamicValue(difference.lhs) || isJsAction);\n\n      if (rhsChange || lhsChange) {\n        result = [\n          {\n            event: DataTreeDiffEvent.EDIT,\n            payload: {\n              propertyPath,\n              value: difference.rhs,\n            },\n          },\n        ];\n        /**\n         * If lhs is an array/object\n         * Add delete events for all memberExpressions\n         */\n\n        const dataTreeDeleteDiffs = translateCollectionDiffs(\n          propertyPath,\n          difference.lhs,\n          DataTreeDiffEvent.DELETE,\n        );\n        result = result.concat(dataTreeDeleteDiffs);\n      } else if (difference.lhs === undefined || difference.rhs === undefined) {\n        // Handle static value changes that change structure that can lead to\n        // old bindings being eligible\n        if (\n          difference.lhs === undefined &&\n          (isTrueObject(difference.rhs) || Array.isArray(difference.rhs))\n        ) {\n          result.event = DataTreeDiffEvent.NEW;\n          result.payload = { propertyPath };\n        }\n        if (\n          difference.rhs === undefined &&\n          (isTrueObject(difference.lhs) || Array.isArray(difference.lhs))\n        ) {\n          result = [\n            {\n              event: DataTreeDiffEvent.EDIT,\n              payload: {\n                propertyPath,\n                value: difference.rhs,\n              },\n            },\n          ];\n\n          const dataTreeDeleteDiffs = translateCollectionDiffs(\n            propertyPath,\n            difference.lhs,\n            DataTreeDiffEvent.DELETE,\n          );\n\n          result = dataTreeDeleteDiffs.concat(result);\n        }\n      } else if (\n        isTrueObject(difference.lhs) &&\n        !isTrueObject(difference.rhs)\n      ) {\n        // This will happen for static value changes where a property went\n        // from being an object to any other type like string or number\n        // in such a case we want to delete all nested paths of the\n        // original lhs object\n\n        result = translateCollectionDiffs(\n          propertyPath,\n          difference.lhs,\n          DataTreeDiffEvent.DELETE,\n        );\n\n        // when an object is being replaced by an array\n        // list all new array accessors that are being added\n        // so dependencies will be created based on existing bindings\n        if (Array.isArray(difference.rhs)) {\n          result = result.concat(\n            translateCollectionDiffs(\n              propertyPath,\n              difference.rhs,\n              DataTreeDiffEvent.NEW,\n            ),\n          );\n        }\n      } else if (\n        !isTrueObject(difference.lhs) &&\n        isTrueObject(difference.rhs)\n      ) {\n        // This will happen for static value changes where a property went\n        // from being any other type like string or number to an object\n        // in such a case we want to add all nested paths of the\n        // new rhs object\n        result = translateCollectionDiffs(\n          propertyPath,\n          difference.rhs,\n          DataTreeDiffEvent.NEW,\n        );\n\n        // when an array is being replaced by an object\n        // remove all array accessors that are deleted\n        // so dependencies by existing bindings are removed\n        if (Array.isArray(difference.lhs)) {\n          result = result.concat(\n            translateCollectionDiffs(\n              propertyPath,\n              difference.lhs,\n              DataTreeDiffEvent.DELETE,\n            ),\n          );\n        }\n      }\n      break;\n    }\n    case \"A\": {\n      return translateDiffEventToDataTreeDiffEvent(\n        {\n          ...difference.item,\n          path: [...difference.path, difference.index],\n        },\n        unEvalDataTree,\n      );\n    }\n    default: {\n      break;\n    }\n  }\n  return result;\n};\n\nexport const translateDiffArrayIndexAccessors = (\n  propertyPath: string,\n  array: unknown[],\n  event: DataTreeDiffEvent,\n) => {\n  const result: DataTreeDiff[] = [];\n  array.forEach((data, index) => {\n    const path = `${propertyPath}[${index}]`;\n    result.push({\n      event,\n      payload: {\n        propertyPath: path,\n      },\n    });\n  });\n  return result;\n};\n/*\n  Table1.selectedRow\n  Table1.selectedRow.email: [\"Input1.defaultText\"]\n */\n\nexport const addDependantsOfNestedPropertyPaths = (\n  parentPaths: Array<string>,\n  inverseMap: DependencyMap,\n): Set<string> => {\n  const withNestedPaths: Set<string> = new Set();\n  const dependantNodes = Object.keys(inverseMap);\n  parentPaths.forEach((propertyPath) => {\n    withNestedPaths.add(propertyPath);\n    dependantNodes\n      .filter((dependantNodePath) =>\n        isChildPropertyPath(propertyPath, dependantNodePath),\n      )\n      .forEach((dependantNodePath) => {\n        inverseMap[dependantNodePath].forEach((path) => {\n          withNestedPaths.add(path);\n        });\n      });\n  });\n  return withNestedPaths;\n};\n\nexport function isWidget(\n  entity: Partial<DataTreeEntity>,\n): entity is DataTreeWidget {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.WIDGET\n  );\n}\n\nexport const shouldSuppressAutoComplete = (widget: DataTreeWidget) =>\n  Boolean(widget.suppressAutoComplete);\n\nexport const shouldSuppressDebuggerError = (widget: DataTreeWidget) =>\n  Boolean(widget.suppressDebuggerError);\n\nexport function isAction(\n  entity: Partial<DataTreeEntity>,\n): entity is DataTreeAction {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.ACTION\n  );\n}\n\nexport function isAppsmithEntity(\n  entity: DataTreeEntity,\n): entity is DataTreeAppsmith {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.APPSMITH\n  );\n}\n\nexport function isJSAction(entity: DataTreeEntity): entity is DataTreeJSAction {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.JSACTION\n  );\n}\n\nexport function isJSObject(entity: DataTreeEntity): entity is DataTreeJSAction {\n  return (\n    typeof entity === \"object\" &&\n    \"ENTITY_TYPE\" in entity &&\n    entity.ENTITY_TYPE === ENTITY_TYPE.JSACTION &&\n    \"pluginType\" in entity &&\n    entity.pluginType === PluginType.JS\n  );\n}\n\n// We need to remove functions from data tree to avoid any unexpected identifier while JSON parsing\n// Check issue https://github.com/appsmithorg/appsmith/issues/719\nexport const removeFunctions = (value: any) => {\n  if (_.isFunction(value)) {\n    return \"Function call\";\n  } else if (_.isObject(value)) {\n    return JSON.parse(\n      JSON.stringify(value, (_, v) =>\n        typeof v === \"bigint\" ? v.toString() : v,\n      ),\n    );\n  } else {\n    return value;\n  }\n};\n\nexport const makeParentsDependOnChildren = (\n  depMap: DependencyMap,\n  allkeys: Record<string, true>,\n): DependencyMap => {\n  //return depMap;\n  // Make all parents depend on child\n  Object.keys(depMap).forEach((key) => {\n    depMap = makeParentsDependOnChild(depMap, key, allkeys);\n    depMap[key].forEach((path) => {\n      depMap = makeParentsDependOnChild(depMap, path, allkeys);\n    });\n  });\n  return depMap;\n};\n\nexport const makeParentsDependOnChild = (\n  depMap: DependencyMap,\n  child: string,\n  allkeys: Record<string, true>,\n): DependencyMap => {\n  const result: DependencyMap = depMap;\n  let curKey = child;\n  if (!allkeys[curKey]) {\n    logWarn(\n      `makeParentsDependOnChild - ${curKey} is not present in dataTree.`,\n      \"This might result in a cyclic dependency.\",\n    );\n  }\n  let matches: Array<string> | null;\n  // Note: The `=` is intentional\n  // Stops looping when match is null\n  while ((matches = curKey.match(IMMEDIATE_PARENT_REGEX)) !== null) {\n    const parentKey = matches[1];\n    // Todo: switch everything to set.\n    const existing = new Set(result[parentKey] || []);\n    existing.add(curKey);\n    result[parentKey] = Array.from(existing);\n    curKey = parentKey;\n  }\n  return result;\n};\n\n// The idea is to find the immediate parents of the property paths\n// e.g. For Table1.selectedRow.email, the parent is Table1.selectedRow\nexport const getImmediateParentsOfPropertyPaths = (\n  propertyPaths: Array<string>,\n): Array<string> => {\n  // Use a set to ensure that we dont have duplicates\n  const parents: Set<string> = new Set();\n\n  propertyPaths.forEach((path) => {\n    const matches = path.match(IMMEDIATE_PARENT_REGEX);\n\n    if (matches !== null) {\n      parents.add(matches[1]);\n    }\n  });\n\n  return Array.from(parents);\n};\n\nexport const getAllPaths = (\n  records: any,\n  curKey = \"\",\n  result: Record<string, true> = {},\n): Record<string, true> => {\n  // Add the key if it exists\n  if (curKey) result[curKey] = true;\n  if (Array.isArray(records)) {\n    for (let i = 0; i < records.length; i++) {\n      const tempKey = curKey ? `${curKey}[${i}]` : `${i}`;\n      getAllPaths(records[i], tempKey, result);\n    }\n  } else if (typeof records === \"object\" && records) {\n    for (const key of Object.keys(records)) {\n      const tempKey = curKey ? `${curKey}.${key}` : `${key}`;\n      getAllPaths(records[key], tempKey, result);\n    }\n  }\n  return result;\n};\nexport const trimDependantChangePaths = (\n  changePaths: Set<string>,\n  dependencyMap: DependencyMap,\n): Array<string> => {\n  const trimmedPaths = [];\n  for (const path of changePaths) {\n    let foundADependant = false;\n    if (path in dependencyMap) {\n      const dependants = dependencyMap[path];\n      for (const dependantPath of dependants) {\n        if (changePaths.has(dependantPath)) {\n          foundADependant = true;\n          break;\n        }\n      }\n    }\n    if (!foundADependant) {\n      trimmedPaths.push(path);\n    }\n  }\n  return trimmedPaths;\n};\n\nexport function getSafeToRenderDataTree(\n  tree: DataTree,\n  widgetTypeConfigMap: WidgetTypeConfigMap,\n) {\n  return Object.keys(tree).reduce((tree, entityKey: string) => {\n    const entity = tree[entityKey] as DataTreeWidget;\n    if (!isWidget(entity)) {\n      return tree;\n    }\n    const safeToRenderEntity = { ...entity };\n    // Set user input values to their parsed values\n    Object.entries(entity.validationPaths).forEach(([property, validation]) => {\n      const value = _.get(entity, property);\n      // Pass it through parse\n      const { parsed } = validateWidgetProperty(\n        validation,\n        value,\n        entity,\n        property,\n      );\n      _.set(safeToRenderEntity, property, parsed);\n    });\n    // Set derived values to undefined or else they would go as bindings\n    Object.keys(widgetTypeConfigMap[entity.type].derivedProperties).forEach(\n      (property) => {\n        _.set(safeToRenderEntity, property, undefined);\n      },\n    );\n    return { ...tree, [entityKey]: safeToRenderEntity };\n  }, tree);\n}\n\nexport const addErrorToEntityProperty = ({\n  dataTree,\n  errors,\n  evalProps,\n  fullPropertyPath,\n}: {\n  errors: EvaluationError[];\n  dataTree: DataTree;\n  fullPropertyPath: string;\n  evalProps: EvalProps;\n}) => {\n  const { entityName, propertyPath } = getEntityNameAndPropertyPath(\n    fullPropertyPath,\n  );\n  const isPrivateEntityPath = getAllPrivateWidgetsInDataTree(dataTree)[\n    entityName\n  ];\n  const logBlackList = get(dataTree, `${entityName}.logBlackList`, {});\n  if (propertyPath && !(propertyPath in logBlackList) && !isPrivateEntityPath) {\n    const errorPath = `${entityName}.${EVAL_ERROR_PATH}['${propertyPath}']`;\n    const existingErrors = get(evalProps, errorPath, []) as EvaluationError[];\n    set(evalProps, errorPath, existingErrors.concat(errors));\n  }\n\n  return dataTree;\n};\n\nexport const resetValidationErrorsForEntityProperty = ({\n  evalProps,\n  fullPropertyPath,\n}: {\n  fullPropertyPath: string;\n  evalProps: EvalProps;\n}) => {\n  const { entityName, propertyPath } = getEntityNameAndPropertyPath(\n    fullPropertyPath,\n  );\n  if (propertyPath) {\n    const errorPath = `${entityName}.${EVAL_ERROR_PATH}['${propertyPath}']`;\n    const existingErrorsExceptValidation = (_.get(\n      evalProps,\n      errorPath,\n      [],\n    ) as EvaluationError[]).filter(\n      (error) => error.errorType !== PropertyEvaluationErrorType.VALIDATION,\n    );\n    _.set(evalProps, errorPath, existingErrorsExceptValidation);\n  }\n};\n\n// For the times when you need to know if something truly an object like { a: 1, b: 2}\n// typeof, lodash.isObject and others will return false positives for things like array, null, etc\nexport const isTrueObject = (\n  item: unknown,\n): item is Record<string, unknown> => {\n  return Object.prototype.toString.call(item) === \"[object Object]\";\n};\n\n/**\n * This function finds the datatype of the given value.\n * typeof, lodash and others will return false positives for things like array, wrapper objects, etc\n * @param value\n * @returns datatype of the received value as string\n */\nexport const findDatatype = (value: unknown) => {\n  return Object.prototype.toString\n    .call(value)\n    .slice(8, -1)\n    .toLowerCase();\n};\n\nexport const isDynamicLeaf = (unEvalTree: DataTree, propertyPath: string) => {\n  const [entityName, ...propPathEls] = _.toPath(propertyPath);\n  // Framework feature: Top level items are never leaves\n  if (entityName === propertyPath) return false;\n  // Ignore if this was a delete op\n  if (!unEvalTree.hasOwnProperty(entityName)) return false;\n\n  const entity = unEvalTree[entityName];\n  if (!isAction(entity) && !isWidget(entity) && !isJSAction(entity))\n    return false;\n  const relativePropertyPath = convertPathToString(propPathEls);\n  return (\n    relativePropertyPath in entity.reactivePaths ||\n    (isWidget(entity) && relativePropertyPath in entity.triggerPaths)\n  );\n};\n\nexport const addWidgetPropertyDependencies = ({\n  entity,\n  entityName,\n}: {\n  entity: DataTreeWidget;\n  entityName: string;\n}) => {\n  const dependencies: DependencyMap = {};\n\n  Object.entries(entity.propertyOverrideDependency).forEach(\n    ([overriddenPropertyKey, overridingPropertyKeyMap]) => {\n      const existingDependenciesSet = new Set(\n        dependencies[`${entityName}.${overriddenPropertyKey}`] || [],\n      );\n      // add meta dependency\n      overridingPropertyKeyMap.META &&\n        existingDependenciesSet.add(\n          `${entityName}.${overridingPropertyKeyMap.META}`,\n        );\n      // add default dependency\n      overridingPropertyKeyMap.DEFAULT &&\n        existingDependenciesSet.add(\n          `${entityName}.${overridingPropertyKeyMap.DEFAULT}`,\n        );\n\n      dependencies[`${entityName}.${overriddenPropertyKey}`] = [\n        ...existingDependenciesSet,\n      ];\n    },\n  );\n  return dependencies;\n};\n\nexport const isPrivateEntityPath = (\n  privateWidgets: PrivateWidgets,\n  fullPropertyPath: string,\n) => {\n  const entityName = fullPropertyPath.split(\".\")[0];\n  if (Object.keys(privateWidgets).indexOf(entityName) !== -1) {\n    return true;\n  }\n  return false;\n};\n\nexport const getAllPrivateWidgetsInDataTree = (\n  dataTree: DataTree,\n): PrivateWidgets => {\n  let privateWidgets: PrivateWidgets = {};\n\n  Object.keys(dataTree).forEach((entityName) => {\n    const entity = dataTree[entityName];\n    if (isWidget(entity) && !_.isEmpty(entity.privateWidgets)) {\n      privateWidgets = { ...privateWidgets, ...entity.privateWidgets };\n    }\n  });\n\n  return privateWidgets;\n};\n\nexport const getDataTreeWithoutPrivateWidgets = (\n  dataTree: DataTree,\n): DataTree => {\n  const privateWidgets = getAllPrivateWidgetsInDataTree(dataTree);\n  const privateWidgetNames = Object.keys(privateWidgets);\n  const treeWithoutPrivateWidgets = _.omit(dataTree, privateWidgetNames);\n  return treeWithoutPrivateWidgets;\n};\n\nconst getDataTreeWithoutSuppressedAutoComplete = (\n  dataTree: DataTree,\n): DataTree => {\n  const entityIds = Object.keys(dataTree).filter((entityName) => {\n    const entity = dataTree[entityName];\n    return isWidget(entity) && shouldSuppressAutoComplete(entity);\n  });\n\n  return _.omit(dataTree, entityIds);\n};\n\nexport const getDataTreeForAutocomplete = (dataTree: DataTree): DataTree => {\n  const treeWithoutPrivateWidgets = getDataTreeWithoutPrivateWidgets(dataTree);\n  const treeWithoutSuppressedAutoComplete = getDataTreeWithoutSuppressedAutoComplete(\n    treeWithoutPrivateWidgets,\n  );\n\n  return treeWithoutSuppressedAutoComplete;\n};\n\n/**\n *  overrideWidgetProperties method has logic to update overriddenPropertyPaths when overridingPropertyPaths are evaluated.\n *\n *  when we evaluate widget's overridingPropertyPaths for example defaultText of input widget,\n *  we override the values like text and meta.text in dataTree, these values are called as overriddenPropertyPaths\n *\n * @param {{\n *   entity: DataTreeWidget;\n *   propertyPath: string;\n *   value: unknown;\n *   currentTree: DataTree;\n *   evalMetaUpdates: EvalMetaUpdates;\n * }} params\n * @return {*}\n */\nexport const overrideWidgetProperties = (params: {\n  entity: DataTreeWidget;\n  propertyPath: string;\n  value: unknown;\n  currentTree: DataTree;\n  evalMetaUpdates: EvalMetaUpdates;\n  isNewWidget: boolean;\n}) => {\n  const {\n    currentTree,\n    entity,\n    evalMetaUpdates,\n    isNewWidget,\n    propertyPath,\n    value,\n  } = params;\n  const clonedValue = klona(value);\n  if (propertyPath in entity.overridingPropertyPaths) {\n    const overridingPropertyPaths =\n      entity.overridingPropertyPaths[propertyPath];\n\n    const pathsNotToOverride = widgetPathsNotToOverride(\n      isNewWidget,\n      entity,\n      propertyPath,\n    );\n\n    overridingPropertyPaths.forEach((overriddenPropertyPath) => {\n      const overriddenPropertyPathArray = overriddenPropertyPath.split(\".\");\n      if (pathsNotToOverride.includes(overriddenPropertyPath)) return;\n      _.set(\n        currentTree,\n        [entity.widgetName, ...overriddenPropertyPathArray],\n        clonedValue,\n      );\n      // evalMetaUpdates has all updates from property which overrides meta values.\n      if (\n        propertyPath.split(\".\")[0] !== \"meta\" &&\n        overriddenPropertyPathArray[0] === \"meta\"\n      ) {\n        const metaPropertyPath = overriddenPropertyPathArray.slice(1);\n        evalMetaUpdates.push({\n          widgetId: entity.widgetId,\n          metaPropertyPath,\n          value: clonedValue,\n        });\n      }\n    });\n  } else if (\n    propertyPath in entity.propertyOverrideDependency &&\n    clonedValue === undefined\n  ) {\n    // When a reset a widget its meta value becomes undefined, ideally they should reset to default value.\n    // below we handle logic to reset meta values to default values.\n    const propertyOverridingKeyMap =\n      entity.propertyOverrideDependency[propertyPath];\n    if (propertyOverridingKeyMap.DEFAULT) {\n      const defaultValue = entity[propertyOverridingKeyMap.DEFAULT];\n      const clonedDefaultValue = klona(defaultValue);\n      if (defaultValue !== undefined) {\n        const propertyPathArray = propertyPath.split(\".\");\n        _.set(\n          currentTree,\n          [entity.widgetName, ...propertyPathArray],\n          clonedDefaultValue,\n        );\n\n        return {\n          overwriteParsedValue: true,\n          newValue: clonedDefaultValue,\n        };\n      }\n    }\n  }\n};\nexport function isValidEntity(\n  entity: DataTreeEntity,\n): entity is DataTreeObjectEntity {\n  if (!isObject(entity)) {\n    return false;\n  }\n  return \"ENTITY_TYPE\" in entity;\n}\nexport const isATriggerPath = (\n  entity: DataTreeEntity,\n  propertyPath: string,\n) => {\n  return isWidget(entity) && isPathDynamicTrigger(entity, propertyPath);\n};\n\n// Checks if entity newly got added to the unevalTree\nexport const isNewEntity = (updates: DataTreeDiff[], entityName: string) => {\n  return !!find(updates, {\n    event: DataTreeDiffEvent.NEW,\n    payload: { propertyPath: entityName },\n  });\n};\n\nconst widgetPathsNotToOverride = (\n  isNewWidget: boolean,\n  entity: DataTreeWidget,\n  propertyPath: string,\n) => {\n  let pathsNotToOverride: string[] = [];\n  const overriddenPropertyPaths = entity.overridingPropertyPaths[propertyPath];\n\n  // Check if widget has pre-existing meta values (although newly added to the unevalTree)\n  if (isNewWidget && entity.isMetaPropDirty) {\n    const overriddenMetaPaths = overriddenPropertyPaths.filter(\n      (path) => path.split(\".\")[0] === \"meta\",\n    );\n    // If widget is newly added but has pre-existing meta values, this meta values take precedence and should not be overridden\n    pathsNotToOverride = [...overriddenMetaPaths];\n    // paths which these meta values override should also not get overridden\n    overriddenMetaPaths.forEach((path) => {\n      if (entity.overridingPropertyPaths.hasOwnProperty(path)) {\n        pathsNotToOverride = [\n          ...pathsNotToOverride,\n          ...entity.overridingPropertyPaths[path],\n        ];\n      }\n    });\n  }\n  return pathsNotToOverride;\n};\n\nconst isWidgetDefaultPropertyPath = (\n  widget: DataTreeWidget,\n  propertyPath: string,\n) => {\n  for (const property of Object.keys(widget.propertyOverrideDependency)) {\n    const overrideDependency = widget.propertyOverrideDependency[property];\n    if (overrideDependency.DEFAULT === propertyPath) return true;\n  }\n  return false;\n};\n\nconst isMetaWidgetTemplate = (widget: DataTreeWidget) => {\n  return !!widget.siblingMetaWidgets;\n};\n\n// When a default value changes in a template(widgets used to generate other widgets), meta values of metaWidgets not present in the unevalTree become stale\nexport function getStaleMetaStateIds(args: {\n  entity: DataTreeWidget;\n  propertyPath: string;\n  isNewWidget: boolean;\n  metaWidgets: string[];\n}) {\n  const { entity, isNewWidget, metaWidgets, propertyPath } = args;\n  return !isNewWidget &&\n    isWidgetDefaultPropertyPath(entity, propertyPath) &&\n    isMetaWidgetTemplate(entity)\n    ? difference(entity.siblingMetaWidgets, metaWidgets)\n    : [];\n}\n\nexport function convertJSFunctionsToString(\n  jscollections: Record<string, DataTreeJSAction>,\n) {\n  const collections = klona(jscollections);\n  Object.keys(collections).forEach((collectionName) => {\n    const jsCollection = collections[collectionName];\n    const jsFunctions = jsCollection.meta;\n    for (const funcName in jsFunctions) {\n      if (jsCollection[funcName] instanceof String) {\n        if (has(jsCollection, [funcName, \"data\"])) {\n          set(jsCollection, [`${funcName}.data`], jsCollection[funcName].data);\n        }\n        set(jsCollection, funcName, jsCollection[funcName].toString());\n      }\n    }\n  });\n\n  return collections;\n}\n","export enum AppsmithWorkers {\n  LINT_WORKER = \"LINT_WORKER\",\n  EVALUATION_WORKER = \"EVALUATION_WORKER\",\n  SETUP_WORKER = \"SETUP_WORKER\",\n}\nexport enum WorkerErrorTypes {\n  CLONE_ERROR = \"CLONE_ERROR\",\n}\n\nexport interface WorkerRequest<TData, TActions> {\n  method: TActions;\n  data: TData;\n}\n","import { Position } from \"codemirror\";\n\n// For these error types, we want to show a warning\n// All messages can be found here => https://github.com/jshint/jshint/blob/2.9.5/src/messages.js\nexport const WARNING_LINT_ERRORS = {\n  W098: \"'{a}' is defined but never used.\",\n  W014:\n    \"Misleading line break before '{a}'; readers may interpret this as an expression boundary.\",\n};\n\n/** These errors should be overlooked\n * E041 => Unrecoverable syntax error.\n * W032 => Unnecessary semicolon.\n */\nexport const IGNORED_LINT_ERRORS = [\"E041\", \"W032\"];\n\n// https://github.com/jshint/jshint/blob/d3d84ae1695359aef077ddb143f4be98001343b4/src/messages.js#L204\nexport const IDENTIFIER_NOT_DEFINED_LINT_ERROR_CODE = \"W117\";\n\n// Refined error messages\nexport const REFINED_LINT_ERROR_MESSAGES: Record<string, string> = {\n  \"'await' is not defined.\":\n    \"'await' expressions are only allowed within async functions. Did you mean to mark this function as 'async'?\",\n};\n\nexport const LINT_TOOLTIP_CLASS = \"CodeMirror-lint-tooltip\";\nexport const LINT_TOOLTIP_JUSTIFIED_LEFT_CLASS = \"CodeMirror-lint-tooltip-left\";\nexport enum LintTooltipDirection {\n  left = \"left\",\n  right = \"right\",\n}\nexport const JS_OBJECT_START_STATEMENT = \"export default\";\nexport const INVALID_JSOBJECT_START_STATEMENT = `JSObject must start with '${JS_OBJECT_START_STATEMENT}'`;\nexport const CODE_EDITOR_START_POSITION: Position = { line: 0, ch: 0 };\nexport const VALID_JS_OBJECT_BINDING_POSITION: Position = {\n  line: 0,\n  ch: JS_OBJECT_START_STATEMENT.length,\n};\nexport const SUPPORTED_WEB_APIS = {\n  console: true,\n  crypto: true,\n};\nexport enum CustomLintErrorCode {\n  INVALID_ENTITY_PROPERTY = \"INVALID_ENTITY_PROPERTY\",\n}\nexport const CUSTOM_LINT_ERRORS: Record<\n  CustomLintErrorCode,\n  (...args: any[]) => string\n> = {\n  [CustomLintErrorCode.INVALID_ENTITY_PROPERTY]: (\n    entityName: string,\n    propertyName: string,\n  ) => `\"${propertyName}\" doesn't exist in ${entityName}`,\n};\n","import { DATA_BIND_REGEX_GLOBAL } from \"constants/BindingsConstants\";\nimport { isBoolean, get, set, isString } from \"lodash\";\nimport {\n  ConditionalOutput,\n  FormConfigEvalObject,\n  FormEvalOutput,\n} from \"reducers/evaluationReducers/formEvaluationReducer\";\nimport { FormConfigType, HiddenType } from \"./BaseControl\";\nimport { diff, Diff } from \"deep-diff\";\nimport { MongoDefaultActionConfig } from \"constants/DatasourceEditorConstants\";\nimport { Action } from \"@sentry/react/dist/types\";\nimport { klona } from \"klona/full\";\n\nexport const evaluateCondtionWithType = (\n  conditions: Array<boolean> | undefined,\n  type: string | undefined,\n) => {\n  if (conditions) {\n    let flag;\n    //this is where each conditions gets evaluated\n    if (conditions.length > 1) {\n      if (type === \"AND\") {\n        flag = conditions.reduce((acc: any, item: boolean) => {\n          return acc && item;\n        }, conditions[0]);\n      } else if (type === \"OR\") {\n        flag = conditions.reduce((acc: any, item: boolean) => {\n          return acc || item;\n        }, undefined);\n      }\n    } else {\n      flag = conditions[0];\n    }\n    return flag;\n  }\n};\n\nexport const isHiddenConditionsEvaluation = (\n  values: any,\n  hidden?: HiddenType,\n): any => {\n  if (!!hidden && !isBoolean(hidden)) {\n    //if nested condtions are there recursively from bottom to top call this function on each condtion\n    let conditionType, conditions;\n    if (\"conditionType\" in hidden) {\n      conditionType = hidden.conditionType;\n    }\n    if (\"conditions\" in hidden) {\n      conditions = hidden.conditions;\n    }\n    if (Array.isArray(conditions)) {\n      conditions = conditions.map((rule: any) => {\n        return isHiddenConditionsEvaluation(values, rule);\n      });\n    } else {\n      return caculateIsHidden(values, hidden);\n    }\n    return evaluateCondtionWithType(conditions, conditionType);\n  }\n};\n\nexport const caculateIsHidden = (\n  values: any,\n  hiddenConfig?: HiddenType,\n  featureFlag?: boolean,\n) => {\n  if (!!hiddenConfig && !isBoolean(hiddenConfig)) {\n    let valueAtPath;\n    let value, comparison;\n    if (\"path\" in hiddenConfig) {\n      valueAtPath = get(values, hiddenConfig.path);\n    }\n    if (\"value\" in hiddenConfig) {\n      value = hiddenConfig.value;\n    }\n    if (\"comparison\" in hiddenConfig) {\n      comparison = hiddenConfig.comparison;\n    }\n\n    switch (comparison) {\n      case \"EQUALS\":\n        return valueAtPath === value;\n      case \"NOT_EQUALS\":\n        return valueAtPath !== value;\n      case \"GREATER\":\n        return valueAtPath > value;\n      case \"LESSER\":\n        return valueAtPath < value;\n      case \"IN\":\n        return Array.isArray(value) && value.includes(valueAtPath);\n      case \"NOT_IN\":\n        return Array.isArray(value) && !value.includes(valueAtPath);\n      case \"FEATURE_FLAG\":\n        // FEATURE_FLAG comparision is used to hide previous configs,\n        // and show new configs if feature flag is enabled, if disabled/ not present,\n        // previous config would be shown as is\n        return featureFlag === value;\n      default:\n        return true;\n    }\n  }\n};\n\nexport const isHidden = (\n  values: any,\n  hiddenConfig?: HiddenType,\n  featureFlag?: boolean,\n) => {\n  if (!!hiddenConfig && !isBoolean(hiddenConfig)) {\n    if (\"conditionType\" in hiddenConfig) {\n      //check if nested conditions exist\n      return isHiddenConditionsEvaluation(values, hiddenConfig);\n    } else {\n      return caculateIsHidden(values, hiddenConfig, featureFlag);\n    }\n  }\n  return !!hiddenConfig;\n};\n\nexport enum ViewTypes {\n  JSON = \"json\",\n  COMPONENT = \"component\",\n}\n\nexport const alternateViewTypeInputConfig = () => {\n  return {\n    label: \"\",\n    isValid: true,\n    controlType: \"QUERY_DYNAMIC_INPUT_TEXT\",\n    evaluationSubstitutionType: \"TEMPLATE\",\n    inputType: \"TEXT_WITH_BINDING\",\n    // showLineNumbers: true,\n  };\n};\n\nexport const getViewType = (values: any, configProperty: string) => {\n  if (\n    configProperty.startsWith(\"actionConfiguration.formData\") &&\n    configProperty.endsWith(\".data\")\n  ) {\n    const pathForViewType = configProperty.replace(\".data\", \".viewType\");\n    return get(values, pathForViewType, ViewTypes.COMPONENT);\n  } else {\n    return ViewTypes.COMPONENT;\n  }\n};\n\nexport const switchViewType = (\n  values: any,\n  configProperty: string,\n  viewType: string,\n  formName: string,\n  changeFormValue: (formName: string, path: string, value: any) => void,\n) => {\n  const newViewType =\n    viewType === ViewTypes.JSON ? ViewTypes.COMPONENT : ViewTypes.JSON;\n  const pathForJsonData = configProperty.replace(\".data\", \".jsonData\");\n  const pathForComponentData = configProperty.replace(\n    \".data\",\n    \".componentData\",\n  );\n  const componentData = get(values, pathForComponentData);\n  const currentData = get(values, configProperty, \"\");\n  const stringifiedCurrentData = JSON.stringify(currentData, null, \"\\t\");\n\n  if (newViewType === ViewTypes.JSON) {\n    changeFormValue(formName, pathForComponentData, currentData);\n\n    // when switching to JSON, we always want a form to json conversion of the data.\n    changeFormValue(\n      formName,\n      configProperty,\n      isString(currentData)\n        ? currentData\n        : stringifiedCurrentData.replace(/\\\\/g, \"\"),\n    );\n  } else {\n    changeFormValue(formName, pathForJsonData, currentData);\n    if (!!componentData) {\n      changeFormValue(formName, configProperty, componentData);\n    }\n  }\n\n  changeFormValue(\n    formName,\n    configProperty.replace(\".data\", \".viewType\"),\n    newViewType,\n  );\n};\n\n// Function that extracts the initial value from the JSON configs\nexport const getConfigInitialValues = (\n  config: Record<string, any>[],\n  multipleViewTypesSupported = false,\n) => {\n  const configInitialValues: Record<string, any> = {};\n\n  // We expect the JSON configs to be an array of objects\n  if (!Array.isArray(config)) return configInitialValues;\n\n  // Function to loop through the configs and extract the initial values\n  const parseConfig = (section: any): any => {\n    if (\"initialValue\" in section) {\n      if (section.controlType === \"KEYVALUE_ARRAY\") {\n        section.initialValue.forEach(\n          (initialValue: string | number, index: number) => {\n            const configProperty = section.configProperty.replace(\"*\", index);\n\n            set(configInitialValues, configProperty, initialValue);\n          },\n        );\n      } else {\n        set(configInitialValues, section.configProperty, section.initialValue);\n      }\n    } else if (section.controlType === \"WHERE_CLAUSE\") {\n      let logicalTypes = [];\n      if (\"logicalTypes\" in section && section.logicalTypes.length > 0) {\n        logicalTypes = section.logicalTypes;\n      } else {\n        logicalTypes = [\n          {\n            label: \"OR\",\n            value: \"OR\",\n          },\n          {\n            label: \"AND\",\n            value: \"AND\",\n          },\n        ];\n      }\n      set(\n        configInitialValues,\n        `${section.configProperty}.condition`,\n        logicalTypes[0].value,\n      );\n      if (\n        multipleViewTypesSupported &&\n        section.configProperty.includes(\".data\")\n      ) {\n        set(\n          configInitialValues,\n          section.configProperty.replace(\".data\", \".viewType\"),\n          \"component\",\n        );\n        set(\n          configInitialValues,\n          section.configProperty.replace(\".data\", \".componentData.condition\"),\n          logicalTypes[0].value,\n        );\n      }\n    }\n    if (\"children\" in section) {\n      section.children.forEach((childSection: any) => {\n        parseConfig(childSection);\n      });\n    } else if (\"schema\" in section) {\n      section.schema.forEach((childSection: any) => {\n        parseConfig(childSection);\n      });\n    } else if (\n      \"configProperty\" in section &&\n      multipleViewTypesSupported &&\n      section.configProperty.includes(\".data\")\n    ) {\n      set(\n        configInitialValues,\n        section.configProperty.replace(\".data\", \".viewType\"),\n        \"component\",\n      );\n      if (section.configProperty in configInitialValues) {\n        set(\n          configInitialValues,\n          section.configProperty.replace(\".data\", \".componentData\"),\n          configInitialValues[section.configProperty],\n        );\n      }\n    }\n  };\n\n  config.forEach((section: any) => {\n    parseConfig(section);\n  });\n\n  return configInitialValues;\n};\n\nexport const actionPathFromName = (\n  actionName: string,\n  name: string,\n): string => {\n  const ActionConfigStarts = \"actionConfiguration.\";\n  let path = name;\n  if (path.startsWith(ActionConfigStarts)) {\n    path = \"config.\" + path.slice(ActionConfigStarts.length);\n  }\n  return `${actionName}.${path}`;\n};\n\nexport enum PaginationSubComponent {\n  Limit = \"limit\",\n  Offset = \"offset\",\n  Cursor = \"cursor\",\n}\n\nexport enum SortingSubComponent {\n  Column = \"column\",\n  Order = \"order\",\n}\n\nexport enum WhereClauseSubComponent {\n  Condition = \"condition\",\n  Children = \"children\",\n  Key = \"key\",\n  Value = \"value\",\n}\n\nexport const allowedControlTypes = [\"DROP_DOWN\", \"QUERY_DYNAMIC_INPUT_TEXT\"];\n\nconst extractExpressionObject = (\n  config: string,\n  path: any,\n  parentPath: string,\n): FormConfigEvalObject => {\n  const bindingPaths: FormConfigEvalObject = {};\n  const expressions = config.match(DATA_BIND_REGEX_GLOBAL);\n  if (Array.isArray(expressions) && expressions.length > 0) {\n    const completePath = parentPath.length > 0 ? `${parentPath}.${path}` : path;\n    expressions.forEach((exp) => {\n      bindingPaths[completePath] = {\n        expression: exp,\n        output: \"\",\n      };\n    });\n  }\n  return bindingPaths;\n};\n\nexport const extractEvalConfigFromFormConfig = (\n  formConfig: FormConfigType,\n  paths: string[],\n  parentPath = \"\",\n  bindingsFound: FormConfigEvalObject = {},\n) => {\n  paths.forEach((path: string) => {\n    if (!(path in formConfig)) return;\n    const config = get(formConfig, path, \"\");\n    if (typeof config === \"string\") {\n      bindingsFound = {\n        ...bindingsFound,\n        ...extractExpressionObject(config, path, parentPath),\n      };\n    } else if (typeof config === \"object\") {\n      bindingsFound = {\n        ...bindingsFound,\n        ...extractEvalConfigFromFormConfig(\n          config,\n          Object.keys(config),\n          parentPath.length > 0 ? `${parentPath}.${path}` : path,\n          bindingsFound,\n        ),\n      };\n    }\n  });\n\n  return bindingsFound;\n};\n\n// Extract the output of conditionals attached to the form from the state\nexport const extractConditionalOutput = (\n  section: any,\n  formEvaluationState: FormEvalOutput,\n): ConditionalOutput => {\n  let conditionalOutput: ConditionalOutput = {};\n  if (\n    section.hasOwnProperty(\"propertyName\") &&\n    formEvaluationState.hasOwnProperty(section.propertyName)\n  ) {\n    conditionalOutput = formEvaluationState[section.propertyName];\n  } else if (\n    section.hasOwnProperty(\"configProperty\") &&\n    formEvaluationState.hasOwnProperty(section.configProperty)\n  ) {\n    conditionalOutput = formEvaluationState[section.configProperty];\n  } else if (\n    section.hasOwnProperty(\"identifier\") &&\n    !!section.identifier &&\n    formEvaluationState.hasOwnProperty(section.identifier)\n  ) {\n    conditionalOutput = formEvaluationState[section.identifier];\n  }\n  return conditionalOutput;\n};\n\n// Function to check if the section config is allowed to render (Only for UQI forms)\nexport const checkIfSectionCanRender = (\n  conditionalOutput: ConditionalOutput,\n) => {\n  // By default, allow the section to render. This is to allow for the case where no conditional is provided.\n  // The evaluation state disallows the section to render if the condition is not met. (Checkout formEval.ts)\n  let allowToRender = true;\n  if (\n    conditionalOutput.hasOwnProperty(\"visible\") &&\n    typeof conditionalOutput.visible === \"boolean\"\n  ) {\n    allowToRender = conditionalOutput.visible;\n  }\n\n  if (\n    conditionalOutput.hasOwnProperty(\"evaluateFormConfig\") &&\n    !!conditionalOutput.evaluateFormConfig &&\n    conditionalOutput.evaluateFormConfig.hasOwnProperty(\n      \"updateEvaluatedConfig\",\n    ) &&\n    typeof conditionalOutput.evaluateFormConfig.updateEvaluatedConfig ===\n      \"boolean\"\n  ) {\n    allowToRender = conditionalOutput.evaluateFormConfig.updateEvaluatedConfig;\n  }\n  return allowToRender;\n};\n\n// Function to check if the section config is enabled (Only for UQI forms)\nexport const checkIfSectionIsEnabled = (\n  conditionalOutput: ConditionalOutput,\n) => {\n  // By default, the section is enabled. This is to allow for the case where no conditional is provided.\n  // The evaluation state disables the section if the condition is not met. (Checkout formEval.ts)\n  let enabled = true;\n  if (\n    conditionalOutput.hasOwnProperty(\"enabled\") &&\n    typeof conditionalOutput.enabled === \"boolean\"\n  ) {\n    enabled = conditionalOutput.enabled;\n  }\n  return enabled;\n};\n\n// Function to modify the section config based on the output of evaluations\nexport const modifySectionConfig = (section: any, enabled: boolean): any => {\n  if (!enabled) {\n    section.disabled = true;\n  } else {\n    section.disabled = false;\n  }\n\n  return section;\n};\n\nexport const updateEvaluatedSectionConfig = (\n  section: any,\n  conditionalOutput: ConditionalOutput,\n  enabled = true,\n) => {\n  // we deep clone the section coming from the editorConfig to prevent any mutations of\n  // the editorConfig in the redux state.\n  // just spreading the object does a shallow clone(top level cloning), so we use the klona package to deep clone\n  // klona is faster than deepClone from lodash.\n\n  // leaving the commented code as a reminder of the above observation.\n  // const updatedSection = { ...section };\n  const updatedSection = klona(section);\n  let evaluatedConfig: FormConfigEvalObject = {};\n  if (\n    conditionalOutput.hasOwnProperty(\"evaluateFormConfig\") &&\n    !!conditionalOutput.evaluateFormConfig &&\n    conditionalOutput.evaluateFormConfig.hasOwnProperty(\n      \"updateEvaluatedConfig\",\n    ) &&\n    typeof conditionalOutput.evaluateFormConfig.updateEvaluatedConfig ===\n      \"boolean\" &&\n    conditionalOutput.evaluateFormConfig.updateEvaluatedConfig\n  ) {\n    evaluatedConfig =\n      conditionalOutput.evaluateFormConfig.evaluateFormConfigObject;\n\n    const paths = Object.keys(evaluatedConfig);\n    paths.forEach((path: string) => {\n      set(updatedSection, path, evaluatedConfig[path].output);\n    });\n  }\n\n  return modifySectionConfig(updatedSection, enabled);\n};\n\nexport function fixActionPayloadForMongoQuery(\n  action?: Action,\n): Action | undefined {\n  if (!action) return action;\n\n  /* eslint-disable */\n  //@ts-nocheck\n  try {\n    let actionObjectDiff: undefined | Diff<any, any>[] = diff(\n      action,\n      MongoDefaultActionConfig,\n    );\n    if (actionObjectDiff) {\n      actionObjectDiff = actionObjectDiff.filter((diff) => diff.kind === \"N\");\n      for (let i = 0; i < actionObjectDiff.length; i++) {\n        let path = \"\";\n        let value = \"\";\n        //kind = N indicates a newly added property/element\n        //This property is present in initialValues but not in action object\n        if (\n          actionObjectDiff &&\n          actionObjectDiff[i].hasOwnProperty(\"kind\") &&\n          actionObjectDiff[i].path &&\n          Array.isArray(actionObjectDiff[i].path) &&\n          actionObjectDiff[i]?.path?.length &&\n          actionObjectDiff[i]?.kind === \"N\"\n        ) {\n          // @ts-expect-error: Types are not available\n          if (typeof actionObjectDiff[i]?.path[0] === \"string\") {\n            // @ts-expect-error: Types are not available\n            path = actionObjectDiff[i]?.path?.join(\".\");\n          }\n          // @ts-expect-error: Types are not available\n          value = actionObjectDiff[i]?.rhs;\n          // @ts-expect-error: Types are not available\n          set(action, path, value);\n        }\n      }\n    }\n    return action;\n    //@ts-check\n  } catch (error) {\n    console.error(\"Error adding default paths in Mongo query\");\n    return action;\n  }\n}\n\n// Function to check if the config has KEYVALUE_ARRAY controlType with more than 1 dependent children\nexport function isKVArray(children: Array<any>) {\n  if (!Array.isArray(children) || children.length < 2) return false;\n  return (\n    children[0].controlType && children[0].controlType === \"KEYVALUE_ARRAY\"\n  );\n}\n","import { ErrorActionPayload } from \"sagas/ErrorSagas\";\nimport { ActionResponse } from \"api/ActionAPI\";\nimport { PluginType } from \"entities/Action\";\nimport queryActionSettingsConfig from \"constants/AppsmithActionConstants/formConfig/QuerySettingsConfig\";\nimport apiActionSettingsConfig from \"constants/AppsmithActionConstants/formConfig/ApiSettingsConfig\";\nimport apiActionEditorConfig from \"constants/AppsmithActionConstants/formConfig/ApiEditorConfigs\";\nimport saasActionSettingsConfig from \"constants/AppsmithActionConstants/formConfig/GoogleSheetsSettingsConfig\";\nimport apiActionDependencyConfig from \"constants/AppsmithActionConstants/formConfig/ApiDependencyConfigs\";\nimport apiActionDatasourceFormButtonConfig from \"constants/AppsmithActionConstants/formConfig/ApiDatasourceFormsButtonConfig\";\nimport { ENTITY_TYPE } from \"entities/DataTree/types\";\n\nexport type ExecuteActionPayloadEvent = {\n  type: EventType;\n  callback?: (result: ExecutionResult) => void;\n};\n\nexport type ExecutionResult = {\n  success: boolean;\n};\n\nexport type TriggerSource = {\n  id: string;\n  name: string;\n  entityType?: ENTITY_TYPE;\n  collectionId?: string;\n  isJSAction?: boolean;\n  actionId?: string;\n};\n\nexport type ExecuteTriggerPayload = {\n  dynamicString: string;\n  event: ExecuteActionPayloadEvent;\n  callbackData?: Array<any>;\n  triggerPropertyName?: string;\n  source?: TriggerSource;\n  widgetId?: string;\n  globalContext?: Record<string, unknown>;\n};\n\nexport type ContentType =\n  | \"application/json\"\n  | \"application/x-www-form-urlencoded\";\n\nexport interface APIHeaders {\n  \"Content-Type\": ContentType;\n  Accept?: string;\n}\n\nexport interface APIRequest {\n  requestId?: string;\n}\n\nexport enum EventType {\n  ON_RESET = \"ON_RESET\",\n  ON_PAGE_LOAD = \"ON_PAGE_LOAD\",\n  ON_PREV_PAGE = \"ON_PREV_PAGE\",\n  ON_NEXT_PAGE = \"ON_NEXT_PAGE\",\n  ON_PAGE_SIZE_CHANGE = \"ON_PAGE_SIZE_CHANGE\",\n  ON_ERROR = \"ON_ERROR\",\n  ON_SUCCESS = \"ON_SUCCESS\",\n  ON_ROW_SELECTED = \"ON_ROW_SELECTED\",\n  ON_SEARCH = \"ON_SEARCH\",\n  ON_CLICK = \"ON_CLICK\",\n  ON_DATA_POINT_CLICK = \"ON_DATA_POINT_CLICK\",\n  ON_FILES_SELECTED = \"ON_FILES_SELECTED\",\n  ON_HOVER = \"ON_HOVER\",\n  ON_TOGGLE = \"ON_TOGGLE\",\n  ON_LOAD = \"ON_LOAD\",\n  ON_MODAL_CLOSE = \"ON_MODAL_CLOSE\",\n  ON_TEXT_CHANGE = \"ON_TEXT_CHANGE\",\n  ON_SUBMIT = \"ON_SUBMIT\",\n  ON_CHECK_CHANGE = \"ON_CHECK_CHANGE\",\n  ON_SWITCH_CHANGE = \"ON_SWITCH_CHANGE\",\n  ON_SELECT = \"ON_SELECT\",\n  ON_DATE_SELECTED = \"ON_DATE_SELECTED\",\n  ON_DATE_RANGE_SELECTED = \"ON_DATE_RANGE_SELECTED\",\n  ON_DROPDOWN_OPEN = \"ON_DROPDOWN_OPEN\",\n  ON_DROPDOWN_CLOSE = \"ON_DROPDOWN_CLOSE\",\n  ON_OPTION_CHANGE = \"ON_OPTION_CHANGE\",\n  ON_FILTER_CHANGE = \"ON_FILTER_CHANGE\",\n  ON_FILTER_UPDATE = \"ON_FILTER_UPDATE\",\n  ON_MARKER_CLICK = \"ON_MARKER_CLICK\",\n  ON_CREATE_MARKER = \"ON_CREATE_MARKER\",\n  ON_TAB_CHANGE = \"ON_TAB_CHANGE\",\n  ON_VIDEO_START = \"ON_VIDEO_START\",\n  ON_VIDEO_END = \"ON_VIDEO_END\",\n  ON_VIDEO_PLAY = \"ON_VIDEO_PLAY\",\n  ON_VIDEO_PAUSE = \"ON_VIDEO_PAUSE\",\n  ON_AUDIO_START = \"ON_AUDIO_START\",\n  ON_AUDIO_END = \"ON_AUDIO_END\",\n  ON_AUDIO_PLAY = \"ON_AUDIO_PLAY\",\n  ON_AUDIO_PAUSE = \"ON_AUDIO_PAUSE\",\n  ON_RATE_CHANGED = \"ON_RATE_CHANGED\",\n  ON_IFRAME_URL_CHANGED = \"ON_IFRAME_URL_CHANGED\",\n  ON_IFRAME_SRC_DOC_CHANGED = \"ON_IFRAME_SRC_DOC_CHANGED\",\n  ON_IFRAME_MESSAGE_RECEIVED = \"ON_IFRAME_MESSAGE_RECEIVED\",\n  ON_SNIPPET_EXECUTE = \"ON_SNIPPET_EXECUTE\",\n  ON_SORT = \"ON_SORT\",\n  ON_CHECKBOX_GROUP_SELECTION_CHANGE = \"ON_CHECKBOX_GROUP_SELECTION_CHANGE\",\n  ON_LIST_PAGE_CHANGE = \"ON_LIST_PAGE_CHANGE\",\n  ON_RECORDING_START = \"ON_RECORDING_START\",\n  ON_RECORDING_COMPLETE = \"ON_RECORDING_COMPLETE\",\n  ON_SWITCH_GROUP_SELECTION_CHANGE = \"ON_SWITCH_GROUP_SELECTION_CHANGE\",\n  ON_JS_FUNCTION_EXECUTE = \"ON_JS_FUNCTION_EXECUTE\",\n  ON_CAMERA_IMAGE_CAPTURE = \"ON_CAMERA_IMAGE_CAPTURE\",\n  ON_CAMERA_IMAGE_SAVE = \"ON_CAMERA_IMAGE_SAVE\",\n  ON_CAMERA_VIDEO_RECORDING_START = \"ON_CAMERA_VIDEO_RECORDING_START\",\n  ON_CAMERA_VIDEO_RECORDING_STOP = \"ON_CAMERA_VIDEO_RECORDING_STOP\",\n  ON_CAMERA_VIDEO_RECORDING_SAVE = \"ON_CAMERA_VIDEO_RECORDING_SAVE\",\n  ON_ENTER_KEY_PRESS = \"ON_ENTER_KEY_PRESS\",\n  ON_BLUR = \"ON_BLUR\",\n  ON_FOCUS = \"ON_FOCUS\",\n  ON_BULK_SAVE = \"ON_BULK_SAVE\",\n  ON_BULK_DISCARD = \"ON_BULK_DISCARD\",\n  ON_ROW_SAVE = \"ON_ROW_SAVE\",\n  ON_ROW_DISCARD = \"ON_ROW_DISCARD\",\n  ON_CODE_DETECTED = \"ON_CODE_DETECTED\",\n  ON_ADD_NEW_ROW_SAVE = \"ON_ADD_NEW_ROW_SAVE\",\n  ON_ADD_NEW_ROW_DISCARD = \"ON_ADD_NEW_ROW_DISCARD\",\n}\n\nexport interface PageAction {\n  id: string;\n  pluginType: PluginType;\n  name: string;\n  jsonPathKeys: string[];\n  timeoutInMillisecond: number;\n  clientSideExecution?: boolean;\n  collectionId?: string;\n}\n\nexport interface ExecuteErrorPayload extends ErrorActionPayload {\n  actionId: string;\n  isPageLoad?: boolean;\n  data: ActionResponse;\n}\n\nexport interface LayoutOnLoadActionErrors {\n  errorType: string;\n  code: number;\n  message: string;\n}\n\n// Group 1 = datasource (https://www.domain.com)\n// Group 2 = path (/nested/path)\n// Group 3 = params (?param=123&param2=12)\nexport const urlGroupsRegexExp = /^(https?:\\/{2}\\S+?)(\\/[\\s\\S]*?)?(\\?(?![^{]*})[\\s\\S]*)?$/;\n\nexport const EXECUTION_PARAM_KEY = \"executionParams\";\nexport const EXECUTION_PARAM_REFERENCE_REGEX = /this.params|this\\?.params/g;\nexport const THIS_DOT_PARAMS_KEY = \"params\";\n\nexport const RESP_HEADER_DATATYPE = \"X-APPSMITH-DATATYPE\";\nexport const API_REQUEST_HEADERS: APIHeaders = {\n  \"Content-Type\": \"application/json\",\n};\nexport const POSTMAN = \"POSTMAN\";\nexport const CURL = \"CURL\";\nexport const Swagger = \"Swagger\";\n\nexport const defaultActionSettings: Record<PluginType, any> = {\n  [PluginType.API]: apiActionSettingsConfig,\n  [PluginType.DB]: queryActionSettingsConfig,\n  [PluginType.SAAS]: saasActionSettingsConfig,\n  [PluginType.REMOTE]: saasActionSettingsConfig,\n  [PluginType.JS]: [],\n};\n\nexport const defaultActionEditorConfigs: Record<PluginType, any> = {\n  [PluginType.API]: apiActionEditorConfig,\n  [PluginType.DB]: [],\n  [PluginType.SAAS]: [],\n  [PluginType.REMOTE]: [],\n  [PluginType.JS]: [],\n};\n\nexport const defaultActionDependenciesConfig: Record<\n  PluginType,\n  Record<string, string[]>\n> = {\n  [PluginType.API]: apiActionDependencyConfig,\n  [PluginType.DB]: {},\n  [PluginType.SAAS]: {},\n  [PluginType.REMOTE]: {},\n  [PluginType.JS]: {},\n};\n\nexport const defaultDatasourceFormButtonConfig: Record<PluginType, string[]> = {\n  [PluginType.API]: apiActionDatasourceFormButtonConfig.API,\n  [PluginType.DB]: apiActionDatasourceFormButtonConfig.DB,\n  [PluginType.SAAS]: apiActionDatasourceFormButtonConfig.SAAS,\n  [PluginType.REMOTE]: apiActionDatasourceFormButtonConfig.REMOTE,\n  [PluginType.JS]: [],\n};\n","export const DATA_BIND_REGEX = /{{([\\s\\S]*?)}}/;\nexport const DATA_BIND_REGEX_GLOBAL = /{{([\\s\\S]*?)}}/g;\nexport const AUTOCOMPLETE_MATCH_REGEX = /{{\\s*.*?\\s*}}/g;\nexport const QUOTED_BINDING_REGEX = /[\"']({{[\\s\\S]*?}})[\"']/g;\n","/* eslint-disable @typescript-eslint/ban-types */\nimport { DataTree } from \"entities/DataTree/dataTreeFactory\";\nimport { EvalContext } from \"workers/Evaluation/evaluate\";\nimport { EvaluationVersion } from \"api/ApplicationApi\";\nimport { addFn } from \"workers/Evaluation/fns/utils/fnGuard\";\nimport { set } from \"lodash\";\nimport {\n  entityFns,\n  getPlatformFunctions,\n} from \"@appsmith/workers/Evaluation/fns\";\ndeclare global {\n  /** All identifiers added to the worker global scope should also\n   * be included in the DEDICATED_WORKER_GLOBAL_SCOPE_IDENTIFIERS in\n   * app/client/src/constants/WidgetValidation.ts\n   * */\n\n  interface Window {\n    $isDataField: boolean;\n    $isAsync: boolean;\n    $evaluationVersion: EvaluationVersion;\n    $cloudHosting: boolean;\n  }\n}\n\nexport enum ExecutionType {\n  PROMISE = \"PROMISE\",\n  TRIGGER = \"TRIGGER\",\n}\n\n/**\n * This method returns new dataTree with entity function and platform function\n */\nexport const addDataTreeToContext = (args: {\n  EVAL_CONTEXT: EvalContext;\n  dataTree: Readonly<DataTree>;\n  skipEntityFunctions?: boolean;\n  isTriggerBased: boolean;\n}) => {\n  const {\n    dataTree,\n    EVAL_CONTEXT,\n    isTriggerBased,\n    skipEntityFunctions = false,\n  } = args;\n  const dataTreeEntries = Object.entries(dataTree);\n  const entityFunctionCollection: Record<string, Record<string, Function>> = {};\n\n  for (const [entityName, entity] of dataTreeEntries) {\n    EVAL_CONTEXT[entityName] = entity;\n    if (skipEntityFunctions || !isTriggerBased) continue;\n    for (const entityFn of entityFns) {\n      if (!entityFn.qualifier(entity)) continue;\n      const func = entityFn.fn(entity);\n      const fullPath = `${entityFn.path || `${entityName}.${entityFn.name}`}`;\n      set(entityFunctionCollection, fullPath, func);\n    }\n  }\n\n  // if eval is not trigger based i.e., sync eval then we skip adding entity and platform function to evalContext\n  if (!isTriggerBased) return;\n\n  for (const [entityName, funcObj] of Object.entries(\n    entityFunctionCollection,\n  )) {\n    EVAL_CONTEXT[entityName] = Object.assign({}, dataTree[entityName], funcObj);\n  }\n};\n\nexport const addPlatformFunctionsToEvalContext = (context: any) => {\n  for (const fnDef of getPlatformFunctions(self.$cloudHosting)) {\n    addFn(context, fnDef.name, fnDef.fn.bind(context));\n  }\n};\n\nexport const getAllAsyncFunctions = (dataTree: DataTree) => {\n  const asyncFunctionNameMap: Record<string, true> = {};\n  const dataTreeEntries = Object.entries(dataTree);\n  for (const [entityName, entity] of dataTreeEntries) {\n    for (const entityFn of entityFns) {\n      if (!entityFn.qualifier(entity)) continue;\n      const fullPath = `${entityFn.path || `${entityName}.${entityFn.name}`}`;\n      asyncFunctionNameMap[fullPath] = true;\n    }\n  }\n  for (const platformFn of getPlatformFunctions(self.$cloudHosting)) {\n    asyncFunctionNameMap[platformFn.name] = true;\n  }\n  return asyncFunctionNameMap;\n};\n","import {\n  DataTree,\n  DataTreeEntity,\n  UnEvalTree,\n  UnEvalTreeEntityObject,\n} from \"entities/DataTree/dataTreeFactory\";\nimport { set } from \"lodash\";\nimport { EvalProps } from \"workers/common/DataTreeEvaluator\";\nimport { removeFunctions } from \"@appsmith/workers/Evaluation/evaluationUtils\";\n\n/**\n * This method accept an entity object as input and if it has __config__ property than it moves the __config__ to object's prototype\n */\nexport function createNewEntity(entity: UnEvalTreeEntityObject) {\n  if (!entity || !entity.hasOwnProperty(\"__config__\")) return entity;\n  const { __config__, ...rest } = entity;\n  const newObj = Object.create(__config__);\n  Object.assign(newObj, rest) as DataTreeEntity;\n  return newObj;\n}\n/**\n * This method takes unevaltree received from mainThread as input and return a new unEvalTree with each entity config moved to entity object's prototype.\n * Moving configs to prototype skips it from diffing, cloning and getAllPaths calculation.\n * Refer: https://github.com/appsmithorg/appsmith/pull/18361 to know more\n */\nexport function createUnEvalTreeForEval(unevalTree: UnEvalTree) {\n  const newUnEvalTree: DataTree = {};\n\n  for (const entityName of Object.keys(unevalTree)) {\n    const entity = unevalTree[entityName];\n    newUnEvalTree[entityName] = createNewEntity(\n      entity as UnEvalTreeEntityObject,\n    );\n  }\n\n  return newUnEvalTree;\n}\n\n/**\n * This method loops through each entity object of dataTree and sets the entity config from prototype as object properties.\n * This is done to send back dataTree in the format expected by mainThread.\n */\nexport function makeEntityConfigsAsObjProperties(\n  dataTree: DataTree,\n  option = {} as {\n    sanitizeDataTree?: boolean;\n    evalProps?: EvalProps;\n  },\n): DataTree {\n  const { evalProps, sanitizeDataTree = true } = option;\n  const newDataTree: DataTree = {};\n  for (const entityName of Object.keys(dataTree)) {\n    const entityConfig = Object.getPrototypeOf(dataTree[entityName]) || {};\n    const entity = dataTree[entityName];\n    newDataTree[entityName] = Object.assign({}, entityConfig, entity);\n  }\n  const dataTreeToReturn = sanitizeDataTree\n    ? JSON.parse(JSON.stringify(newDataTree))\n    : newDataTree;\n\n  if (!evalProps) return dataTreeToReturn;\n\n  const sanitizedEvalProps = removeFunctions(evalProps) as EvalProps;\n  for (const [entityName, entityEvalProps] of Object.entries(\n    sanitizedEvalProps,\n  )) {\n    if (!entityEvalProps.__evaluation__) continue;\n    set(\n      dataTreeToReturn[entityName],\n      \"__evaluation__\",\n      entityEvalProps.__evaluation__,\n    );\n  }\n\n  return dataTreeToReturn;\n}\n","export enum EVAL_WORKER_SYNC_ACTION {\n  SETUP = \"SETUP\",\n  EVAL_TREE = \"EVAL_TREE\",\n  EVAL_ACTION_BINDINGS = \"EVAL_ACTION_BINDINGS\",\n  CLEAR_CACHE = \"CLEAR_CACHE\",\n  VALIDATE_PROPERTY = \"VALIDATE_PROPERTY\",\n  UNDO = \"undo\",\n  REDO = \"redo\",\n  UPDATE_REPLAY_OBJECT = \"UPDATE_REPLAY_OBJECT\",\n  SET_EVALUATION_VERSION = \"SET_EVALUATION_VERSION\",\n  INIT_FORM_EVAL = \"INIT_FORM_EVAL\",\n  EXECUTE_SYNC_JS = \"EXECUTE_SYNC_JS\",\n  INSTALL_LIBRARY = \"INSTALL_LIBRARY\",\n  UNINSTALL_LIBRARY = \"UNINSTALL_LIBRARY\",\n  LOAD_LIBRARIES = \"LOAD_LIBRARIES\",\n  LINT_TREE = \"LINT_TREE\",\n}\n\nexport enum EVAL_WORKER_ASYNC_ACTION {\n  EVAL_TRIGGER = \"EVAL_TRIGGER\",\n  EVAL_EXPRESSION = \"EVAL_EXPRESSION\",\n}\n\nexport const EVAL_WORKER_ACTIONS = {\n  ...EVAL_WORKER_SYNC_ACTION,\n  ...EVAL_WORKER_ASYNC_ACTION,\n};\n\nexport enum MAIN_THREAD_ACTION {\n  PROCESS_TRIGGER = \"PROCESS_TRIGGER\",\n  PROCESS_BATCHED_TRIGGERS = \"PROCESS_BATCHED_TRIGGERS\",\n  PROCESS_STORE_UPDATES = \"PROCESS_STORE_UPDATES\",\n  PROCESS_LOGS = \"PROCESS_LOGS\",\n  LINT_TREE = \"LINT_TREE\",\n  PROCESS_JS_FUNCTION_EXECUTION = \"PROCESS_JS_FUNCTION_EXECUTION\",\n}\n","export * from \"ce/workers/Evaluation/evalWorkerActions\";\nimport { MAIN_THREAD_ACTION as CE_MAIN_THREAD_ACTION } from \"ce/workers/Evaluation/evalWorkerActions\";\n\nexport const MAIN_THREAD_ACTION = {\n  ...CE_MAIN_THREAD_ACTION,\n  LOG_JS_FUNCTION_EXECUTION: \"LOG_JS_FUNCTION_EXECUTION\",\n};\n","import navigateTo, {\n  TNavigateToActionType,\n  TNavigateToDescription,\n} from \"./navigateTo\";\nimport showAlert, {\n  TShowAlertActionType,\n  TShowAlertDescription,\n} from \"./showAlert\";\nimport {\n  closeModal,\n  showModal,\n  TCloseModalActionType,\n  TCloseModalDescription,\n  TShowModalActionType,\n  TShowModalDescription,\n} from \"./modalFns\";\nimport download, {\n  TDownloadActionType,\n  TDownloadDescription,\n} from \"./download\";\nimport postWindowMessage, {\n  TPostWindowMessageActionType,\n  TPostWindowMessageDescription,\n} from \"./postWindowMessage\";\nimport copyToClipboard, {\n  TCopyToClipboardActionType,\n  TCopyToClipboardDescription,\n} from \"./copyToClipboard\";\nimport resetWidget, {\n  TResetWidgetActionType,\n  TResetWidgetDescription,\n} from \"./resetWidget\";\nimport {\n  clearStore,\n  removeValue,\n  storeValue,\n  TClearStoreDescription,\n  TRemoveValueDescription,\n  TStoreValueDescription,\n} from \"./storeFns\";\nimport run, {\n  clear,\n  TClearActionType,\n  TClearDescription,\n  TRunActionType,\n  TRunDescription,\n} from \"./actionFns\";\nimport {\n  isAction,\n  isAppsmithEntity,\n} from \"ce/workers/Evaluation/evaluationUtils\";\nimport {\n  DataTreeAction,\n  DataTreeEntity,\n} from \"entities/DataTree/dataTreeFactory\";\nimport {\n  getGeoLocation,\n  stopWatchGeoLocation,\n  TGetGeoLocationActionType,\n  TGetGeoLocationDescription,\n  TStopWatchGeoLocationActionType,\n  TStopWatchGeoLocationDescription,\n  TWatchGeoLocationActionType,\n  TWatchGeoLocationDescription,\n  watchGeoLocation,\n} from \"./geolocationFns\";\nimport { isAsyncGuard } from \"./utils/fnGuard\";\n\n// cloudHosting -> to use in EE\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getPlatformFunctions = (cloudHosting: boolean) => {\n  return platformFns;\n};\n\nconst platformFns = [\n  {\n    name: \"navigateTo\",\n    fn: navigateTo,\n  },\n  {\n    name: \"showAlert\",\n    fn: showAlert,\n  },\n  {\n    name: \"showModal\",\n    fn: showModal,\n  },\n  {\n    name: \"closeModal\",\n    fn: closeModal,\n  },\n  {\n    name: \"download\",\n    fn: download,\n  },\n  {\n    name: \"postWindowMessage\",\n    fn: postWindowMessage,\n  },\n  {\n    name: \"copyToClipboard\",\n    fn: copyToClipboard,\n  },\n  {\n    name: \"resetWidget\",\n    fn: resetWidget,\n  },\n  {\n    name: \"storeValue\",\n    fn: storeValue,\n  },\n  {\n    name: \"removeValue\",\n    fn: removeValue,\n  },\n  {\n    name: \"clearStore\",\n    fn: clearStore,\n  },\n];\n\nexport const entityFns = [\n  {\n    name: \"run\",\n    qualifier: (entity: DataTreeEntity) => isAction(entity),\n    fn: (entity: DataTreeEntity) =>\n      isAsyncGuard(run.bind(entity), `${(entity as DataTreeAction).name}.run`),\n  },\n  {\n    name: \"clear\",\n    qualifier: (entity: DataTreeEntity) => isAction(entity),\n    fn: (entity: DataTreeEntity) =>\n      isAsyncGuard(\n        clear.bind(entity),\n        `${(entity as DataTreeAction).name}.clear`,\n      ),\n  },\n  {\n    name: \"getGeoLocation\",\n    path: \"appsmith.geolocation.getCurrentPosition\",\n    qualifier: (entity: DataTreeEntity) => isAppsmithEntity(entity),\n    fn: () =>\n      isAsyncGuard(getGeoLocation, \"appsmith.geolocation.getCurrentPosition\"),\n  },\n  {\n    name: \"watchGeoLocation\",\n    path: \"appsmith.geolocation.watchPosition\",\n    qualifier: (entity: DataTreeEntity) => isAppsmithEntity(entity),\n    fn: () =>\n      isAsyncGuard(watchGeoLocation, \"appsmith.geolocation.watchPosition\"),\n  },\n  {\n    name: \"stopWatchGeoLocation\",\n    path: \"appsmith.geolocation.clearWatch\",\n    qualifier: (entity: DataTreeEntity) => isAppsmithEntity(entity),\n    fn: () =>\n      isAsyncGuard(stopWatchGeoLocation, \"appsmith.geolocation.clearWatch\"),\n  },\n];\n\nexport type ActionTriggerKeys =\n  | TClearActionType\n  | TRunActionType\n  | TDownloadActionType\n  | TShowModalActionType\n  | TCloseModalActionType\n  | TShowAlertActionType\n  | TDownloadActionType\n  | TNavigateToActionType\n  | TResetWidgetActionType\n  | TCopyToClipboardActionType\n  | TPostWindowMessageActionType\n  | TGetGeoLocationActionType\n  | TWatchGeoLocationActionType\n  | TStopWatchGeoLocationActionType;\n\nexport const getActionTriggerFunctionNames = (\n  // cloudHosting -> to use in ee\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  cloudHosting: boolean,\n): Record<string, string> => {\n  return ActionTriggerFunctionNames;\n};\n\nconst ActionTriggerFunctionNames: Record<string, string> = {\n  CLEAR_INTERVAL: \"clearInterval\",\n  CLEAR_PLUGIN_ACTION: \"action.clear\",\n  CLOSE_MODAL: \"closeModal\",\n  COPY_TO_CLIPBOARD: \"copyToClipboard\",\n  DOWNLOAD: \"download\",\n  NAVIGATE_TO: \"navigateTo\",\n  RESET_WIDGET_META_RECURSIVE_BY_NAME: \"resetWidget\",\n  RUN_PLUGIN_ACTION: \"action.run\",\n  SET_INTERVAL: \"setInterval\",\n  SHOW_ALERT: \"showAlert\",\n  SHOW_MODAL_BY_NAME: \"showModal\",\n  STORE_VALUE: \"storeValue\",\n  REMOVE_VALUE: \"removeValue\",\n  CLEAR_STORE: \"clearStore\",\n  GET_CURRENT_LOCATION: \"getCurrentLocation\",\n  WATCH_CURRENT_LOCATION: \"watchLocation\",\n  STOP_WATCHING_CURRENT_LOCATION: \"stopWatch\",\n  POST_MESSAGE: \"postWindowMessage\",\n  SET_TIMEOUT: \"setTimeout\",\n  CLEAR_TIMEOUT: \"clearTimeout\",\n};\n\nexport type ActionDescription =\n  | TRunDescription\n  | TClearDescription\n  | TShowModalDescription\n  | TCloseModalDescription\n  | TClearDescription\n  | TStoreValueDescription\n  | TClearStoreDescription\n  | TRemoveValueDescription\n  | TDownloadDescription\n  | TPostWindowMessageDescription\n  | TNavigateToDescription\n  | TShowAlertDescription\n  | TResetWidgetDescription\n  | TCopyToClipboardDescription\n  | TGetGeoLocationDescription\n  | TWatchGeoLocationDescription\n  | TStopWatchGeoLocationDescription;\n","import { ActionResponse } from \"api/ActionAPI\";\nimport { PluginId } from \"api/PluginApi\";\nimport { ValidationConfig } from \"constants/PropertyControlConstants\";\nimport { ActionConfig, PluginType } from \"entities/Action\";\nimport { ActionDescription } from \"@appsmith/workers/Evaluation/fns\";\nimport { Variable } from \"entities/JSCollection\";\nimport { DependencyMap, DynamicPath } from \"utils/DynamicBindingUtils\";\n\nexport type ActionDispatcher = (...args: any[]) => ActionDescription;\n\nexport enum ENTITY_TYPE {\n  ACTION = \"ACTION\",\n  WIDGET = \"WIDGET\",\n  APPSMITH = \"APPSMITH\",\n  JSACTION = \"JSACTION\",\n}\n\nexport enum EvaluationSubstitutionType {\n  TEMPLATE = \"TEMPLATE\",\n  PARAMETER = \"PARAMETER\",\n  SMART_SUBSTITUTE = \"SMART_SUBSTITUTE\",\n}\n\n// Action entity types\nexport interface ActionEntityEvalTree {\n  actionId: string;\n  isLoading: boolean;\n  data: ActionResponse[\"body\"];\n  run: ActionDispatcher | Record<string, unknown>;\n  clear: ActionDispatcher | Record<string, unknown>;\n  responseMeta: {\n    statusCode?: string;\n    isExecutionSuccess: boolean;\n    headers?: unknown;\n  };\n  ENTITY_TYPE: ENTITY_TYPE.ACTION;\n  config: Partial<ActionConfig>;\n  datasourceUrl: string;\n}\n\nexport interface ActionEntityConfig {\n  dynamicBindingPathList: DynamicPath[];\n  bindingPaths: Record<string, EvaluationSubstitutionType>;\n  reactivePaths: Record<string, EvaluationSubstitutionType>;\n  ENTITY_TYPE: ENTITY_TYPE.ACTION;\n  dependencyMap: DependencyMap;\n  logBlackList: Record<string, true>;\n  pluginType: PluginType;\n  pluginId: PluginId;\n  actionId: string;\n  name: string;\n}\n\n// JSAction (JSObject) entity Types\n\nexport interface MetaArgs {\n  arguments: Variable[];\n  isAsync: boolean;\n  confirmBeforeExecute: boolean;\n}\n\nexport interface JSActionEntityConfig {\n  meta: Record<string, MetaArgs>;\n  dynamicBindingPathList: DynamicPath[];\n  bindingPaths: Record<string, EvaluationSubstitutionType>;\n  reactivePaths: Record<string, EvaluationSubstitutionType>;\n  variables: Array<string>;\n  dependencyMap: DependencyMap;\n  pluginType: PluginType.JS;\n  name: string;\n  ENTITY_TYPE: ENTITY_TYPE.JSACTION;\n  actionId: string;\n}\n\nexport interface JSActionEvalTree {\n  [propName: string]: any;\n  body: string;\n}\n\n// Widget entity Types\n\n// Private widgets do not get evaluated\n// For example, for widget Button1 in a List widget List1, List1.template.Button1.text gets evaluated,\n// so there is no need to evaluate Button1.text\nexport type PrivateWidgets = Record<string, true>;\n\n/**\n *  Map of overriding property as key and overridden property as values\n */\nexport type OverridingPropertyPaths = Record<string, string[]>;\n\nexport enum OverridingPropertyType {\n  META = \"META\",\n  DEFAULT = \"DEFAULT\",\n}\nexport interface overrideDependency {\n  DEFAULT: string;\n  META: string;\n}\n/**\n *  Map of property name as key and value as object with defaultPropertyName and metaPropertyName which it depends on.\n */\nexport type PropertyOverrideDependency = Record<\n  string,\n  Partial<overrideDependency>\n>;\n\nexport type WidgetConfig = {\n  bindingPaths: Record<string, EvaluationSubstitutionType>;\n  reactivePaths: Record<string, EvaluationSubstitutionType>;\n  triggerPaths: Record<string, boolean>;\n  validationPaths: Record<string, ValidationConfig>;\n  ENTITY_TYPE: ENTITY_TYPE.WIDGET;\n  logBlackList: Record<string, true>;\n  propertyOverrideDependency: PropertyOverrideDependency;\n  overridingPropertyPaths: OverridingPropertyPaths;\n  privateWidgets: PrivateWidgets;\n};\n","import { Doc, Map, UndoManager } from \"yjs\";\nimport { captureException } from \"@sentry/react\";\nimport { diff as deepDiff, applyChange, revertChange, Diff } from \"deep-diff\";\n\nimport { getPathsFromDiff } from \"./replayUtils\";\nimport { ENTITY_TYPE } from \"entities/AppsmithConsole\";\n\nconst _DIFF_ = \"diff\";\ntype ReplayType = \"UNDO\" | \"REDO\";\n\nexport default abstract class ReplayEntity<T> {\n  private diffMap: any;\n  private undoManager: UndoManager;\n  protected entity: T;\n  private replayEntityType: ENTITY_TYPE;\n  logs: any[] = [];\n  protected abstract processDiff(\n    diff: Diff<T, T>,\n    replay: any,\n    isUndo: boolean,\n  ): any;\n\n  constructor(entity: T, replayEntityType: ENTITY_TYPE) {\n    const doc = new Doc();\n    this.diffMap = doc.get(\"map\", Map);\n    this.entity = entity;\n    this.diffMap.set(_DIFF_, []);\n    this.undoManager = new UndoManager(this.diffMap, { captureTimeout: 100 });\n    this.replayEntityType = replayEntityType;\n  }\n\n  /**\n   * checks if there is anything in the redoStack or undoStack\n   *\n   * @return boolean\n   */\n  canReplay(replayType: ReplayType) {\n    switch (replayType) {\n      case \"UNDO\":\n        return this.undoManager.undoStack.length > 0;\n      case \"REDO\":\n        return this.undoManager.redoStack.length > 0;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * get the diffs from yMap\n   *\n   * @returns\n   */\n  private getDiffs() {\n    return this.diffMap.get(_DIFF_);\n  }\n\n  /**\n   * replay actions ( undo redo )\n   *\n   * Note:\n   * important thing to note is that for redo we redo first, then\n   * get the diff map and undo, we get diff first, then undo\n   *\n   * @param replayType\n   */\n  replay(replayType: ReplayType) {\n    const start = performance.now();\n\n    if (this.canReplay(replayType)) {\n      let diffs;\n\n      switch (replayType) {\n        case \"UNDO\":\n          diffs = this.getDiffs();\n          this.undoManager.undo();\n          break;\n        case \"REDO\":\n          this.undoManager.redo();\n          diffs = this.getDiffs();\n          break;\n      }\n\n      const replay = this.applyDiffs(diffs, replayType);\n      const stop = performance.now();\n      this.logs.push({\n        log: `replay ${replayType}`,\n        undoTime: `${stop - start} ms`,\n        replay: replay,\n        diffs: diffs,\n      });\n\n      return {\n        replayEntity: this.entity,\n        replay,\n        logs: this.logs,\n        event: `REPLAY_${replayType}`,\n        timeTaken: stop - start,\n        paths: getPathsFromDiff(diffs),\n        replayEntityType: this.replayEntityType,\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * saves the changes (diff) in yMap\n   * only if there is a deep diff\n   *\n   * @param widgets\n   */\n  update(entity: T) {\n    const startTime = performance.now();\n    const diffs = deepDiff(this.entity, entity);\n    if (diffs && diffs.length) {\n      this.entity = entity;\n      this.diffMap.set(_DIFF_, diffs);\n    }\n    const endTime = performance.now();\n    this.logs.push({\n      log: \"replay updating\",\n      updateTime: `${endTime - startTime} ms`,\n    });\n  }\n\n  clearLogs() {\n    this.logs = [];\n  }\n\n  /**\n   * apply the diff on the current dsl\n   *\n   * @param diffs\n   * @param isUndo\n   */\n  applyDiffs(diffs: Array<Diff<T, T>>, replayType: ReplayType) {\n    const replay: any = {};\n    const isUndo = replayType === \"UNDO\";\n    const applyDiff = isUndo ? revertChange : applyChange;\n\n    for (const diff of diffs) {\n      if (!Array.isArray(diff.path) || diff.path.length === 0) {\n        continue;\n      }\n      try {\n        this.processDiff(diff, replay, isUndo);\n        applyDiff(this.entity, true, diff);\n      } catch (e) {\n        captureException(e, {\n          extra: {\n            diff,\n            updateLength: diffs.length,\n          },\n        });\n      }\n    }\n\n    return replay;\n  }\n}\n","import { Diff } from \"deep-diff\";\nimport { get, isArray, isEmpty, set } from \"lodash\";\nexport const UPDATES = \"propertyUpdates\";\nexport const REPLAY_DELAY = 300;\nexport const REPLAY_FOCUS_DELAY = 100;\nexport const TOASTS = \"toasts\";\nexport const FOCUSES = \"needsFocus\";\nexport const WIDGETS = \"widgets\";\n\n/**\n * checks the existing value and sets he propertyUpdate if required\n *\n * @param replay\n * @param path\n * @param value\n * @returns\n */\nexport function setPropertyUpdate(\n  replay: any,\n  path: string[],\n  value: string[],\n) {\n  const existingPathValue = get(replay, path);\n\n  if (!existingPathValue || existingPathValue.length > 2) {\n    set(replay, path, value);\n    set(replay, UPDATES, true);\n  }\n}\n\n/**\n * pushes value to array element in array of objects\n *\n * @param obj\n * @param key\n * @param value\n * @returns\n */\nexport function addToArray(obj: any, key: string, value: any) {\n  if (!obj) return;\n\n  if (obj[key] && Array.isArray(obj[key])) {\n    obj[key].push(value);\n  } else {\n    obj[key] = [value];\n  }\n}\n\n/**\n * creates paths changed from diffs  array\n *\n * @param diffs\n * @returns\n */\nexport function getPathsFromDiff(diffs: Array<Diff<any, any>>) {\n  const paths = [];\n\n  for (const diff of diffs) {\n    if (!diff.path || !Array.isArray(diff.path)) continue;\n    paths.push(diff.path.join(\".\"));\n  }\n\n  return paths;\n}\n\n/**\n * creates paths changed from diffs  array\n *\n * @param path\n * @returns\n */\nexport function pathArrayToString(path?: string[]) {\n  let stringPath = \"\";\n  if (!path || path.length === 0) return stringPath;\n  stringPath = path[0];\n  for (let i = 1; i < path.length; i++) {\n    stringPath += isNaN(parseInt(path[i])) ? `.${path[i]}` : `[${path[i]}]`;\n  }\n  return stringPath;\n}\n\n/**\n * Retrieves field config and parent section using the config property\n *\n * @param config\n * @param field\n * @param parentSection\n * @returns\n */\nexport function findFieldInfo(\n  config: Array<any>,\n  field: string,\n  parentSection = \"\",\n) {\n  let result = {};\n  if (!config || !isArray(config)) return result;\n  for (const conf of config) {\n    if (conf.configProperty === field) {\n      result = { conf, parentSection };\n      break;\n    } else if (conf.children) {\n      parentSection = conf.sectionName || parentSection;\n      result = findFieldInfo(conf.children, field, parentSection);\n      if (!isEmpty(result)) break;\n    }\n  }\n  return result;\n}\n","import _, { get, isString } from \"lodash\";\nimport { DATA_BIND_REGEX } from \"constants/BindingsConstants\";\nimport { Action } from \"entities/Action\";\nimport { WidgetProps } from \"widgets/BaseWidget\";\nimport { Severity } from \"entities/AppsmithConsole\";\nimport {\n  getEntityNameAndPropertyPath,\n  isAction,\n  isJSAction,\n  isTrueObject,\n  isWidget,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport { DataTreeEntity } from \"entities/DataTree/dataTreeFactory\";\nimport { getType, Types } from \"./TypeHelpers\";\nimport { ViewTypes } from \"components/formControls/utils\";\n\nexport type DependencyMap = Record<string, Array<string>>;\nexport type FormEditorConfigs = Record<string, any[]>;\nexport type FormSettingsConfigs = Record<string, any[]>;\nexport type FormDependencyConfigs = Record<string, DependencyMap>;\nexport type FormDatasourceButtonConfigs = Record<string, string[]>;\n\n// referencing DATA_BIND_REGEX fails for the value \"{{Table1.tableData[Table1.selectedRowIndex]}}\" if you run it multiple times and don't recreate\nexport const isDynamicValue = (value: string): boolean =>\n  DATA_BIND_REGEX.test(value);\n\n//{{}}{{}}}\nexport function getDynamicStringSegments(dynamicString: string): string[] {\n  let stringSegments = [];\n  const indexOfDoubleParanStart = dynamicString.indexOf(\"{{\");\n  if (indexOfDoubleParanStart === -1) {\n    return [dynamicString];\n  }\n  //{{}}{{}}}\n  const firstString = dynamicString.substring(0, indexOfDoubleParanStart);\n  firstString && stringSegments.push(firstString);\n  let rest = dynamicString.substring(\n    indexOfDoubleParanStart,\n    dynamicString.length,\n  );\n  //{{}}{{}}}\n  let sum = 0;\n  for (let i = 0; i <= rest.length - 1; i++) {\n    const char = rest[i];\n    const prevChar = rest[i - 1];\n\n    if (char === \"{\") {\n      sum++;\n    } else if (char === \"}\") {\n      sum--;\n      if (prevChar === \"}\" && sum === 0) {\n        stringSegments.push(rest.substring(0, i + 1));\n        rest = rest.substring(i + 1, rest.length);\n        if (rest) {\n          stringSegments = stringSegments.concat(\n            getDynamicStringSegments(rest),\n          );\n          break;\n        }\n      }\n    }\n  }\n  if (sum !== 0 && dynamicString !== \"\") {\n    return [dynamicString];\n  }\n  return stringSegments;\n}\n\n//{{}}{{}}}\nexport const getDynamicBindings = (\n  dynamicString: string,\n  entity?: DataTreeEntity,\n): { stringSegments: string[]; jsSnippets: string[] } => {\n  // Protect against bad string parse\n  if (!dynamicString || !_.isString(dynamicString)) {\n    return { stringSegments: [], jsSnippets: [] };\n  }\n  const sanitisedString = dynamicString.trim();\n  let stringSegments, paths: any;\n  if (entity && isJSAction(entity)) {\n    stringSegments = [sanitisedString];\n    paths = [sanitisedString];\n  } else {\n    // Get the {{binding}} bound values\n    stringSegments = getDynamicStringSegments(sanitisedString);\n    // Get the \"binding\" path values\n    paths = stringSegments.map((segment) => {\n      const length = segment.length;\n      const matches = isDynamicValue(segment);\n      if (matches) {\n        return segment.substring(2, length - 2);\n      }\n      return \"\";\n    });\n  }\n  return { stringSegments: stringSegments, jsSnippets: paths };\n};\n\nexport const combineDynamicBindings = (\n  jsSnippets: string[],\n  stringSegments: string[],\n) => {\n  return stringSegments\n    .map((segment, index) => {\n      if (jsSnippets[index] && jsSnippets[index].length > 0) {\n        return jsSnippets[index];\n      } else {\n        return `'${segment}'`;\n      }\n    })\n    .join(\" + \");\n};\n\nexport enum EvalErrorTypes {\n  CYCLICAL_DEPENDENCY_ERROR = \"CYCLICAL_DEPENDENCY_ERROR\",\n  EVAL_PROPERTY_ERROR = \"EVAL_PROPERTY_ERROR\",\n  EVAL_TREE_ERROR = \"EVAL_TREE_ERROR\",\n  UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n  BAD_UNEVAL_TREE_ERROR = \"BAD_UNEVAL_TREE_ERROR\",\n  PARSE_JS_ERROR = \"PARSE_JS_ERROR\",\n  EXTRACT_DEPENDENCY_ERROR = \"EXTRACT_DEPENDENCY_ERROR\",\n  CLONE_ERROR = \"CLONE_ERROR\",\n}\n\nexport type EvalError = {\n  type: EvalErrorTypes;\n  message: string;\n  context?: Record<string, any>;\n};\n\nexport interface DynamicPath {\n  key: string;\n  value?: string;\n}\n\nexport interface WidgetDynamicPathListProps {\n  dynamicBindingPathList?: DynamicPath[];\n  dynamicTriggerPathList?: DynamicPath[];\n  dynamicPropertyPathList?: DynamicPath[];\n}\n\nexport interface EntityWithBindings {\n  dynamicBindingPathList?: DynamicPath[];\n}\n\nexport const getEntityDynamicBindingPathList = (\n  entity: EntityWithBindings,\n): DynamicPath[] => {\n  if (\n    entity &&\n    entity.dynamicBindingPathList &&\n    Array.isArray(entity.dynamicBindingPathList)\n  ) {\n    return [...entity.dynamicBindingPathList];\n  }\n  return [];\n};\n\nexport const isPathADynamicBinding = (\n  entity: EntityWithBindings,\n  path: string,\n): boolean => {\n  if (\n    entity &&\n    entity.dynamicBindingPathList &&\n    Array.isArray(entity.dynamicBindingPathList)\n  ) {\n    return _.find(entity.dynamicBindingPathList, { key: path }) !== undefined;\n  }\n  return false;\n};\n/**\n * Get property path from full property path\n * Input: \"Table1.meta.searchText\" => Output: \"meta.searchText\"\n * @param {string} fullPropertyPath\n * @return {*}\n */\nexport const getPropertyPath = (fullPropertyPath: string) => {\n  return fullPropertyPath.substring(fullPropertyPath.indexOf(\".\") + 1);\n};\n\nexport const getWidgetDynamicTriggerPathList = (\n  widget: WidgetProps,\n): DynamicPath[] => {\n  if (\n    widget &&\n    widget.dynamicTriggerPathList &&\n    Array.isArray(widget.dynamicTriggerPathList)\n  ) {\n    return [...widget.dynamicTriggerPathList];\n  }\n  return [];\n};\n\nexport const isPathDynamicTrigger = (\n  widget: WidgetProps,\n  path: string,\n): boolean => {\n  if (\n    widget &&\n    widget.dynamicTriggerPathList &&\n    Array.isArray(widget.dynamicTriggerPathList)\n  ) {\n    return _.find(widget.dynamicTriggerPathList, { key: path }) !== undefined;\n  }\n  return false;\n};\n\nexport const getWidgetDynamicPropertyPathList = (\n  widget: WidgetProps,\n): DynamicPath[] => {\n  if (\n    widget &&\n    widget.dynamicPropertyPathList &&\n    Array.isArray(widget.dynamicPropertyPathList)\n  ) {\n    return [...widget.dynamicPropertyPathList];\n  }\n  return [];\n};\n\nexport const isPathDynamicProperty = (\n  widget: WidgetProps,\n  path: string,\n): boolean => {\n  if (\n    widget &&\n    widget.dynamicPropertyPathList &&\n    Array.isArray(widget.dynamicPropertyPathList)\n  ) {\n    return _.find(widget.dynamicPropertyPathList, { key: path }) !== undefined;\n  }\n  return false;\n};\n\nexport const THEME_BINDING_REGEX = /{{.*appsmith\\.theme\\..*}}/;\n\nexport const isThemeBoundProperty = (\n  widget: WidgetProps,\n  path: string,\n): boolean => {\n  return widget && widget[path] && THEME_BINDING_REGEX.test(widget[path]);\n};\n\nexport const unsafeFunctionForEval = [\n  \"XMLHttpRequest\",\n  \"setImmediate\",\n  \"Navigator\",\n];\n\nexport const isChildPropertyPath = (\n  parentPropertyPath: string,\n  childPropertyPath: string,\n): boolean => {\n  return (\n    parentPropertyPath === childPropertyPath ||\n    childPropertyPath.startsWith(`${parentPropertyPath}.`) ||\n    childPropertyPath.startsWith(`${parentPropertyPath}[`)\n  );\n};\n\n/**\n * Paths set via evaluator on entities\n * During evaluation, the evaluator will set various data points\n * on the entity objects to describe their state while evaluating.\n * This information can be found on the following paths\n * These paths are meant to be objects with\n * information about the properties in\n * a single place\n *\n * Stored in a flattened object like\n * widget.__evaluation__.errors.primaryColumns.customColumn.computedValue = [...]\n **/\nexport const EVALUATION_PATH = \"__evaluation__\";\nexport const EVAL_ERROR_PATH = `${EVALUATION_PATH}.errors`;\nexport const EVAL_VALUE_PATH = `${EVALUATION_PATH}.evaluatedValues`;\n\n/**\n * non-populated object\n {\n   __evaluation__:{\n     evaluatedValues:{\n       primaryColumns: [...],\n       primaryColumns.status: {...},\n       primaryColumns.action: {...}\n     }\n   }\n }\n\n * Populated Object\n {\n   __evaluation__:{\n     evaluatedValues:{\n       primaryColumns: {\n         status: [...],\n         action:[...]\n        }\n     }\n   }\n }\n\n */\nconst getNestedEvalPath = (\n  fullPropertyPath: string,\n  pathType: string,\n  fullPath = true,\n  isPopulated = false,\n) => {\n  const { entityName, propertyPath } = getEntityNameAndPropertyPath(\n    fullPropertyPath,\n  );\n  const nestedPath = isPopulated\n    ? `${pathType}.${propertyPath}`\n    : `${pathType}.['${propertyPath}']`;\n\n  if (fullPath) {\n    return `${entityName}.${nestedPath}`;\n  }\n  return nestedPath;\n};\n\nexport const getEvalErrorPath = (\n  fullPropertyPath: string,\n  options = {\n    fullPath: true,\n    isPopulated: false,\n  },\n) => {\n  return getNestedEvalPath(\n    fullPropertyPath,\n    EVAL_ERROR_PATH,\n    options.fullPath,\n    options.isPopulated,\n  );\n};\n\nexport const getEvalValuePath = (\n  fullPropertyPath: string,\n  options = {\n    fullPath: true,\n    isPopulated: false,\n  },\n) => {\n  return getNestedEvalPath(\n    fullPropertyPath,\n    EVAL_VALUE_PATH,\n    options.fullPath,\n    options.isPopulated,\n  );\n};\n\nexport enum PropertyEvaluationErrorType {\n  VALIDATION = \"VALIDATION\",\n  PARSE = \"PARSE\",\n  LINT = \"LINT\",\n}\nexport interface DataTreeError {\n  raw: string;\n  errorMessage: Error;\n  severity: Severity.WARNING | Severity.ERROR;\n}\n\nexport interface EvaluationError extends DataTreeError {\n  errorType:\n    | PropertyEvaluationErrorType.PARSE\n    | PropertyEvaluationErrorType.VALIDATION;\n  originalBinding?: string;\n}\n\nexport interface LintError extends DataTreeError {\n  errorType: PropertyEvaluationErrorType.LINT;\n  errorSegment: string;\n  originalBinding: string;\n  variables: (string | undefined | null)[];\n  code: string;\n  line: number;\n  ch: number;\n}\n\nexport interface DataTreeEvaluationProps {\n  __evaluation__?: {\n    errors: Record<string, EvaluationError[]>;\n    evaluatedValues?: Record<string, unknown>;\n  };\n}\n\nexport const PropertyEvalErrorTypeDebugMessage: Record<\n  PropertyEvaluationErrorType,\n  (propertyPath: string) => string\n> = {\n  [PropertyEvaluationErrorType.VALIDATION]: (propertyPath: string) =>\n    `The value at ${propertyPath} is invalid`,\n  [PropertyEvaluationErrorType.PARSE]: () => `Could not parse the binding`,\n  [PropertyEvaluationErrorType.LINT]: () => `Errors found while evaluating`,\n};\n\n// this variable temporarily holds dynamic paths generated by the recursive function (getDynamicValuePaths - Line 468).\nlet temporaryDynamicPathStore: DynamicPath[] = [];\n\n// recursive function to get full key path of any object that has dynamic bindings.\nconst getDynamicValuePaths = (val: any, parentPath: string) => {\n  if (isString(val) && isDynamicValue(val)) {\n    return temporaryDynamicPathStore.push({ key: `${parentPath}` });\n  }\n\n  if (Array.isArray(val)) {\n    val.forEach((obj, index) => {\n      return getDynamicValuePaths(obj, `${parentPath}[${index}]`);\n    });\n  }\n\n  if (isTrueObject(val)) {\n    Object.entries(val).forEach(([key, value]) => {\n      getDynamicValuePaths(value, `${parentPath}.${key}`);\n    });\n  }\n};\n\nexport function getDynamicBindingsChangesSaga(\n  action: Action,\n  value: unknown,\n  field: string,\n) {\n  const bindingField = field.replace(\"actionConfiguration.\", \"\");\n  // we listen to any viewType changes.\n  const viewType = field.endsWith(\".viewType\");\n  let dynamicBindings: DynamicPath[] = action.dynamicBindingPathList || [];\n\n  if (field.endsWith(\".jsonData\") || field.endsWith(\".componentData\")) {\n    return dynamicBindings;\n  }\n\n  if (\n    action.datasource &&\n    \"datasourceConfiguration\" in action.datasource &&\n    field === \"datasource\"\n  ) {\n    // only the datasource.datasourceConfiguration.url can be a dynamic field\n    dynamicBindings = dynamicBindings.filter(\n      (binding) => binding.key !== \"datasourceUrl\",\n    );\n    const datasourceUrl = action.datasource.datasourceConfiguration.url;\n    isDynamicValue(datasourceUrl) &&\n      dynamicBindings.push({ key: \"datasourceUrl\" });\n    return dynamicBindings;\n  }\n\n  // When a key-value pair is added or deleted from a fieldArray\n  // Value is an Array representing the new fieldArray.\n\n  if (Array.isArray(value)) {\n    // first we clear the dynamic bindings of any paths that is a child of the current path.\n    dynamicBindings = dynamicBindings.filter(\n      (binding) => !isChildPropertyPath(bindingField, binding.key),\n    );\n\n    // then we recursively go through the value and find paths with dynamic bindings\n    temporaryDynamicPathStore = [];\n    if (!!value) {\n      getDynamicValuePaths(value, bindingField);\n    }\n    if (!!temporaryDynamicPathStore && temporaryDynamicPathStore.length > 0) {\n      dynamicBindings = [...dynamicBindings, ...temporaryDynamicPathStore];\n    }\n  } else if (getType(value) === Types.OBJECT) {\n    dynamicBindings = dynamicBindings.filter((dynamicPath) => {\n      if (isChildPropertyPath(bindingField, dynamicPath.key)) {\n        const childPropertyValue = _.get(value, dynamicPath.key);\n        return isDynamicValue(childPropertyValue);\n      }\n    });\n  } else if (typeof value === \"string\") {\n    const fieldExists = _.some(dynamicBindings, { key: bindingField });\n\n    const isDynamic = isDynamicValue(value);\n\n    if (!isDynamic && fieldExists) {\n      dynamicBindings = dynamicBindings.filter((d) => d.key !== bindingField);\n    }\n    if (isDynamic && !fieldExists) {\n      dynamicBindings.push({ key: bindingField });\n    }\n  }\n\n  // the reason this is done is to change the dynamicBindingsPathlist of a component when a user toggles the form control\n  // from component mode to json mode and vice versa.\n\n  // when in json mode, we want to get rid of all the existing componentData paths and replace it with a single path for the json mode\n  // for example: [{key: 'formData.sortBy.data[0].column'}, {key: 'formData.sortBy.data[1].column'}] will be replaced with just this [{key: 'formData.sortBy.data'}]\n\n  // when in component mode, we want to first remove all the paths for json mode and\n  //  get back all the paths in the componentData that have dynamic bindings and add them to the the dynamic bindings pathlist.\n  // for example: [{key: 'formData.sortBy.data'}] will be replaced with this [{key: 'formData.sortBy.data[0].column'}, {key: 'formData.sortBy.data[1].column'}]\n\n  // if the currently changing field is a component's view type\n  if (!!viewType) {\n    const dataBindingField = bindingField.replace(\".viewType\", \".data\");\n    // then we filter the field of any paths that includes the binding fields\n    dynamicBindings = dynamicBindings.filter(\n      (dynamicPath) => !dynamicPath?.key?.includes(dataBindingField),\n    );\n\n    // if the value of the viewType is of json and, we push in the field\n    if (value === ViewTypes.JSON) {\n      const jsonFieldPath = field.replace(\".viewType\", \".jsonData\");\n      const jsonFieldValue = get(action, jsonFieldPath);\n      if (isDynamicValue(jsonFieldValue)) {\n        dynamicBindings.push({ key: dataBindingField });\n      }\n    } else if (value === ViewTypes.COMPONENT) {\n      const componentFieldPath = field.replace(\".viewType\", \".componentData\");\n      const componentFieldValue = get(action, componentFieldPath);\n      temporaryDynamicPathStore = [];\n\n      if (!!componentFieldValue) {\n        getDynamicValuePaths(componentFieldValue, dataBindingField);\n      }\n      if (!!temporaryDynamicPathStore && temporaryDynamicPathStore.length > 0) {\n        dynamicBindings = [...dynamicBindings, ...temporaryDynamicPathStore];\n      }\n    }\n  }\n  return dynamicBindings;\n}\n\nexport function getEntityType(entity: DataTreeEntity) {\n  return \"ENTITY_TYPE\" in entity && entity.ENTITY_TYPE;\n}\n\nexport function getEntityId(entity: DataTreeEntity) {\n  if (isAction(entity)) return entity.actionId;\n  if (isWidget(entity)) return entity.widgetId;\n  if (isJSAction(entity)) return entity.actionId;\n}\n\nexport function getEntityName(entity: DataTreeEntity) {\n  if (isAction(entity)) return entity.name;\n  if (isWidget(entity)) return entity.widgetName;\n  if (isJSAction(entity)) return entity.name;\n}\n","/**\n * This file contains the utility function to send and receive messages from the worker.\n * TRequestMessage<TBody> is used to send a request to/from the worker.\n * TResponseMessage<TBody> is used to send a response to/from the worker.\n * TDefaultMessage<TBody> is used to send a message to/from worker. Does not expect a response.\n */\n\nexport enum MessageType {\n  REQUEST = \"REQUEST\",\n  RESPONSE = \"RESPONSE\",\n  DEFAULT = \"DEFAULT\",\n}\n\ntype TRequestMessage<TBody> = {\n  body: TBody;\n  messageId: string;\n  messageType: MessageType.REQUEST;\n};\n\ntype TResponseMessage<TBody> = {\n  body: TBody;\n  messageId: string;\n  messageType: MessageType.RESPONSE;\n};\n\nexport type TDefaultMessage<TBody> = {\n  messageId?: string;\n  body: TBody;\n  messageType: MessageType.DEFAULT;\n};\n\nexport type TMessage<TBody> =\n  | TRequestMessage<TBody>\n  | TResponseMessage<TBody>\n  | TDefaultMessage<TBody>;\n\n/** Avoid from using postMessage directly.\n * This function should be used to send messages to the worker and back.\n * Purpose: To have some standardization in the messages that are transferred.\n * TODO: Add support for window postMessage options\n * TODO: Add support for transferable objects.\n */\nexport function sendMessage(\n  this: Worker | typeof globalThis,\n  message: TMessage<unknown>,\n) {\n  this.postMessage(message);\n}\n","import _ from \"lodash\";\n\nexport enum Types {\n  URL = \"URL\",\n  STRING = \"STRING\",\n  NUMBER = \"NUMBER\",\n  BOOLEAN = \"BOOLEAN\",\n  OBJECT = \"OBJECT\",\n  ARRAY = \"ARRAY\",\n  FUNCTION = \"FUNCTION\",\n  UNDEFINED = \"UNDEFINED\",\n  NULL = \"NULL\",\n  UNKNOWN = \"UNKNOWN\",\n}\n\nexport const getType = (value: unknown) => {\n  if (_.isString(value)) return Types.STRING;\n  if (_.isNumber(value)) return Types.NUMBER;\n  if (_.isBoolean(value)) return Types.BOOLEAN;\n  if (Array.isArray(value)) return Types.ARRAY;\n  if (_.isFunction(value)) return Types.FUNCTION;\n  if (_.isObject(value)) return Types.OBJECT;\n  if (_.isUndefined(value)) return Types.UNDEFINED;\n  if (_.isNull(value)) return Types.NULL;\n  return Types.UNKNOWN;\n};\n\nexport function isURL(str: string) {\n  const pattern = new RegExp(\n    \"^((blob:)?https?:\\\\/\\\\/)?\" + // protocol\n    \"((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.)+[a-z]{2,}|\" + // domain name\n    \"((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))\" + // OR ip (v4) address\n    \"(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*\" + // port and path\n    \"(\\\\?[;&a-z\\\\d%_.~+=-]*)?\" + // query string\n      \"(\\\\#[-a-z\\\\d_]*)?$\",\n    \"i\",\n  ); // fragment locator\n  return !!pattern.test(str);\n}\n\nexport type TruthyPrimitiveTypes = number | string | boolean | bigint | symbol;\n","import {\n  DataTree,\n  DataTreeAppsmith,\n  DataTreeJSAction,\n  EvaluationSubstitutionType,\n} from \"entities/DataTree/dataTreeFactory\";\nimport { ParsedBody, ParsedJSSubAction } from \"utils/JSPaneUtils\";\nimport { unset, set, get, find } from \"lodash\";\nimport {\n  BatchedJSExecutionData,\n  BatchedJSExecutionErrors,\n  JSCollectionData,\n  JSExecutionData,\n  JSExecutionError,\n} from \"reducers/entityReducers/jsActionsReducer\";\nimport { select } from \"redux-saga/effects\";\nimport { JSAction } from \"entities/JSCollection\";\nimport { getJSCollectionsForCurrentPage } from \"selectors/entitiesSelector\";\nimport {\n  getEntityNameAndPropertyPath,\n  isJSAction,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport { APP_MODE } from \"entities/App\";\n\n/**\n * here we add/remove the properties (variables and actions) which got added/removed from the JSObject parsedBody.\n  NOTE: For other entity below logic is maintained in DataTreeFactory, for JSObject we handle it inside evaluations\n * \n * @param parsedBody \n * @param jsCollection \n * @param unEvalTree \n * @returns \n */\nexport const updateJSCollectionInUnEvalTree = (\n  parsedBody: ParsedBody,\n  jsCollection: DataTreeJSAction,\n  unEvalTree: DataTree,\n) => {\n  // jsCollection here means unEvalTree JSObject\n  const modifiedUnEvalTree = unEvalTree;\n  const functionsList: Array<string> = [];\n  const varList: Array<string> = jsCollection.variables;\n  Object.keys(jsCollection.meta).forEach((action) => {\n    functionsList.push(action);\n  });\n\n  const oldConfig = Object.getPrototypeOf(jsCollection) as DataTreeJSAction;\n\n  if (parsedBody.actions && parsedBody.actions.length > 0) {\n    for (let i = 0; i < parsedBody.actions.length; i++) {\n      const action = parsedBody.actions[i];\n      if (jsCollection.hasOwnProperty(action.name)) {\n        if (jsCollection[action.name] !== action.body) {\n          const data = get(\n            modifiedUnEvalTree,\n            `${jsCollection.name}.${action.name}.data`,\n            {},\n          );\n          set(\n            modifiedUnEvalTree,\n            `${jsCollection.name}.${action.name}`,\n            new String(action.body),\n          );\n\n          set(\n            modifiedUnEvalTree,\n            `${jsCollection.name}.${action.name}.data`,\n            data,\n          );\n        }\n      } else {\n        const reactivePaths = oldConfig.reactivePaths;\n\n        reactivePaths[action.name] =\n          EvaluationSubstitutionType.SMART_SUBSTITUTE;\n        reactivePaths[`${action.name}.data`] =\n          EvaluationSubstitutionType.TEMPLATE;\n\n        const dynamicBindingPathList = oldConfig.dynamicBindingPathList;\n        dynamicBindingPathList.push({ key: action.name });\n\n        const dependencyMap = oldConfig.dependencyMap;\n        dependencyMap[\"body\"].push(action.name);\n\n        const meta = oldConfig.meta;\n        meta[action.name] = {\n          arguments: action.arguments,\n          isAsync: false,\n          confirmBeforeExecute: false,\n        };\n\n        const data = get(\n          modifiedUnEvalTree,\n          `${jsCollection.name}.${action.name}.data`,\n          {},\n        );\n        set(\n          modifiedUnEvalTree,\n          `${jsCollection.name}.${action.name}`,\n          new String(action.body.toString()),\n        );\n        set(\n          modifiedUnEvalTree,\n          `${jsCollection.name}.${action.name}.data`,\n          data,\n        );\n      }\n    }\n  }\n  if (functionsList && functionsList.length > 0) {\n    for (let i = 0; i < functionsList.length; i++) {\n      const oldActionName = functionsList[i];\n      const existed = parsedBody.actions.find(\n        (js: ParsedJSSubAction) => js.name === oldActionName,\n      );\n      if (!existed) {\n        const reactivePaths = oldConfig.reactivePaths;\n        delete reactivePaths[oldActionName];\n\n        oldConfig.dynamicBindingPathList = oldConfig.dynamicBindingPathList.filter(\n          (path) => path[\"key\"] !== oldActionName,\n        );\n\n        const dependencyMap = oldConfig.dependencyMap[\"body\"];\n        const removeIndex = dependencyMap.indexOf(oldActionName);\n        if (removeIndex > -1) {\n          oldConfig.dependencyMap[\"body\"] = dependencyMap.filter(\n            (item) => item !== oldActionName,\n          );\n        }\n        const meta = oldConfig.meta;\n        delete meta[oldActionName];\n\n        unset(modifiedUnEvalTree[jsCollection.name], oldActionName);\n        unset(modifiedUnEvalTree[jsCollection.name], `${oldActionName}.data`);\n      }\n    }\n  }\n  if (parsedBody.variables.length) {\n    for (let i = 0; i < parsedBody.variables.length; i++) {\n      const newVar = parsedBody.variables[i];\n      const existedVar = varList.indexOf(newVar.name);\n      if (existedVar > -1) {\n        const existedVarVal = jsCollection[newVar.name];\n        if (\n          (!!existedVarVal && existedVarVal.toString()) !==\n            (newVar.value && newVar.value.toString()) ||\n          (!existedVarVal && !!newVar)\n        ) {\n          set(\n            modifiedUnEvalTree,\n            `${jsCollection.name}.${newVar.name}`,\n            newVar.value,\n          );\n        }\n      } else {\n        varList.push(newVar.name);\n        const reactivePaths = oldConfig.reactivePaths;\n        reactivePaths[newVar.name] =\n          EvaluationSubstitutionType.SMART_SUBSTITUTE;\n\n        const dynamicBindingPathList = oldConfig.dynamicBindingPathList;\n        dynamicBindingPathList.push({ key: newVar.name });\n\n        set(modifiedUnEvalTree, `${jsCollection.name}.variables`, varList);\n        set(\n          modifiedUnEvalTree,\n          `${jsCollection.name}.${newVar.name}`,\n          newVar.value,\n        );\n      }\n    }\n    let newVarList: Array<string> = varList;\n    for (let i = 0; i < varList.length; i++) {\n      const varListItem = varList[i];\n      const existsInParsed = parsedBody.variables.find(\n        (item) => item.name === varListItem,\n      );\n      if (!existsInParsed) {\n        const reactivePaths = oldConfig.reactivePaths;\n        delete reactivePaths[varListItem];\n\n        oldConfig.dynamicBindingPathList = oldConfig.dynamicBindingPathList.filter(\n          (path) => path[\"key\"] !== varListItem,\n        );\n\n        newVarList = newVarList.filter((item) => item !== varListItem);\n        unset(modifiedUnEvalTree[jsCollection.name], varListItem);\n      }\n    }\n    if (newVarList.length) {\n      set(modifiedUnEvalTree, `${jsCollection.name}.variables`, newVarList);\n    }\n  }\n  return modifiedUnEvalTree;\n};\n\n/**\n * When JSObject parseBody is empty we remove all variables and actions from unEvalTree\n * this will lead to removal of properties from the dataTree\n * @param unEvalTree\n * @param entity\n * @returns\n */\nexport const removeFunctionsAndVariableJSCollection = (\n  unEvalTree: DataTree,\n  entity: DataTreeJSAction,\n  jsEntityName: string,\n) => {\n  const oldConfig = Object.getPrototypeOf(entity) as DataTreeJSAction;\n  const modifiedDataTree: DataTree = unEvalTree;\n  const functionsList: Array<string> = [];\n  Object.keys(entity.meta).forEach((action) => {\n    functionsList.push(action);\n  });\n  //removed variables\n  const varList: Array<string> = entity.variables;\n  set(modifiedDataTree, `${jsEntityName}.variables`, []);\n  for (let i = 0; i < varList.length; i++) {\n    const varName = varList[i];\n    unset(modifiedDataTree[jsEntityName], varName);\n  }\n  //remove functions\n\n  const reactivePaths = entity.reactivePaths;\n  const meta = entity.meta;\n\n  for (let i = 0; i < functionsList.length; i++) {\n    const actionName = functionsList[i];\n    delete reactivePaths[actionName];\n    delete meta[actionName];\n    unset(modifiedDataTree[jsEntityName], actionName);\n\n    oldConfig.dynamicBindingPathList = oldConfig.dynamicBindingPathList.filter(\n      (path: any) => path[\"key\"] !== actionName,\n    );\n\n    entity.dependencyMap[\"body\"] = entity.dependencyMap[\"body\"].filter(\n      (item: any) => item !== actionName,\n    );\n  }\n\n  return modifiedDataTree;\n};\n\nexport function isJSObjectFunction(\n  dataTree: DataTree,\n  jsObjectName: string,\n  key: string,\n) {\n  const entity = dataTree[jsObjectName];\n  if (isJSAction(entity)) {\n    return entity.meta.hasOwnProperty(key);\n  }\n  return false;\n}\n\nexport function getAppMode(dataTree: DataTree) {\n  const appsmithObj = dataTree.appsmith as DataTreeAppsmith;\n  return appsmithObj.mode as APP_MODE;\n}\n\nexport function isPromise(value: any): value is Promise<unknown> {\n  return Boolean(value && typeof value.then === \"function\");\n}\n\nfunction updateJSExecutionError(\n  errors: BatchedJSExecutionErrors,\n  executionError: JSExecutionError,\n) {\n  const { collectionId } = executionError;\n  if (errors[collectionId]) {\n    errors[collectionId].push(executionError);\n  } else {\n    errors[collectionId] = [executionError];\n  }\n}\n\nfunction updateJSExecutionData(\n  sortedData: BatchedJSExecutionData,\n  executionData: JSExecutionData,\n) {\n  const { collectionId } = executionData;\n  if (sortedData[collectionId]) {\n    sortedData[collectionId].push(executionData);\n  } else {\n    sortedData[collectionId] = [executionData];\n  }\n}\n\nfunction getJSActionFromJSCollections(\n  jsCollections: JSCollectionData[],\n  jsfuncFullName: string,\n) {\n  const {\n    entityName: collectionName,\n    propertyPath: functionName,\n  } = getEntityNameAndPropertyPath(jsfuncFullName);\n\n  const jsCollection = find(\n    jsCollections,\n    (collection) => collection.config.name === collectionName,\n  );\n  if (!jsCollection) return;\n\n  const jsAction: JSAction | undefined = find(\n    jsCollection.config.actions,\n    (action) => action.name === functionName,\n  );\n  return jsAction;\n}\n\nexport function* sortJSExecutionDataByCollectionId(\n  data: Record<string, unknown>,\n  errors: Record<string, unknown>,\n) {\n  // Sorted data by collectionId\n  const sortedData: BatchedJSExecutionData = {};\n  // Sorted errors by collectionId\n  const sortedErrors: BatchedJSExecutionErrors = {};\n\n  const JSCollectionsForCurrentPage: JSCollectionData[] = yield select(\n    getJSCollectionsForCurrentPage,\n  );\n\n  for (const jsfuncFullName of Object.keys(data)) {\n    const jsAction = getJSActionFromJSCollections(\n      JSCollectionsForCurrentPage,\n      jsfuncFullName,\n    );\n    if (!(jsAction && jsAction.collectionId)) continue;\n    const { collectionId, id: actionId } = jsAction;\n\n    if (errors[jsfuncFullName]) {\n      updateJSExecutionError(sortedErrors, {\n        collectionId,\n        isDirty: true,\n        actionId,\n      });\n    }\n\n    updateJSExecutionData(sortedData, {\n      collectionId,\n      actionId,\n      data: get(data, jsfuncFullName),\n    });\n  }\n\n  return { sortedData, sortedErrors };\n}\n","//@ts-expect-error no types.\nimport * as documentMock from \"linkedom/worker\";\n\nexport const DOM_APIS = Object.keys(documentMock).reduce((acc, key) => {\n  acc[key] = true;\n  return acc;\n}, {} as Record<string, true>);\n\nexport default function() {\n  for (const [key, value] of Object.entries(documentMock)) {\n    //@ts-expect-error no types\n    self[key] = value;\n  }\n  const dom = documentMock.parseHTML(`<!DOCTYPE html><body></body>`);\n  self.window = dom.window;\n  self.document = dom.window.document;\n  self.window = self;\n}\n","import { DataTree } from \"entities/DataTree/dataTreeFactory\";\nimport { getAllAsyncFunctions } from \"@appsmith/workers/Evaluation/Actions\";\n\nconst UNDEFINED_ACTION_IN_SYNC_EVAL_ERROR =\n  \"Found a reference to {{actionName}} during evaluation. Sync fields cannot execute framework actions. Please remove any direct/indirect references to {{actionName}} and try again.\";\n\nclass ErrorModifier {\n  private errorNamesToScan = [\"ReferenceError\", \"TypeError\"];\n  // Note all regex below groups the async function name\n\n  private asyncFunctionsNameMap: Record<string, true> = {};\n\n  updateAsyncFunctions(dataTree: DataTree) {\n    this.asyncFunctionsNameMap = getAllAsyncFunctions(dataTree);\n  }\n\n  run(error: Error) {\n    const errorMessage = getErrorMessage(error);\n\n    if (!this.errorNamesToScan.includes(error.name)) return errorMessage;\n\n    for (const asyncFunctionFullPath of Object.keys(\n      this.asyncFunctionsNameMap,\n    )) {\n      const functionNameWithWhiteSpace = \" \" + asyncFunctionFullPath + \" \";\n      if (getErrorMessageWithType(error).match(functionNameWithWhiteSpace)) {\n        return {\n          name: \"ValidationError\",\n          message: UNDEFINED_ACTION_IN_SYNC_EVAL_ERROR.replaceAll(\n            \"{{actionName}}\",\n            asyncFunctionFullPath + \"()\",\n          ),\n        };\n      }\n    }\n\n    return errorMessage;\n  }\n}\n\nexport const errorModifier = new ErrorModifier();\n\nexport class FoundPromiseInSyncEvalError extends Error {\n  constructor() {\n    super();\n    this.name = \"\";\n    this.message =\n      \"Found a Promise() during evaluation. Sync fields cannot execute asynchronous code.\";\n  }\n}\n\nexport class ActionCalledInSyncFieldError extends Error {\n  constructor(actionName: string) {\n    super(actionName);\n\n    if (!actionName) {\n      this.message = \"Async function called in a sync field\";\n      return;\n    }\n\n    this.name = \"\";\n    this.message = UNDEFINED_ACTION_IN_SYNC_EVAL_ERROR.replaceAll(\n      \"{{actionName}}\",\n      actionName + \"()\",\n    );\n  }\n}\n\nexport const getErrorMessage = (error: Error) => {\n  return error.name\n    ? {\n        name: error.name,\n        message: error.message,\n      }\n    : {\n        name: \"ValidationError\",\n        message: error.message,\n      };\n};\n\nexport const getErrorMessageWithType = (error: Error) => {\n  return error.name ? `${error.name}: ${error.message}` : error.message;\n};\n","/* eslint-disable no-console */\nimport { DataTree } from \"entities/DataTree/dataTreeFactory\";\nimport {\n  EvaluationError,\n  PropertyEvaluationErrorType,\n} from \"utils/DynamicBindingUtils\";\nimport unescapeJS from \"unescape-js\";\nimport { Severity } from \"entities/AppsmithConsole\";\nimport { EventType } from \"constants/AppsmithActionConstants/ActionConstants\";\nimport { TriggerMeta } from \"@appsmith/sagas/ActionExecution/ActionExecutionSagas\";\nimport indirectEval from \"./indirectEval\";\nimport { jsObjectFunctionFactory } from \"./fns/utils/jsObjectFnFactory\";\nimport { DOM_APIS } from \"./SetupDOM\";\nimport { JSLibraries, libraryReservedIdentifiers } from \"../common/JSLibrary\";\nimport { errorModifier, FoundPromiseInSyncEvalError } from \"./errorModifier\";\nimport { addDataTreeToContext } from \"@appsmith/workers/Evaluation/Actions\";\n\nexport type EvalResult = {\n  result: any;\n  errors: EvaluationError[];\n};\n\nexport enum EvaluationScriptType {\n  EXPRESSION = \"EXPRESSION\",\n  ANONYMOUS_FUNCTION = \"ANONYMOUS_FUNCTION\",\n  ASYNC_ANONYMOUS_FUNCTION = \"ASYNC_ANONYMOUS_FUNCTION\",\n  TRIGGERS = \"TRIGGERS\",\n}\n\nexport const ScriptTemplate = \"<<string>>\";\n\nexport const EvaluationScripts: Record<EvaluationScriptType, string> = {\n  [EvaluationScriptType.EXPRESSION]: `\n  function $$closedFn () {\n    const $$result = ${ScriptTemplate}\n    return $$result\n  }\n  $$closedFn.call(THIS_CONTEXT)\n  `,\n  [EvaluationScriptType.ANONYMOUS_FUNCTION]: `\n  function $$closedFn (script) {\n    const $$userFunction = script;\n    const $$result = $$userFunction?.apply(THIS_CONTEXT, ARGUMENTS);\n    return $$result\n  }\n  $$closedFn(${ScriptTemplate})\n  `,\n  [EvaluationScriptType.ASYNC_ANONYMOUS_FUNCTION]: `\n  async function $$closedFn (script) {\n    const $$userFunction = script;\n    const $$result = $$userFunction?.apply(THIS_CONTEXT, ARGUMENTS);\n    return await $$result;\n  }\n  $$closedFn(${ScriptTemplate})\n  `,\n  [EvaluationScriptType.TRIGGERS]: `\n  async function $$closedFn () {\n    const $$result = ${ScriptTemplate};\n    return await $$result\n  }\n  $$closedFn.call(THIS_CONTEXT)\n  `,\n};\n\nconst topLevelWorkerAPIs = Object.keys(self).reduce((acc, key: string) => {\n  acc[key] = true;\n  return acc;\n}, {} as any);\n\nfunction resetWorkerGlobalScope() {\n  self.$isDataField = false;\n  for (const key of Object.keys(self)) {\n    if (topLevelWorkerAPIs[key] || DOM_APIS[key]) continue;\n    //TODO: Remove this once we have a better way to handle this\n    if ([\"evaluationVersion\", \"window\", \"document\", \"location\"].includes(key))\n      continue;\n    if (JSLibraries.find((lib) => lib.accessor.includes(key))) continue;\n    if (libraryReservedIdentifiers[key]) continue;\n    try {\n      // @ts-expect-error: Types are not available\n      delete self[key];\n    } catch (e) {\n      // @ts-expect-error: Types are not available\n      self[key] = undefined;\n    }\n  }\n}\n\nexport const getScriptType = (\n  evalArgumentsExist = false,\n  isTriggerBased = false,\n): EvaluationScriptType => {\n  let scriptType = EvaluationScriptType.EXPRESSION;\n  if (evalArgumentsExist && isTriggerBased) {\n    scriptType = EvaluationScriptType.ASYNC_ANONYMOUS_FUNCTION;\n  } else if (evalArgumentsExist && !isTriggerBased) {\n    scriptType = EvaluationScriptType.ANONYMOUS_FUNCTION;\n  } else if (isTriggerBased && !evalArgumentsExist) {\n    scriptType = EvaluationScriptType.TRIGGERS;\n  }\n  return scriptType;\n};\n\nexport const additionalLibrariesNames: string[] = [];\n\nexport const getScriptToEval = (\n  userScript: string,\n  type: EvaluationScriptType,\n): string => {\n  // Using replace here would break scripts with replacement patterns (ex: $&, $$)\n  const buffer = EvaluationScripts[type].split(ScriptTemplate);\n  return `${buffer[0]}${userScript}${buffer[1]}`;\n};\n\nconst beginsWithLineBreakRegex = /^\\s+|\\s+$/;\n\nexport type EvalContext = Record<string, any>;\ntype ResolvedFunctions = Record<string, any>;\nexport interface createEvaluationContextArgs {\n  dataTree: DataTree;\n  resolvedFunctions: ResolvedFunctions;\n  context?: EvaluateContext;\n  isTriggerBased: boolean;\n  evalArguments?: Array<unknown>;\n  // Whether not to add functions like \"run\", \"clear\" to entity in global data\n  skipEntityFunctions?: boolean;\n}\n/**\n * This method created an object with dataTree and appsmith's framework actions that needs to be added to worker global scope for the JS code evaluation to then consume it.\n *\n * Example:\n * - For `eval(\"Table1.tableData\")` code to work as expected, we define Table1.tableData in worker global scope and for that we use `createEvaluationContext` to get the object to set in global scope.\n */\nexport const createEvaluationContext = (args: createEvaluationContextArgs) => {\n  const {\n    context,\n    dataTree,\n    evalArguments,\n    isTriggerBased,\n    resolvedFunctions,\n    skipEntityFunctions,\n  } = args;\n\n  const EVAL_CONTEXT: EvalContext = {};\n  ///// Adding callback data\n  EVAL_CONTEXT.ARGUMENTS = evalArguments;\n  //// Adding contextual data not part of data tree\n  EVAL_CONTEXT.THIS_CONTEXT = context?.thisContext || {};\n\n  if (context?.globalContext) {\n    Object.assign(EVAL_CONTEXT, context.globalContext);\n  }\n\n  addDataTreeToContext({\n    EVAL_CONTEXT,\n    dataTree,\n    skipEntityFunctions: !!skipEntityFunctions,\n    isTriggerBased,\n  });\n\n  assignJSFunctionsToContext(EVAL_CONTEXT, resolvedFunctions, isTriggerBased);\n\n  return EVAL_CONTEXT;\n};\n\nexport const assignJSFunctionsToContext = (\n  EVAL_CONTEXT: EvalContext,\n  resolvedFunctions: ResolvedFunctions,\n  isTriggerBased: boolean,\n) => {\n  const jsObjectNames = Object.keys(resolvedFunctions || {});\n  for (const jsObjectName of jsObjectNames) {\n    const resolvedObject = resolvedFunctions[jsObjectName];\n    const jsObject = EVAL_CONTEXT[jsObjectName];\n    const jsObjectFunction: Record<string, Record<\"data\", unknown>> = {};\n    if (!jsObject) continue;\n    for (const fnName of Object.keys(resolvedObject)) {\n      const fn = resolvedObject[fnName];\n      if (typeof fn !== \"function\") continue;\n      // Investigate promisify of JSObject function confirmation\n      // Task: https://github.com/appsmithorg/appsmith/issues/13289\n      // Previous implementation commented code: https://github.com/appsmithorg/appsmith/pull/18471\n      const data = jsObject[fnName]?.data;\n      jsObjectFunction[fnName] = isTriggerBased\n        ? jsObjectFunctionFactory(fn, jsObjectName + \".\" + fnName)\n        : fn;\n      if (!!data) {\n        jsObjectFunction[fnName][\"data\"] = data;\n      }\n    }\n\n    EVAL_CONTEXT[jsObjectName] = Object.assign({}, jsObject, jsObjectFunction);\n  }\n};\n\nexport function sanitizeScript(js: string) {\n  // We remove any line breaks from the beginning of the script because that\n  // makes the final function invalid. We also unescape any escaped characters\n  // so that eval can happen\n  const trimmedJS = js.replace(beginsWithLineBreakRegex, \"\");\n  return self.evaluationVersion > 1 ? trimmedJS : unescapeJS(trimmedJS);\n}\n\n/** Define a context just for this script\n * thisContext will define it on the `this`\n * globalContext will define it globally\n * requestId is used for completing promises\n */\nexport type EvaluateContext = {\n  thisContext?: Record<string, any>;\n  globalContext?: Record<string, any>;\n  requestId?: string;\n  eventType?: EventType;\n  triggerMeta?: TriggerMeta;\n};\n\nexport const getUserScriptToEvaluate = (\n  userScript: string,\n  isTriggerBased: boolean,\n  evalArguments?: Array<any>,\n) => {\n  const unescapedJS = sanitizeScript(userScript);\n  // If nothing is present to evaluate, return\n  if (!unescapedJS.length) {\n    return {\n      script: \"\",\n    };\n  }\n  const scriptType = getScriptType(!!evalArguments, isTriggerBased);\n  const script = getScriptToEval(unescapedJS, scriptType);\n  return { script };\n};\n\nexport default function evaluateSync(\n  userScript: string,\n  dataTree: DataTree,\n  resolvedFunctions: Record<string, any>,\n  isJSCollection: boolean,\n  context?: EvaluateContext,\n  evalArguments?: Array<any>,\n): EvalResult {\n  return (function() {\n    resetWorkerGlobalScope();\n    const errors: EvaluationError[] = [];\n    let result;\n\n    // skipping log reset if the js collection is being evaluated without run\n    // Doing this because the promise execution is losing logs in the process due to resets\n    /**** Setting the eval context ****/\n    const evalContext: EvalContext = createEvaluationContext({\n      dataTree,\n      resolvedFunctions,\n      context,\n      evalArguments,\n      isTriggerBased: isJSCollection,\n    });\n\n    evalContext[\"$isDataField\"] = true;\n\n    const { script } = getUserScriptToEvaluate(\n      userScript,\n      false,\n      evalArguments,\n    );\n\n    // If nothing is present to evaluate, return instead of evaluating\n    if (!script.length) {\n      return {\n        errors: [],\n        result: undefined,\n        triggers: [],\n      };\n    }\n\n    // Set it to self so that the eval function can have access to it\n    // as global data. This is what enables access all appsmith\n    // entity properties from the global context\n    Object.assign(self, evalContext);\n\n    try {\n      result = indirectEval(script);\n      if (result instanceof Promise) {\n        /**\n         * If a promise is returned in sync field then show the error to help understand sync field doesn't await to resolve promise.\n         * NOTE: Awaiting for promise will make sync field evaluation slower.\n         */\n        throw new FoundPromiseInSyncEvalError();\n      }\n    } catch (error) {\n      errors.push({\n        errorMessage: errorModifier.run(error as Error),\n        severity: Severity.ERROR,\n        raw: script,\n        errorType: PropertyEvaluationErrorType.PARSE,\n        originalBinding: userScript,\n      });\n    } finally {\n      for (const entityName in evalContext) {\n        if (evalContext.hasOwnProperty(entityName)) {\n          // @ts-expect-error: Types are not available\n          delete self[entityName];\n        }\n      }\n      self[\"$isDataField\"] = false;\n    }\n    return { result, errors };\n  })();\n}\n\nexport async function evaluateAsync(\n  userScript: string,\n  dataTree: DataTree,\n  resolvedFunctions: Record<string, any>,\n  context?: EvaluateContext,\n  evalArguments?: Array<any>,\n) {\n  return (async function() {\n    resetWorkerGlobalScope();\n    const errors: EvaluationError[] = [];\n    let result;\n\n    /**** Setting the eval context ****/\n    const evalContext: EvalContext = createEvaluationContext({\n      dataTree,\n      resolvedFunctions,\n      context,\n      evalArguments,\n      isTriggerBased: true,\n    });\n\n    const { script } = getUserScriptToEvaluate(userScript, true, evalArguments);\n    evalContext[\"$isDataField\"] = false;\n\n    // Set it to self so that the eval function can have access to it\n    // as global data. This is what enables access all appsmith\n    // entity properties from the global context\n    Object.assign(self, evalContext);\n\n    try {\n      result = await indirectEval(script);\n    } catch (e) {\n      const error = e as Error;\n      const errorMessage = error.name\n        ? { name: error.name, message: error.message }\n        : {\n            name: \"UncaughtPromiseRejection\",\n            message: `${error.message}`,\n          };\n      errors.push({\n        errorMessage: errorMessage,\n        severity: Severity.ERROR,\n        raw: script,\n        errorType: PropertyEvaluationErrorType.PARSE,\n        originalBinding: userScript,\n      });\n    } finally {\n      return {\n        result,\n        errors,\n      };\n    }\n  })();\n}\n","import { dataTreeEvaluator } from \"./evalTree\";\nimport { EvalWorkerASyncRequest } from \"../types\";\nimport { createUnEvalTreeForEval } from \"@appsmith/workers/Evaluation/dataTreeUtils\";\nimport ExecutionMetaData from \"../fns/utils/ExecutionMetaData\";\n\nexport default async function(request: EvalWorkerASyncRequest) {\n  const { data } = request;\n  const {\n    callbackData,\n    dynamicTrigger,\n    eventType,\n    globalContext,\n    triggerMeta,\n    unEvalTree: __unEvalTree__,\n  } = data;\n  if (!dataTreeEvaluator) {\n    return { triggers: [], errors: [] };\n  }\n  ExecutionMetaData.setExecutionMetaData(triggerMeta, eventType);\n  const unEvalTree = createUnEvalTreeForEval(__unEvalTree__);\n  const {\n    evalOrder,\n    nonDynamicFieldValidationOrder,\n    unEvalUpdates,\n  } = dataTreeEvaluator.setupUpdateTree(unEvalTree);\n  dataTreeEvaluator.evalAndValidateSubTree(\n    evalOrder,\n    nonDynamicFieldValidationOrder,\n    unEvalUpdates,\n  );\n  const evalTree = dataTreeEvaluator.evalTree;\n  const resolvedFunctions = dataTreeEvaluator.resolvedFunctions;\n\n  return dataTreeEvaluator.evaluateTriggers(\n    dynamicTrigger,\n    evalTree,\n    resolvedFunctions,\n    callbackData,\n    {\n      globalContext,\n      eventType,\n      triggerMeta,\n    },\n  );\n}\n","export function createMessage(\n  format: (...strArgs: any[]) => string,\n  ...args: any[]\n) {\n  return format(...args);\n}\n\n/*\n  For self hosted, it displays the string \"Appsmith Community v1.10.0\" or \"Appsmith Business v1.10.0\".\n  For cloud hosting, it displays \"Appsmith v1.10.0\".\n  This is because Appsmith Cloud doesn't support business features yet.\n */\nexport const APPSMITH_DISPLAY_VERSION = (\n  edition: string,\n  version: string,\n  cloudHosting: boolean,\n) => `Appsmith ${!cloudHosting ? edition : \"\"} ${version}`;\nexport const YES = () => `Yes`;\nexport const ARE_YOU_SURE = () => `Are you sure?`;\nexport const ERROR_ADD_API_INVALID_URL = () =>\n  `Unable to create API. Try adding a URL to the datasource`;\nexport const ERROR_MESSAGE_NAME_EMPTY = () => `Please select a name`;\nexport const ERROR_MESSAGE_CREATE_APPLICATION = () =>\n  `We could not create the Application`;\nexport const APPLICATION_NAME_UPDATE = () => `Application name updated`;\nexport const ERROR_EMPTY_APPLICATION_NAME = () =>\n  `Application name can't be empty`;\nexport const API_PATH_START_WITH_SLASH_ERROR = () => `Path cannot start with /`;\nexport const FIELD_REQUIRED_ERROR = () => `This field is required`;\nexport const INPUT_DEFAULT_TEXT_MAX_CHAR_ERROR = (max: number) =>\n  `Default text length must be less than or equal to ${max} characters`;\nexport const INPUT_TEXT_MAX_CHAR_ERROR = (max: number) =>\n  `Input text length must be less than ${max} characters`;\nexport const INPUT_DEFAULT_TEXT_MAX_NUM_ERROR = () =>\n  `Default Text value must be less than Max number allowed`;\nexport const INPUT_DEFAULT_TEXT_MIN_NUM_ERROR = () =>\n  `Default Text value must be greater than Min number allowed`;\nexport const VALID_FUNCTION_NAME_ERROR = () =>\n  `Must be a valid variable name (camelCase)`;\nexport const UNIQUE_NAME_ERROR = () => `Name must be unique`;\nexport const NAME_SPACE_ERROR = () => `Name must not have spaces`;\nexport const APLHANUMERIC_HYPHEN_SLASH_SPACE_ERROR = () =>\n  `Name must only contain alphanumeric characters, hyphen, slash, and space`;\n\nexport const FORM_VALIDATION_EMPTY_EMAIL = () => `Please enter an email`;\nexport const FORM_VALIDATION_INVALID_EMAIL = () =>\n  `Please provide a valid email address`;\nexport const ENTER_VIDEO_URL = () => `Please provide a valid url`;\nexport const ENTER_AUDIO_URL = () => `Please provide a valid url`;\n\nexport const FORM_VALIDATION_EMPTY_PASSWORD = () => `Please enter the password`;\nexport const FORM_VALIDATION_PASSWORD_RULE = () =>\n  `Please provide a password between 6 and 256 characters`;\nexport const FORM_VALIDATION_INVALID_PASSWORD = FORM_VALIDATION_PASSWORD_RULE;\n\nexport const LOGIN_PAGE_EMAIL_INPUT_LABEL = () => `Email`;\nexport const LOGIN_PAGE_PASSWORD_INPUT_LABEL = () => `Password`;\nexport const LOGIN_PAGE_EMAIL_INPUT_PLACEHOLDER = () =>\n  `Enter your email address`;\nexport const LOGIN_PAGE_PASSWORD_INPUT_PLACEHOLDER = () =>\n  `Enter your password`;\nexport const LOGIN_PAGE_INVALID_CREDS_ERROR = () =>\n  `It looks like you may have entered incorrect/invalid credentials. Please try again or reset password using the button below.`;\nexport const LOGIN_PAGE_INVALID_CREDS_FORGOT_PASSWORD_LINK = () =>\n  `Reset Password`;\nexport const NEW_TO_APPSMITH = () => `Don't have an account?`;\nexport const LOGIN_PAGE_TITLE = () => `Sign in`;\nexport const LOGIN_PAGE_SUBTITLE = () => `Sign in to your account`;\n\nexport const LOGIN_PAGE_LOGIN_BUTTON_TEXT = () => `sign in`;\nexport const LOGIN_PAGE_FORGOT_PASSWORD_TEXT = () => `Forgot Password`;\nexport const LOGIN_PAGE_REMEMBER_ME_LABEL = () => `Remember`;\nexport const LOGIN_PAGE_SIGN_UP_LINK_TEXT = () => `Sign up`;\nexport const SIGNUP_PAGE_TITLE = () => `Create your free account`;\nexport const SIGNUP_PAGE_SUBTITLE = () => `Use your workspace email`;\nexport const SIGNUP_PAGE_EMAIL_INPUT_LABEL = () => `Email`;\nexport const SIGNUP_PAGE_EMAIL_INPUT_PLACEHOLDER = () => `Email`;\nexport const SIGNUP_PAGE_NAME_INPUT_PLACEHOLDER = () => `Name`;\nexport const SIGNUP_PAGE_NAME_INPUT_LABEL = () => `Name`;\nexport const SIGNUP_PAGE_PASSWORD_INPUT_LABEL = () => `Password`;\nexport const SIGNUP_PAGE_PASSWORD_INPUT_PLACEHOLDER = () => `Password`;\nexport const SIGNUP_PAGE_LOGIN_LINK_TEXT = () => `Sign in`;\nexport const SIGNUP_PAGE_NAME_INPUT_SUBTEXT = () => `How should we call you?`;\nexport const SIGNUP_PAGE_SUBMIT_BUTTON_TEXT = () => `Sign Up`;\nexport const ALREADY_HAVE_AN_ACCOUNT = () => `Already have an account?`;\n\nexport const SIGNUP_PAGE_SUCCESS = () =>\n  `Awesome! You have successfully registered.`;\nexport const SIGNUP_PAGE_SUCCESS_LOGIN_BUTTON_TEXT = () => `Login`;\n\nexport const RESET_PASSWORD_PAGE_PASSWORD_INPUT_LABEL = () => `New password`;\nexport const RESET_PASSWORD_PAGE_PASSWORD_INPUT_PLACEHOLDER = () =>\n  `New Password`;\nexport const RESET_PASSWORD_LOGIN_LINK_TEXT = () => `Back to sign in`;\nexport const RESET_PASSWORD_PAGE_TITLE = () => `Reset password`;\nexport const RESET_PASSWORD_SUBMIT_BUTTON_TEXT = () => `Reset`;\nexport const RESET_PASSWORD_PAGE_SUBTITLE = () =>\n  `Create a new password for your account `;\n\nexport const RESET_PASSWORD_RESET_SUCCESS = () =>\n  `Your password has been reset`; //`Your password has been reset. Please login` (see next entry));\nexport const RESET_PASSWORD_RESET_SUCCESS_LOGIN_LINK = () => `Login`;\n\nexport const RESET_PASSWORD_EXPIRED_TOKEN = () =>\n  `The password reset link has expired. Please try generating a new link`;\nexport const RESET_PASSWORD_INVALID_TOKEN = () =>\n  `The password reset link is invalid. Please try generating a new link`;\nexport const RESET_PASSWORD_FORGOT_PASSWORD_LINK = () => `Forgot password`;\n\nexport const FORGOT_PASSWORD_PAGE_EMAIL_INPUT_LABEL = () => `Email`;\nexport const FORGOT_PASSWORD_PAGE_EMAIL_INPUT_PLACEHOLDER = () => `Email`;\nexport const FORGOT_PASSWORD_PAGE_TITLE = () => `Reset password`;\nexport const FORGOT_PASSWORD_PAGE_SUBTITLE = () =>\n  `We will send a reset link to the email below`;\nexport const FORGOT_PASSWORD_PAGE_SUBMIT_BUTTON_TEXT = () => `Reset`;\nexport const FORGOT_PASSWORD_SUCCESS_TEXT = (email: string) =>\n  `A password reset link has been sent to your email address ${email} registered with Appsmith.`;\n\nexport const PRIVACY_POLICY_LINK = () => `Privacy policy`;\nexport const TERMS_AND_CONDITIONS_LINK = () => `Terms and conditions`;\n\nexport const ERROR_500 = () =>\n  `We apologize, something went wrong. We're trying to fix things.`;\nexport const ERROR_0 = () =>\n  `We could not connect to our servers. Please check your network connection`;\nexport const ERROR_401 = () =>\n  `We are unable to verify your identity. Please login again.`;\nexport const ERROR_403 = (entity: string, userEmail: string) =>\n  `Sorry, but your account (${userEmail}) does not seem to have the required access to update this ${entity}. Please get in touch with your Appsmith admin to resolve this.`;\nexport const PAGE_NOT_FOUND_ERROR = () =>\n  `The page you’re looking for either does not exist, or cannot be found`;\nexport const INVALID_URL_ERROR = () => `Invalid URL`;\nexport const MAKE_APPLICATION_PUBLIC = () => \"Make application public\";\nexport const MAKE_APPLICATION_PUBLIC_TOOLTIP = () =>\n  \"A public app is accessible to anyone who can access your instance of appsmith\";\nexport const INVITE_TAB = () => \"Invite\";\nexport const INVITE_USERS_VALIDATION_EMAIL_LIST = () =>\n  `Invalid email address(es) found`;\nexport const INVITE_USERS_VALIDATION_ROLE_EMPTY = () => `Please select a role`;\n\nexport const INVITE_USERS_EMAIL_LIST_PLACEHOLDER = () =>\n  `Comma separated emails`;\nexport const INVITE_USERS_ROLE_SELECT_PLACEHOLDER = () => `Select role`;\nexport const INVITE_USERS_ROLE_SELECT_LABEL = () => `Role`;\nexport const INVITE_USERS_EMAIL_LIST_LABEL = () => `User emails`;\nexport const INVITE_USERS_ADD_EMAIL_LIST_FIELD = () => `Add more`;\nexport const INVITE_USERS_MESSAGE = () => `Invite users`;\nexport const INVITE_USERS_PLACEHOLDER = () => `Enter email address(es)`;\nexport const INVITE_USERS_SUBMIT_BUTTON_TEXT = () => `Invite users`;\nexport const INVITE_USERS_SUBMIT_SUCCESS = () =>\n  `The users have been invited successfully`;\nexport const INVITE_USER_SUBMIT_SUCCESS = () =>\n  `The user has been invited successfully`;\nexport const INVITE_USERS_VALIDATION_EMAILS_EMPTY = () =>\n  `Please enter the user emails`;\n\nexport const CREATE_PASSWORD_RESET_SUCCESS = () => `Your password has been set`;\nexport const CREATE_PASSWORD_RESET_SUCCESS_LOGIN_LINK = () => `Login`;\n\nexport const DELETING_APPLICATION = () => `Deleting application...`;\nexport const DUPLICATING_APPLICATION = () => `Duplicating application...`;\n\nexport const FORGOT_PASSWORD_PAGE_LOGIN_LINK = () => `Back to sign in`;\nexport const ADD_API_TO_PAGE_SUCCESS_MESSAGE = (actionName: string) =>\n  `${actionName} API added to page`;\nexport const INPUT_WIDGET_DEFAULT_VALIDATION_ERROR = () => `Invalid input`;\n\nexport const AUTOFIT_ALL_COLUMNS = () => `Autofit all columns`;\nexport const AUTOFIT_THIS_COLUMN = () => `Autofit this column`;\nexport const AUTOFIT_COLUMN = () => `Autofit column`;\n\nexport const DATE_WIDGET_DEFAULT_VALIDATION_ERROR = () => \"Date out of range\";\n\nexport const TIMEZONE = () => `Timezone`;\nexport const ENABLE_TIME = () => `Enable Time`;\n\nexport const EDIT_APP = () => `Edit App`;\nexport const FORK_APP = () => `Fork App`;\nexport const SIGN_IN = () => `Sign in`;\n\nexport const EDITOR_HEADER = {\n  saving: () => \"Saving\",\n  saveFailed: () => \"Save failed\",\n  share: () => \"SHARE\",\n  previewTooltip: {\n    text: () => \"Preview\",\n    shortcut: () => \"P\",\n  },\n};\n\n// Homepage\nexport const CREATE_NEW_APPLICATION = () => `Create new`;\nexport const SEARCH_APPS = () => `Search for apps...`;\nexport const GETTING_STARTED = () => `GETTING STARTED`;\nexport const WORKSPACES_HEADING = () => `WORKSPACES`;\nexport const WELCOME_TOUR = () => `Welcome Tour`;\nexport const NO_APPS_FOUND = () =>\n  `Whale! Whale! This name doesn't ring a bell!`;\n\n// Lightning menu\nexport const LIGHTNING_MENU_DATA_API = () => `Use data from an API`;\nexport const LIGHTNING_MENU_DATA_QUERY = () => `Use data from a query`;\nexport const LIGHTNING_MENU_DATA_TOOLTIP = () => `Quick start data binding`;\nexport const LIGHTNING_MENU_DATA_WIDGET = () => `Use data from a widget`;\nexport const LIGHTNING_MENU_QUERY_CREATE_NEW = () => `Create new query`;\nexport const LIGHTNING_MENU_API_CREATE_NEW = () => `Create new API`;\n\nexport const LIGHTNING_MENU_OPTION_TEXT = () => `Plain Text`;\nexport const LIGHTNING_MENU_OPTION_JS = () => `Write JS`;\nexport const LIGHTNING_MENU_OPTION_HTML = () => `Write HTML`;\nexport const CHECK_REQUEST_BODY = () =>\n  `Please check your request configuration to debug`;\nexport const DONT_SHOW_THIS_AGAIN = () => `Don't show this again`;\n\nexport const TABLE_FILTER_COLUMN_TYPE_CALLOUT = () =>\n  `Change column datatype to see filter operators`;\n\nexport const SAVE_HOTKEY_TOASTER_MESSAGE = () =>\n  \"Don't worry about saving, we've got you covered!\";\n\nexport const WIDGET_SIDEBAR_TITLE = () => `Widgets`;\nexport const WIDGET_SIDEBAR_CAPTION = () =>\n  `Drag a widget and drop it on the canvas`;\nexport const GOOGLE_RECAPTCHA_KEY_ERROR = () =>\n  `Google Re-Captcha token generation failed! Please check the Re-captcha site key.`;\nexport const GOOGLE_RECAPTCHA_DOMAIN_ERROR = () =>\n  `Google Re-Captcha token generation failed! Please check the allowed domains.`;\n\nexport const SERVER_API_TIMEOUT_ERROR = () =>\n  `Appsmith server is taking too long to respond. Please try again after some time`;\nexport const DEFAULT_ERROR_MESSAGE = () => `There was an unexpected error`;\nexport const REMOVE_FILE_TOOL_TIP = () => \"Remove Upload\";\nexport const ERROR_FILE_TOO_LARGE = (fileSize: string) =>\n  `File size should be less than ${fileSize}!`;\nexport const ERROR_DATEPICKER_MIN_DATE = () =>\n  `Min date cannot be greater than current widget value`;\nexport const ERROR_DATEPICKER_MAX_DATE = () =>\n  `Min date cannot be greater than current widget value`;\nexport const ERROR_WIDGET_DOWNLOAD = (err: string) => `Download failed. ${err}`;\nexport const ERROR_PLUGIN_ACTION_EXECUTE = (actionName: string) =>\n  `${actionName} failed to execute`;\nexport const ACTION_EXECUTION_CANCELLED = (actionName: string) =>\n  `${actionName} was cancelled`;\nexport const ERROR_FAIL_ON_PAGE_LOAD_ACTIONS = () =>\n  `Failed to execute actions during page load`;\nexport const ERROR_ACTION_EXECUTE_FAIL = (actionName: string) =>\n  `${actionName} action returned an error response`;\nexport const ACTION_MOVE_SUCCESS = (actionName: string, pageName: string) =>\n  `${actionName} action moved to page ${pageName} successfully`;\nexport const ERROR_ACTION_MOVE_FAIL = (actionName: string) =>\n  `Error while moving action ${actionName}`;\nexport const ACTION_COPY_SUCCESS = (actionName: string, pageName: string) =>\n  `${actionName} action copied to page ${pageName} successfully`;\nexport const ERROR_ACTION_COPY_FAIL = (actionName: string) =>\n  `Error while copying action ${actionName}`;\nexport const ERROR_ACTION_RENAME_FAIL = (actionName: string) =>\n  `Unable to update action name to ${actionName}`;\n\n// Action Names Messages\nexport const ACTION_NAME_PLACEHOLDER = (type: string) =>\n  `Name of the ${type} in camelCase`;\nexport const ACTION_INVALID_NAME_ERROR = () => \"Please enter a valid name\";\nexport const ACTION_NAME_CONFLICT_ERROR = (name: string) =>\n  `${name} is already being used or is a restricted keyword.`;\nexport const ENTITY_EXPLORER_ACTION_NAME_CONFLICT_ERROR = (name: string) =>\n  `${name} is already being used.`;\n\nexport const DATASOURCE_CREATE = (dsName: string) =>\n  `${dsName} datasource created`;\nexport const DATASOURCE_DELETE = (dsName: string) =>\n  `${dsName} datasource deleted successfully`;\nexport const DATASOURCE_UPDATE = (dsName: string) =>\n  `${dsName} datasource updated successfully`;\nexport const DATASOURCE_VALID = (dsName: string) =>\n  `${dsName} datasource is valid`;\nexport const EDIT_DATASOURCE = () => \"EDIT DATASOURCE\";\nexport const SAVE_DATASOURCE = () => \"SAVE AS DATASOURCE\";\nexport const SAVE_DATASOURCE_MESSAGE = () =>\n  \"Save the URL as a datasource to access authentication settings\";\nexport const EDIT_DATASOURCE_MESSAGE = () =>\n  \"Edit Datasource to access authentication settings\";\nexport const OAUTH_ERROR = () => \"OAuth Error\";\nexport const OAUTH_2_0 = () => \"OAuth 2.0\";\nexport const ENABLE = () => \"ENABLE\";\nexport const UPGRADE = () => \"UPGRADE\";\nexport const EDIT = () => \"EDIT\";\nexport const UNEXPECTED_ERROR = () => \"An unexpected error occurred\";\nexport const EXPECTED_ERROR = () => \"An error occurred\";\nexport const NO_DATASOURCE_FOR_QUERY = () =>\n  `Seems like you don’t have any Datasources to create a query`;\nexport const ACTION_EDITOR_REFRESH = () => \"Refresh\";\nexport const INVALID_FORM_CONFIGURATION = () => \"Invalid form configuration\";\nexport const ACTION_RUN_BUTTON_MESSAGE_FIRST_HALF = () => \"🙌 Click on\";\nexport const ACTION_RUN_BUTTON_MESSAGE_SECOND_HALF = () =>\n  \"after adding your query\";\nexport const CREATE_NEW_DATASOURCE = () => \"Create new datasource\";\n\nexport const ERROR_EVAL_ERROR_GENERIC = () =>\n  `Unexpected error occurred while evaluating the application`;\n\nexport const ERROR_EVAL_TRIGGER = (message: string) =>\n  `Error occurred while evaluating trigger: ${message}`;\n\nexport const WIDGET_COPY = (widgetName: string) => `Copied ${widgetName}`;\nexport const ERROR_WIDGET_COPY_NO_WIDGET_SELECTED = () =>\n  `Please select a widget to copy`;\nexport const ERROR_WIDGET_COPY_NOT_ALLOWED = () =>\n  `This selected widget cannot be copied.`;\nexport const WIDGET_CUT = (widgetName: string) => `Cut ${widgetName}`;\nexport const ERROR_WIDGET_CUT_NO_WIDGET_SELECTED = () =>\n  `Please select a widget to cut`;\nexport const ERROR_WIDGET_CUT_NOT_ALLOWED = () =>\n  `This selected widget cannot be cut.`;\nexport const SELECT_ALL_WIDGETS_MSG = () =>\n  `All widgets in this page including modals have been selected`;\nexport const ERROR_ADD_WIDGET_FROM_QUERY = () => `Failed to add widget`;\n\nexport const REST_API_AUTHORIZATION_SUCCESSFUL = () =>\n  \"Authorization was successful!\";\nexport const REST_API_AUTHORIZATION_FAILED = () =>\n  \"Authorization failed. Please check your details or try again.\";\n// Todo: improve this for appsmith_error error message\nexport const REST_API_AUTHORIZATION_APPSMITH_ERROR = () =>\n  \"Something went wrong.\";\n\nexport const OAUTH_AUTHORIZATION_SUCCESSFUL = \"Authorization was successful!\";\nexport const OAUTH_AUTHORIZATION_FAILED =\n  \"Authorization failed. Please check your details or try again.\";\n// Todo: improve this for appsmith_error error message\nexport const OAUTH_AUTHORIZATION_APPSMITH_ERROR = \"Something went wrong.\";\nexport const OAUTH_APPSMITH_TOKEN_NOT_FOUND = \"Appsmith token not found\";\n\nexport const GSHEET_AUTHORIZATION_ERROR =\n  \"Data source is not authorized, please authorize to continue.\";\n\nexport const LOCAL_STORAGE_QUOTA_EXCEEDED_MESSAGE = () =>\n  \"Error saving a key in localStorage. You have exceeded the allowed storage size limit\";\nexport const LOCAL_STORAGE_NO_SPACE_LEFT_ON_DEVICE_MESSAGE = () =>\n  \"Error saving a key in localStorage. You have run out of disk space\";\nexport const LOCAL_STORAGE_NOT_SUPPORTED_APP_MIGHT_NOT_WORK_AS_EXPECTED = () =>\n  \"LocalStorage is not supported on your device. Some features including the Appsmith store won't work.\";\n\nexport const OMNIBAR_PLACEHOLDER = () =>\n  `Search Widgets, Queries, Documentation`;\nexport const OMNIBAR_PLACEHOLDER_SNIPPETS = () => \"Search code snippets\";\nexport const OMNIBAR_PLACEHOLDER_NAV = () => \"Search widgets and queries\";\nexport const OMNIBAR_PLACEHOLDER_DOC = () => \"Search documentation\";\nexport const CREATE_NEW_OMNIBAR_PLACEHOLDER = () =>\n  \"Create a new Query, API or JS Object\";\nexport const HELPBAR_PLACEHOLDER = () => \"Search\";\nexport const NO_SEARCH_DATA_TEXT = () => \"No results found\";\n\nexport const WIDGET_BIND_HELP = () =>\n  \"Having trouble taking inputs from widgets?\";\n\nexport const BACK_TO_HOMEPAGE = () => \"Go back to homepage\";\n\n// error pages\nexport const PAGE_NOT_FOUND_TITLE = () => \"404\";\nexport const PAGE_NOT_FOUND = () => \"Page not found\";\nexport const PAGE_SERVER_UNAVAILABLE_ERROR_CODE = () => \"503\";\nexport const PAGE_SERVER_UNAVAILABLE_TITLE = () =>\n  \"Appsmith server is unavailable\";\nexport const PAGE_SERVER_UNAVAILABLE_DESCRIPTION = () =>\n  \"Please try again later\";\nexport const PAGE_SERVER_TIMEOUT_ERROR_CODE = () => \"504\";\nexport const PAGE_SERVER_TIMEOUT_TITLE = () =>\n  \"Appsmith server is taking too long to respond\";\nexport const PAGE_SERVER_TIMEOUT_DESCRIPTION = () =>\n  `Please retry after some time`;\nexport const PAGE_CLIENT_ERROR_TITLE = () => \"Whoops something went wrong!\";\nexport const PAGE_CLIENT_ERROR_DESCRIPTION = () =>\n  \"This is embarrassing, please contact Appsmith support for help\";\n\n// comments\nexport const POST = () => \"Post\";\nexport const CANCEL = () => \"Cancel\";\nexport const REMOVE = () => \"Remove\";\n\n// Showcase Carousel\nexport const NEXT = () => \"NEXT\";\nexport const BACK = () => \"BACK\";\nexport const SKIP = () => \"SKIP\";\n\n// Debugger\nexport const CLICK_ON = () => \"🙌 Click on \";\nexport const PRESS = () => \"🎉 Press \";\nexport const OPEN_THE_DEBUGGER = () => \" to show/hide the debugger\";\nexport const DEBUGGER_QUERY_RESPONSE_SECOND_HALF = () =>\n  \" to see more info in the debugger\";\nexport const LOGS_FILTER_OPTION_ALL = () => \"Show All Logs\";\nexport const LOGS_FILTER_OPTION_ERROR = () => \"Error Logs\";\nexport const LOGS_FILTER_OPTION_CONSOLE = () => \"Console Logs\";\nexport const LOGS_FILTER_OPTION_SYSTEM = () => \"System Logs\";\nexport const NO_LOGS = () => \"No logs to show\";\nexport const NO_ERRORS = () => \"No signs of trouble here!\";\nexport const DEBUGGER_ERRORS = () => \"Errors\";\nexport const DEBUGGER_LOGS = () => \"Logs\";\nexport const INSPECT_ENTITY = () => \"Inspect entity\";\nexport const INSPECT_ENTITY_BLANK_STATE = () => \"Select an entity to inspect\";\nexport const VALUE_IS_INVALID = (propertyPath: string) =>\n  `The value at ${propertyPath} is invalid`;\nexport const ACTION_CONFIGURATION_UPDATED = () => \"Configuration updated\";\nexport const WIDGET_PROPERTIES_UPDATED = () => \"Widget properties were updated\";\nexport const EMPTY_RESPONSE_FIRST_HALF = () => \"🙌 Click on\";\nexport const EMPTY_RESPONSE_LAST_HALF = () => \"to get a response\";\nexport const EMPTY_JS_RESPONSE_LAST_HALF = () =>\n  \"to view response of selected function\";\nexport const INVALID_EMAIL = () => \"Please enter a valid email\";\nexport const DEBUGGER_INTERCOM_TEXT = (text: string) =>\n  `Hi, \\nI'm facing the following error on Appsmith, can you please help? \\n\\n${text}`;\nexport const DEBUGGER_TRIGGER_ERROR = (propertyName: string) =>\n  `Error occurred while evaluating trigger ${propertyName}`;\n\nexport const TROUBLESHOOT_ISSUE = () => \"Troubleshoot issue\";\nexport const DEBUGGER_OPEN_DOCUMENTATION = () => \"Open documentation\";\nexport const DEBUGGER_SEARCH_SNIPPET = () => \"Browse code snippets\";\nexport const DEBUGGER_APPSMITH_SUPPORT = () => \"Get Appsmith support\";\n\n//action creator menu\nexport const NO_ACTION = () => `No action`;\nexport const EXECUTE_A_QUERY = () => `Execute a query`;\nexport const NAVIGATE_TO = () => `Navigate to`;\nexport const SHOW_MESSAGE = () => `Show message`;\nexport const OPEN_MODAL = () => `Open modal`;\nexport const CLOSE_MODAL = () => `Close modal`;\nexport const STORE_VALUE = () => `Store value`;\nexport const REMOVE_VALUE = () => `Remove value`;\nexport const CLEAR_STORE = () => `Clear store`;\nexport const DOWNLOAD = () => `Download`;\nexport const COPY_TO_CLIPBOARD = () => `Copy to clipboard`;\nexport const RESET_WIDGET = () => `Reset widget`;\nexport const EXECUTE_JS_FUNCTION = () => `Execute a JS function`;\nexport const SET_INTERVAL = () => `Set interval`;\nexport const CLEAR_INTERVAL = () => `Clear interval`;\nexport const GET_GEO_LOCATION = () => `Get Geolocation`;\nexport const WATCH_GEO_LOCATION = () => `Watch Geolocation`;\nexport const STOP_WATCH_GEO_LOCATION = () => `Stop watching Geolocation`;\nexport const POST_MESSAGE = () => `Post message`;\n\n//js actions\nexport const JS_ACTION_COPY_SUCCESS = (actionName: string, pageName: string) =>\n  `${actionName} copied to page ${pageName} successfully`;\nexport const ERROR_JS_ACTION_COPY_FAIL = (actionName: string) =>\n  `Error while copying ${actionName}`;\nexport const JS_ACTION_DELETE_SUCCESS = (actionName: string) =>\n  `${actionName} deleted successfully`;\nexport const JS_ACTION_MOVE_SUCCESS = (actionName: string, pageName: string) =>\n  `${actionName} moved to page ${pageName} successfully`;\nexport const ERROR_JS_ACTION_MOVE_FAIL = (actionName: string) =>\n  `Error while moving ${actionName}`;\nexport const ERROR_JS_COLLECTION_RENAME_FAIL = (actionName: string) =>\n  `Unable to update js collection name to ${actionName}`;\nexport const PARSE_JS_FUNCTION_ERROR = (message: string) =>\n  `Syntax error: ${message}`;\n\nexport const EXECUTING_FUNCTION = () => `Executing function`;\nexport const UPDATING_JS_COLLECTION = () => `Updating...`;\nexport const EMPTY_JS_OBJECT = () =>\n  `Nothing to show, write some code to get response`;\nexport const EXPORT_DEFAULT_BEGINNING = () =>\n  `Start object with export default`;\nexport const ACTION_EXECUTION_FAILED = (actionName: string) =>\n  `The action \"${actionName}\" has failed.`;\nexport const JS_EXECUTION_SUCCESS = () => \"JS Function executed successfully\";\nexport const JS_EXECUTION_FAILURE = () => \"JS Function execution failed\";\nexport const JS_EXECUTION_FAILURE_TOASTER = () =>\n  \"There was an error while executing function\";\nexport const JS_SETTINGS_ONPAGELOAD = () => \"Run function on page load (Beta)\";\nexport const JS_EXECUTION_SUCCESS_TOASTER = (actionName: string) =>\n  `${actionName} ran successfully`;\nexport const JS_SETTINGS_ONPAGELOAD_SUBTEXT = () =>\n  \"Will refresh data every time page is reloaded\";\nexport const JS_SETTINGS_CONFIRM_EXECUTION = () =>\n  \"Request confirmation before calling function?\";\nexport const JS_SETTINGS_CONFIRM_EXECUTION_SUBTEXT = () =>\n  \"Ask confirmation from the user every time before refreshing data\";\nexport const JS_SETTINGS_EXECUTE_TIMEOUT = () =>\n  \"Function Timeout (in milliseconds)\";\nexport const ASYNC_FUNCTION_SETTINGS_HEADING = () => \"Async Function Settings\";\nexport const NO_ASYNC_FUNCTIONS = () =>\n  \"There is no asynchronous function in this JSObject\";\nexport const NO_JS_FUNCTION_TO_RUN = (JSObjectName: string) =>\n  `${JSObjectName} has no function`;\nexport const NO_JS_FUNCTION_RETURN_VALUE = (JSFunctionName: string) =>\n  `${JSFunctionName} did not return any data. Did you add a return statement?`;\n\n// Import/Export Application features\nexport const IMPORT_APPLICATION_MODAL_TITLE = () => \"Import application\";\nexport const IMPORT_APPLICATION_MODAL_LABEL = () =>\n  \"Where would you like to import your application from?\";\nexport const IMPORT_APP_FROM_FILE_TITLE = () => \"Import from file\";\nexport const UPLOADING_JSON = () => \"Uploading JSON file\";\nexport const UPLOADING_APPLICATION = () => \"Uploading application\";\nexport const IMPORT_APP_FROM_GIT_TITLE = () =>\n  \"Import from Git repository (Beta)\";\nexport const IMPORT_APP_FROM_FILE_MESSAGE = () =>\n  \"Drag and drop your file or upload from your computer\";\nexport const IMPORT_APP_FROM_GIT_MESSAGE = () =>\n  \"Import an application from its Git repository using its SSH URL\";\nexport const IMPORT_FROM_GIT_REPOSITORY = () => \"Import from Git repository\";\nexport const RECONNECT_MISSING_DATASOURCE_CREDENTIALS = () =>\n  \"Reconnect missing datasource credentials\";\nexport const RECONNECT_MISSING_DATASOURCE_CREDENTIALS_DESCRIPTION = () =>\n  \"Fill these with utmost care as the application will not behave normally otherwise\";\nexport const RECONNECT_DATASOURCE_SUCCESS_MESSAGE1 = () =>\n  \"These datasources were imported successfully!\";\nexport const RECONNECT_DATASOURCE_SUCCESS_MESSAGE2 = () =>\n  \"Please fill up the missing datasources\";\nexport const ADD_MISSING_DATASOURCES = () => \"Add missing Datasources\";\nexport const SKIP_TO_APPLICATION_TOOLTIP_HEADER = () =>\n  \"This action is irreversible.\";\nexport const SKIP_TO_APPLICATION_TOOLTIP_DESCRIPTION = () =>\n  `You can always reconnect the datasources later but until then the application might be unuseable.`;\nexport const SKIP_TO_APPLICATION = () => \"Skip to Application\";\nexport const SELECT_A_METHOD_TO_ADD_CREDENTIALS = () =>\n  \"Select a method to add credentials\";\nexport const DELETE_CONFIRMATION_MODAL_TITLE = () => `Are you sure?`;\nexport const DELETE_CONFIRMATION_MODAL_SUBTITLE = (name?: string | null) =>\n  `You want to remove ${name} from this workspace`;\nexport const PARSING_ERROR = () =>\n  \"Syntax Error: Unable to parse code, please check error logs to debug\";\nexport const PARSING_WARNING = () =>\n  \"Linting Errors: Please resolve linting errors before using these functions\";\nexport const JS_FUNCTION_CREATE_SUCCESS = () =>\n  \"New JS function added successfully\";\nexport const JS_FUNCTION_UPDATE_SUCCESS = () =>\n  \"JS Function updated successfully\";\nexport const JS_FUNCTION_DELETE_SUCCESS = () =>\n  \"JS function deleted successfully\";\nexport const JS_OBJECT_BODY_INVALID = () => \"JS object could not be parsed\";\nexport const JS_ACTION_EXECUTION_ERROR = (jsFunctionName: string) =>\n  `An error occured while trying to execute ${jsFunctionName}, please check error logs to debug`;\n//Editor Page\nexport const EDITOR_HEADER_SAVE_INDICATOR = () => \"Saved\";\n\n//undo redo\nexport const WIDGET_REMOVED = (widgetName: string) =>\n  `${widgetName} is removed`;\nexport const WIDGET_ADDED = (widgetName: string) =>\n  `${widgetName} is added back`;\nexport const BULK_WIDGET_REMOVED = (widgetName: string) =>\n  `${widgetName} widgets are removed`;\nexport const BULK_WIDGET_ADDED = (widgetName: string) =>\n  `${widgetName} widgets are added back`;\n\n// Generate page from DB Messages\n\nexport const UNSUPPORTED_PLUGIN_DIALOG_TITLE = () =>\n  `Couldn't auto-generate a page from this datasource.`;\n\nexport const UNSUPPORTED_PLUGIN_DIALOG_SUBTITLE = () =>\n  `You can continue building your app with it using our drag & drop builder`;\nexport const UNSUPPORTED_PLUGIN_DIALOG_MAIN_HEADING = () => `Heads up`;\n\nexport const BUILD_FROM_SCRATCH_ACTION_SUBTITLE = () =>\n  \"Start from scratch and create your custom UI\";\n\nexport const BUILD_FROM_SCRATCH_ACTION_TITLE = () => \"Build with drag & drop\";\n\nexport const GENERATE_PAGE_ACTION_TITLE = () => \"Generate Page With Data\";\n\nexport const GENERATE_PAGE_FORM_TITLE = () => \"Generate from data\";\n\nexport const GEN_CRUD_SUCCESS_MESSAGE = () =>\n  \"Hurray! Your application is ready for use.\";\nexport const GEN_CRUD_INFO_DIALOG_TITLE = () => \"How it works?\";\nexport const GEN_CRUD_INFO_DIALOG_SUBTITLE = () =>\n  \"CRUD page is generated from selected datasource. You can use the form to modify data. Since all your data is already connected, you can add more queries and modify the bindings\";\nexport const GEN_CRUD_COLUMN_HEADER_TITLE = () => \"Column headers fetched\";\nexport const GEN_CRUD_NO_COLUMNS = () => \"No columns found\";\nexport const GEN_CRUD_DATASOURCE_DROPDOWN_LABEL = () => \"Select datasource\";\nexport const GEN_CRUD_TABLE_HEADER_LABEL = () => \"Table header index\";\nexport const GEN_CRUD_TABLE_HEADER_TOOLTIP_DESC = () =>\n  \"Row index of the column headers in the sheet table\";\n// Actions Right pane\nexport const SEE_CONNECTED_ENTITIES = () => \"See all connected entities\";\nexport const INCOMING_ENTITIES = () => \"Incoming entities\";\nexport const NO_INCOMING_ENTITIES = () => \"No incoming entities\";\nexport const OUTGOING_ENTITIES = () => \"Outgoing entities\";\nexport const NO_OUTGOING_ENTITIES = () => \"No outgoing entities\";\nexport const NO_CONNECTIONS = () => \"No connections to show here\";\nexport const BACK_TO_CANVAS = () => \"Back to canvas\";\nexport const SUGGESTED_WIDGET_DESCRIPTION = () =>\n  \"This will add a new widget to the canvas.\";\nexport const ADD_NEW_WIDGET = () => \"Add new widget\";\nexport const SUGGESTED_WIDGETS = () => \"Suggested widgets\";\nexport const SUGGESTED_WIDGET_TOOLTIP = () => \"Add to canvas\";\nexport const WELCOME_TOUR_STICKY_BUTTON_TEXT = () => \"Next mission\";\n\n// Data Sources pane\nexport const EMPTY_ACTIVE_DATA_SOURCES = () => \"No active datasources found.\";\nexport const SCHEMA_NOT_AVAILABLE = () => \"Schema not available\";\n\nexport const SNIPPET_EXECUTION_SUCCESS = () => `Snippet executed successfully.`;\n\nexport const SNIPPET_EXECUTION_FAILED = () => `Snippet execution failed.`;\n\nexport const SNIPPET_INSERT = () => `Hit ⏎ to insert`;\nexport const SNIPPET_COPY = () => `Hit ⏎ to copy`;\nexport const SNIPPET_EXECUTE = () => `Hit ⏎ to run`;\nexport const APPLY_SEARCH_CATEGORY = () => `⏎ Jump`;\n\n// Git sync\nexport const CONNECTED_TO_GIT = () => \"Connected to Git\";\n\nexport const GIT_DISCONNECT_POPUP_TITLE = () =>\n  `This will disconnect the Git repository from this application`;\n\nexport const GIT_DISCONNECT_POPUP_SUBTITLE = () =>\n  `Git features will no more be shown for this application`;\nexport const GIT_DISCONNECT_POPUP_MAIN_HEADING = () => `Are you sure?`;\n\nexport const GIT_CONNECTION = () => \"Git Connection\";\nexport const GIT_IMPORT = () => \"Git Import\";\nexport const MERGE = () => \"Merge\";\nexport const GIT_SETTINGS = () => \"Git Settings\";\nexport const CONNECT_TO_GIT = () => \"Connect to Git repository\";\nexport const CONNECT_TO_GIT_SUBTITLE = () =>\n  \"Checkout branches, make commits, and deploy your application\";\nexport const REMOTE_URL = () => \"Remote URL\";\nexport const REMOTE_URL_INFO = () =>\n  `Create an empty Git repository and paste the remote URL here.`;\nexport const IMPORT_URL_INFO = () => `Paste the remote URL here:`;\nexport const REMOTE_URL_VIA = () => \"Remote URL via\";\n\nexport const USER_PROFILE_SETTINGS_TITLE = () => \"User settings\";\n\nexport const USE_DEFAULT_CONFIGURATION = () => \"Use default configuration\";\nexport const AUTHOR_NAME = () => \"Author name\";\nexport const AUTHOR_NAME_CANNOT_BE_EMPTY = () => \"Author name cannot be empty\";\nexport const AUTHOR_EMAIL = () => \"Author email\";\n\nexport const NAME_YOUR_NEW_BRANCH = () => \"Name your new branch\";\nexport const SWITCH_BRANCHES = () => \"Switch branches\";\n\nexport const DOCUMENTATION = () => \"Documentation\";\nexport const DOCUMENTATION_TOOLTIP = () => \"Open Docs in Omnibar\";\nexport const CONNECT = () => \"Connect\";\nexport const LATEST_DP_TITLE = () => \"Latest deployed preview\";\nexport const LATEST_DP_SUBTITLE = () => \"last deployed\";\nexport const CHECK_DP = () => \"CHECK\";\nexport const DEPLOY_TO_CLOUD = () => \"Deploy to cloud\";\nexport const DEPLOY_WITHOUT_GIT = () =>\n  \"Deploy your application without version control\";\nexport const COMMIT_CHANGES = () => \"Commit changes\";\nexport const COMMIT_TO = () => \"Commit to\";\nexport const COMMIT_AND_PUSH = () => \"Commit & push\";\nexport const PULL_CHANGES = () => \"PULL CHANGES\";\nexport const REGENERATE_SSH_KEY = (keyType: string, keySize: number) =>\n  `Regenerate ${keyType} ${keySize} key`;\nexport const GENERATE_SSH_KEY = (keyType: string, keySize: number) =>\n  `${keyType} ${keySize} key`;\nexport const SSH_KEY_PLATFORM = (name: string) => ` (${name})`;\nexport const SSH_KEY = () => \"SSH key\";\nexport const COPY_SSH_KEY = () => \"Copy SSH key\";\nexport const SSH_KEY_GENERATED = () => \"SSH key generated\";\nexport const REGENERATE_KEY_CONFIRM_MESSAGE = () =>\n  \"This might cause the application to break. This key needs to be updated in your Git repository too!\";\nexport const DEPLOY_KEY_USAGE_GUIDE_MESSAGE = () =>\n  \"Paste this key in your repository settings and give it write access.\";\nexport const COMMITTING_AND_PUSHING_CHANGES = () =>\n  \"Committing and pushing changes...\";\nexport const DISCARDING_AND_PULLING_CHANGES = () =>\n  \"Discarding and pulling changes...\";\nexport const DISCARD_SUCCESS = () => \"Discarded changes successfully.\";\n\nexport const IS_MERGING = () => \"Merging changes...\";\n\nexport const MERGE_CHANGES = () => \"Merge changes\";\nexport const SELECT_BRANCH_TO_MERGE = () => \"Select branch to merge\";\nexport const CONNECT_GIT = () => \"Connect Git\";\nexport const CONNECT_GIT_BETA = () => \"Connect Git (Beta)\";\nexport const RETRY = () => \"RETRY\";\nexport const CREATE_NEW_BRANCH = () => \"CREATE NEW BRANCH\";\nexport const ERROR_WHILE_PULLING_CHANGES = () => \"ERROR WHILE PULLING CHANGES\";\nexport const SUBMIT = () => \"SUBMIT\";\nexport const GIT_USER_UPDATED_SUCCESSFULLY = () =>\n  \"Git user updated successfully\";\nexport const REMOTE_URL_INPUT_PLACEHOLDER = () =>\n  \"git@example.com:user/repository.git\";\nexport const GIT_COMMIT_MESSAGE_PLACEHOLDER = () => \"Your commit message here\";\nexport const COPIED_SSH_KEY = () => \"Copied SSH key\";\nexport const INVALID_USER_DETAILS_MSG = () => \"Please enter valid user details\";\nexport const PASTE_SSH_URL_INFO = () =>\n  \"Please enter a valid SSH URL of your repository\";\nexport const GENERATE_KEY = () => \"Generate key\";\nexport const UPDATE_CONFIG = () => \"UPDATE CONFIG\";\nexport const CONNECT_BTN_LABEL = () => \"CONNECT\";\nexport const IMPORT_BTN_LABEL = () => \"IMPORT\";\nexport const FETCH_GIT_STATUS = () => \"Fetching status...\";\nexport const FETCH_MERGE_STATUS = () => \"Checking mergeability...\";\nexport const NO_MERGE_CONFLICT = () =>\n  \"This branch has no conflicts with the base branch.\";\nexport const MERGE_CONFLICT_ERROR = () => \"Merge conflicts found!\";\nexport const FETCH_MERGE_STATUS_FAILURE = () => \"Unable to fetch merge status\";\nexport const GIT_UPSTREAM_CHANGES = () =>\n  \"Looks like there are pending upstream changes. We will pull the changes and push them to your repository.\";\nexport const GIT_CONFLICTING_INFO = () =>\n  \"Please resolve the merge conflicts manually on your repository.\";\nexport const CANNOT_PULL_WITH_LOCAL_UNCOMMITTED_CHANGES = () =>\n  \"You have uncommitted changes. Please commit before pulling the remote changes.\";\nexport const CANNOT_MERGE_DUE_TO_UNCOMMITTED_CHANGES = () =>\n  \"Your current branch has uncommitted changes. Please commit them before proceeding to merge.\";\n\nexport const DISCONNECT_SERVICE_SUBHEADER = () =>\n  \"Changes to this section can disrupt user authentication. Proceed with caution.\";\nexport const DISCONNECT_SERVICE_WARNING = () =>\n  \"will be removed as primary method of authentication\";\nexport const AUTHENTICATION_METHOD_ENABLED = (methodName: string) => `\n  ${methodName} authentication method is enabled\n`;\n\nexport const REVOKE_EXISTING_REPOSITORIES = () =>\n  \"Revoke Existing Repositories\";\nexport const REVOKE_EXISTING_REPOSITORIES_INFO = () =>\n  \"To make space for newer repositories, you can remove existing repositories.\";\nexport const CONTACT_SUPPORT = () => \"Contact Support\";\nexport const CONTACT_SALES_MESSAGE_ON_INTERCOM = (workspaceName: string) =>\n  `Hey there, thanks for getting in touch! We understand that you’d like to extend the number of private repos for your ${workspaceName}. Could you tell us how many private repositories you require and why? We'll get back to you in a short while.`;\nexport const REPOSITORY_LIMIT_REACHED = () => \"Repository Limit Reached\";\nexport const REPOSITORY_LIMIT_REACHED_INFO = () =>\n  \"Adding and using upto 3 repositories is free. To add more repositories, kindly upgrade.\";\nexport const APPLICATION_IMPORT_SUCCESS = (username: string) =>\n  `${username}! Your application is ready to use.`;\nexport const APPLICATION_IMPORT_SUCCESS_DESCRIPTION = () =>\n  \"All your datasources are configured and ready to use.\";\nexport const NONE_REVERSIBLE_MESSAGE = () =>\n  \"This action is non-reversible. Please proceed with caution.\";\nexport const CONTACT_SUPPORT_TO_UPGRADE = () =>\n  \"Please contact support to upgrade. You can add unlimited private repositories in upgraded plan.\";\nexport const REVOKE_CAUSE_APPLICATION_BREAK = () =>\n  \"Revoking your repository might cause the application to break.\";\nexport const REVOKE_GIT = () => \"Revoke access\";\nexport const DISCONNECT = () => \"DISCONNECT\";\nexport const REVOKE = () => \"REVOKE\";\nexport const REVOKE_ACCESS = () => \"REVOKE ACCESS\";\nexport const GIT_DISCONNECTION_SUBMENU = () => \"Git Connection > Disconnect\";\nexport const DISCONNECT_FROM_GIT = (name: string) =>\n  `Disconnect ${name} from Git`;\nexport const GIT_REVOKE_ACCESS = (name: string) => `Revoke Access To ${name}`;\nexport const GIT_TYPE_REPO_NAME_FOR_REVOKING_ACCESS = (name: string) =>\n  `Type “${name}” in the input box to revoke access.`;\nexport const APPLICATION_NAME = () => \"Application name\";\nexport const OPEN_REPO = () => \"OPEN REPOSITORY\";\nexport const CONNECTING_REPO = () => \"Connecting to Git repository\";\nexport const IMPORTING_APP_FROM_GIT = () => \"Importing application from Git\";\nexport const CONFIRM_SSH_KEY = () =>\n  \"Please make sure your SSH key has write access.\";\nexport const READ_DOCUMENTATION = () => \"Read documentation\";\nexport const LEARN_MORE = () => \"Learn More\";\nexport const GIT_NO_UPDATED_TOOLTIP = () => \"No new updates to push\";\n\nexport const FIND_OR_CREATE_A_BRANCH = () => \"Find or create a branch\";\nexport const SYNC_BRANCHES = () => \"Sync branches\";\n\nexport const CONFLICTS_FOUND = () =>\n  \"Conflicts found. Please resolve them and pull again.\";\nexport const UNCOMMITTED_CHANGES = () => \"You have uncommitted changes\";\nexport const NO_COMMITS_TO_PULL = () =>\n  \"No commits to pull. This branch is in sync with the remote repository\";\nexport const CONFLICTS_FOUND_WHILE_PULLING_CHANGES = () =>\n  \"Conflicts found while pulling changes.\";\nexport const NOT_LIVE_FOR_YOU_YET = () => \"It's not live for you yet\";\nexport const COMING_SOON = () => \"Coming Soon!\";\nexport const CONNECTING_TO_REPO_DISABLED = () =>\n  \"Connecting to a Git repository is disabled\";\nexport const DURING_ONBOARDING_TOUR = () => \"during the onboarding tour\";\nexport const MERGED_SUCCESSFULLY = () => \"Merged successfully\";\nexport const DISCARD_CHANGES_WARNING = () =>\n  \"Discarding these changes will pull previous changes from Git.\";\nexport const DISCARD_CHANGES = () => \"Discard changes\";\n\n// GIT DEPLOY begin\nexport const DEPLOY = () => \"Deploy\";\nexport const DEPLOY_YOUR_APPLICATION = () => \"Deploy your application\";\nexport const CHANGES_SINCE_LAST_DEPLOYMENT = () =>\n  \"Changes since last deployment\";\nexport const CHANGES_ONLY_USER = () => \"Changes since last commit\";\nexport const CHANGES_MADE_SINCE_LAST_COMMIT = () =>\n  \"Changes made since last commit\";\nexport const CHANGES_ONLY_MIGRATION = () =>\n  \"Appsmith update changes since last commit\";\nexport const CHANGES_USER_AND_MIGRATION = () =>\n  \"Appsmith update and user changes since last commit\";\nexport const CURRENT_PAGE_DISCARD_WARNING = (page: string) =>\n  `Current page (${page}) is in the discard list.`;\n// GIT DEPLOY end\n\n// GIT CHANGE LIST begin\nexport const CHANGES_FROM_APPSMITH = () =>\n  \"Some changes are platform upgrades from Appsmith.\";\nexport const TRY_TO_PULL = () =>\n  \"We will try to pull before pushing your changes.\";\nexport const NOT_PUSHED_YET = () =>\n  \"These are the commits that haven't been pushed to remote yet.\";\n// GIT CHANGE LIST end\n\n// GIT DELETE BRANCH begin\nexport const DELETE = () => \"Delete\";\nexport const LOCAL_BRANCHES = () => \"Local branches\";\nexport const REMOTE_BRANCHES = () => \"Remote branches\";\n\nexport const DELETE_BRANCH_SUCCESS = (branchName: string) =>\n  `Successfully deleted branch: ${branchName}`;\n\n// warnings\nexport const DELETE_BRANCH_WARNING_CHECKED_OUT = (currentBranchName: string) =>\n  `Cannot delete checked out branch. Please check out other branch before deleting ${currentBranchName}.`;\nexport const DELETE_BRANCH_WARNING_DEFAULT = (defaultBranchName: string) =>\n  `Cannot delete default branch: ${defaultBranchName}`;\n// GIT DELETE BRANCH end\n\n// GIT ERRORS begin\nexport const ERROR_GIT_AUTH_FAIL = () =>\n  \"Please make sure that regenerated SSH key is added and has write access to the repository.\";\nexport const ERROR_GIT_INVALID_REMOTE = () =>\n  \"Either the remote repository doesn't exist or is unreachable.\";\n// GIT ERRORS end\n\n// JS Snippets\nexport const SNIPPET_DESCRIPTION = () =>\n  `Search and insert code snippets to perform complex actions quickly.`;\nexport const DOC_DESCRIPTION = () =>\n  `Find answers through Appsmith documentation.`;\nexport const NAV_DESCRIPTION = () =>\n  `Navigate to any page, widget or file across this project.`;\nexport const ACTION_OPERATION_DESCRIPTION = () =>\n  `Create a new Query, API or JS Object`;\n\nexport const TRIGGER_ACTION_VALIDATION_ERROR = (\n  functionName: string,\n  argumentName: string,\n  expectedType: string,\n  received: string,\n) =>\n  `${functionName} expected ${expectedType} for '${argumentName}' argument but received ${received}`;\n\n// Comment card tooltips\nexport const MORE_OPTIONS = () => \"More Options\";\nexport const ADD_REACTION = () => \"Add Reaction\";\nexport const RESOLVE_THREAD = () => \"Resolve Thread\";\nexport const RESOLVED_THREAD = () => \"Resolved Thread\";\nexport const EMOJI = () => \"Emoji\";\n\n// Sniping mode messages\nexport const SNIPING_SELECT_WIDGET_AGAIN = () =>\n  \"Unable to detect the widget, please select the widget again.\";\n\nexport const SNIPING_NOT_SUPPORTED = () =>\n  \"Binding on selection is not supported for this type of widget!\";\n\n//First Time User Onboarding\n//Checklist page\nexport enum ONBOARDING_CHECKLIST_ACTIONS {\n  CONNECT_A_DATASOURCE = \"CONNECT DATASOURCE\",\n  CREATE_A_QUERY = \"CREATE A QUERY\",\n  ADD_WIDGETS = \"ADD WIDGETS\",\n  CONNECT_DATA_TO_WIDGET = \"CONNECT DATA TO WIDGET\",\n  DEPLOY_APPLICATIONS = \"DEPLOY APPLICATION\",\n}\n\nexport const ONBOARDING_CHECKLIST_BANNER_HEADER = () =>\n  \"Amazing work! You’ve explored the basics of Appsmith\";\nexport const ONBOARDING_CHECKLIST_BANNER_BODY = () =>\n  \"You can carry on here, or explore the homepage to see how your projects are stored.\";\nexport const ONBOARDING_CHECKLIST_BANNER_BUTTON = () => \"Explore homepage\";\nexport const ONBOARDING_SKIPPED_FIRST_TIME_USER = () =>\n  \"Skipped onboarding tour\";\nexport const ONBOARDING_CHECKLIST_HEADER = () => \"👋 Welcome to Appsmith!\";\nexport const ONBOARDING_CHECKLIST_BODY = () =>\n  \"Let’s get you started on your first application, explore Appsmith yourself or follow our guide below to discover what Appsmith can do.\";\nexport const ONBOARDING_CHECKLIST_COMPLETE_TEXT = () => \"complete\";\n\nexport const ONBOARDING_CHECKLIST_CONNECT_DATA_SOURCE = {\n  bold: () => \"Connect your datasource\",\n  normal: () => \"to start building an application.\",\n};\n\nexport const ONBOARDING_CHECKLIST_CREATE_A_QUERY = {\n  bold: () => \"Create a query\",\n  normal: () => \"of your datasource.\",\n};\n\nexport const ONBOARDING_CHECKLIST_ADD_WIDGETS = {\n  bold: () => \"Start visualising your application\",\n  normal: () => \"using widgets.\",\n};\n\nexport const ONBOARDING_CHECKLIST_CONNECT_DATA_TO_WIDGET = {\n  bold: () => \"Connect your data to the widgets\",\n  normal: () => \"using JavaScript.\",\n};\n\nexport const ONBOARDING_CHECKLIST_DEPLOY_APPLICATIONS = {\n  bold: () => \"Deploy your application,\",\n  normal: () => \"and see your creation live.\",\n};\n\nexport const ONBOARDING_CHECKLIST_FOOTER = () =>\n  \"Not sure where to start? Take the welcome tour\";\n\n//Introduction modal\nexport const HOW_APPSMITH_WORKS = () =>\n  \"Here’s a quick overview of how Appsmith works. \";\nexport const ONBOARDING_INTRO_CONNECT_YOUR_DATABASE = () =>\n  \"Connect to your database or APIs\";\nexport const DRAG_AND_DROP = () =>\n  \"Drag and drop pre-built widgets to build UI\";\nexport const CUSTOMIZE_WIDGET_STYLING = () =>\n  \"Customise the styling of every widget. Then bind your data to the widget and use JS to write any logic.\";\nexport const ONBOARDING_INTRO_PUBLISH = () =>\n  \"Publish & Share with permissions\";\nexport const CHOOSE_ACCESS_CONTROL_ROLES = () =>\n  \"Instantly publish & share your apps with users. Choose from pre-defined access control roles.\";\nexport const BUILD_MY_FIRST_APP = () => \"Build on my own\";\nexport const ONBOARDING_INTRO_FOOTER = () =>\n  \"Let’s start building your first application\";\nexport const START_TUTORIAL = () => \"START TUTORIAL\";\nexport const WELCOME_TO_APPSMITH = () => \"Welcome to Appsmith!\";\nexport const QUERY_YOUR_DATABASE = () =>\n  \"Query your own database or API inside Appsmith. Write JS to construct dynamic queries.\";\n\n//Statusbar\nexport const ONBOARDING_STATUS_STEPS_FIRST = () => \"First: Add a datasource\";\nexport const ONBOARDING_STATUS_STEPS_FIRST_ALT = () => \"Next: Add a datasource\";\nexport const ONBOARDING_STATUS_STEPS_SECOND = () => \"Next: Create a query\";\nexport const ONBOARDING_STATUS_STEPS_THIRD = () => \"Next: Add a widget\";\nexport const ONBOARDING_STATUS_STEPS_THIRD_ALT = () => \"First: Add a widget\";\nexport const ONBOARDING_STATUS_STEPS_FOURTH = () =>\n  \"Next: Connect data to widget\";\nexport const ONBOARDING_STATUS_STEPS_FIVETH = () =>\n  \"Next: Deploy your application\";\nexport const ONBOARDING_STATUS_STEPS_SIXTH = () => \"Completed 🎉\";\nexport const ONBOARDING_STATUS_GET_STARTED = () => \"GET STARTED\";\n\n//Tasks\n//1. datasource\nexport const ONBOARDING_TASK_DATASOURCE_HEADER = () =>\n  \"Start by adding your first Datasource\";\nexport const ONBOARDING_TASK_DATASOURCE_BODY = () =>\n  \"Adding a datasource makes creating applications more powerful. Don’t worry if you don’t have any data on hand, we have a sample dataset that you can use.\";\nexport const ONBOARDING_TASK_DATASOURCE_BUTTON = () => \"+ Add a datasource\";\nexport const ONBOARDING_TASK_DATASOURCE_FOOTER_ACTION = () => \"Add a widget\";\nexport const ONBOARDING_TASK_DATASOURCE_FOOTER = () => \"first.\";\n//2. query\nexport const ONBOARDING_TASK_QUERY_HEADER = () => \"Next, create a query\";\nexport const ONBOARDING_TASK_QUERY_BODY = () =>\n  \"Great job adding a datasource! The next thing you can do is create a query on your data.\";\nexport const ONBOARDING_TASK_QUERY_BUTTON = () => \"+ Create a query\";\nexport const ONBOARDING_TASK_QUERY_FOOTER_ACTION = () => \"Add a widget\";\n//2. widget\nexport const ONBOARDING_TASK_WIDGET_HEADER = () =>\n  \"Next, add a widget to start displaying data\";\nexport const ONBOARDING_TASK_WIDGET_BODY = () =>\n  \"Great job adding a datasource! The next thing you can do is add widget to start visualizing your data.\";\nexport const ONBOARDING_TASK_WIDGET_BUTTON = () => \"+ Add a widget\";\nexport const ONBOARDING_TASK_WIDGET_FOOTER_ACTION = () =>\n  \"deploy your application\";\nexport const ONBOARDING_TASK_FOOTER = () => \"Alternatively, you can also\";\n\nexport const USE_SNIPPET = () => \"Snippet\";\nexport const SNIPPET_TOOLTIP = () => \"Search code snippets\";\n\n//Welcome page\nexport const WELCOME_HEADER = () => \"Welcome!\";\nexport const WELCOME_BODY = () =>\n  \"Let us setup your account so you can make awesome applications!\";\nexport const WELCOME_ACTION = () => \"Get started\";\n\n// API Editor\nexport const API_EDITOR_TAB_TITLES = {\n  HEADERS: () => \"Headers\",\n  PARAMS: () => \"Params\",\n  BODY: () => \"Body\",\n  PAGINATION: () => \"Pagination\",\n  AUTHENTICATION: () => \"Authentication\",\n  SETTINGS: () => \"Settings\",\n};\nexport const ACTION_EXECUTION_MESSAGE = (actionType: string) =>\n  `Sending the ${actionType} request`;\n\nexport const WELCOME_FORM_HEADER = () => \"Let us get to know you better!\";\nexport const WELCOME_FORM_FULL_NAME = () => \"Full Name\";\nexport const WELCOME_FORM_EMAIL_ID = () => \"Email Id\";\nexport const WELCOME_FORM_CREATE_PASSWORD = () => \"Create Password\";\nexport const WELCOME_FORM_VERIFY_PASSWORD = () => \"Verify Password\";\nexport const WELCOME_FORM_ROLE_DROPDOWN = () => \"What Role Do You Play?\";\nexport const WELCOME_FORM_ROLE_DROPDOWN_PLACEHOLDER = () => \"- Select a role -\";\nexport const WELCOME_FORM_ROLE = () => \"Role\";\nexport const WELCOME_FORM_CUSTOM_USE_CASE = () => \"Use case\";\nexport const WELCOME_FORM_USE_CASE = () => \"Tell Us About Your Use Case\";\nexport const WELCOME_FORM_USE_CASE_PLACEHOLDER = () => \"- Select a use case -\";\nexport const WELCOME_FORM_DATA_COLLECTION_HEADER = () =>\n  \"Usage data preference\";\nexport const WELCOME_FORM_DATA_COLLECTION_BODY = () =>\n  \"Share anonymous usage data to help improve the product.\";\nexport const WELCOME_FORM_DATA_COLLECTION_LINK = () => \"See what is shared\";\nexport const WELCOME_FORM_DATA_COLLECTION_LABEL_ENABLE = () =>\n  \"Share data & make Appsmith better!\";\nexport const WELCOME_FORM_DATA_COLLECTION_LABEL_DISABLE = () =>\n  \"Don't share any data\";\nexport const WELCOME_FORM_NEWLETTER_HEADER = () => \"Stay in touch\";\nexport const WELCOME_FORM_NEWLETTER_LABEL = () =>\n  \"Get updates about what we are cooking. We will not spam you.\";\nexport const WELCOME_FORM_SUBMIT_LABEL = () => \"Make your first App\";\n\n//help tooltips\nexport const ACCOUNT_TOOLTIP = () => \"Your account\";\nexport const RENAME_APPLICATION_TOOLTIP = () => \"Rename application\";\nexport const LOGO_TOOLTIP = () => \"Back to homepage\";\nexport const ADD_PAGE_TOOLTIP = () => \"Add a new page\";\nexport const ADD_DATASOURCE_TOOLTIP = () =>\n  \"Add datasource or create new query\";\nexport const ADD_WIDGET_TOOLTIP = () => \"Find and add a widget\";\nexport const HELP_RESOURCE_TOOLTIP = () => \"Help and resources\";\nexport const COPY_ELEMENT = () => \"Copy element\";\nexport const LAYOUT_DROPDOWN_TOOLTIP = () =>\n  \"Choose how your application looks on desktop, tablet and mobile devices\";\nexport const DEPLOY_BUTTON_TOOLTIP = () =>\n  \"Deploy the current version of the application\";\nexport const SHARE_BUTTON_TOOLTIP = () => \"Invite your team to Appsmith\";\nexport const SHARE_BUTTON_TOOLTIP_WITH_USER = (length: number) => () =>\n  `Shared with ${length} other`;\nexport const DEBUGGER_TOOLTIP = () => \"Open Debugger\";\nexport const PAGE_PROPERTIES_TOOLTIP = () => \"Page properties\";\nexport const CLEAR_LOG_TOOLTIP = () => \"Clear logs\";\nexport const ADD_JS_ACTION = () => \"Add a new JS Object\";\nexport const ENTITY_MORE_ACTIONS_TOOLTIP = () => \"More actions\";\nexport const NOTIFICATIONS_TOOLTIP = () => \"Notifications\";\n\n// Navigation Menu\nexport const DEPLOY_MENU_OPTION = () => \"Deploy\";\nexport const CURRENT_DEPLOY_PREVIEW_OPTION = () => \"Current Deployed Version\";\nexport const CONNECT_TO_GIT_OPTION = () => \"Connect to Git Repository\";\n//\nexport const GO_TO_PAGE = () => \"Go to page\";\nexport const DEFAULT_PAGE_TOOLTIP = () => \"Default page\";\nexport const HIDDEN_TOOLTIP = () => \"Hidden\";\nexport const CLONE_TOOLTIP = () => \"Clone\";\nexport const DELETE_TOOLTIP = () => \"Delete\";\nexport const SETTINGS_TOOLTIP = () => \"Settings\";\n//settings\nexport const ADMIN_SETTINGS = () => \"Admin Settings\";\nexport const RESTART_BANNER_BODY = () =>\n  \"Hang in there. This should be done soon.\";\nexport const RESTART_BANNER_HEADER = () => \"Restarting your server\";\nexport const RESTART_ERROR_BODY = () =>\n  \"You can try restarting the server again for the settings to take place.\";\nexport const RESTART_ERROR_HEADER = () => \"Restarting failed\";\nexport const RETRY_BUTTON = () => \"Retry\";\nexport const INFO_VERSION_MISMATCH_FOUND_RELOAD_REQUEST = () =>\n  \"Hey! There is a new version of Appsmith available. Please consider refreshing your window.\";\nexport const TEST_EMAIL_SUCCESS = (email: string) => () =>\n  `Test email sent, please check the inbox of ${email}`;\nexport const TEST_EMAIL_SUCCESS_TROUBLESHOOT = () => \"Troubleshoot\";\nexport const TEST_EMAIL_FAILURE = () => \"Sending Test Email Failed\";\nexport const DISCONNECT_AUTH_ERROR = () =>\n  \"Cannot disconnect the only connected authentication method.\";\nexport const MANDATORY_FIELDS_ERROR = () => \"Mandatory fields cannot be empty\";\n\n// Audit logs begin\nexport const AUDIT_LOGS = () => \"Audit Logs\";\nexport const TRY_AGAIN_WITH_YOUR_FILTER = () => \"Try again with your filter\";\n\n// Audit logs Upgrade page begin\nexport const INTRODUCING = (featureName: string) =>\n  `Introducing ${featureName}`;\nexport const AUDIT_LOGS_UPGRADE_PAGE_SUB_HEADING = () =>\n  \"See a timestamped trail of events in your workspace. Filter by type of event, user, resource ID, and time. Drill down into each event to investigate further.\";\nexport const SECURITY_AND_COMPLIANCE = () => \"Security & Compliance\";\nexport const SECURITY_AND_COMPLIANCE_DETAIL1 = () =>\n  \"Proactively derisk misconfigured permissions, roll back changes from a critical security event, and keep checks against your compliance policies.\";\nexport const SECURITY_AND_COMPLIANCE_DETAIL2 = () =>\n  \"Exports to popular compliance tools coming soon\";\nexport const DEBUGGING = () => \"Debugging\";\nexport const DEBUGGING_DETAIL1 = () =>\n  \"Debug with a timeline of events filtered by user and resource ID, correlate them with end-user and app developer actions, and investigate back to the last known good state of your app.\";\nexport const INCIDENT_MANAGEMENT = () => \"Incident Management\";\nexport const INCIDENT_MANAGEMENT_DETAIL1 = () =>\n  \"Go back in time from an incident to see who did what, correlate events with breaking changes, and run RCAs to remediate incidents for now and the future.\";\nexport const AVAILABLE_ON_BUSINESS = () => \"Available on a business plan only\";\nexport const EXCLUSIVE_TO_BUSINESS = (featureName: string) =>\n  `The ${featureName} feature is exclusive to workspaces on the Business Plan`;\n// Audit logs Upgrade page end\n// Audit logs end\n\n// Access control upgrade page begin\nexport const GRANULAR_ACCESS_CONTROL_FOR_TEAMS = () =>\n  \"Granular Access Controls for teams\";\nexport const ACCESS_CONTROL_UPGRADE_PAGE_SUB_HEADING = () =>\n  \"Control all permissions for all resources in your apps in a workspace. Manage permissions granularly by attributes. Use permissions and user groups to easily define access levels.\";\nexport const SECURITY_APPS_LEAST_PRIVILEGE = () =>\n  \"Secure apps by the least privilege needed\";\nexport const SECURITY_APPS_LEAST_PRIVILEGE_DETAIL1 = () =>\n  `Create roles by the least privilege needed as defaults, <span>e.g.: View only</span>, assign them to users in groups, <span>e.g.: Marketing</span>, and modify for special access, <span>e.g.: Content creators_Execute queries</span>`;\nexport const PREVENT_ACCIDENTAL_DAMAGE = () =>\n  \"Prevent accidental damage to data\";\nexport const PREVENT_ACCIDENTAL_DAMAGE_DETAIL1 = () =>\n  `Assign edit and delete permissions to an entire group, then modify granularly so non-native users of your data don’t drop a table or bulk-delete streaming data records before you can say, “Retrieve”.`;\nexport const RESTRICT_PUBLIC_EXPOSURE = () =>\n  \"Restrict public exposure of sensitive data\";\nexport const RESTRICT_PUBLIC_EXPOSURE_DETAIL1 = () =>\n  \"Proactively disallow groups of non-admin or non-super-admin users from publicly sharing your app or exporting app data out of your environment, domain, and security perimeters.\";\nexport const ACCESS_CONTROL_UPGRADE_PAGE_FOOTER = () =>\n  \"Unlock granular access controls along with audit logs and SSO for enhanced security and reliability with an upgrade to our Business edition.\";\n// Access control upgrade page end\n\n//\nexport const WELCOME_FORM_NON_SUPER_USER_ROLE_DROPDOWN = () =>\n  \"Tell us more about what you do at work?\";\nexport const WELCOME_FORM_NON_SUPER_USER_ROLE = () => \"Role\";\nexport const WELCOME_FORM_NON_SUPER_USER_USE_CASE = () =>\n  \"What are you planning to use Appsmith for?\";\nexport const QUERY_CONFIRMATION_MODAL_MESSAGE = () =>\n  `Are you sure you want to run `;\nexport const ENTITY_EXPLORER_TITLE = () => \"NAVIGATION\";\nexport const MULTI_SELECT_PROPERTY_PANE_MESSAGE = () =>\n  `Select a widget to see it's properties`;\nexport const WIDGET_DEPRECATION_MESSAGE = (widgetName: string) =>\n  `Drag the latest ${widgetName} to unlock new features and prevent end-of-life headaches for this widget.`;\n\nexport const LOCK_ENTITY_EXPLORER_MESSAGE = () => `Lock sidebar open`;\nexport const CLOSE_ENTITY_EXPLORER_MESSAGE = () => `Close sidebar`;\nexport const JS_TOGGLE_DISABLED_MESSAGE = \"Clear the field to toggle back\";\nexport const PROPERTY_PANE_EMPTY_SEARCH_RESULT_MESSAGE =\n  \"No Properties found based on your search\";\nexport const PROPERTY_SEARCH_INPUT_PLACEHOLDER =\n  \"Search for controls, labels etc\";\n\n// API Pane\nexport const API_PANE_NO_BODY = () => \"This request does not have a body\";\nexport const API_PANE_AUTO_GENERATED_HEADER = () =>\n  \"This content-type header is auto-generated by appsmith based on body type of the API. Create a new header content-type to overwrite this value.\";\nexport const API_PANE_DUPLICATE_HEADER = (headerName: string) =>\n  `This is a duplicate header and will be overridden by the ${headerName} header added by you.`;\n\nexport const TABLE_WIDGET_TOTAL_RECORD_TOOLTIP = () =>\n  \"It stores the total no. of rows in the table. Helps in calculating the no. of pages that further allows to enable or disable the next/previous control in pagination.\";\nexport const CREATE_DATASOURCE_TOOLTIP = () => \"Add a new datasource\";\nexport const ADD_QUERY_JS_TOOLTIP = () => \"Add a new query / JS Object\";\nexport const LIST_WIDGET_V2_TOTAL_RECORD_TOOLTIP = () =>\n  \"Count of all the records in the source data for the list. This helps us calculate the number of pages to be shown\";\n\n// Add datasource\nexport const GENERATE_APPLICATION_TITLE = () => \"Generate Page\";\nexport const GENERATE_APPLICATION_DESCRIPTION = () =>\n  \"Quickly generate a page to perform CRUD operations on your database tables\";\nexport const DELETE_WORKSPACE_SUCCESSFUL = () =>\n  \"Workspace deleted successfully\";\n// theming\nexport const CHANGE_APP_THEME = (name: string) => `Theme ${name} Applied`;\nexport const SET_DEFAULT_SELECTED_THEME = (name: string) =>\n  `Applied the ${name} theme, since custom theme was not found`;\nexport const SAVE_APP_THEME = (name: string) => `Theme ${name} Saved`;\nexport const DELETE_APP_THEME = (name: string) => `Theme ${name} Deleted`;\nexport const DELETE_APP_THEME_WARNING = () =>\n  `Do you really want to delete this theme? This process cannot be undone.`;\nexport const APP_THEME_BETA_CARD_HEADING = () => `🎨 Theme your app`;\nexport const APP_THEME_BETA_CARD_CONTENT = () =>\n  `Customize your app's look through global styles. Full widget support coming soon`;\n\nexport const UPGRADE_TO_EE = (authLabel: string) =>\n  `Hello, I would like to upgrade and start using ${authLabel} authentication.`;\nexport const UPGRADE_TO_EE_FEATURE = (feature: string) =>\n  `Hello, I would like to upgrade and start using the ${feature} feature.`;\nexport const UPGRADE_TO_EE_GENERIC = () => `Hello, I would like to upgrade`;\nexport const ADMIN_AUTH_SETTINGS_TITLE = () => \"Select Authentication Method\";\nexport const ADMIN_AUTH_SETTINGS_SUBTITLE = () =>\n  \"Select a protocol you want to authenticate users with\";\nexport const DANGER_ZONE = () => \"Danger Zone\";\nexport const DISCONNECT_AUTH_METHOD = () => \"Disconnect\";\nexport const DISCONNECT_CONFIRMATION = () => \"Are you sure?\";\n\n// Branding\nexport const ADMIN_BRANDING_SETTINGS_TITLE = () =>\n  \"Custom branding for your workspaces\";\nexport const ADMIN_BRANDING_SETTINGS_SUBTITLE = () =>\n  \"Make your workspaces and apps look more yours in a few clicks as in the example below. Upload your logo and favicon, set your primary color, and preview the new look. To save a look you like, upgrade to our Business plan.\";\nexport const ADMIN_BRANDING_COLOR_TOOLTIP = () =>\n  `When you choose a primary color, we auto-magically fill in the secondary and accent colors. You can change them to get the look you want.`;\nexport const ADMIN_BRANDING_LOGO_SIZE_ERROR = () =>\n  `Uploaded file must be less than 2MB`;\nexport const ADMIN_BRANDING_LOGO_DIMENSION_ERROR = () =>\n  `Logo should  be atleast 256px in height`;\nexport const ADMIN_BRANDING_LOGO_FORMAT_ERROR = () =>\n  `Uploaded file must be in .SVG .PNG, and .JPG formats`;\nexport const ADMIN_BRANDING_LOGO_REQUIREMENT = () =>\n  `.SVG, .PNG, or .JPG only • Max 2MB`;\nexport const ADMIN_BRANDING_FAVICON_DIMENSION_ERROR = () =>\n  `Uploaded file must have a max size of 32X32 pixels`;\nexport const ADMIN_BRANDING_FAVICON_SIZE_ERROR = () =>\n  `Uploaded file must be less than 2MB`;\nexport const ADMIN_BRANDING_FAVICON_FORMAT_ERROR = () =>\n  `Uploaded file must be in .ICO, .PNG, and .JPG formats`;\nexport const ADMIN_BRANDING_FAVICON_REQUIREMENT = () =>\n  `.ICO, .PNG, or .JPG only • Max 32X32`;\nexport const ADMIN_BRANDING_COLOR_TOOLTIP_PRIMARY = () =>\n  `Used on buttons, links, and other interactive elements.`;\nexport const ADMIN_BRANDING_COLOR_TOOLTIP_BACKGROUND = () =>\n  `Used as background color for the auth pages`;\nexport const ADMIN_BRANDING_COLOR_TOOLTIP_HOVER = () =>\n  `Used as hover color for the button.`;\nexport const ADMIN_BRANDING_COLOR_TOOLTIP_FONT = () =>\n  `Used as text color for the buttons.`;\nexport const ADMIN_BRANDING_COLOR_TOOLTIP_DISABLED = () =>\n  `Used as background color for disabled buttons.`;\nexport const ADMIN_BRANDING_UPGRADE_INTERCOM_MESSAGE = () =>\n  `I would like to enable Custom Branding for my workspace and am interested in Appsmith Business.`;\n\n// Guided tour\n// -- STEPS ---\nexport const STEP_ONE_TITLE = () =>\n  \"First step is querying the database. Here we are querying a Postgres database populated with customers data.\";\nexport const STEP_ONE_SUCCESS_TEXT = () =>\n  \"Excellent! You successfully queried the database and you can see the response of the query below. \";\nexport const STEP_ONE_BUTTON_TEXT = () => \"PROCEED TO NEXT STEP\";\nexport const STEP_TWO_TITLE = () =>\n  \"Let’s display this response in a table. Select the table widget we’ve added for you.\";\nexport const STEP_THREE_TITLE = () =>\n  \"Display the response of the query in a table.\";\nexport const STEP_THREE_SUCCESS_TEXT = () =>\n  \"Great job! The table is now displaying the response of a query. You can use {{ }} in any input field to bind data to widgets.\";\nexport const STEP_THREE_SUCCESS_BUTTON_TEXT = () => \"PROCEED TO NEXT STEP\";\nexport const STEP_FOUR_TITLE = () =>\n  \"Let’s build a form to update a customer record \";\nexport const STEP_FOUR_HINT_BUTTON_TEXT = () => \"PROCEED\";\nexport const STEP_FOUR_SUCCESS_TEXT = () =>\n  \"Awesome! You connected the input widget to table’s selected row. The input will always show the data from the selected row.\";\nexport const STEP_FOUR_SUCCESS_BUTTON_TEXT = () => \"PROCEED TO NEXT STEP\";\nexport const STEP_FIVE_TITLE = () =>\n  \"Connect all input fields in the Customer Update Form with the table\";\nexport const STEP_FIVE_HINT_TEXT = () =>\n  `Now let's connect rest of widgets in the container to Table's selected row`;\nexport const STEP_FIVE_SUCCESS_TEXT = () =>\n  \"Great work! All inputs are now connected to the  table’s selected row\";\nexport const STEP_FIVE_SUCCESS_BUTTON_TEXT = () => \"PROCEED TO NEXT STEP\";\nexport const STEP_SIX_TITLE = () =>\n  \"Add an update button to trigger an update query\";\nexport const STEP_SIX_SUCCESS_TEXT = () =>\n  \"Perfect! Your update button is ready to trigger an update query.\";\nexport const STEP_SIX_SUCCESS_BUTTON_TEXT = () => \"PROCEED TO NEXT STEP\";\nexport const STEP_SEVEN_TITLE = () =>\n  \"Trigger updateCustomerInfo query by binding to the button widget\";\nexport const STEP_EIGHT_TITLE = () =>\n  \"After successfully triggering the update query, fetch the updated customer data. \";\nexport const STEP_EIGHT_SUCCESS_TEXT = () =>\n  \"Exceptional work! You’ve now built a way to see customer data and update it.\";\nexport const STEP_NINE_TITLE = () => \"Final step: Test & deploy your app\";\nexport const CONTINUE = () => \"CONTINUE\";\nexport const PROCEED_TO_NEXT_STEP = () => \"PROCEED TO NEXT STEP\";\nexport const PROCEED = () => \"PROCEED\";\nexport const COMPLETE = () => \"COMPLETE\";\n// -- Modal --\nexport const DEVIATION = () => \"You are deviating from the tutorial\";\nexport const END_CONFIRMATION = () => \"Are you sure you want to end?\";\nexport const CANCEL_DIALOG = () => \"CANCEL\";\n// -- End Tutorial --\nexport const END_TUTORIAL = () => \"END TUTORIAL\";\n// -- Intro content --\nexport const TITLE = () =>\n  \"In this tutorial we’ll build a tool to display customer information\";\nexport const DESCRIPTION = () =>\n  \"This tool has a table that displays customer data and a form to update a particular customer record. Try out the tool below before you start building.\";\nexport const BUTTON_TEXT = () => \"Start Building\";\n// -- Rating --\nexport const RATING_TITLE = () =>\n  \"Congratulations! You just built your first app in Appsmith.\";\nexport const RATING_DESCRIPTION = () =>\n  \"You can now invite others to this application.\";\nexport const RATING_TEXT = () => \"Rate your experience\";\n// -- End Message --\nexport const END_TITLE = () => \"What’s next? Start building your own apps.\";\nexport const END_DESCRIPTION = () =>\n  \"Inspect properties of queries, components, etc.\";\nexport const END_BUTTON_TEXT = () => \"START BUILDING AN APP\";\n\nexport const CONTEXT_EDIT_NAME = () => \"Edit Name\";\nexport const CONTEXT_SHOW_BINDING = () => \"Show Bindings\";\nexport const CONTEXT_MOVE = () => \"Move to page\";\nexport const CONTEXT_COPY = () => \"Copy to page\";\nexport const CONTEXT_DELETE = () => \"Delete\";\nexport const CONFIRM_CONTEXT_DELETE = () => \"Are you sure?\";\nexport const CONFIRM_CONTEXT_DELETING = () => \"Deleting\";\nexport const CONTEXT_NO_PAGE = () => \"No pages\";\nexport const CONTEXT_REFRESH = () => \"Refresh\";\nexport const CONTEXT_CLONE = () => \"Clone\";\nexport const CONTEXT_SETTINGS = () => \"Settings\";\nexport const CONTEXT_SET_AS_HOME_PAGE = () => \"Set as Home Page\";\nexport const PAGE = () => \"Page\";\nexport const PAGES = () => \"Pages\";\n\n// Entity explorer\nexport const ADD_DATASOURCE_BUTTON = () => \"ADD DATASOURCE\";\nexport const ADD_WIDGET_BUTTON = () => \"ADD WIDGET\";\nexport const ADD_QUERY_JS_BUTTON = () => \"ADD QUERY/JS\";\nexport const EMPTY_WIDGET_MAIN_TEXT = () => \"No widget to display\";\nexport const EMPTY_WIDGET_BUTTON_TEXT = () => \"NEW WIDGET\";\nexport const EMPTY_QUERY_JS_MAIN_TEXT = () => \"No query/JS to display\";\nexport const EMPTY_QUERY_JS_BUTTON_TEXT = () => \"NEW QUERY/JS\";\nexport const EMPTY_DATASOURCE_MAIN_TEXT = () => \"No datasource to display\";\nexport const EMPTY_DATASOURCE_BUTTON_TEXT = () => \"NEW DATASOURCE\";\n\n// Templates\nexport const MORE = () => \"MORE\";\nexport const SHOW_LESS = () => \"SHOW LESS\";\nexport const CHOOSE_WHERE_TO_FORK = () => \"Choose where to fork the template\";\nexport const SELECT_WORKSPACE = () => \"Select Workspace\";\nexport const FORK_TEMPLATE = () => \"FORK TEMPLATE\";\nexport const TEMPLATES = () => \"TEMPLATES\";\nexport const FORK_THIS_TEMPLATE = () => \"Use template\";\nexport const COULDNT_FIND_TEMPLATE = () =>\n  \"Couldn’t find what you are looking for?\";\nexport const COULDNT_FIND_TEMPLATE_DESCRIPTION = () =>\n  \"A github issue portal will be opened up for you to create an issue regarding what type of template you need.\";\nexport const REQUEST_TEMPLATE = () => \"Request for a template\";\nexport const SEARCH_TEMPLATES = () => \"Search templates\";\nexport const INTRODUCING_TEMPLATES = () => \"Introducing Templates\";\nexport const TEMPLATE_NOTIFICATION_DESCRIPTION = () =>\n  \"Use these templates to learn, create, and build apps even faster\";\nexport const GO_BACK = () => \"GO BACK\";\nexport const OVERVIEW = () => \"Overview\";\nexport const FUNCTION = () => \"Function\";\nexport const INDUSTRY = () => \"Use Case\";\nexport const DATASOURCES = () => \"Datasources\";\nexport const NOTE = () => \"Note:\";\nexport const NOTE_MESSAGE = () => \"You can add your datasources as well\";\nexport const WIDGET_USED = () => \"Widgets\";\nexport const SIMILAR_TEMPLATES = () => \"Similar Templates\";\nexport const VIEW_ALL_TEMPLATES = () => \"VIEW ALL TEMPLATES\";\nexport const FILTERS = () => \"FILTERS\";\nexport const TEMPLATE_CARD_TITLE = () => \"Start from a template\";\nexport const TEMPLATE_CARD_DESCRIPTION = () =>\n  \"Create app from template by selecting pages\";\nexport const FILTER_SELECTALL = () => \"Select all\";\nexport const FILTER_SELECT_PAGES = () => \"ADD SELECTED PAGES\";\nexport const FORKING_TEMPLATE = () => \"Setting up the template\";\nexport const FETCHING_TEMPLATES = () => \"Loading template details\";\nexport const FETCHING_TEMPLATE_LIST = () => \"Loading templates list\";\n\nexport const TEMPLATES_BACK_BUTTON = () => \"BACK TO TEMPLATES\";\n\nexport const IMAGE_LOAD_ERROR = () => \"Unable to display the image\";\n\nexport const REDIRECT_URL_TOOLTIP = () =>\n  \"This URL will be used while configuring your Identity Provider's Callback/Redirect URL\";\nexport const ENTITY_ID_TOOLTIP = () =>\n  \"This URL will be used while configuring your Identity Provider's Entity ID URL\";\n\nexport const FORK_APP_MODAL_LOADING_TITLE = () =>\n  \"Fetching workspaces to fork to...\";\nexport const FORK_APP_MODAL_EMPTY_TITLE = () =>\n  \"No workspace available to fork to\";\nexport const FORK_APP_MODAL_SUCCESS_TITLE = () =>\n  \"Choose where to fork the app\";\nexport const FORK = () => `FORK`;\n\nexport const CLEAN_URL_UPDATE = {\n  name: () => \"Update URLs\",\n  shortDesc: () =>\n    \"All URLs in your applications will update to a new readable format that includes the application and page names.\",\n  description: [\n    () =>\n      \"All URLs in your applications will be updated to match our new style. This will make your apps easier to find, and URLs easier to remember.\",\n    (url: string) =>\n      `The current app’s URL will be:<br /><code style=\"line-break: anywhere; padding: 2px 4px; line-height: 22px\">${url}</code>`,\n  ],\n  disclaimer: () =>\n    \"Existing references to <strong>appsmith.URL.fullpath</strong> and <strong>appsmith.URL.pathname</strong> properties will behave differently.\",\n};\n\nexport const MEMBERS_TAB_TITLE = (\n  length: number,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  cloudHosting?: boolean,\n) => `Users (${length})`;\n\nexport const CREATE_PAGE = () => \"New Blank Page\";\nexport const CANVAS_NEW_PAGE_CARD = () => \"Create New Page\";\nexport const GENERATE_PAGE = () => \"Generate page from data table\";\nexport const GENERATE_PAGE_DESCRIPTION = () =>\n  \"Start app with a simple CRUD UI and customize it\";\nexport const ADD_PAGE_FROM_TEMPLATE = () => \"Add Page From Template\";\nexport const INVALID_URL = () =>\n  \"Please enter a valid URL, for example, https://example.com\";\nexport const SAVE_OR_DISCARD_DATASOURCE_WARNING = () =>\n  `Unsaved changes will be lost if you exit this page, save the changes before exiting.`;\n\nexport const APP_SETTINGS_PANE_HEADER = () => \"Settings\";\nexport const APP_SETTINGS_CLOSE_TOOLTIP = () => \"Close settings panel\";\n\nexport const GENERAL_SETTINGS_SECTION_HEADER = () => \"General\";\nexport const GENERAL_SETTINGS_SECTION_CONTENT_HEADER = () => \"General Settings\";\nexport const GENERAL_SETTINGS_SECTION_HEADER_DESC = () =>\n  \"App name, icon and share\";\nexport const GENERAL_SETTINGS_APP_NAME_LABEL = () => \"App Name\";\nexport const GENERAL_SETTINGS_NAME_EMPTY_MESSAGE = () =>\n  \"App name cannot be empty\";\nexport const GENERAL_SETTINGS_NAME_SPECIAL_CHARACTER_ERROR = () =>\n  \"Only alphanumeric or '-()' are allowed\";\nexport const GENERAL_SETTINGS_APP_ICON_LABEL = () => \"App Icon\";\n\nexport const THEME_SETTINGS_SECTION_HEADER = () => \"Theme\";\nexport const THEME_SETTINGS_SECTION_CONTENT_HEADER = () => \"Theme Settings\";\nexport const THEME_SETTINGS_SECTION_HEADER_DESC = () =>\n  \"Set theme, color and font\";\n\nexport const PAGE_SETTINGS_SECTION_HEADER = () => \"Page settings\";\nexport const PAGE_SETTINGS_SECTION_CONTENT_HEADER = () => \"Settings\";\nexport const PAGE_SETTINGS_PAGE_NAME_LABEL = () => \"Page Name\";\nexport const PAGE_SETTINGS_NAME_EMPTY_MESSAGE = () =>\n  \"Page name cannot be empty\";\nexport const PAGE_SETTINGS_NAME_SPECIAL_CHARACTER_ERROR = () =>\n  \"Only alphanumeric or '-' are allowed\";\nexport const PAGE_SETTINGS_PAGE_URL_LABEL = () => \"Change Page URL\";\nexport const PAGE_SETTINGS_PAGE_URL_VERSION_UPDATE_1 = () => \"Please\";\nexport const PAGE_SETTINGS_PAGE_URL_VERSION_UPDATE_2 = () => \"update\";\nexport const PAGE_SETTINGS_PAGE_URL_VERSION_UPDATE_3 = () =>\n  \"your app URL to new readable format to change this\";\nexport const PAGE_SETTINGS_SHOW_PAGE_NAV = () => \"Show page navigation\";\nexport const PAGE_SETTINGS_SHOW_PAGE_NAV_TOOLTIP = () =>\n  \"Show or hide the page in the appsmith navbar in view mode\";\nexport const PAGE_SETTINGS_SET_AS_HOMEPAGE = () => \"Set as home page\";\nexport const PAGE_SETTINGS_SET_AS_HOMEPAGE_TOOLTIP = () =>\n  \"This is the current home page, you can change this by setting another page as the home page\";\nexport const PAGE_SETTINGS_SET_AS_HOMEPAGE_TOOLTIP_NON_HOME_PAGE = () =>\n  \"Set this page as your home page. This will override your previously set home page.\";\nexport const PAGE_SETTINGS_ACTION_NAME_CONFLICT_ERROR = (name: string) =>\n  `${name} is already being used.`;\n\nexport const IN_APP_EMBED_SETTING = {\n  applicationUrl: () => \"application url\",\n  allowEmbeddingLabel: () => \"Embedding enabled\",\n  allowEmbeddingTooltip: () =>\n    \"This app can be embedded in all domains, including malicious ones\",\n  copy: () => \"Copy\",\n  copied: () => \"Copied\",\n  limitEmbeddingLabel: () => \"Embedding restricted\",\n  limitEmbeddingTooltip: () => \"This app can be embedded in approved URLs only\",\n  disableEmbeddingLabel: () => \"Embedding disabled\",\n  disableEmbeddingTooltip: () =>\n    \"This app cannot be embedded anywhere on the Internet\",\n  embed: () => \"Embed\",\n  embedSnippetTitle: () => \"Copy embed code\",\n  change: () => \"Change\",\n  copiedEmbedCode: () => \"Embed code copied to clipboard\",\n  embedSize: () => \"Embed size\",\n  previewEmbeddedApp: () => \"PREVIEW EMBEDDED APP\",\n  sectionHeader: () => \"Share & Embed\",\n  sectionContentHeader: () => \"Share\",\n  sectionHeaderDesc: () => \"Make public, embed properties\",\n  showNavigationBar: () => \"Show navigation bar\",\n};\n\nexport const NEW_QUERY_BUTTON_TEXT = () => \"New Query\";\nexport const NEW_API_BUTTON_TEXT = () => \"New API\";\nexport const GENERATE_NEW_PAGE_BUTTON_TEXT = () => \"GENERATE NEW PAGE\";\nexport const RECONNECT_BUTTON_TEXT = () => \"RECONNECT\";\nexport const SAVE_BUTTON_TEXT = () => \"SAVE\";\nexport const SAVE_AND_AUTHORIZE_BUTTON_TEXT = () => \"SAVE AND AUTHORIZE\";\nexport const DISCARD_POPUP_DONT_SAVE_BUTTON_TEXT = () => \"DON'T SAVE\";\n\n// Alert options and labels for showMessage types\nexport const ALERT_STYLE_OPTIONS = [\n  { label: \"Info\", value: \"'info'\", id: \"info\" },\n  {\n    label: \"Success\",\n    value: \"'success'\",\n    id: \"success\",\n  },\n  { label: \"Error\", value: \"'error'\", id: \"error\" },\n  { label: \"Warning\", value: \"'warning'\", id: \"warning\" },\n];\n\nexport const customJSLibraryMessages = {\n  ADD_JS_LIBRARY: () => \"Add JS Libraries\",\n  REC_LIBRARY: () => \"Recommended Libraries\",\n  INSTALLATION_SUCCESSFUL: (accessor: string) =>\n    `Installation Successful. You can access the library via ${accessor}`,\n  INSTALLATION_FAILED: () => \"Installation failed\",\n  INSTALLED_ALREADY: (accessor: string) =>\n    `This library is already installed. You could access it via ${accessor}.`,\n  UNINSTALL_FAILED: (name: string) =>\n    `Couldn't uninstall ${name}. Please try again after sometime.`,\n  UNINSTALL_SUCCESS: (accessor: string) =>\n    `${accessor} is uninstalled successfully.`,\n  LEARN_MORE_DESC: () => \"Learn more about Custom JS Libraries\",\n  UNSUPPORTED_LIB: () => `Library is unsupported`,\n  UNSUPPORTED_LIB_DESC: () =>\n    `Unfortunately, this library cannot be supported due to platform limitations. Please try installing a different library.`,\n  LEARN_MORE: () => `Learn more`,\n  REPORT_ISSUE: () => `Report issue`,\n  AUTOCOMPLETE_FAILED: (name: string) =>\n    `Code completion for ${name} will not work.`,\n  CLIENT_LOAD_FAILED: (url: string) => `Failed to load the script at ${url}.`,\n  LIB_OVERRIDE_ERROR: (\n    name: string,\n  ) => `The library ${name} is already installed.\n  If you are trying to install a different version, uninstall the library first.`,\n  DEFS_FAILED_ERROR: (name: string) =>\n    `Failed to generate autocomplete definitions for ${name}.`,\n  IMPORT_URL_ERROR: (url: string) =>\n    `The script at ${url} cannot be installed.`,\n  NAME_COLLISION_ERROR: (accessors: string) =>\n    `Name collision detected: ${accessors}`,\n};\n\n// Business Edition upgrade page\nexport const MOVE_TO_BUSINESS_EDITION = (trailingChar: string) =>\n  `Move to Business Edition${trailingChar ? trailingChar : \"\"}`;\n","import log from \"loglevel\";\nimport { Def } from \"tern\";\n\nfunction getTernDocType(obj: any) {\n  const type = typeof obj;\n  switch (type) {\n    case \"string\":\n      return \"string\";\n    case \"number\":\n      return \"number\";\n    case \"boolean\":\n      return \"bool\";\n    case \"undefined\":\n      return \"?\";\n    case \"function\":\n      return \"fn()\";\n    default:\n      return \"?\";\n  }\n}\n\nconst ignoredKeys = [\n  \"constructor\",\n  \"WINDOW\",\n  \"window\",\n  \"self\",\n  \"arguments\",\n  \"caller\",\n  \"length\",\n  \"name\",\n];\n\nexport function makeTernDefs(obj: any) {\n  const defs: Def = {};\n  const cachedDefs: any = [];\n  const visitedReferences: any = [];\n  const MAX_ITERATIONS = 5000;\n  let iteration_count = 1;\n  const baseObjPrototype = Object.getPrototypeOf({});\n\n  const queue = [[obj, defs]];\n\n  try {\n    while (queue.length && iteration_count < MAX_ITERATIONS) {\n      const [src, target] = queue.shift() as any;\n      if (visitedReferences.includes(src)) {\n        target[\"!type\"] = cachedDefs[visitedReferences.indexOf(src)][\"!type\"];\n        continue;\n      }\n      const type = typeof src;\n      if (!src || (type !== \"object\" && type !== \"function\")) {\n        target[\"!type\"] = getTernDocType(src);\n        continue;\n      } else if (type === \"function\") {\n        target[\"!type\"] = \"fn()\";\n      }\n      queue.push(\n        ...Object.getOwnPropertyNames(src)\n          .filter((key) => !ignoredKeys.includes(key))\n          .map((key) => {\n            target[key] = {};\n            return [src[key], target[key]];\n          }),\n      );\n      if (type === \"object\") {\n        const prototype = Object.getPrototypeOf(src);\n        if (prototype !== baseObjPrototype) {\n          queue.push(\n            ...Object.getOwnPropertyNames(prototype)\n              .filter((key) => !ignoredKeys.includes(key))\n              .map((key) => {\n                target[key] = {};\n                return [src[key], target[key]];\n              }),\n          );\n        }\n      }\n      iteration_count++;\n    }\n  } catch (e) {\n    log.debug(\"Unknown depth\", e);\n  }\n  return defs;\n}\n","import {\n  createMessage,\n  customJSLibraryMessages,\n} from \"@appsmith/constants/messages\";\nimport difference from \"lodash/difference\";\nimport { Def } from \"tern\";\nimport {\n  JSLibraries,\n  libraryReservedIdentifiers,\n  resetJSLibraries,\n} from \"../../common/JSLibrary\";\nimport { makeTernDefs } from \"../../common/JSLibrary/ternDefinitionGenerator\";\nimport { EvalWorkerSyncRequest } from \"../types\";\n\nenum LibraryInstallError {\n  NameCollisionError,\n  ImportError,\n  TernDefinitionError,\n  LibraryOverrideError,\n}\n\nclass NameCollisionError extends Error {\n  code = LibraryInstallError.NameCollisionError;\n  constructor(accessors: string) {\n    super(\n      createMessage(customJSLibraryMessages.NAME_COLLISION_ERROR, accessors),\n    );\n    this.name = \"NameCollisionError\";\n  }\n}\n\nclass ImportError extends Error {\n  code = LibraryInstallError.ImportError;\n  constructor(url: string) {\n    super(createMessage(customJSLibraryMessages.IMPORT_URL_ERROR, url));\n    this.name = \"ImportError\";\n  }\n}\n\nclass TernDefinitionError extends Error {\n  code = LibraryInstallError.TernDefinitionError;\n  constructor(name: string) {\n    super(createMessage(customJSLibraryMessages.DEFS_FAILED_ERROR, name));\n    this.name = \"TernDefinitionError\";\n  }\n}\n\nclass LibraryOverrideError extends Error {\n  code = LibraryInstallError.LibraryOverrideError;\n  data: any;\n  constructor(name: string, data: any) {\n    super(createMessage(customJSLibraryMessages.LIB_OVERRIDE_ERROR, name));\n    this.name = \"LibraryOverrideError\";\n    this.data = data;\n  }\n}\n\nexport function installLibrary(request: EvalWorkerSyncRequest) {\n  const { data } = request;\n  const { takenAccessors, takenNamesMap, url } = data;\n  const defs: Def = {};\n  try {\n    const currentEnvKeys = Object.keys(self);\n\n    //@ts-expect-error Find libraries that were uninstalled.\n    const unsetKeys = currentEnvKeys.filter((key) => self[key] === undefined);\n\n    const existingLibraries: Record<string, any> = {};\n\n    for (const acc of takenAccessors) {\n      existingLibraries[acc] = self[acc];\n    }\n\n    try {\n      self.importScripts(url);\n    } catch (e) {\n      throw new ImportError(url);\n    }\n\n    // Find keys add that were installed to the global scope.\n    const accessor = difference(Object.keys(self), currentEnvKeys) as Array<\n      string\n    >;\n\n    checkForNameCollision(accessor, takenNamesMap);\n\n    checkIfUninstalledEarlier(accessor, unsetKeys);\n\n    checkForOverrides(url, accessor, takenAccessors, existingLibraries);\n\n    if (accessor.length === 0) return { status: false, defs, accessor };\n\n    //Reserves accessor names.\n    const name = accessor[accessor.length - 1];\n\n    defs[\"!name\"] = `LIB/${name}`;\n    try {\n      for (const key of accessor) {\n        //@ts-expect-error no types\n        defs[key] = makeTernDefs(self[key]);\n      }\n    } catch (e) {\n      for (const acc of accessor) {\n        //@ts-expect-error no types\n        self[acc] = undefined;\n      }\n      throw new TernDefinitionError(\n        `Failed to generate autocomplete definitions: ${name}`,\n      );\n    }\n\n    //Reserve accessor names.\n    for (const acc of accessor) {\n      libraryReservedIdentifiers[acc] = true;\n    }\n\n    return { success: true, defs, accessor };\n  } catch (error) {\n    return { success: false, defs, error };\n  }\n}\n\nexport function uninstallLibrary(request: EvalWorkerSyncRequest) {\n  const { data } = request;\n  const accessor = data;\n  try {\n    for (const key of accessor) {\n      try {\n        delete self[key];\n      } catch (e) {\n        //@ts-expect-error ignore\n        self[key] = undefined;\n      }\n      delete libraryReservedIdentifiers[key];\n    }\n    return { success: true };\n  } catch (e) {\n    return { success: false };\n  }\n}\n\nexport function loadLibraries(request: EvalWorkerSyncRequest) {\n  resetJSLibraries();\n  //Add types\n  const { data } = request;\n  const urls = data.map((lib: any) => lib.url);\n  const keysBefore = Object.keys(self);\n  let message = \"\";\n\n  try {\n    self.importScripts(...urls);\n  } catch (e) {\n    message = (e as Error).message;\n  }\n  const keysAfter = Object.keys(self);\n  const newKeys = difference(keysAfter, keysBefore);\n  for (const key of newKeys) {\n    libraryReservedIdentifiers[key] = true;\n  }\n  JSLibraries.push(...data);\n  return { success: !message, message };\n}\n\nfunction checkForNameCollision(\n  accessor: string[],\n  takenNamesMap: Record<string, any>,\n) {\n  const collidingNames = accessor.filter((key: string) => takenNamesMap[key]);\n  if (collidingNames.length) {\n    for (const acc of accessor) {\n      //@ts-expect-error no types\n      self[acc] = undefined;\n    }\n    throw new NameCollisionError(collidingNames.join(\", \"));\n  }\n}\n\nfunction checkIfUninstalledEarlier(accessor: string[], unsetKeys: string[]) {\n  if (accessor.length > 0) return;\n  for (const key of unsetKeys) {\n    //@ts-expect-error no types\n    if (!self[key]) continue;\n    accessor.push(key);\n  }\n}\n\nfunction checkForOverrides(\n  url: string,\n  accessor: string[],\n  takenAccessors: string[],\n  existingLibraries: Record<string, any>,\n) {\n  if (accessor.length > 0) return;\n  const overriddenAccessors: Array<string> = [];\n  for (const acc of takenAccessors) {\n    //@ts-expect-error no types\n    if (existingLibraries[acc] === self[acc]) continue;\n    //@ts-expect-error no types\n    self[acc] = existingLibraries[acc];\n    overriddenAccessors.push(acc);\n  }\n  if (overriddenAccessors.length === 0) return;\n  throw new LibraryOverrideError(url, overriddenAccessors);\n}\n","import { Diff } from \"deep-diff\";\nimport { Action } from \"entities/Action\";\nimport ReplayEntity from \"..\";\nimport { pathArrayToString } from \"../replayUtils\";\nimport { JSActionConfig } from \"entities/JSCollection\";\nimport { Datasource } from \"entities/Datasource\";\nimport { ENTITY_TYPE } from \"entities/AppsmithConsole\";\nimport isEmpty from \"lodash/isEmpty\";\nimport { Canvas } from \"./ReplayCanvas\";\n\n/*\n This type represents all the form objects that can be undone/redone.\n (Action, datasource, jsAction etc)\n*/\nexport type Replayable =\n  | Partial<JSActionConfig>\n  | Partial<Datasource>\n  | Partial<Action>\n  | Partial<Canvas>;\n\ntype ReplayEditorDiff = Diff<Replayable, Replayable>;\n\nexport type ReplayEditorUpdate = {\n  modifiedProperty: string;\n  index?: number;\n  update: Replayable | ReplayEditorDiff;\n  kind: \"N\" | \"D\" | \"E\" | \"A\";\n  isUndo?: boolean;\n};\nexport default class ReplayEditor extends ReplayEntity<Replayable> {\n  constructor(entity: Replayable, entityType: ENTITY_TYPE) {\n    super(entity, entityType);\n  }\n\n  public processDiff(\n    diff: Diff<Replayable, Replayable>,\n    replay: any,\n    isUndo: boolean,\n  ): void {\n    if (!diff || !diff.path || !diff.path.length) return;\n    replay.updates = (replay.updates || []).concat(\n      this.getChanges(diff, isUndo) || [],\n    );\n  }\n\n  /*\n    The should get us the modified property (configProperty from editor, settings and form json files), the updated value and the kind of update.\n    The modifiedProperty would be used to highlight the field that has been replayed. We might need to use the kind in future to display toast\n    messages or even highlight based on the kind.\n  */\n  private getChanges(\n    diff: Diff<Replayable, Replayable>,\n    isUndo: boolean,\n  ): ReplayEditorUpdate | undefined {\n    const { kind, path } = diff;\n    if (diff.kind === \"N\") {\n      if (isEmpty(diff.rhs)) return;\n      return {\n        modifiedProperty: pathArrayToString(path),\n        update: diff.rhs,\n        kind,\n      };\n    } else if (diff.kind === \"A\") {\n      return {\n        modifiedProperty: pathArrayToString(path),\n        update: diff.item,\n        index: diff.index,\n        kind,\n        isUndo,\n      };\n    } else if (diff.kind === \"E\") {\n      return {\n        modifiedProperty: pathArrayToString(path),\n        update: isUndo ? diff.lhs : diff.rhs,\n        kind,\n      };\n    }\n    return {\n      modifiedProperty: pathArrayToString(path),\n      update: diff.lhs,\n      kind,\n    };\n  }\n}\n","import { createEvaluationContext } from \"../../evaluate\";\nimport { dataTreeEvaluator } from \"../../handlers/evalTree\";\nimport ExecutionMetaData from \"../utils/ExecutionMetaData\";\n\nconst _internalSetTimeout = self.setTimeout;\nconst _internalClearTimeout = self.clearTimeout;\n\nfunction setTimeout(cb: (...args: any) => any, delay: number, ...args: any) {\n  const metaData = ExecutionMetaData.getExecutionMetaData();\n  return _internalSetTimeout(\n    function(...args: any) {\n      const evalContext = createEvaluationContext({\n        dataTree: dataTreeEvaluator?.evalTree || {},\n        resolvedFunctions: dataTreeEvaluator?.resolvedFunctions || {},\n        isTriggerBased: true,\n      });\n      self[\"$isDataField\"] = false;\n      Object.assign(self, evalContext);\n      ExecutionMetaData.setExecutionMetaData(\n        metaData.triggerMeta,\n        metaData.eventType,\n      );\n      typeof cb === \"function\" && cb(...args);\n    },\n    delay,\n    ...args,\n  );\n}\n\nfunction clearTimeout(timerId: number) {\n  return _internalClearTimeout(timerId);\n}\n\nexport { setTimeout, clearTimeout };\n","const _originalFetch = self.fetch;\n\nexport function fetch(...args: Parameters<typeof _originalFetch>) {\n  const request = new Request(args[0], { ...args[1] });\n  return _originalFetch(request);\n}\n","import get from \"lodash/get\";\n\nexport default function initLocalStorage(this: any) {\n  const getItem = (key: string) => {\n    return get(this.appsmith.store, key);\n  };\n  const setItem = (key: string, value: any) => {\n    this.storeValue(key, value);\n  };\n  const removeItem = (key: string) => {\n    this.removeValue(key);\n  };\n  const clear = () => {\n    this.clearStore();\n  };\n  const localStorage = {\n    getItem,\n    setItem,\n    removeItem,\n    clear,\n  };\n  Object.defineProperty(this, \"localStorage\", {\n    enumerable: false,\n    value: localStorage,\n  });\n}\n","import { setInterval, clearAllIntervals } from \"./interval\";\nimport { setTimeout, clearTimeout } from \"./timeout\";\nimport { fetch } from \"./fetch\";\nimport { addFn } from \"../utils/fnGuard\";\nimport userLogs from \"./console\";\nimport initLocalStorage from \"./localStorage\";\n\nexport function overrideWebAPIs(ctx: any) {\n  userLogs.overrideConsoleAPI();\n  addFn(ctx, \"setInterval\", setInterval);\n  addFn(ctx, \"clearInterval\", clearAllIntervals);\n  addFn(ctx, \"setTimeout\", setTimeout);\n  addFn(ctx, \"clearTimeout\", clearTimeout);\n  addFn(ctx, \"fetch\", fetch);\n  initLocalStorage.call(ctx);\n}\n","import noop from \"lodash/noop\";\nimport {\n  EVAL_WORKER_ACTIONS,\n  EVAL_WORKER_ASYNC_ACTION,\n  EVAL_WORKER_SYNC_ACTION,\n} from \"@appsmith/workers/Evaluation/evalWorkerActions\";\nimport { EvalWorkerSyncRequest, EvalWorkerASyncRequest } from \"../types\";\nimport evalActionBindings from \"./evalActionBindings\";\nimport evalExpression from \"./evalExpression\";\nimport evalTree, { clearCache } from \"./evalTree\";\nimport evalTrigger from \"./evalTrigger\";\nimport executeSyncJS from \"./executeSyncJS\";\nimport initFormEval from \"./initFormEval\";\nimport { installLibrary, loadLibraries, uninstallLibrary } from \"./jsLibrary\";\nimport { redo, undo, updateReplayObject } from \"./replay\";\nimport setupEvaluationEnvironment, {\n  setEvaluationVersion,\n} from \"./setupEvalEnv\";\nimport validateProperty from \"./validateProperty\";\n\nconst syncHandlerMap: Record<\n  EVAL_WORKER_SYNC_ACTION,\n  (req: EvalWorkerSyncRequest) => any\n> = {\n  [EVAL_WORKER_ACTIONS.EVAL_ACTION_BINDINGS]: evalActionBindings,\n  [EVAL_WORKER_ACTIONS.EVAL_TREE]: evalTree,\n  [EVAL_WORKER_ACTIONS.EXECUTE_SYNC_JS]: executeSyncJS,\n  [EVAL_WORKER_ACTIONS.UNDO]: undo,\n  [EVAL_WORKER_ACTIONS.REDO]: redo,\n  [EVAL_WORKER_ACTIONS.UPDATE_REPLAY_OBJECT]: updateReplayObject,\n  [EVAL_WORKER_ACTIONS.VALIDATE_PROPERTY]: validateProperty,\n  [EVAL_WORKER_ACTIONS.INSTALL_LIBRARY]: installLibrary,\n  [EVAL_WORKER_ACTIONS.UNINSTALL_LIBRARY]: uninstallLibrary,\n  [EVAL_WORKER_ACTIONS.LOAD_LIBRARIES]: loadLibraries,\n  [EVAL_WORKER_ACTIONS.LINT_TREE]: noop,\n  [EVAL_WORKER_ACTIONS.SETUP]: setupEvaluationEnvironment,\n  [EVAL_WORKER_ACTIONS.CLEAR_CACHE]: clearCache,\n  [EVAL_WORKER_ACTIONS.SET_EVALUATION_VERSION]: setEvaluationVersion,\n  [EVAL_WORKER_ACTIONS.INIT_FORM_EVAL]: initFormEval,\n};\n\nconst asyncHandlerMap: Record<\n  EVAL_WORKER_ASYNC_ACTION,\n  (req: EvalWorkerASyncRequest) => any\n> = {\n  [EVAL_WORKER_ACTIONS.EVAL_TRIGGER]: evalTrigger,\n  [EVAL_WORKER_ACTIONS.EVAL_EXPRESSION]: evalExpression,\n};\n\nexport { syncHandlerMap, asyncHandlerMap };\n","import { dataTreeEvaluator } from \"./evalTree\";\nimport { removeFunctions } from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport { EvalWorkerSyncRequest } from \"../types\";\n\nexport default function(request: EvalWorkerSyncRequest) {\n  const { data } = request;\n  const { bindings, executionParams } = data;\n  if (!dataTreeEvaluator) {\n    return { values: undefined, errors: [] };\n  }\n\n  const values = dataTreeEvaluator.evaluateActionBindings(\n    bindings,\n    executionParams,\n  );\n\n  const cleanValues = removeFunctions(values);\n\n  const errors = dataTreeEvaluator.errors;\n  dataTreeEvaluator.clearErrors();\n  return { values: cleanValues, errors };\n}\n","import evaluateSync from \"../evaluate\";\nimport { dataTreeEvaluator } from \"./evalTree\";\nimport { EvalWorkerSyncRequest } from \"../types\";\nimport ExecutionMetaData from \"../fns/utils/ExecutionMetaData\";\n\nexport default function(request: EvalWorkerSyncRequest) {\n  const { data } = request;\n  const { eventType, functionCall, triggerMeta } = data;\n  if (!dataTreeEvaluator) {\n    return true;\n  }\n  ExecutionMetaData.setExecutionMetaData(triggerMeta, eventType);\n  const evalTree = dataTreeEvaluator.evalTree;\n  const resolvedFunctions = dataTreeEvaluator.resolvedFunctions;\n  return evaluateSync(\n    functionCall,\n    evalTree,\n    resolvedFunctions,\n    false,\n    undefined,\n  );\n}\n","import ReplayEditor from \"entities/Replay/ReplayEntity/ReplayEditor\";\nimport { EvalWorkerSyncRequest } from \"../types\";\nimport { CANVAS, replayMap } from \"./evalTree\";\n\nexport function undo(request: EvalWorkerSyncRequest) {\n  const { data } = request;\n  const { entityId } = data;\n  if (!replayMap[entityId || CANVAS]) return;\n  const replayResult = replayMap[entityId || CANVAS].replay(\"UNDO\");\n  replayMap[entityId || CANVAS].clearLogs();\n  return replayResult;\n}\n\nexport function redo(request: EvalWorkerSyncRequest) {\n  const { data } = request;\n  const { entityId } = data;\n  if (!replayMap[entityId ?? CANVAS]) return;\n  const replayResult = replayMap[entityId ?? CANVAS].replay(\"REDO\");\n  replayMap[entityId ?? CANVAS].clearLogs();\n  return replayResult;\n}\n\nexport function updateReplayObject(request: EvalWorkerSyncRequest) {\n  const { data } = request;\n  const { entity, entityId, entityType } = data;\n  const replayObject = replayMap[entityId];\n  if (replayObject) {\n    replayObject.update(entity);\n  } else {\n    replayMap[entityId] = new ReplayEditor(entity, entityType);\n  }\n  return true;\n}\n","import { validateWidgetProperty } from \"workers/common/DataTreeEvaluator/validationUtils\";\nimport { removeFunctions } from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport { EvalWorkerSyncRequest } from \"../types\";\n\nexport default function(request: EvalWorkerSyncRequest) {\n  const { data } = request;\n  const { property, props, validation, value } = data;\n  return removeFunctions(\n    validateWidgetProperty(validation, value, props, property),\n  );\n}\n","import { unsafeFunctionForEval } from \"utils/DynamicBindingUtils\";\nimport setupDOM from \"../SetupDOM\";\nimport { EvalWorkerSyncRequest } from \"../types\";\nimport { addPlatformFunctionsToEvalContext } from \"@appsmith/workers/Evaluation/Actions\";\nimport { overrideWebAPIs } from \"../fns/overrides\";\n\nexport default function(request: EvalWorkerSyncRequest) {\n  self.$isDataField = false;\n  ///// Remove all unsafe functions\n  unsafeFunctionForEval.forEach((func) => {\n    // @ts-expect-error: Types are not available\n    self[func] = undefined;\n  });\n  setupDOM();\n  overrideWebAPIs(self);\n  Object.defineProperty(self, \"$cloudHosting\", {\n    value: request.data.cloudHosting,\n    enumerable: false,\n  });\n  addPlatformFunctionsToEvalContext(self);\n  return true;\n}\n\nexport function setEvaluationVersion(request: EvalWorkerSyncRequest) {\n  const { data } = request;\n  const { version } = data;\n  self.evaluationVersion = version || 1;\n  return true;\n}\n","import { setFormEvaluationSaga } from \"../formEval\";\nimport { EvalWorkerSyncRequest } from \"../types\";\n\nexport default function(request: EvalWorkerSyncRequest) {\n  const { data } = request;\n  const { currentEvalState, payload, type } = data;\n  const response = setFormEvaluationSaga(type, payload, currentEvalState);\n  return response;\n}\n","import { evaluateAsync } from \"../evaluate\";\nimport { EvalWorkerASyncRequest } from \"../types\";\nimport { dataTreeEvaluator } from \"./evalTree\";\n\nexport default function(request: EvalWorkerASyncRequest) {\n  const { data } = request;\n  const { expression } = data;\n  const evalTree = dataTreeEvaluator?.evalTree;\n  const resolvedFunctions = dataTreeEvaluator?.resolvedFunctions || {};\n  if (!evalTree) return {};\n  return evaluateAsync(expression, evalTree, resolvedFunctions, {});\n}\n","// Workers do not have access to log.error\n/* eslint-disable no-console */\nimport { EvalWorkerASyncRequest, EvalWorkerSyncRequest } from \"./types\";\nimport { syncHandlerMap, asyncHandlerMap } from \"./handlers\";\nimport { TMessage, MessageType } from \"utils/MessageUtil\";\nimport { WorkerMessenger } from \"./fns/utils/Messenger\";\n\n//TODO: Create a more complete RPC setup in the subtree-eval branch.\nfunction syncRequestMessageListener(\n  e: MessageEvent<TMessage<EvalWorkerSyncRequest>>,\n) {\n  const { messageType } = e.data;\n  if (messageType !== MessageType.REQUEST) return;\n  const startTime = performance.now();\n  const { body, messageId } = e.data;\n  const { method } = body;\n  if (!method) return;\n  const messageHandler = syncHandlerMap[method];\n  if (typeof messageHandler !== \"function\") return;\n  const responseData = messageHandler(body);\n  if (!responseData) return;\n  const endTime = performance.now();\n  WorkerMessenger.respond(messageId, responseData, endTime - startTime);\n}\n\nasync function asyncRequestMessageListener(\n  e: MessageEvent<TMessage<EvalWorkerASyncRequest>>,\n) {\n  const { messageType } = e.data;\n  if (messageType !== MessageType.REQUEST) return;\n  const start = performance.now();\n  const { body, messageId } = e.data;\n  const { method } = body;\n  if (!method) return;\n  const messageHandler = asyncHandlerMap[method];\n  if (typeof messageHandler !== \"function\") return;\n  const data = await messageHandler(body);\n  if (!data) return;\n  const end = performance.now();\n  WorkerMessenger.respond(messageId, data, end - start);\n}\n\nself.addEventListener(\"message\", syncRequestMessageListener);\nself.addEventListener(\"message\", asyncRequestMessageListener);\n","import { uuid4 } from \"@sentry/utils\";\nimport {\n  ENTITY_TYPE,\n  LogObject,\n  Methods,\n  Severity,\n  SourceEntity,\n} from \"entities/AppsmithConsole\";\nimport { klona } from \"klona/lite\";\nimport moment from \"moment\";\nimport { TriggerMeta } from \"@appsmith/sagas/ActionExecution/ActionExecutionSagas\";\nimport TriggerEmitter from \"../utils/TriggerEmitter\";\nimport { EventEmitter } from \"events\";\nimport ExecutionMetaData from \"../utils/ExecutionMetaData\";\n\nclass UserLog {\n  private isEnabled = true;\n  enable() {\n    this.isEnabled = true;\n  }\n  disable() {\n    this.isEnabled = false;\n  }\n  private emitter?: EventEmitter;\n\n  private saveLog(method: Methods, data: any[]) {\n    const parsed = this.parseLogs(method, data);\n    this.emitter?.emit(\"process_logs\", parsed);\n  }\n\n  public overrideConsoleAPI() {\n    this.emitter = TriggerEmitter;\n    const { debug, error, info, log, table, warn } = console;\n    console = {\n      ...console,\n      table: (...args: any) => {\n        if (!this.isEnabled) return;\n        table.call(this, args);\n        this.saveLog(\"table\", args);\n      },\n      error: (...args: any) => {\n        if (!this.isEnabled) return;\n        error.apply(this, args);\n        this.saveLog(\"error\", args);\n      },\n      log: (...args: any) => {\n        if (!this.isEnabled) return;\n        log.apply(this, args);\n        this.saveLog(\"log\", args);\n      },\n      debug: (...args: any) => {\n        if (!this.isEnabled) return;\n        debug.apply(this, args);\n        this.saveLog(\"debug\", args);\n      },\n      warn: (...args: any) => {\n        if (!this.isEnabled) return;\n        warn.apply(this, args);\n        this.saveLog(\"warn\", args);\n      },\n      info: (...args: any) => {\n        if (!this.isEnabled) return;\n        info.apply(this, args);\n        this.saveLog(\"info\", args);\n      },\n    };\n  }\n  private replaceFunctionWithNamesFromObjects(data: any) {\n    if (typeof data === \"function\") return `func() ${data.name}`;\n    if (!data || typeof data !== \"object\") return data;\n    if (data instanceof Promise) return \"Promise\";\n    const acc: any =\n      Object.prototype.toString.call(data) === \"[object Array]\" ? [] : {};\n    return Object.keys(data).reduce((acc, key) => {\n      acc[key] = this.replaceFunctionWithNamesFromObjects(data[key]);\n      return acc;\n    }, acc);\n  }\n  // iterates over the data and if data is object/array, then it will remove any functions from it\n  private sanitizeData(data: any): any {\n    try {\n      const returnData = this.replaceFunctionWithNamesFromObjects(data);\n      return returnData;\n    } catch (e) {\n      return [`There was some error: ${e} ${JSON.stringify(data)}`];\n    }\n  }\n\n  private getSource = (triggerMeta?: TriggerMeta): SourceEntity => {\n    const type = triggerMeta?.source?.entityType || ENTITY_TYPE.JSACTION;\n    const name =\n      triggerMeta?.source?.name || triggerMeta?.triggerPropertyName || \"\";\n    const propertyPath = triggerMeta?.triggerPropertyName || \"\";\n    const id = triggerMeta?.source?.id || \"\";\n    //@ts-expect-error : we are not using the source entity in the console\n    return { type, name, id, propertyPath };\n  };\n\n  // parses the incoming log and converts it to the log object\n  private parseLogs(method: Methods, data: any[]): LogObject {\n    // Create an ID\n    const id = uuid4();\n    const timestamp = moment().format(\"hh:mm:ss\");\n    // Parse the methods\n    let output = data;\n    // For logs UI we only keep 3 levels of severity, info, warn, error\n    let severity = Severity.INFO;\n    if (method === \"error\") {\n      severity = Severity.ERROR;\n      output = data.map((error) => {\n        return error?.stack || error;\n      });\n    } else if (method === \"warn\") {\n      severity = Severity.WARNING;\n    }\n\n    const { triggerMeta } = ExecutionMetaData.getExecutionMetaData();\n    return {\n      method,\n      id,\n      data: this.sanitizeData(klona(output)),\n      timestamp,\n      severity,\n      source: this.getSource(triggerMeta),\n    };\n  }\n}\n\nconst userLogs = new UserLog();\n\nexport default userLogs;\n","import { createEvaluationContext } from \"../../evaluate\";\nimport { dataTreeEvaluator } from \"../../handlers/evalTree\";\nimport ExecutionMetaData from \"../utils/ExecutionMetaData\";\n\nconst _internalSetInterval = self.setInterval;\nconst _internalClearInterval = self.clearInterval;\n\nconst intervalIdMap = new Map<number | string, number>();\n\nexport function clearAllIntervals() {\n  intervalIdMap.forEach((intervalId) => _internalClearInterval(intervalId));\n  intervalIdMap.clear();\n}\n\nexport function clearInterval(intervalId: number | string) {\n  const runningIntervalId = intervalIdMap.get(intervalId);\n  intervalIdMap.delete(intervalId);\n  return _internalClearInterval(runningIntervalId);\n}\n\nexport function setInterval(\n  callback: (...args: any[]) => void,\n  delay = 300,\n  ...args: any[]\n) {\n  const metaData = ExecutionMetaData.getExecutionMetaData();\n  const runningIntervalId = intervalIdMap.get(args[0]);\n  if (runningIntervalId) {\n    _internalClearInterval(runningIntervalId);\n    intervalIdMap.delete(args[0]);\n  }\n  const _internalIntervalId = _internalSetInterval(\n    (...args: any[]) => {\n      const evalContext = createEvaluationContext({\n        dataTree: dataTreeEvaluator?.evalTree || {},\n        resolvedFunctions: dataTreeEvaluator?.resolvedFunctions || {},\n        isTriggerBased: true,\n      });\n      self[\"$isDataField\"] = false;\n      Object.assign(self, evalContext);\n      ExecutionMetaData.setExecutionMetaData(\n        metaData.triggerMeta,\n        metaData.eventType,\n      );\n      typeof callback === \"function\" && callback(...args);\n    },\n    delay,\n    ...args,\n  );\n  const customIntervalId = args[0] || _internalIntervalId;\n  intervalIdMap.set(customIntervalId, _internalIntervalId);\n  return _internalIntervalId;\n}\n","/* eslint-disable no-console */\nimport { WorkerErrorTypes } from \"ce/workers/common/types\";\nimport { uniqueId } from \"lodash\";\nimport { MessageType, sendMessage } from \"utils/MessageUtil\";\ntype TPromiseResponse =\n  | {\n      data: any;\n      error: null;\n    }\n  | {\n      error: { message: string; errorBody: unknown };\n      data: null;\n    };\n\nfunction responseHandler(requestId: string): Promise<TPromiseResponse> {\n  return new Promise((resolve) => {\n    const listener = (event: MessageEvent) => {\n      const { body, messageId, messageType } = event.data;\n      if (messageId === requestId && messageType === MessageType.RESPONSE) {\n        resolve(body.data);\n        self.removeEventListener(\"message\", listener);\n      }\n    };\n    self.addEventListener(\"message\", listener);\n  });\n}\n\nexport class WorkerMessenger {\n  static async request(payload: any) {\n    const messageId = uniqueId(`request-${payload.method}-`);\n    sendMessage.call(self, {\n      messageId,\n      messageType: MessageType.REQUEST,\n      body: payload,\n    });\n    const response = await responseHandler(messageId);\n    return response;\n  }\n\n  static ping(payload: any) {\n    sendMessage.call(self, {\n      messageType: MessageType.DEFAULT,\n      body: payload,\n    });\n  }\n\n  static respond(messageId: string, data: unknown, timeTaken: number) {\n    try {\n      sendMessage.call(self, {\n        messageId,\n        messageType: MessageType.RESPONSE,\n        body: { data, timeTaken },\n      });\n    } catch (e) {\n      console.error(e);\n      sendMessage.call(self, {\n        messageId,\n        messageType: MessageType.RESPONSE,\n        body: {\n          timeTaken: timeTaken.toFixed(2),\n          data: {\n            errors: [\n              {\n                type: WorkerErrorTypes.CLONE_ERROR,\n                message: (e as Error)?.message,\n                context: JSON.stringify(data),\n              },\n            ],\n          },\n        },\n      });\n    }\n  }\n}\n","import { ActionCalledInSyncFieldError } from \"workers/Evaluation/errorModifier\";\n\nexport function addFn(\n  ctx: any,\n  fnName: string,\n  fn: (...args: any[]) => any,\n  fnGuards = [isAsyncGuard],\n) {\n  Object.defineProperty(ctx, fnName, {\n    value: function(...args: any[]) {\n      for (const guard of fnGuards) {\n        fn = guard(fn, fnName);\n      }\n      return fn(...args);\n    },\n    enumerable: false,\n    writable: true,\n    configurable: true,\n  });\n}\n\nexport function isAsyncGuard<P extends ReadonlyArray<unknown>>(\n  fn: (...args: P) => unknown,\n  fnName: string,\n) {\n  return (...args: P) => {\n    if (!self.$isDataField) return fn(...args);\n    self[\"$isAsync\"] = true;\n    throw new ActionCalledInSyncFieldError(fnName);\n  };\n}\n","import {\n  DynamicValues,\n  EvaluatedFormConfig,\n  FormEvalOutput,\n  FormEvaluationState,\n  FormConfigEvalObject,\n  DynamicValuesConfig,\n} from \"reducers/evaluationReducers/formEvaluationReducer\";\nimport { ReduxActionTypes } from \"@appsmith/constants/ReduxActionConstants\";\nimport { ActionConfig } from \"entities/Action\";\nimport { FormEvalActionPayload } from \"sagas/FormEvaluationSaga\";\nimport { FormConfigType } from \"components/formControls/BaseControl\";\nimport { isArray, isEmpty, isString, merge, uniq } from \"lodash\";\nimport { extractEvalConfigFromFormConfig } from \"components/formControls/utils\";\nimport { isDynamicValue } from \"utils/DynamicBindingUtils\";\nimport { isTrueObject } from \"@appsmith/workers/Evaluation/evaluationUtils\";\n\nexport enum ConditionType {\n  HIDE = \"hide\", // When set, the component will be shown until condition is true\n  SHOW = \"show\", // When set, the component will be hidden until condition is true\n  ENABLE = \"enable\", // When set, the component will be enabled until condition is true\n  DISABLE = \"disable\", // When set, the component will be disabled until condition is true\n  FETCH_DYNAMIC_VALUES = \"fetchDynamicValues\", // When set, the component will fetch the values dynamically\n  EVALUATE_FORM_CONFIG = \"evaluateFormConfig\", // When set, the component will evaluate the form config settings\n}\n\nexport enum FormDataPaths {\n  COMMAND = \"actionConfiguration.formData.command.data\",\n  ENTITY_TYPE = \"actionConfiguration.formData.entityType.data\",\n}\n\n// Object to hold the initial eval object\nlet finalEvalObj: FormEvalOutput;\n\n// This variable, holds an array of strings that represent the path for the evalConfigs.\n// This path os used to configure the evalFormConfig objects for various form configs\nlet evalConfigPaths: string[] = [];\n\n// This regex matches the config property string up to countless places.\nexport const MATCH_ACTION_CONFIG_PROPERTY = /\\b(actionConfiguration\\.\\w+.(?:(\\w+.)){1,})\\b/g;\nexport function matchExact(r: RegExp, str: string) {\n  const match = str.match(r);\n  return match || [];\n}\n\n// Recursive function to generate the evaluation state for form config\nconst generateInitialEvalState = (formConfig: FormConfigType) => {\n  const conditionals: Record<string, any> = {};\n  const conditionTypes: Record<string, any> = {};\n  let dependencyPaths: string[] = [];\n\n  // // Any element is only added to the eval state if they have a conditional statement present, if not they are allowed to be rendered\n  // if (\"conditionals\" in formConfig && !!formConfig.conditionals) {\n  let key = \"unknowns\";\n\n  // A unique key is used to refer the object in the eval state, can be propertyName, configProperty or identifier\n  if (\"propertyName\" in formConfig && !!formConfig.propertyName) {\n    key = formConfig.propertyName;\n  } else if (\"configProperty\" in formConfig && !!formConfig.configProperty) {\n    key = formConfig.configProperty;\n  } else if (\"identifier\" in formConfig && !!formConfig.identifier) {\n    key = formConfig.identifier;\n  }\n\n  // Any element is only added to the eval state if they have a conditional statement present, if not they are allowed to be rendered\n  if (\"conditionals\" in formConfig && !!formConfig.conditionals) {\n    const allConditionTypes = Object.keys(formConfig.conditionals);\n    if (\n      allConditionTypes.includes(ConditionType.HIDE) ||\n      allConditionTypes.includes(ConditionType.SHOW)\n    ) {\n      conditionTypes.visible = false;\n      merge(conditionals, formConfig.conditionals);\n\n      const showOrHideDependencies = matchExact(\n        MATCH_ACTION_CONFIG_PROPERTY,\n        formConfig.conditionals?.show || formConfig.conditionals?.hide || \"\",\n      );\n\n      dependencyPaths = [...dependencyPaths, ...showOrHideDependencies];\n    }\n\n    if (\n      allConditionTypes.includes(ConditionType.ENABLE) ||\n      allConditionTypes.includes(ConditionType.DISABLE)\n    ) {\n      conditionTypes.enabled = true;\n      merge(conditionals, formConfig.conditionals);\n\n      const enableOrDisableDependencies = matchExact(\n        MATCH_ACTION_CONFIG_PROPERTY,\n        formConfig.conditionals?.enable ||\n          formConfig.conditionals?.disable ||\n          \"\",\n      );\n\n      dependencyPaths = [...dependencyPaths, ...enableOrDisableDependencies];\n    }\n\n    // if (allConditionTypes.includes(ConditionType.EVALUATE_FORM_CONFIG)) {\n    //   // Setting the component as invisible since it has elements that will be evaluated later\n    //   conditionTypes.visible = false;\n    //   const evaluateFormConfig: EvaluatedFormConfig = {\n    //     updateEvaluatedConfig: false,\n    //     paths: formConfig.conditionals.evaluateFormConfig.paths,\n    //     evaluateFormConfigObject: extractEvalConfigFromFormConfig(\n    //       formConfig,\n    //       formConfig.conditionals.evaluateFormConfig.paths,\n    //     ),\n    //   };\n    //   conditionTypes.evaluateFormConfig = evaluateFormConfig;\n    //   conditionals.evaluateFormConfig =\n    //     formConfig.conditionals.evaluateFormConfig.condition;\n    // }\n\n    if (allConditionTypes.includes(ConditionType.FETCH_DYNAMIC_VALUES)) {\n      const fetchDynamicValuesDependencies = matchExact(\n        MATCH_ACTION_CONFIG_PROPERTY,\n        formConfig.conditionals?.fetchDynamicValues?.condition || \"\",\n      );\n      let dynamicDependencyPathList: Set<string> | undefined;\n\n      if (fetchDynamicValuesDependencies.length > 0) {\n        dynamicDependencyPathList = new Set(fetchDynamicValuesDependencies);\n      } else {\n        dynamicDependencyPathList = undefined;\n      }\n\n      const dynamicValues: DynamicValues = {\n        allowedToFetch: false,\n        isLoading: false,\n        hasStarted: false,\n        hasFetchFailed: false,\n        data: [],\n        config: formConfig.conditionals.fetchDynamicValues.config,\n        dynamicDependencyPathList,\n        evaluatedConfig: { params: {} },\n      };\n      conditionTypes.fetchDynamicValues = dynamicValues;\n      conditionals.fetchDynamicValues =\n        formConfig.conditionals.fetchDynamicValues.condition;\n    }\n\n    // make the evalConfigPaths empty before calling the generateFormEvalFormConfigPaths\n    // this is helpful since we are iterating through the form configs and we do not want to store the value of a\n    // prev form config into another one.\n    evalConfigPaths = [];\n\n    // recursively generate the paths for form cofigs that need evalFormConfig.\n    // and we store them in the evalFormFonfig\n    generateEvalFormConfigPaths(formConfig);\n\n    // we generate a unique array of paths, if the paths are greater than 0,\n    // we generate and add the evaluateFormConfig object to the current formConfig.\n    if (uniq(evalConfigPaths).length > 0) {\n      conditionTypes.visible = false;\n      const evaluateFormConfig: EvaluatedFormConfig = {\n        updateEvaluatedConfig: false,\n        paths: uniq(evalConfigPaths),\n        evaluateFormConfigObject: extractEvalConfigFromFormConfig(\n          formConfig,\n          uniq(evalConfigPaths),\n        ),\n      };\n      conditionTypes.evaluateFormConfig = evaluateFormConfig;\n      conditionals.evaluateFormConfig = \"{{true}}\";\n    }\n  }\n\n  // keep the configProperty in the formConfig values.\n  let configPropertyPath;\n  if (!!formConfig.configProperty) {\n    configPropertyPath = formConfig.configProperty;\n  }\n\n  let staticDependencyPathList: Set<string> | undefined;\n\n  if (dependencyPaths.length > 0) {\n    staticDependencyPathList = new Set(dependencyPaths);\n  } else {\n    staticDependencyPathList = undefined;\n  }\n\n  // Conditionals are stored in the eval state itself for quick access\n  finalEvalObj[key] = {\n    ...conditionTypes,\n    conditionals,\n    configPropertyPath,\n    staticDependencyPathList,\n  };\n\n  if (\"children\" in formConfig && !!formConfig.children)\n    formConfig.children.forEach((config: FormConfigType) =>\n      generateInitialEvalState(config),\n    );\n\n  if (\"schema\" in formConfig && !!formConfig.schema)\n    formConfig.schema.forEach((config: FormConfigType) =>\n      generateInitialEvalState({ ...config }),\n    );\n};\n\n// The idea here is to recursively go through each of the key value pairs of the current form config\n// then we check if the form config or its children/options/schemas have dynamic values\n// if the children/options/schemas have dynamic values within them, we add the key name of the parent to the evalFormConfigPaths\n// this might sound strange but we add the evaluateFormConfig property to the parent.\n// this is why we pass the parent key into the function and use it to update the evalFormConfig.\nfunction generateEvalFormConfigPaths(\n  formConfig: FormConfigType,\n  parentKey = \"\",\n) {\n  // this stores all the paths for the current form config,\n  // we then use this path to update the evalFormConfig array with the parent\n  const paths: string[] = [];\n  // we never check the conditionals object, or the placeholderText.\n  // we also never check children and schema cause the recursive function that this function is called in already checks the children and schemas (to prevent double recursive checks).\n  // the second placeHolderText is due to a rogue value in the formConfig of one of S3 datasource form config.\n  const configToBeChecked = {\n    ...formConfig,\n    conditionals: undefined,\n    children: undefined,\n    schema: undefined,\n    placeholderText: undefined,\n    placeHolderText: undefined,\n  };\n\n  Object.entries(configToBeChecked).forEach(([key, value]) => {\n    // we check if the current value for the key is a dynamic value, if yes, we push the current key into our paths array.\n    if (!!value) {\n      if (isString(value)) {\n        if (isDynamicValue(value)) {\n          paths.push(key);\n          // if parent key is empty, then there is a very good chance it's coming from the root form config.\n          // and in that case we can just set it to it.\n          if (!parentKey) parentKey = key;\n        }\n      }\n\n      // if it's an array, we run it recursively on the array values.\n      if (isArray(value)) {\n        value.forEach((val) => {\n          generateEvalFormConfigPaths(val, key);\n        });\n      }\n\n      // if it is an object, we do the same.\n      if (isTrueObject(value as FormConfigType)) {\n        generateEvalFormConfigPaths(value, key);\n      }\n    }\n  });\n\n  // if the path array is greater than one, we update the evalConfigPaths with parent key.\n  if (paths.length > 0) {\n    evalConfigPaths.push(parentKey);\n  }\n}\n\nfunction evaluateDynamicValuesConfig(\n  actionConfiguration: ActionConfig,\n  config: Record<string, any>,\n) {\n  const evaluatedConfig: Record<string, any> = { ...config };\n  const configArray = Object.entries(config);\n  if (configArray.length > 0) {\n    configArray.forEach(([key, value]) => {\n      if (typeof value === \"object\") {\n        evaluatedConfig[key] = evaluateDynamicValuesConfig(\n          actionConfiguration,\n          value,\n        );\n      } else if (typeof value === \"string\" && value.length > 0) {\n        if (isDynamicValue(value)) {\n          let evaluatedValue = \"\";\n          try {\n            evaluatedValue = eval(value);\n          } catch (e) {\n            evaluatedValue = \"error\";\n          } finally {\n            evaluatedConfig[key] = evaluatedValue;\n          }\n        }\n      }\n    });\n  }\n  return evaluatedConfig;\n}\n\nfunction evaluateFormConfigElements(\n  actionConfiguration: ActionConfig,\n  config: FormConfigEvalObject,\n) {\n  const paths = Object.keys(config);\n  if (paths.length > 0) {\n    paths.forEach((path) => {\n      const { expression } = config[path];\n      try {\n        const evaluatedVal = eval(expression);\n        config[path].output = evaluatedVal;\n      } catch (e) {}\n    });\n  }\n  return config;\n}\n\n// Function to run the eval for the whole form when data changes\nfunction evaluate(\n  actionConfiguration: ActionConfig,\n  currentEvalState: FormEvalOutput,\n  actionDiffPath?: string,\n  hasRouteChanged?: boolean,\n) {\n  Object.keys(currentEvalState).forEach((key: string) => {\n    try {\n      if (currentEvalState[key].hasOwnProperty(\"conditionals\")) {\n        const conditionBlock = currentEvalState[key].conditionals;\n        if (!!conditionBlock) {\n          Object.keys(conditionBlock).forEach((conditionType: string) => {\n            const output = eval(conditionBlock[conditionType]);\n            if (conditionType === ConditionType.HIDE) {\n              currentEvalState[key].visible = !output;\n            } else if (conditionType === ConditionType.SHOW) {\n              currentEvalState[key].visible = output;\n            } else if (conditionType === ConditionType.DISABLE) {\n              currentEvalState[key].enabled = !output;\n            } else if (conditionType === ConditionType.ENABLE) {\n              currentEvalState[key].enabled = output;\n            } else if (\n              conditionType === ConditionType.FETCH_DYNAMIC_VALUES &&\n              currentEvalState[key].hasOwnProperty(\"fetchDynamicValues\") &&\n              !!currentEvalState[key].fetchDynamicValues\n            ) {\n              // this boolean value represents if the current action diff path is a dependency to the form config.\n              let isActionDiffADependency = false;\n\n              // If the key in the currentEval state has dynamicDependencyPathList, we check to see if the path of the changed value\n              // exists in the path list, if it does, we evaluate the dynamicValues and fetch the data via API call,\n              // but if the value does not exist in the path list, we prevent the dynamic value from being refetched via API call.\n              // in other words, if the current actionDiffPath is a dependency, then isActionDiffADependency becomes true.\n              if (\n                currentEvalState[key] &&\n                !!currentEvalState[key]?.fetchDynamicValues\n                  ?.dynamicDependencyPathList &&\n                !isEmpty(\n                  currentEvalState[key]?.fetchDynamicValues\n                    ?.dynamicDependencyPathList,\n                ) &&\n                !!actionDiffPath &&\n                currentEvalState[\n                  key\n                ]?.fetchDynamicValues?.dynamicDependencyPathList?.has(\n                  actionDiffPath,\n                )\n              ) {\n                isActionDiffADependency = true;\n              }\n\n              // if the actionDiffPath is a dependency or if the route has changed (navigated to another action/page) of if there's no actionDiffPath at all (when the page is refreshed)\n              // we want to trigger an API call for the dynamic values.\n              if (\n                isActionDiffADependency ||\n                !actionDiffPath ||\n                hasRouteChanged\n              ) {\n                (currentEvalState[key]\n                  .fetchDynamicValues as DynamicValues).allowedToFetch = output;\n                (currentEvalState[key]\n                  .fetchDynamicValues as DynamicValues).isLoading = output;\n                (currentEvalState[key]\n                  .fetchDynamicValues as DynamicValues).evaluatedConfig = evaluateDynamicValuesConfig(\n                  actionConfiguration,\n                  (currentEvalState[key].fetchDynamicValues as DynamicValues)\n                    .config,\n                ) as DynamicValuesConfig;\n              } else {\n                (currentEvalState[key]\n                  .fetchDynamicValues as DynamicValues).allowedToFetch = false;\n                (currentEvalState[key]\n                  .fetchDynamicValues as DynamicValues).isLoading = false;\n              }\n            } else if (\n              conditionType === ConditionType.EVALUATE_FORM_CONFIG &&\n              currentEvalState[key].hasOwnProperty(\"evaluateFormConfig\") &&\n              !!currentEvalState[key].evaluateFormConfig\n            ) {\n              (currentEvalState[key]\n                .evaluateFormConfig as EvaluatedFormConfig).updateEvaluatedConfig = output;\n              currentEvalState[key].visible = output;\n              if (output && !!currentEvalState[key].evaluateFormConfig)\n                (currentEvalState[key]\n                  .evaluateFormConfig as EvaluatedFormConfig).evaluateFormConfigObject = evaluateFormConfigElements(\n                  actionConfiguration,\n                  (currentEvalState[key]\n                    .evaluateFormConfig as EvaluatedFormConfig)\n                    .evaluateFormConfigObject,\n                );\n            }\n          });\n        }\n      }\n    } catch (e) {}\n  });\n  return currentEvalState;\n}\n\n// Fetches current evaluation and runs a new one based on the new data\nfunction getFormEvaluation(\n  formId: string,\n  actionConfiguration: ActionConfig,\n  currentEvalState: FormEvaluationState,\n  actionDiffPath?: string,\n  hasRouteChanged?: boolean,\n): FormEvaluationState {\n  // Only change the form evaluation state if the form ID is same or the evaluation state is present\n  if (!!currentEvalState && currentEvalState.hasOwnProperty(formId)) {\n    const currentFormIdEvalState = currentEvalState[formId];\n    // specific conditions to be evaluated\n    let conditionToBeEvaluated = {};\n    // dynamic conditions always need evaluations\n    let dynamicConditionsToBeFetched = {};\n    for (const [key, value] of Object.entries(currentFormIdEvalState)) {\n      if (\n        value &&\n        !!value.configPropertyPath &&\n        !!actionDiffPath &&\n        actionDiffPath?.includes(value.configPropertyPath)\n      ) {\n        conditionToBeEvaluated = { ...conditionToBeEvaluated, [key]: value };\n      }\n\n      // static dependency pathlist should be a key of identifiers that point to formControls that are dependent on the result of the current form config value.\n      // it is important to note the difference between staticDependencyPathList and dynamicDependencyPathList is that the former is for formConfigs that don't require API calls.\n      // they are mostly layout based i.e. show/hide, enable/disable\n      if (!!value.staticDependencyPathList && !!actionDiffPath) {\n        value.staticDependencyPathList.forEach(() => {\n          if (value.staticDependencyPathList?.has(actionDiffPath)) {\n            conditionToBeEvaluated = {\n              ...conditionToBeEvaluated,\n              [key]: value,\n            };\n          }\n        });\n      }\n\n      // if there are dynamic values present, add them to the condition to be evaluated.\n      if (value && (!!value.fetchDynamicValues || !!value.evaluateFormConfig)) {\n        dynamicConditionsToBeFetched = {\n          ...dynamicConditionsToBeFetched,\n          [key]: value,\n        };\n      }\n    }\n\n    // if no condition is to be evaluated or if the currently changing action diff path is the command path\n    // then we run evaluations on the whole form.\n    if (\n      isEmpty(conditionToBeEvaluated) ||\n      actionDiffPath === FormDataPaths.COMMAND\n    ) {\n      conditionToBeEvaluated = evaluate(\n        actionConfiguration,\n        currentEvalState[formId],\n        actionDiffPath,\n        hasRouteChanged,\n      );\n    } else {\n      conditionToBeEvaluated = {\n        ...conditionToBeEvaluated,\n        ...dynamicConditionsToBeFetched,\n      };\n      conditionToBeEvaluated = evaluate(\n        actionConfiguration,\n        conditionToBeEvaluated,\n        actionDiffPath,\n        hasRouteChanged,\n      );\n    }\n\n    currentEvalState[formId] = {\n      ...currentEvalState[formId],\n      ...conditionToBeEvaluated,\n    };\n  }\n\n  return currentEvalState;\n}\n\n// Filter function to assign a function to the Action dispatched\nexport function setFormEvaluationSaga(\n  type: string,\n  payload: FormEvalActionPayload,\n  currentEvalState: FormEvaluationState,\n) {\n  if (type === ReduxActionTypes.INIT_FORM_EVALUATION) {\n    finalEvalObj = {};\n\n    // Config is extracted from the editor json first\n    if (\n      \"editorConfig\" in payload &&\n      !!payload.editorConfig &&\n      payload.editorConfig.length > 0\n    ) {\n      payload.editorConfig.forEach((config: FormConfigType) => {\n        generateInitialEvalState(config);\n      });\n    }\n\n    // Then the form config is extracted from the settings json\n    if (\n      \"settingConfig\" in payload &&\n      !!payload.settingConfig &&\n      payload.settingConfig.length > 0\n    ) {\n      payload.settingConfig.forEach((config: FormConfigType) => {\n        generateInitialEvalState(config);\n      });\n    }\n\n    // if the evaluations are empty, then the form is not valid, don't mutate the state\n    if (isEmpty(finalEvalObj)) {\n      return currentEvalState;\n    }\n\n    // This is the initial evaluation state, evaluations can now be run on top of this\n    return { [payload.formId]: finalEvalObj };\n  } else {\n    const {\n      actionConfiguration,\n      actionDiffPath,\n      formId,\n      hasRouteChanged,\n    } = payload;\n    // In case the formData is not ready or the form is not of type UQI, return empty state\n    if (!actionConfiguration || !actionConfiguration.formData) {\n      return currentEvalState;\n    } else {\n      return getFormEvaluation(\n        formId,\n        actionConfiguration,\n        currentEvalState,\n        actionDiffPath,\n        hasRouteChanged,\n      );\n    }\n  }\n}\n","import { Diff } from \"deep-diff\";\nimport { CanvasWidgetsReduxState } from \"reducers/entityReducers/canvasWidgetsReducer\";\nimport ReplayEntity from \"../index\";\nimport { set } from \"lodash\";\nimport {\n  addToArray,\n  FOCUSES,\n  setPropertyUpdate,\n  TOASTS,\n  UPDATES,\n  WIDGETS,\n} from \"../replayUtils\";\nimport { AppTheme } from \"entities/AppTheming\";\nimport { ENTITY_TYPE } from \"entities/AppsmithConsole\";\n\nexport type Canvas = {\n  widgets: CanvasWidgetsReduxState;\n  theme: AppTheme;\n};\nexport type CanvasDiff = Diff<Canvas, Canvas>;\nexport type DSLDiff = Diff<CanvasWidgetsReduxState, CanvasWidgetsReduxState>;\n\nconst positionProps = [\n  \"leftColumn\",\n  \"rightColumn\",\n  \"topRow\",\n  \"bottomRow\",\n  \"minHeight\",\n  \"parentColumnSpace\",\n  \"parentRowSpace\",\n  \"children\",\n  \"parentId\",\n  \"renderMode\",\n  \"detachFromLayout\",\n  \"noContainerOffset\",\n  \"isCanvas\",\n  \"height\",\n];\n\n/**\n * checks property changed is a positional property\n *\n * @param widgetProperty\n * @returns\n */\nfunction isPositionUpdate(widgetProperty: string) {\n  return positionProps.indexOf(widgetProperty) !== -1;\n}\nexport default class ReplayCanvas extends ReplayEntity<Canvas> {\n  public constructor(entity: Canvas) {\n    super(entity, ENTITY_TYPE.WIDGET);\n  }\n\n  /**\n   * process the diff\n   *\n   * @param diff\n   * @param replay\n   * @param isUndo\n   * @returns\n   */\n  public processDiff(diff: CanvasDiff, replay: any, isUndo: boolean) {\n    if (!diff || !diff.path || !diff.path.length || diff.path[1] === \"0\")\n      return;\n\n    if (diff.path.indexOf(\"widgets\") > -1) {\n      return this.processDiffForWidgets(diff, replay, isUndo);\n    }\n\n    if (diff.path.indexOf(\"theme\") > -1) {\n      return this.processDiffForTheme(diff, replay);\n    }\n  }\n\n  /**\n   * process diff related to app theming\n   *\n   * @param diff\n   * @param replay\n   * @param isUndo\n   */\n  public processDiffForTheme(diff: CanvasDiff, replay: any) {\n    if (!diff || !diff.path || !diff.path.length || diff.path[1] === \"0\")\n      return;\n\n    set(replay, \"theme\", true);\n\n    if (diff.path.join(\".\") === \"theme.name\") {\n      set(replay, \"themeChanged\", true);\n    }\n  }\n\n  /**\n   * process diffs related to DSL ( widgets )\n   *\n   * @param diff\n   * @param replay\n   * @param isUndo\n   * @returns\n   */\n  public processDiffForWidgets(diff: CanvasDiff, replay: any, isUndo: boolean) {\n    if (!diff || !diff.path || !diff.path.length || diff.path[1] === \"0\")\n      return;\n\n    const widgetId = diff.path[1];\n\n    switch (diff.kind) {\n      // new elements is added in dsl\n      case \"N\":\n        if (diff.path.length == 2) {\n          const toast = this.createToast(\n            diff.rhs,\n            this.entity.widgets[widgetId],\n            widgetId,\n            isUndo,\n            !isUndo,\n          );\n          addToArray(replay, TOASTS, toast);\n        } else {\n          setPropertyUpdate(replay, [WIDGETS, widgetId, UPDATES], diff.path);\n        }\n        break;\n      // element is deleted in dsl\n      case \"D\":\n        if (diff.path.length == 2) {\n          const toast = this.createToast(\n            diff.lhs,\n            this.entity.widgets[widgetId],\n            widgetId,\n            isUndo,\n            isUndo,\n          );\n          addToArray(replay, TOASTS, toast);\n        } else {\n          setPropertyUpdate(replay, [WIDGETS, widgetId, UPDATES], diff.path);\n        }\n        break;\n      // element is edited\n      case \"E\":\n        if (isPositionUpdate(diff.path[diff.path.length - 2])) {\n          set(replay, [WIDGETS, widgetId, FOCUSES], true);\n        } else {\n          setPropertyUpdate(replay, [WIDGETS, widgetId, UPDATES], diff.path);\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  private createToast(\n    diffWidget: any,\n    dslWidget: CanvasWidgetsReduxState | undefined,\n    widgetId: string,\n    isUndo: boolean,\n    isCreated: boolean,\n  ) {\n    const widgetName = isCreated\n      ? diffWidget.widgetName\n      : dslWidget?.widgetName;\n    return {\n      isCreated,\n      isUndo,\n      widgetName,\n      widgetId,\n    };\n  }\n}\n","import { getType, Types } from \"utils/TypeHelpers\";\nimport _ from \"lodash\";\nimport { EvaluationSubstitutionType } from \"entities/DataTree/dataTreeFactory\";\nimport { isDynamicValue } from \"utils/DynamicBindingUtils\";\nimport { QUOTED_BINDING_REGEX } from \"constants/BindingsConstants\";\n\nconst filterBindingSegmentsAndRemoveQuotes = (\n  binding: string,\n  subSegments: string[],\n  subSegmentValues: unknown[],\n) => {\n  const bindingStrippedQuotes = binding.replace(\n    QUOTED_BINDING_REGEX,\n    (original, firstGroup) => {\n      return firstGroup;\n    },\n  );\n  const subBindings: string[] = [];\n  const subValues: unknown[] = [];\n  subSegments.forEach((segment, i) => {\n    if (isDynamicValue(segment)) {\n      subBindings.push(segment);\n      subValues.push(subSegmentValues[i]);\n    }\n  });\n  return { binding: bindingStrippedQuotes, subBindings, subValues };\n};\n\nexport const smartSubstituteDynamicValues = (\n  originalBinding: string,\n  subSegments: string[],\n  subSegmentValues: unknown[],\n): string => {\n  const {\n    binding,\n    subBindings,\n    subValues,\n  } = filterBindingSegmentsAndRemoveQuotes(\n    originalBinding,\n    subSegments,\n    subSegmentValues,\n  );\n  let finalBinding = binding;\n  subBindings.forEach((b, i) => {\n    const value = subValues[i];\n    switch (getType(value)) {\n      case Types.NUMBER:\n      case Types.BOOLEAN:\n      case Types.NULL:\n      case Types.UNDEFINED:\n        // Direct substitution\n        finalBinding = finalBinding.replace(b, `${value}`);\n        break;\n      case Types.STRING:\n        // Add quotes to a string\n        // JSON.stringify string to escape any unsupported characters\n        finalBinding = finalBinding.replace(b, `${JSON.stringify(value)}`);\n        break;\n      case Types.ARRAY:\n      case Types.OBJECT:\n        // Stringify and substitute\n        finalBinding = finalBinding.replace(b, JSON.stringify(value, null, 2));\n        break;\n    }\n  });\n  return finalBinding;\n};\n\nexport const parameterSubstituteDynamicValues = (\n  originalBinding: string,\n  subSegments: string[],\n  subSegmentValues: unknown[],\n) => {\n  const {\n    binding,\n    subBindings,\n    subValues,\n  } = filterBindingSegmentsAndRemoveQuotes(\n    originalBinding,\n    subSegments,\n    subSegmentValues,\n  );\n  // if only one binding is provided in the whole string, we need to throw an error\n  if (subSegments.length === 1 && subBindings.length === 1) {\n    throw Error(\n      \"Dynamic bindings in prepared statements are only used to provide parameters inside SQL query. No SQL query found.\",\n    );\n  }\n\n  let finalBinding = binding;\n  const parameters: Record<string, unknown> = {};\n  subBindings.forEach((b, i) => {\n    // Replace binding with $1, $2;\n    const key = `$${i + 1}`;\n    finalBinding = finalBinding.replace(b, key);\n    parameters[key] =\n      typeof subValues[i] === \"object\"\n        ? JSON.stringify(subValues[i], null, 2)\n        : subValues[i];\n  });\n  return { value: finalBinding, parameters };\n};\n// For creating a final value where bindings could be in a template format\nexport const templateSubstituteDynamicValues = (\n  binding: string,\n  subBindings: string[],\n  subValues: unknown[],\n): string => {\n  // Replace the string with the data tree values\n  let finalValue = binding;\n  subBindings.forEach((b, i) => {\n    let value = subValues[i];\n    if (Array.isArray(value) || _.isObject(value)) {\n      value = JSON.stringify(value);\n    }\n    try {\n      if (typeof value === \"string\" && JSON.parse(value)) {\n        value = value.replace(/\\\\([\\s\\S])|(\")/g, \"\\\\$1$2\");\n      }\n    } catch (e) {\n      // do nothing\n    }\n    finalValue = finalValue.replace(b, `${value}`);\n  });\n  return finalValue;\n};\n\nexport const substituteDynamicBindingWithValues = (\n  binding: string,\n  subSegments: string[],\n  subSegmentValues: unknown[],\n  evaluationSubstitutionType: EvaluationSubstitutionType,\n): string | { value: string; parameters: Record<string, unknown> } => {\n  switch (evaluationSubstitutionType) {\n    case EvaluationSubstitutionType.TEMPLATE:\n      return templateSubstituteDynamicValues(\n        binding,\n        subSegments,\n        subSegmentValues,\n      );\n    case EvaluationSubstitutionType.SMART_SUBSTITUTE:\n      return smartSubstituteDynamicValues(\n        binding,\n        subSegments,\n        subSegmentValues,\n      );\n    case EvaluationSubstitutionType.PARAMETER:\n      return parameterSubstituteDynamicValues(\n        binding,\n        subSegments,\n        subSegmentValues,\n      );\n  }\n};\n","import { find, get, isEmpty, union } from \"lodash\";\nimport toPath from \"lodash/toPath\";\nimport {\n  EvalErrorTypes,\n  EvalError,\n  DependencyMap,\n  getDynamicBindings,\n  getEntityDynamicBindingPathList,\n} from \"utils/DynamicBindingUtils\";\nimport { extractIdentifierInfoFromCode } from \"@shared/ast\";\nimport {\n  addWidgetPropertyDependencies,\n  convertPathToString,\n  getEntityNameAndPropertyPath,\n  isAction,\n  isJSAction,\n  isWidget,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport {\n  DataTreeAction,\n  DataTreeEntity,\n  DataTreeJSAction,\n  DataTreeWidget,\n} from \"entities/DataTree/dataTreeFactory\";\nimport {\n  DEDICATED_WORKER_GLOBAL_SCOPE_IDENTIFIERS,\n  JAVASCRIPT_KEYWORDS,\n} from \"constants/WidgetValidation\";\nimport { APPSMITH_GLOBAL_FUNCTIONS } from \"components/editorComponents/ActionCreator/constants\";\nimport { libraryReservedIdentifiers } from \"workers/common/JSLibrary\";\n\n/** This function extracts validReferences and invalidReferences from a binding {{}}\n * @param script\n * @param allPaths\n * @returns validReferences - Valid references from bindings\n * invalidReferences- References which are currently invalid\n * @example - For binding {{unknownEntity.name + Api1.name}}, it returns\n * {\n * validReferences:[Api1.name],\n * invalidReferences: [unknownEntity.name]\n * }\n */\nexport const extractInfoFromBinding = (\n  script: string,\n  allPaths: Record<string, true>,\n): { validReferences: string[]; invalidReferences: string[] } => {\n  const { references } = extractIdentifierInfoFromCode(\n    script,\n    self.evaluationVersion,\n    { ...invalidEntityIdentifiers, ...libraryReservedIdentifiers },\n  );\n  return extractInfoFromReferences(references, allPaths);\n};\n\n/** This function extracts validReferences and invalidReferences from an Array of Identifiers\n * @param references\n * @param allPaths\n * @returns validReferences - Valid references from bindings\n * invalidReferences- References which are currently invalid\n *  @example - For identifiers [unknownEntity.name , Api1.name], it returns\n * {\n * validReferences:[Api1.name],\n * invalidReferences: [unknownEntity.name]\n * }\n */\nexport const extractInfoFromReferences = (\n  references: string[],\n  allPaths: Record<string, true>,\n): {\n  validReferences: string[];\n  invalidReferences: string[];\n} => {\n  const validReferences: Set<string> = new Set<string>();\n  const invalidReferences: string[] = [];\n  references.forEach((reference: string) => {\n    // If the identifier exists directly, add it and return\n    if (allPaths.hasOwnProperty(reference)) {\n      validReferences.add(reference);\n      return;\n    }\n    const subpaths = toPath(reference);\n    let current = \"\";\n    // We want to keep going till we reach top level, but not add top level\n    // Eg: Input1.text should not depend on entire Table1 unless it explicitly asked for that.\n    // This is mainly to avoid a lot of unnecessary evals, if we feel this is wrong\n    // we can remove the length requirement, and it will still work\n    while (subpaths.length > 1) {\n      current = convertPathToString(subpaths);\n      // We've found the dep, add it and return\n      if (allPaths.hasOwnProperty(current)) {\n        validReferences.add(current);\n        return;\n      }\n      subpaths.pop();\n    }\n    // If no valid reference is derived, add it to the list of invalidReferences\n    invalidReferences.push(reference);\n  });\n  return { validReferences: Array.from(validReferences), invalidReferences };\n};\n\ninterface BindingsInfo {\n  validReferences: string[];\n  invalidReferences: string[];\n  errors: EvalError[];\n}\nexport const extractInfoFromBindings = (\n  bindings: string[],\n  allPaths: Record<string, true>,\n) => {\n  return bindings.reduce(\n    (bindingsInfo: BindingsInfo, binding) => {\n      try {\n        const { invalidReferences, validReferences } = extractInfoFromBinding(\n          binding,\n          allPaths,\n        );\n        return {\n          ...bindingsInfo,\n          validReferences: union(bindingsInfo.validReferences, validReferences),\n          invalidReferences: union(\n            bindingsInfo.invalidReferences,\n            invalidReferences,\n          ),\n        };\n      } catch (error) {\n        const newEvalError: EvalError = {\n          type: EvalErrorTypes.EXTRACT_DEPENDENCY_ERROR,\n          message: (error as Error).message,\n          context: {\n            script: binding,\n          },\n        };\n        return {\n          ...bindingsInfo,\n          errors: union(bindingsInfo.errors, [newEvalError]),\n        };\n      }\n    },\n    { validReferences: [], invalidReferences: [], errors: [] },\n  );\n};\n\nexport function listTriggerFieldDependencies(\n  entity: DataTreeWidget,\n  entityName: string,\n): DependencyMap {\n  const triggerFieldDependency: DependencyMap = {};\n  if (isWidget(entity)) {\n    const dynamicTriggerPathlist = entity.dynamicTriggerPathList;\n    if (dynamicTriggerPathlist && dynamicTriggerPathlist.length) {\n      dynamicTriggerPathlist.forEach((dynamicPath) => {\n        const propertyPath = dynamicPath.key;\n        const unevalPropValue = get(entity, propertyPath);\n        const { jsSnippets } = getDynamicBindings(unevalPropValue);\n        const existingDeps =\n          triggerFieldDependency[`${entityName}.${propertyPath}`] || [];\n        triggerFieldDependency[\n          `${entityName}.${propertyPath}`\n        ] = existingDeps.concat(jsSnippets.filter((jsSnippet) => !!jsSnippet));\n      });\n    }\n  }\n  return triggerFieldDependency;\n}\n\nexport function listValidationDependencies(\n  entity: DataTreeWidget,\n  entityName: string,\n): DependencyMap {\n  const validationDependency: DependencyMap = {};\n  if (isWidget(entity)) {\n    const { validationPaths } = entity;\n\n    Object.entries(validationPaths).forEach(\n      ([propertyPath, validationConfig]) => {\n        if (validationConfig.dependentPaths) {\n          const dependencyArray = validationConfig.dependentPaths.map(\n            (path) => `${entityName}.${path}`,\n          );\n          validationDependency[\n            `${entityName}.${propertyPath}`\n          ] = dependencyArray;\n        }\n      },\n    );\n  }\n  return validationDependency;\n}\n\n/**This function returns a unique array containing a merge of both arrays\n * @param currentArr\n * @param updateArr\n * @returns A unique array containing a merge of both arrays\n */\nexport const mergeArrays = <T>(currentArr: T[], updateArr: T[]): T[] => {\n  if (!currentArr) return updateArr;\n  return union(currentArr, updateArr);\n};\n\n/**\n * Identifiers which can not be valid names of entities and are not dynamic in nature.\n * therefore should be removed from the list of references extracted from code.\n * NB: DATA_TREE_KEYWORDS in app/client/src/constants/WidgetValidation.ts isn't included, although they are not valid entity names,\n * they can refer to potentially dynamic entities.\n * Eg. \"appsmith\"\n */\nconst invalidEntityIdentifiers: Record<string, unknown> = {\n  ...JAVASCRIPT_KEYWORDS,\n  ...APPSMITH_GLOBAL_FUNCTIONS,\n  ...DEDICATED_WORKER_GLOBAL_SCOPE_IDENTIFIERS,\n};\n\nexport function listEntityDependencies(\n  entity: DataTreeWidget | DataTreeAction | DataTreeJSAction,\n  entityName: string,\n  allPaths: Record<string, true>,\n): DependencyMap {\n  let dependencies: DependencyMap = {};\n\n  if (isWidget(entity)) {\n    // Adding the dynamic triggers in the dependency list as they need linting whenever updated\n    // we don't make it dependent on anything else\n    if (entity.dynamicTriggerPathList) {\n      Object.values(entity.dynamicTriggerPathList).forEach(({ key }) => {\n        dependencies[`${entityName}.${key}`] = [];\n      });\n    }\n    const widgetDependencies = addWidgetPropertyDependencies({\n      entity,\n      entityName,\n    });\n\n    dependencies = {\n      ...dependencies,\n      ...widgetDependencies,\n    };\n  }\n\n  if (isAction(entity) || isJSAction(entity)) {\n    Object.entries(entity.dependencyMap).forEach(\n      ([path, entityDependencies]) => {\n        const actionDependentPaths: Array<string> = [];\n        const mainPath = `${entityName}.${path}`;\n        // Only add dependencies for paths which exist at the moment in appsmith world\n        if (allPaths.hasOwnProperty(mainPath)) {\n          // Only add dependent paths which exist in the data tree. Skip all the other paths to avoid creating\n          // a cyclical dependency.\n          entityDependencies.forEach((dependentPath) => {\n            const completePath = `${entityName}.${dependentPath}`;\n            if (allPaths.hasOwnProperty(completePath)) {\n              actionDependentPaths.push(completePath);\n            }\n          });\n          dependencies[mainPath] = actionDependentPaths;\n        }\n      },\n    );\n  }\n  if (isJSAction(entity)) {\n    // making functions dependent on their function body entities\n    if (entity.reactivePaths) {\n      Object.keys(entity.reactivePaths).forEach((propertyPath) => {\n        const existingDeps =\n          dependencies[`${entityName}.${propertyPath}`] || [];\n        const unevalPropValue = get(entity, propertyPath);\n        const unevalPropValueString =\n          !!unevalPropValue && unevalPropValue.toString();\n        const { jsSnippets } = getDynamicBindings(\n          unevalPropValueString,\n          entity,\n        );\n        dependencies[`${entityName}.${propertyPath}`] = existingDeps.concat(\n          jsSnippets.filter((jsSnippet) => !!jsSnippet),\n        );\n      });\n    }\n  }\n\n  if (isAction(entity) || isWidget(entity)) {\n    // add the dynamic binding paths to the dependency map\n    const dynamicBindingPathList = getEntityDynamicBindingPathList(entity);\n    if (dynamicBindingPathList.length) {\n      dynamicBindingPathList.forEach((dynamicPath) => {\n        const propertyPath = dynamicPath.key;\n        const unevalPropValue = get(entity, propertyPath);\n        const { jsSnippets } = getDynamicBindings(unevalPropValue);\n        const existingDeps =\n          dependencies[`${entityName}.${propertyPath}`] || [];\n        dependencies[`${entityName}.${propertyPath}`] = existingDeps.concat(\n          jsSnippets.filter((jsSnippet) => !!jsSnippet),\n        );\n      });\n    }\n  }\n  return dependencies;\n}\n\nexport function listEntityPathDependencies(\n  entity: DataTreeWidget | DataTreeAction | DataTreeJSAction,\n  fullPropertyPath: string,\n): {\n  isTrigger: boolean;\n  dependencies: string[];\n} {\n  let dependencies: string[] = [];\n  const isTrigger = false;\n  const { propertyPath } = getEntityNameAndPropertyPath(fullPropertyPath);\n  if (isWidget(entity)) {\n    if (isATriggerPath(entity, propertyPath)) {\n      return {\n        isTrigger: true,\n        dependencies: listEntityPathTriggerFieldDependencies(\n          entity,\n          fullPropertyPath,\n        ),\n      };\n    }\n  }\n\n  if (isJSAction(entity)) {\n    if (entity.bindingPaths.hasOwnProperty(propertyPath)) {\n      const unevalPropValue = get(entity, propertyPath);\n      const unevalPropValueString =\n        !!unevalPropValue && unevalPropValue.toString();\n      const { jsSnippets } = getDynamicBindings(unevalPropValueString, entity);\n      dependencies = dependencies.concat(\n        jsSnippets.filter((jsSnippet) => !!jsSnippet),\n      );\n    }\n  }\n\n  if (isAction(entity) || isWidget(entity)) {\n    if (\n      entity.bindingPaths.hasOwnProperty(propertyPath) ||\n      find(entity.dynamicBindingPathList, { key: propertyPath })\n    ) {\n      const unevalPropValue = get(entity, propertyPath);\n      const { jsSnippets } = getDynamicBindings(unevalPropValue);\n      dependencies = dependencies.concat(\n        jsSnippets.filter((jsSnippet) => !!jsSnippet),\n      );\n    }\n  }\n  return { isTrigger, dependencies };\n}\n\nexport function listEntityPathTriggerFieldDependencies(\n  entity: DataTreeWidget,\n  fullPath: string,\n) {\n  let triggerFieldDependencies: string[] = [];\n  const { propertyPath } = getEntityNameAndPropertyPath(fullPath);\n\n  if (isADynamicTriggerPath(entity, propertyPath)) {\n    const unevalPropValue = get(entity, propertyPath);\n    const { jsSnippets } = getDynamicBindings(unevalPropValue);\n    triggerFieldDependencies = jsSnippets.filter((jsSnippet) => !!jsSnippet);\n  }\n\n  return triggerFieldDependencies;\n}\n\nexport function isADynamicTriggerPath(\n  entity: DataTreeEntity,\n  propertyPath: string,\n) {\n  if (isWidget(entity)) {\n    const dynamicTriggerPathlist = entity.dynamicTriggerPathList;\n    const isTriggerPath = find(dynamicTriggerPathlist, { key: propertyPath });\n    if (isTriggerPath) {\n      return true;\n    }\n    return false;\n  }\n}\n\nfunction isATriggerPath(entity: DataTreeEntity, propertyPath: string) {\n  if (isWidget(entity)) {\n    const triggerPaths = entity.triggerPaths;\n    return triggerPaths.hasOwnProperty(propertyPath);\n  }\n  return false;\n}\n\nexport function updateMap(\n  map: DependencyMap,\n  path: string,\n  updates: string[],\n  options: Partial<{ deleteOnEmpty: boolean; replaceValue: boolean }> = {},\n) {\n  const { deleteOnEmpty, replaceValue } = options;\n  const oldValue = replaceValue ? [] : map[path];\n  const updatedEntries = mergeArrays(oldValue, updates);\n  if (deleteOnEmpty && isEmpty(updatedEntries)) {\n    delete map[path];\n  } else {\n    map[path] = updatedEntries;\n  }\n}\n","import {\n  DataTreeDiff,\n  getAllPaths,\n  DataTreeDiffEvent,\n  isWidget,\n  isAction,\n  isJSAction,\n  makeParentsDependOnChildren,\n  isValidEntity,\n  getEntityNameAndPropertyPath,\n  isDynamicLeaf,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport {\n  DataTree,\n  DataTreeAction,\n  DataTreeWidget,\n  DataTreeJSAction,\n} from \"entities/DataTree/dataTreeFactory\";\nimport {\n  DependencyMap,\n  isChildPropertyPath,\n  getPropertyPath,\n  isPathADynamicBinding,\n  getDynamicBindings,\n  isPathDynamicTrigger,\n  getEvalErrorPath,\n} from \"utils/DynamicBindingUtils\";\nimport {\n  extractInfoFromBindings,\n  extractInfoFromReferences,\n  isADynamicTriggerPath,\n  listEntityDependencies,\n  listEntityPathDependencies,\n  listTriggerFieldDependencies,\n  listValidationDependencies,\n  updateMap,\n} from \"./utils\";\nimport DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport { difference, isEmpty, set } from \"lodash\";\n\ninterface CreateDependencyMap {\n  dependencyMap: DependencyMap;\n  triggerFieldDependencyMap: DependencyMap;\n  /** Keeps track of all invalid references present in bindings throughout the page.\n   *  We keep this list so that we don't have to traverse the entire dataTree when\n   *  a new entity or path is added to the datatree in order to determine if an old invalid reference has become valid\n   *  because an entity or path is newly added.\n   * */\n  invalidReferencesMap: DependencyMap;\n  validationDependencyMap: DependencyMap;\n}\n\nexport function createDependencyMap(\n  dataTreeEvalRef: DataTreeEvaluator,\n  unEvalTree: DataTree,\n): CreateDependencyMap {\n  let dependencyMap: DependencyMap = {};\n  let triggerFieldDependencyMap: DependencyMap = {};\n  let validationDependencyMap: DependencyMap = {};\n  const invalidReferencesMap: DependencyMap = {};\n  Object.keys(unEvalTree).forEach((entityName) => {\n    const entity = unEvalTree[entityName];\n    if (isAction(entity) || isWidget(entity) || isJSAction(entity)) {\n      const entityListedDependencies = listEntityDependencies(\n        entity,\n        entityName,\n        dataTreeEvalRef.allKeys,\n      );\n      dependencyMap = { ...dependencyMap, ...entityListedDependencies };\n    }\n    if (isWidget(entity)) {\n      // only widgets have trigger paths\n      triggerFieldDependencyMap = {\n        ...triggerFieldDependencyMap,\n        ...listTriggerFieldDependencies(entity, entityName),\n      };\n      // only widgets have validation paths\n      validationDependencyMap = {\n        ...validationDependencyMap,\n        ...listValidationDependencies(entity, entityName),\n      };\n    }\n  });\n\n  Object.keys(dependencyMap).forEach((key) => {\n    const {\n      errors,\n      invalidReferences,\n      validReferences,\n    } = extractInfoFromBindings(dependencyMap[key], dataTreeEvalRef.allKeys);\n    dependencyMap[key] = validReferences;\n    // To keep invalidReferencesMap as minimal as possible, only paths with invalid references\n    // are stored.\n    if (invalidReferences.length) {\n      invalidReferencesMap[key] = invalidReferences;\n    }\n    errors.forEach((error) => {\n      dataTreeEvalRef.errors.push(error);\n    });\n  });\n\n  // extract references from bindings in trigger fields\n  Object.keys(triggerFieldDependencyMap).forEach((key) => {\n    const {\n      errors,\n      invalidReferences,\n      validReferences,\n    } = extractInfoFromBindings(\n      triggerFieldDependencyMap[key],\n      dataTreeEvalRef.allKeys,\n    );\n    triggerFieldDependencyMap[key] = validReferences;\n    // To keep invalidReferencesMap as minimal as possible, only paths with invalid references\n    // are stored.\n    if (invalidReferences.length) {\n      invalidReferencesMap[key] = invalidReferences;\n    }\n    errors.forEach((error) => {\n      dataTreeEvalRef.errors.push(error);\n    });\n  });\n\n  dependencyMap = makeParentsDependOnChildren(\n    dependencyMap,\n    dataTreeEvalRef.allKeys,\n  );\n\n  return {\n    dependencyMap,\n    triggerFieldDependencyMap,\n    invalidReferencesMap,\n    validationDependencyMap,\n  };\n}\n\ninterface UpdateDependencyMap {\n  dependenciesOfRemovedPaths: string[];\n  pathsToClearErrorsFor: any[];\n  removedPaths: string[];\n  /** Some paths do not need to go through evaluation, but require linting\n   *  For example:\n   *  1. For changes in paths that trigger fields depend on, the triggerFields need to be \"linted\" but not evaluated.\n   *  2. Paths containing invalid references - Eg. for binding {{Api1.unknown}} in button.text, although Api1.unknown\n   *     is not a valid reference, when Api1 is deleted button.text needs to be linted\n   */\n  extraPathsToLint: string[];\n}\nexport const updateDependencyMap = ({\n  dataTreeEvalRef,\n  translatedDiffs,\n  unEvalDataTree,\n}: {\n  dataTreeEvalRef: DataTreeEvaluator;\n  translatedDiffs: Array<DataTreeDiff>;\n  unEvalDataTree: DataTree;\n}): UpdateDependencyMap => {\n  const diffCalcStart = performance.now();\n  let didUpdateDependencyMap = false;\n  let didUpdateValidationDependencyMap = false;\n  const dependenciesOfRemovedPaths: Array<string> = [];\n  const removedPaths: Array<string> = [];\n  const extraPathsToLint = new Set<string>();\n  const pathsToClearErrorsFor: any[] = [];\n  const {\n    dependencyMap,\n    invalidReferencesMap,\n    oldUnEvalTree,\n    triggerFieldDependencyMap,\n  } = dataTreeEvalRef;\n\n  let { allKeys, errors: dataTreeEvalErrors } = dataTreeEvalRef;\n\n  // This is needed for NEW and DELETE events below.\n  // In worst case, it tends to take ~12.5% of entire diffCalc (8 ms out of 67ms for 132 array of NEW)\n  // TODO: Optimise by only getting paths of changed node\n  allKeys = getAllPaths(unEvalDataTree);\n  // Transform the diff library events to Appsmith evaluator events\n\n  translatedDiffs.forEach((dataTreeDiff) => {\n    const {\n      event,\n      payload: { propertyPath: fullPropertyPath, value },\n    } = dataTreeDiff;\n    const { entityName } = getEntityNameAndPropertyPath(fullPropertyPath);\n    const entity =\n      event === DataTreeDiffEvent.DELETE\n        ? oldUnEvalTree[entityName]\n        : unEvalDataTree[entityName];\n    const entityType = isValidEntity(entity) ? entity.ENTITY_TYPE : \"noop\";\n\n    if (entityType !== \"noop\") {\n      switch (event) {\n        case DataTreeDiffEvent.NEW: {\n          if (isWidget(entity) || isAction(entity) || isJSAction(entity)) {\n            if (!isDynamicLeaf(unEvalDataTree, fullPropertyPath)) {\n              const entityDependencyMap: DependencyMap = listEntityDependencies(\n                entity,\n                entityName,\n                allKeys,\n              );\n              if (!isEmpty(entityDependencyMap)) {\n                didUpdateDependencyMap = true;\n                // The entity might already have some dependencies,\n                // so we just want to update those\n                Object.entries(entityDependencyMap).forEach(\n                  ([entityDependent, entityDependencies]) => {\n                    const {\n                      errors: extractDependencyErrors,\n                      invalidReferences,\n                      validReferences,\n                    } = extractInfoFromBindings(entityDependencies, allKeys);\n                    // Update dependencyMap\n                    updateMap(dependencyMap, entityDependent, validReferences);\n                    // Update invalidReferencesMap\n                    updateMap(\n                      invalidReferencesMap,\n                      entityDependent,\n                      invalidReferences,\n                      { deleteOnEmpty: true, replaceValue: true },\n                    );\n                    dataTreeEvalErrors = dataTreeEvalErrors.concat(\n                      extractDependencyErrors,\n                    );\n                  },\n                );\n              }\n              if (isWidget(entity)) {\n                // For widgets,\n                // we need to update the triggerField dependencyMap and validation dependencyMap\n                const triggerFieldDependencies = listTriggerFieldDependencies(\n                  entity,\n                  entityName,\n                );\n                Object.entries(triggerFieldDependencies).forEach(\n                  ([triggerFieldDependent, triggerFieldDependencies]) => {\n                    const {\n                      errors: extractDependencyErrors,\n                      invalidReferences,\n                      validReferences,\n                    } = extractInfoFromBindings(\n                      triggerFieldDependencies,\n                      allKeys,\n                    );\n                    // Update triggerfield dependencyMap\n                    updateMap(\n                      triggerFieldDependencyMap,\n                      triggerFieldDependent,\n                      validReferences,\n                    );\n                    // Update invalidReferencesMap\n                    updateMap(\n                      invalidReferencesMap,\n                      triggerFieldDependent,\n                      invalidReferences,\n                      { deleteOnEmpty: true, replaceValue: true },\n                    );\n                    // update errors\n                    dataTreeEvalErrors = dataTreeEvalErrors.concat(\n                      extractDependencyErrors,\n                    );\n                  },\n                );\n                // update validation dependencies\n                dataTreeEvalRef.validationDependencyMap = {\n                  ...dataTreeEvalRef.validationDependencyMap,\n                  ...listValidationDependencies(entity, entityName),\n                };\n                didUpdateValidationDependencyMap = true;\n              }\n            } else {\n              didUpdateDependencyMap = true;\n              const {\n                dependencies: entityPathDependencies,\n                isTrigger,\n              } = listEntityPathDependencies(entity, fullPropertyPath);\n              if (isTrigger) {\n                // Trigger fields shouldn't depend on anything, in the dependencyMap\n                dependencyMap[fullPropertyPath] = [];\n                const {\n                  errors: extractDependencyErrors,\n                  invalidReferences,\n                  validReferences,\n                } = extractInfoFromBindings(entityPathDependencies, allKeys);\n                // Update trigger dependencyMap\n                updateMap(\n                  triggerFieldDependencyMap,\n                  fullPropertyPath,\n                  validReferences,\n                );\n                // Update invalidReferencesMap\n                updateMap(\n                  invalidReferencesMap,\n                  fullPropertyPath,\n                  invalidReferences,\n                  { replaceValue: true, deleteOnEmpty: true },\n                );\n                // update errors\n                dataTreeEvalErrors = dataTreeEvalErrors.concat(\n                  extractDependencyErrors,\n                );\n              } else {\n                didUpdateDependencyMap = true;\n                const {\n                  errors: extractDependencyErrors,\n                  invalidReferences,\n                  validReferences,\n                } = extractInfoFromBindings(entityPathDependencies, allKeys);\n                // Update dependencyMap\n                updateMap(dependencyMap, fullPropertyPath, validReferences);\n\n                // Update invalidReferencesMap\n                updateMap(\n                  invalidReferencesMap,\n                  fullPropertyPath,\n                  invalidReferences,\n                  { replaceValue: true, deleteOnEmpty: true },\n                );\n                dataTreeEvalErrors = dataTreeEvalErrors.concat(\n                  extractDependencyErrors,\n                );\n              }\n              if (isWidget(entity)) {\n                // update validation dependencies\n                dataTreeEvalRef.validationDependencyMap = {\n                  ...dataTreeEvalRef.validationDependencyMap,\n                  ...listValidationDependencies(entity, entityName),\n                };\n                didUpdateValidationDependencyMap = true;\n              }\n            }\n          }\n          // Either a new entity or a new property path has been added. Go through the list of invalid references and\n          // find out if a new dependency has to be created because the property path used in the binding just became\n          // eligible (a previously invalid reference has become valid because a new entity/path got added).\n\n          const newlyValidReferencesMap: DependencyMap = {};\n          Object.keys(invalidReferencesMap).forEach((path) => {\n            invalidReferencesMap[path].forEach((invalidReference) => {\n              if (isChildPropertyPath(fullPropertyPath, invalidReference)) {\n                updateMap(newlyValidReferencesMap, invalidReference, [path]);\n                if (!dependencyMap[invalidReference]) {\n                  extraPathsToLint.add(path);\n                }\n              }\n            });\n          });\n\n          // We have found some bindings which are related to the new property path and hence should be added to the\n          // global dependency map\n          if (!isEmpty(newlyValidReferencesMap)) {\n            didUpdateDependencyMap = true;\n            Object.keys(newlyValidReferencesMap).forEach(\n              (newlyValidReference) => {\n                const { validReferences } = extractInfoFromReferences(\n                  [newlyValidReference],\n                  allKeys,\n                );\n                newlyValidReferencesMap[newlyValidReference].forEach(\n                  (fullPath) => {\n                    const {\n                      entityName,\n                      propertyPath,\n                    } = getEntityNameAndPropertyPath(fullPath);\n                    const entity = unEvalDataTree[entityName];\n                    if (validReferences.length) {\n                      // For trigger paths, update the triggerfield dependency map\n                      // For other paths, update the dependency map\n                      updateMap(\n                        isADynamicTriggerPath(entity, propertyPath)\n                          ? triggerFieldDependencyMap\n                          : dependencyMap,\n                        fullPath,\n                        validReferences,\n                      );\n\n                      // Since the previously invalid reference has become valid,\n                      // remove it from the invalidReferencesMap\n                      if (invalidReferencesMap[fullPath]) {\n                        const newInvalidReferences = invalidReferencesMap[\n                          fullPath\n                        ].filter(\n                          (invalidReference) =>\n                            invalidReference !== newlyValidReference,\n                        );\n                        updateMap(\n                          invalidReferencesMap,\n                          fullPath,\n                          newInvalidReferences,\n                          { replaceValue: true, deleteOnEmpty: true },\n                        );\n                      }\n                    }\n                  },\n                );\n              },\n            );\n          }\n\n          // Add trigger paths that depend on the added path/entity to \"extrapathstolint\"\n          Object.keys(triggerFieldDependencyMap).forEach((triggerPath) => {\n            triggerFieldDependencyMap[triggerPath].forEach(\n              (triggerPathDependency) => {\n                if (\n                  isChildPropertyPath(fullPropertyPath, triggerPathDependency)\n                ) {\n                  extraPathsToLint.add(triggerPath);\n                }\n              },\n            );\n          });\n          break;\n        }\n        case DataTreeDiffEvent.DELETE: {\n          // Add to removedPaths as they have been deleted from the evalTree\n          removedPaths.push(fullPropertyPath);\n          // If an existing entity was deleted, remove all the bindings from the global dependency map\n\n          /**There are certain cases where the child paths of the entity could have errors and\n           *  need them to be cleared post evaluations. Therefore we store all the paths that are\n           * removed on deleting the entity and use that reference to clear the error logs post evaluation*/\n          if (isWidget(entity)) {\n            const propertyPaths = [fullPropertyPath];\n\n            if (dependencyMap[fullPropertyPath]) {\n              propertyPaths.push(...dependencyMap[fullPropertyPath]);\n            }\n\n            pathsToClearErrorsFor.push({\n              widgetId: entity?.widgetId,\n              paths: propertyPaths,\n            });\n          }\n\n          if (\n            (isWidget(entity) || isAction(entity) || isJSAction(entity)) &&\n            fullPropertyPath === entityName\n          ) {\n            const entityDependencies = listEntityDependencies(\n              entity,\n              entityName,\n              allKeys,\n            );\n            Object.keys(entityDependencies).forEach((widgetDep) => {\n              didUpdateDependencyMap = true;\n              delete dependencyMap[widgetDep];\n              delete invalidReferencesMap[widgetDep];\n            });\n\n            if (isWidget(entity)) {\n              const triggerFieldDependencies = listTriggerFieldDependencies(\n                entity,\n                entityName,\n              );\n              Object.keys(triggerFieldDependencies).forEach((triggerDep) => {\n                delete triggerFieldDependencyMap[triggerDep];\n                delete invalidReferencesMap[triggerDep];\n              });\n\n              // remove validation dependencies\n              const validationDependencies = listValidationDependencies(\n                entity,\n                entityName,\n              );\n              Object.keys(validationDependencies).forEach((validationDep) => {\n                delete dataTreeEvalRef.validationDependencyMap[validationDep];\n              });\n              didUpdateValidationDependencyMap = true;\n            }\n          }\n          // Either an existing entity or an existing property path has been deleted. Update the global dependency map\n          // by removing the bindings from the same.\n          Object.keys(dependencyMap).forEach((dependencyPath) => {\n            didUpdateDependencyMap = true;\n            if (isChildPropertyPath(fullPropertyPath, dependencyPath)) {\n              delete dependencyMap[dependencyPath];\n              delete invalidReferencesMap[dependencyPath];\n            } else {\n              const toRemove: Array<string> = [];\n              dependencyMap[dependencyPath].forEach((dependantPath) => {\n                if (isChildPropertyPath(fullPropertyPath, dependantPath)) {\n                  dependenciesOfRemovedPaths.push(dependencyPath);\n                  toRemove.push(dependantPath);\n                }\n              });\n              dependencyMap[dependencyPath] = difference(\n                dependencyMap[dependencyPath],\n                toRemove,\n              );\n              // If we find any invalid reference (untracked in the dependency map) for this path,\n              // which is a child of the deleted path, add it to the of paths to lint.\n              // Example scenario => For {{Api1.unknown}} in button.text, if Api1 is deleted, we need to lint button.text\n              // Although, \"Api1.unknown\" is not a valid reference\n\n              if (invalidReferencesMap[dependencyPath]) {\n                invalidReferencesMap[dependencyPath].forEach(\n                  (invalidReference) => {\n                    if (\n                      isChildPropertyPath(fullPropertyPath, invalidReference)\n                    ) {\n                      extraPathsToLint.add(dependencyPath);\n                    }\n                  },\n                );\n              }\n\n              // Since we are removing previously valid references,\n              // We also update the invalidReferenceMap for this path\n              if (toRemove.length) {\n                updateMap(invalidReferencesMap, dependencyPath, toRemove);\n              }\n            }\n          });\n          Object.keys(triggerFieldDependencyMap).forEach((dependencyPath) => {\n            if (isChildPropertyPath(fullPropertyPath, dependencyPath)) {\n              delete triggerFieldDependencyMap[dependencyPath];\n              delete invalidReferencesMap[dependencyPath];\n            } else {\n              const toRemove: Array<string> = [];\n              triggerFieldDependencyMap[dependencyPath].forEach(\n                (dependantPath) => {\n                  if (isChildPropertyPath(fullPropertyPath, dependantPath)) {\n                    toRemove.push(dependantPath);\n                  }\n                },\n              );\n              triggerFieldDependencyMap[dependencyPath] = difference(\n                triggerFieldDependencyMap[dependencyPath],\n                toRemove,\n              );\n              if (toRemove.length) {\n                updateMap(invalidReferencesMap, dependencyPath, toRemove);\n              }\n              if (invalidReferencesMap[dependencyPath]) {\n                invalidReferencesMap[dependencyPath].forEach(\n                  (invalidReference) => {\n                    if (\n                      isChildPropertyPath(fullPropertyPath, invalidReference)\n                    ) {\n                      extraPathsToLint.add(dependencyPath);\n                    }\n                  },\n                );\n              }\n            }\n          });\n\n          break;\n        }\n        case DataTreeDiffEvent.EDIT: {\n          // We only care if the difference is in dynamic bindings since static values do not need\n          // an evaluation.\n          if (\n            (isWidget(entity) || isAction(entity) || isJSAction(entity)) &&\n            typeof value === \"string\"\n          ) {\n            const entity:\n              | DataTreeAction\n              | DataTreeWidget\n              | DataTreeJSAction = unEvalDataTree[entityName] as\n              | DataTreeAction\n              | DataTreeWidget\n              | DataTreeJSAction;\n            const entityPropertyPath = getPropertyPath(fullPropertyPath);\n            const isADynamicBindingPath = isPathADynamicBinding(\n              entity,\n              entityPropertyPath,\n            );\n            if (isADynamicBindingPath) {\n              didUpdateDependencyMap = true;\n\n              const { jsSnippets } = getDynamicBindings(value, entity);\n              const correctSnippets = jsSnippets.filter(\n                (jsSnippet) => !!jsSnippet,\n              );\n              const {\n                errors: extractDependencyErrors,\n                invalidReferences,\n                validReferences,\n              } = extractInfoFromBindings(correctSnippets, allKeys);\n              updateMap(\n                invalidReferencesMap,\n                fullPropertyPath,\n                invalidReferences,\n                { replaceValue: true, deleteOnEmpty: true },\n              );\n\n              dataTreeEvalErrors = dataTreeEvalErrors.concat(\n                extractDependencyErrors,\n              );\n\n              // We found a new dynamic binding for this property path. We update the dependency map by overwriting the\n              // dependencies for this property path with the newly found dependencies\n\n              if (correctSnippets.length) {\n                dependencyMap[fullPropertyPath] = validReferences;\n              } else {\n                // The dependency on this property path has been removed. Delete this property path from the global\n                // dependency map\n                delete dependencyMap[fullPropertyPath];\n              }\n              if (isAction(entity) || isJSAction(entity)) {\n                // Actions have a defined dependency map that should always be maintained\n                if (entityPropertyPath in entity.dependencyMap) {\n                  const entityDependenciesName = entity.dependencyMap[\n                    entityPropertyPath\n                  ].map((dep) => `${entityName}.${dep}`);\n\n                  const {\n                    errors,\n                    invalidReferences,\n                    validReferences,\n                  } = extractInfoFromBindings(entityDependenciesName, allKeys);\n                  updateMap(\n                    invalidReferencesMap,\n                    fullPropertyPath,\n                    invalidReferences,\n                    { replaceValue: true, deleteOnEmpty: true },\n                  );\n\n                  errors.forEach((error) => {\n                    dataTreeEvalRef.errors.push(error);\n                  });\n\n                  // Now assign these existing dependent paths to the property path in dependencyMap\n                  if (fullPropertyPath in dependencyMap) {\n                    dependencyMap[fullPropertyPath] = dependencyMap[\n                      fullPropertyPath\n                    ].concat(validReferences);\n                  } else {\n                    dependencyMap[fullPropertyPath] = validReferences;\n                  }\n                }\n              }\n            }\n            // If the whole binding was removed, then the value at this path would be a string without any bindings.\n            // In this case, if the path exists in the dependency map and is a bindingPath, then remove it.\n            else if (\n              entity.bindingPaths[entityPropertyPath] &&\n              fullPropertyPath in dependencyMap\n            ) {\n              didUpdateDependencyMap = true;\n              delete dependencyMap[fullPropertyPath];\n              delete invalidReferencesMap[fullPropertyPath];\n            }\n          }\n          if (\n            isWidget(entity) &&\n            isPathDynamicTrigger(entity, getPropertyPath(fullPropertyPath))\n          ) {\n            const { jsSnippets } = getDynamicBindings(\n              dataTreeDiff.payload.value || \"\",\n              entity,\n            );\n            const entityDependencies = jsSnippets.filter(\n              (jsSnippet) => !!jsSnippet,\n            );\n\n            const {\n              errors: extractDependencyErrors,\n              invalidReferences,\n              validReferences,\n            } = extractInfoFromBindings(entityDependencies, allKeys);\n\n            dataTreeEvalErrors = dataTreeEvalErrors.concat(\n              extractDependencyErrors,\n            );\n            updateMap(\n              invalidReferencesMap,\n              fullPropertyPath,\n              invalidReferences,\n              {\n                replaceValue: true,\n                deleteOnEmpty: true,\n              },\n            );\n            updateMap(\n              triggerFieldDependencyMap,\n              fullPropertyPath,\n              validReferences,\n              { replaceValue: true },\n            );\n          }\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n    }\n  });\n\n  const diffCalcEnd = performance.now();\n  const subDepCalcStart = performance.now();\n  if (didUpdateDependencyMap) {\n    dataTreeEvalRef.dependencyMap = makeParentsDependOnChildren(\n      dataTreeEvalRef.dependencyMap,\n      allKeys,\n    );\n  }\n  const subDepCalcEnd = performance.now();\n  const updateChangedDependenciesStart = performance.now();\n  // If the global dependency map has changed, re-calculate the sort order for all entities and the\n  // global inverse dependency map\n  if (didUpdateDependencyMap) {\n    // This is being called purely to test for new circular dependencies that might have been added\n    dataTreeEvalRef.sortedDependencies = dataTreeEvalRef.sortDependencies(\n      dataTreeEvalRef.dependencyMap,\n      translatedDiffs,\n    );\n    dataTreeEvalRef.inverseDependencyMap = dataTreeEvalRef.getInverseDependencyTree();\n  }\n\n  if (didUpdateValidationDependencyMap) {\n    // This is being called purely to test for new circular dependencies that might have been added\n    dataTreeEvalRef.sortedValidationDependencies = dataTreeEvalRef.sortDependencies(\n      dataTreeEvalRef.validationDependencyMap,\n      translatedDiffs,\n    );\n\n    dataTreeEvalRef.inverseValidationDependencyMap = dataTreeEvalRef.getInverseDependencyTree(\n      {\n        dependencyMap: dataTreeEvalRef.validationDependencyMap,\n        sortedDependencies: dataTreeEvalRef.sortedValidationDependencies,\n      },\n    );\n  }\n\n  /** We need this in order clear out the paths that could have errors when a property is deleted */\n  if (pathsToClearErrorsFor.length) {\n    pathsToClearErrorsFor.forEach((error) => {\n      error.paths.forEach((path: string) => {\n        set(dataTreeEvalRef.evalProps, getEvalErrorPath(path), []);\n      });\n    });\n  }\n\n  const updateChangedDependenciesStop = performance.now();\n  dataTreeEvalRef.logs.push({\n    diffCalcDeps: (diffCalcEnd - diffCalcStart).toFixed(2),\n    subDepCalc: (subDepCalcEnd - subDepCalcStart).toFixed(2),\n    updateChangedDependencies: (\n      updateChangedDependenciesStop - updateChangedDependenciesStart\n    ).toFixed(2),\n  });\n\n  return {\n    pathsToClearErrorsFor,\n    dependenciesOfRemovedPaths,\n    removedPaths,\n    extraPathsToLint: Array.from(extraPathsToLint),\n  };\n};\n","import { addDataTreeToContext } from \"@appsmith/workers/Evaluation/Actions\";\nimport { EvalContext, assignJSFunctionsToContext } from \"./evaluate\";\nimport { DataTree } from \"entities/DataTree/dataTreeFactory\";\nimport userLogs from \"./fns/overrides/console\";\n\nclass FunctionDeterminer {\n  private evalContext: EvalContext = {};\n\n  setupEval(dataTree: DataTree, resolvedFunctions: Record<string, any>) {\n    /**** Setting the eval context ****/\n    const evalContext: EvalContext = {\n      $isDataField: true,\n      $isAsync: false,\n    };\n\n    addDataTreeToContext({\n      dataTree,\n      EVAL_CONTEXT: evalContext,\n      isTriggerBased: true,\n    });\n\n    assignJSFunctionsToContext(evalContext, resolvedFunctions, false);\n\n    // Set it to self so that the eval function can have access to it\n    // as global data. This is what enables access all appsmith\n    // entity properties from the global context\n    Object.assign(self, evalContext);\n\n    this.evalContext = evalContext;\n    userLogs.disable();\n  }\n\n  close() {\n    userLogs.enable();\n    for (const entityName in this.evalContext) {\n      if (this.evalContext.hasOwnProperty(entityName)) {\n        // @ts-expect-error: Types are not available\n        delete self[entityName];\n      }\n    }\n  }\n\n  isFunctionAsync(userFunction: unknown, logs: unknown[] = []) {\n    self[\"$isAsync\"] = false;\n\n    return (function() {\n      try {\n        if (typeof userFunction === \"function\") {\n          if (userFunction.constructor.name === \"AsyncFunction\") {\n            // functions declared with an async keyword\n            self[\"$isAsync\"] = true;\n          } else {\n            const returnValue = userFunction();\n            if (!!returnValue && returnValue instanceof Promise) {\n              self[\"$isAsync\"] = true;\n            }\n          }\n        }\n      } catch (e) {\n        // We do not want to throw errors for internal operations, to users.\n        // logLevel should help us in debugging this.\n        logs.push({ error: \"Error when determining async function\" + e });\n      }\n      const isAsync = !!self[\"$isAsync\"];\n\n      return isAsync;\n    })();\n  }\n}\n\nexport const functionDeterminer = new FunctionDeterminer();\n","import { DataTree, DataTreeJSAction } from \"entities/DataTree/dataTreeFactory\";\nimport { isEmpty, set } from \"lodash\";\nimport { EvalErrorTypes } from \"utils/DynamicBindingUtils\";\nimport { JSUpdate, ParsedJSSubAction } from \"utils/JSPaneUtils\";\nimport { isTypeOfFunction, parseJSObjectWithAST } from \"@shared/ast\";\nimport DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport evaluateSync from \"workers/Evaluation/evaluate\";\nimport {\n  DataTreeDiff,\n  DataTreeDiffEvent,\n  getEntityNameAndPropertyPath,\n  isJSAction,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport {\n  removeFunctionsAndVariableJSCollection,\n  updateJSCollectionInUnEvalTree,\n} from \"workers/Evaluation/JSObject/utils\";\nimport { functionDeterminer } from \"../functionDeterminer\";\n\n/**\n * Here we update our unEvalTree according to the change in JSObject's body\n *\n * @param jsUpdates\n * @param localUnEvalTree\n * @returns\n */\nexport const getUpdatedLocalUnEvalTreeAfterJSUpdates = (\n  jsUpdates: Record<string, JSUpdate>,\n  localUnEvalTree: DataTree,\n) => {\n  if (!isEmpty(jsUpdates)) {\n    Object.keys(jsUpdates).forEach((jsEntityName) => {\n      const entity = localUnEvalTree[jsEntityName];\n      const parsedBody = jsUpdates[jsEntityName].parsedBody;\n      if (isJSAction(entity)) {\n        if (!!parsedBody) {\n          //add/delete/update functions from dataTree\n          localUnEvalTree = updateJSCollectionInUnEvalTree(\n            parsedBody,\n            entity,\n            localUnEvalTree,\n          );\n        } else {\n          //if parse error remove functions and variables from dataTree\n          localUnEvalTree = removeFunctionsAndVariableJSCollection(\n            localUnEvalTree,\n            entity,\n            jsEntityName,\n          );\n        }\n      }\n    });\n  }\n  return localUnEvalTree;\n};\n\nconst regex = new RegExp(/^export default[\\s]*?({[\\s\\S]*?})/);\n\n/**\n * Here we parse the JSObject and then determine\n * 1. it's nature : async or sync\n * 2. Find arguments of JS Actions\n * 3. set variables and actions in currentJSCollectionState and resolvedFunctions\n *\n * @param dataTreeEvalRef\n * @param entity\n * @param jsUpdates\n * @param unEvalDataTree\n * @param entityName\n * @returns\n */\nexport function saveResolvedFunctionsAndJSUpdates(\n  dataTreeEvalRef: DataTreeEvaluator,\n  entity: DataTreeJSAction,\n  jsUpdates: Record<string, JSUpdate>,\n  unEvalDataTree: DataTree,\n  entityName: string,\n) {\n  const correctFormat = regex.test(entity.body);\n  if (correctFormat) {\n    const body = entity.body.replace(/export default/g, \"\");\n    try {\n      delete dataTreeEvalRef.resolvedFunctions[`${entityName}`];\n      delete dataTreeEvalRef.currentJSCollectionState[`${entityName}`];\n      const parseStartTime = performance.now();\n      const parsedObject = parseJSObjectWithAST(body);\n      const parseEndTime = performance.now();\n      const JSObjectASTParseTime = parseEndTime - parseStartTime;\n      dataTreeEvalRef.logs.push({\n        JSObjectName: entityName,\n        JSObjectASTParseTime,\n      });\n      const actions: any = [];\n      const variables: any = [];\n      if (!!parsedObject) {\n        parsedObject.forEach((parsedElement) => {\n          if (isTypeOfFunction(parsedElement.type)) {\n            try {\n              const { result } = evaluateSync(\n                parsedElement.value,\n                unEvalDataTree,\n                {},\n                false,\n                undefined,\n                undefined,\n              );\n              if (!!result) {\n                let params: Array<{ key: string; value: unknown }> = [];\n\n                if (parsedElement.arguments) {\n                  params = parsedElement.arguments.map(\n                    ({ defaultValue, paramName }) => ({\n                      key: paramName,\n                      value: defaultValue,\n                    }),\n                  );\n                }\n\n                const functionString = parsedElement.value;\n                set(\n                  dataTreeEvalRef.resolvedFunctions,\n                  `${entityName}.${parsedElement.key}`,\n                  result,\n                );\n                set(\n                  dataTreeEvalRef.currentJSCollectionState,\n                  `${entityName}.${parsedElement.key}`,\n                  functionString,\n                );\n                actions.push({\n                  name: parsedElement.key,\n                  body: functionString,\n                  arguments: params,\n                  parsedFunction: result,\n                  isAsync: false,\n                });\n              }\n            } catch {\n              // in case we need to handle error state\n            }\n          } else if (parsedElement.type !== \"literal\") {\n            variables.push({\n              name: parsedElement.key,\n              value: parsedElement.value,\n            });\n            set(\n              dataTreeEvalRef.currentJSCollectionState,\n              `${entityName}.${parsedElement.key}`,\n              parsedElement.value,\n            );\n          }\n        });\n        const parsedBody = {\n          body: entity.body,\n          actions: actions,\n          variables,\n        };\n        set(jsUpdates, `${entityName}`, {\n          parsedBody,\n          id: entity.actionId,\n        });\n      } else {\n        set(jsUpdates, `${entityName}`, {\n          parsedBody: undefined,\n          id: entity.actionId,\n        });\n      }\n    } catch (e) {\n      //if we need to push error as popup in case\n    }\n  } else {\n    const errors = {\n      type: EvalErrorTypes.PARSE_JS_ERROR,\n      context: {\n        entity: entity,\n        propertyPath: entityName + \".body\",\n      },\n      message: \"Start object with export default\",\n    };\n    dataTreeEvalRef.errors.push(errors);\n  }\n  return jsUpdates;\n}\n\nexport function parseJSActions(\n  dataTreeEvalRef: DataTreeEvaluator,\n  unEvalDataTree: DataTree,\n  differences?: DataTreeDiff[],\n  oldUnEvalTree?: DataTree,\n) {\n  let jsUpdates: Record<string, JSUpdate> = {};\n  if (!!differences && !!oldUnEvalTree) {\n    differences.forEach((diff) => {\n      const { entityName, propertyPath } = getEntityNameAndPropertyPath(\n        diff.payload.propertyPath,\n      );\n      const entity = unEvalDataTree[entityName];\n\n      if (!isJSAction(entity)) return false;\n\n      if (diff.event === DataTreeDiffEvent.DELETE) {\n        // when JSObject is deleted, we remove it from currentJSCollectionState & resolvedFunctions\n        if (\n          dataTreeEvalRef.currentJSCollectionState &&\n          dataTreeEvalRef.currentJSCollectionState[diff.payload.propertyPath]\n        ) {\n          delete dataTreeEvalRef.currentJSCollectionState[\n            diff.payload.propertyPath\n          ];\n        }\n        if (\n          dataTreeEvalRef.resolvedFunctions &&\n          dataTreeEvalRef.resolvedFunctions[diff.payload.propertyPath]\n        ) {\n          delete dataTreeEvalRef.resolvedFunctions[diff.payload.propertyPath];\n        }\n      }\n\n      if (\n        (diff.event === DataTreeDiffEvent.EDIT && propertyPath === \"body\") ||\n        (diff.event === DataTreeDiffEvent.NEW && propertyPath === \"\")\n      ) {\n        jsUpdates = saveResolvedFunctionsAndJSUpdates(\n          dataTreeEvalRef,\n          entity,\n          jsUpdates,\n          unEvalDataTree,\n          entityName,\n        );\n      }\n    });\n  } else {\n    Object.keys(unEvalDataTree).forEach((entityName) => {\n      const entity = unEvalDataTree[entityName];\n      if (!isJSAction(entity)) {\n        return;\n      }\n      jsUpdates = saveResolvedFunctionsAndJSUpdates(\n        dataTreeEvalRef,\n        entity,\n        jsUpdates,\n        unEvalDataTree,\n        entityName,\n      );\n    });\n  }\n\n  functionDeterminer.setupEval(\n    unEvalDataTree,\n    dataTreeEvalRef.resolvedFunctions,\n  );\n\n  Object.keys(jsUpdates).forEach((entityName) => {\n    const parsedBody = jsUpdates[entityName].parsedBody;\n    if (!parsedBody) return;\n    parsedBody.actions = parsedBody.actions.map((action) => {\n      return {\n        ...action,\n        isAsync: functionDeterminer.isFunctionAsync(\n          action.parsedFunction,\n          dataTreeEvalRef.logs,\n        ),\n        // parsedFunction - used only to determine if function is async\n        parsedFunction: undefined,\n      } as ParsedJSSubAction;\n    });\n  });\n\n  functionDeterminer.close();\n\n  return { jsUpdates };\n}\n\nexport function getJSEntities(dataTree: DataTree) {\n  const jsCollections: Record<string, DataTreeJSAction> = {};\n  Object.keys(dataTree).forEach((entityName: string) => {\n    const entity = dataTree[entityName];\n    if (isJSAction(entity)) {\n      jsCollections[entityName] = entity;\n    }\n  });\n  return jsCollections;\n}\n","import { DataTree } from \"entities/DataTree/dataTreeFactory\";\nimport ReplayEntity from \"entities/Replay\";\nimport ReplayCanvas from \"entities/Replay/ReplayEntity/ReplayCanvas\";\nimport { isEmpty } from \"lodash\";\nimport {\n  DependencyMap,\n  EvalError,\n  EvalErrorTypes,\n} from \"utils/DynamicBindingUtils\";\nimport { JSUpdate } from \"utils/JSPaneUtils\";\nimport DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport { EvalMetaUpdates } from \"@appsmith/workers/common/DataTreeEvaluator/types\";\nimport { initiateLinting } from \"workers/Linting/utils\";\nimport {\n  createUnEvalTreeForEval,\n  makeEntityConfigsAsObjProperties,\n} from \"@appsmith/workers/Evaluation/dataTreeUtils\";\nimport {\n  CrashingError,\n  DataTreeDiff,\n  getSafeToRenderDataTree,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport {\n  EvalTreeRequestData,\n  EvalTreeResponseData,\n  EvalWorkerSyncRequest,\n} from \"../types\";\nimport { clearAllIntervals } from \"../fns/overrides/interval\";\nexport let replayMap: Record<string, ReplayEntity<any>>;\nexport let dataTreeEvaluator: DataTreeEvaluator | undefined;\nexport const CANVAS = \"canvas\";\n\nexport default function(request: EvalWorkerSyncRequest) {\n  const { data } = request;\n  let evalOrder: string[] = [];\n  let lintOrder: string[] = [];\n  let jsUpdates: Record<string, JSUpdate> = {};\n  let unEvalUpdates: DataTreeDiff[] = [];\n  let nonDynamicFieldValidationOrder: string[] = [];\n  let isCreateFirstTree = false;\n  let dataTree: DataTree = {};\n  let errors: EvalError[] = [];\n  let logs: any[] = [];\n  let dependencies: DependencyMap = {};\n  let evalMetaUpdates: EvalMetaUpdates = [];\n  let staleMetaIds: string[] = [];\n  let pathsToClearErrorsFor: any[] = [];\n\n  const {\n    allActionValidationConfig,\n    forceEvaluation,\n    metaWidgets,\n    requiresLinting,\n    shouldReplay,\n    theme,\n    unevalTree: __unevalTree__,\n    widgets,\n    widgetTypeConfigMap,\n  } = data as EvalTreeRequestData;\n\n  const unevalTree = createUnEvalTreeForEval(__unevalTree__);\n\n  try {\n    if (!dataTreeEvaluator) {\n      isCreateFirstTree = true;\n      replayMap = replayMap || {};\n      replayMap[CANVAS] = new ReplayCanvas({ widgets, theme });\n      dataTreeEvaluator = new DataTreeEvaluator(\n        widgetTypeConfigMap,\n        allActionValidationConfig,\n      );\n      const setupFirstTreeResponse = dataTreeEvaluator.setupFirstTree(\n        unevalTree,\n      );\n      evalOrder = setupFirstTreeResponse.evalOrder;\n      lintOrder = setupFirstTreeResponse.lintOrder;\n      jsUpdates = setupFirstTreeResponse.jsUpdates;\n\n      initiateLinting(\n        lintOrder,\n        makeEntityConfigsAsObjProperties(dataTreeEvaluator.oldUnEvalTree, {\n          sanitizeDataTree: false,\n        }),\n        requiresLinting,\n      );\n\n      const dataTreeResponse = dataTreeEvaluator.evalAndValidateFirstTree();\n      dataTree = makeEntityConfigsAsObjProperties(dataTreeResponse.evalTree, {\n        evalProps: dataTreeEvaluator.evalProps,\n      });\n      staleMetaIds = dataTreeResponse.staleMetaIds;\n    } else if (dataTreeEvaluator.hasCyclicalDependency || forceEvaluation) {\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        //allActionValidationConfigs may not be set in dataTreeEvaluatior. Therefore, set it explicitly via setter method\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n      if (shouldReplay) {\n        replayMap[CANVAS]?.update({ widgets, theme });\n      }\n      dataTreeEvaluator = new DataTreeEvaluator(\n        widgetTypeConfigMap,\n        allActionValidationConfig,\n      );\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n      const setupFirstTreeResponse = dataTreeEvaluator.setupFirstTree(\n        unevalTree,\n      );\n      isCreateFirstTree = true;\n      evalOrder = setupFirstTreeResponse.evalOrder;\n      lintOrder = setupFirstTreeResponse.lintOrder;\n      jsUpdates = setupFirstTreeResponse.jsUpdates;\n\n      initiateLinting(\n        lintOrder,\n        makeEntityConfigsAsObjProperties(dataTreeEvaluator.oldUnEvalTree, {\n          sanitizeDataTree: false,\n        }),\n        requiresLinting,\n      );\n\n      const dataTreeResponse = dataTreeEvaluator.evalAndValidateFirstTree();\n      dataTree = makeEntityConfigsAsObjProperties(dataTreeResponse.evalTree, {\n        evalProps: dataTreeEvaluator.evalProps,\n      });\n      staleMetaIds = dataTreeResponse.staleMetaIds;\n    } else {\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n      isCreateFirstTree = false;\n      if (shouldReplay) {\n        replayMap[CANVAS]?.update({ widgets, theme });\n      }\n      const setupUpdateTreeResponse = dataTreeEvaluator.setupUpdateTree(\n        unevalTree,\n      );\n      evalOrder = setupUpdateTreeResponse.evalOrder;\n      lintOrder = setupUpdateTreeResponse.lintOrder;\n      jsUpdates = setupUpdateTreeResponse.jsUpdates;\n      unEvalUpdates = setupUpdateTreeResponse.unEvalUpdates;\n      pathsToClearErrorsFor = setupUpdateTreeResponse.pathsToClearErrorsFor;\n\n      initiateLinting(\n        lintOrder,\n        makeEntityConfigsAsObjProperties(dataTreeEvaluator.oldUnEvalTree, {\n          sanitizeDataTree: false,\n        }),\n        requiresLinting,\n      );\n\n      nonDynamicFieldValidationOrder =\n        setupUpdateTreeResponse.nonDynamicFieldValidationOrder;\n      const updateResponse = dataTreeEvaluator.evalAndValidateSubTree(\n        evalOrder,\n        nonDynamicFieldValidationOrder,\n        unEvalUpdates,\n        Object.keys(metaWidgets),\n      );\n      dataTree = makeEntityConfigsAsObjProperties(dataTreeEvaluator.evalTree, {\n        evalProps: dataTreeEvaluator.evalProps,\n      });\n      evalMetaUpdates = JSON.parse(\n        JSON.stringify(updateResponse.evalMetaUpdates),\n      );\n      staleMetaIds = updateResponse.staleMetaIds;\n    }\n    dataTreeEvaluator = dataTreeEvaluator as DataTreeEvaluator;\n    dependencies = dataTreeEvaluator.inverseDependencyMap;\n    errors = dataTreeEvaluator.errors;\n    dataTreeEvaluator.clearErrors();\n    logs = dataTreeEvaluator.logs;\n    if (shouldReplay) {\n      if (replayMap[CANVAS]?.logs) logs = logs.concat(replayMap[CANVAS]?.logs);\n      replayMap[CANVAS]?.clearLogs();\n    }\n\n    dataTreeEvaluator.clearLogs();\n  } catch (error) {\n    if (dataTreeEvaluator !== undefined) {\n      errors = dataTreeEvaluator.errors;\n      logs = dataTreeEvaluator.logs;\n    }\n    if (!(error instanceof CrashingError)) {\n      errors.push({\n        type: EvalErrorTypes.UNKNOWN_ERROR,\n        message: (error as Error).message,\n      });\n      // eslint-disable-next-line\n      console.error(error);\n    }\n    dataTree = getSafeToRenderDataTree(\n      makeEntityConfigsAsObjProperties(unevalTree, {\n        sanitizeDataTree: false,\n        evalProps: dataTreeEvaluator?.evalProps,\n      }),\n      widgetTypeConfigMap,\n    );\n    unEvalUpdates = [];\n  }\n\n  const evalTreeResponse: EvalTreeResponseData = {\n    dataTree,\n    dependencies,\n    errors,\n    evalMetaUpdates,\n    evaluationOrder: evalOrder,\n    jsUpdates,\n    logs,\n    unEvalUpdates,\n    isCreateFirstTree,\n    staleMetaIds,\n    pathsToClearErrorsFor,\n  };\n\n  return evalTreeResponse;\n}\n\nexport function clearCache() {\n  dataTreeEvaluator = undefined;\n  clearAllIntervals();\n  return true;\n}\n","import {\n  DataTreeEvaluationProps,\n  DependencyMap,\n  EvalError,\n  EvalErrorTypes,\n  EvaluationError,\n  getDynamicBindings,\n  getEntityDynamicBindingPathList,\n  getEntityId,\n  getEntityName,\n  getEntityType,\n  getEvalErrorPath,\n  getEvalValuePath,\n  isChildPropertyPath,\n  isPathADynamicBinding,\n  isPathDynamicTrigger,\n  PropertyEvaluationErrorType,\n} from \"utils/DynamicBindingUtils\";\nimport { WidgetTypeConfigMap } from \"utils/WidgetFactory\";\nimport {\n  DataTree,\n  DataTreeAction,\n  DataTreeEntity,\n  DataTreeJSAction,\n  DataTreeWidget,\n  EvaluationSubstitutionType,\n} from \"entities/DataTree/dataTreeFactory\";\nimport { ENTITY_TYPE, PrivateWidgets } from \"entities/DataTree/types\";\nimport {\n  addDependantsOfNestedPropertyPaths,\n  addErrorToEntityProperty,\n  convertPathToString,\n  CrashingError,\n  DataTreeDiff,\n  getEntityNameAndPropertyPath,\n  getImmediateParentsOfPropertyPaths,\n  isAction,\n  isDynamicLeaf,\n  isJSAction,\n  isWidget,\n  translateDiffEventToDataTreeDiffEvent,\n  trimDependantChangePaths,\n  overrideWidgetProperties,\n  getAllPaths,\n  isValidEntity,\n  isNewEntity,\n  getStaleMetaStateIds,\n  convertJSFunctionsToString,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport {\n  difference,\n  flatten,\n  get,\n  isEmpty,\n  isFunction,\n  isObject,\n  set,\n  union,\n  unset,\n} from \"lodash\";\n\nimport { applyChange, Diff, diff } from \"deep-diff\";\nimport toposort from \"toposort\";\nimport {\n  EXECUTION_PARAM_KEY,\n  EXECUTION_PARAM_REFERENCE_REGEX,\n  THIS_DOT_PARAMS_KEY,\n} from \"constants/AppsmithActionConstants/ActionConstants\";\nimport { DATA_BIND_REGEX } from \"constants/BindingsConstants\";\nimport evaluateSync, {\n  EvalResult,\n  EvaluateContext,\n  evaluateAsync,\n} from \"workers/Evaluation/evaluate\";\nimport { substituteDynamicBindingWithValues } from \"workers/Evaluation/evaluationSubstitution\";\nimport { Severity } from \"entities/AppsmithConsole\";\nimport { error as logError } from \"loglevel\";\nimport { JSUpdate } from \"utils/JSPaneUtils\";\n\nimport {\n  ActionValidationConfigMap,\n  ValidationConfig,\n} from \"constants/PropertyControlConstants\";\nimport { klona } from \"klona/full\";\nimport { EvalMetaUpdates } from \"@appsmith/workers/common/DataTreeEvaluator/types\";\nimport {\n  updateDependencyMap,\n  createDependencyMap,\n} from \"workers/common/DependencyMap\";\nimport {\n  getJSEntities,\n  getUpdatedLocalUnEvalTreeAfterJSUpdates,\n  parseJSActions,\n} from \"workers/Evaluation/JSObject\";\nimport { getFixedTimeDifference } from \"./utils\";\nimport { isJSObjectFunction } from \"workers/Evaluation/JSObject/utils\";\nimport {\n  getValidatedTree,\n  validateActionProperty,\n  validateAndParseWidgetProperty,\n} from \"./validationUtils\";\nimport { errorModifier } from \"workers/Evaluation/errorModifier\";\nimport userLogs from \"workers/Evaluation/fns/overrides/console\";\nimport ExecutionMetaData from \"workers/Evaluation/fns/utils/ExecutionMetaData\";\n\ntype SortedDependencies = Array<string>;\nexport type EvalProps = {\n  [entityName: string]: DataTreeEvaluationProps;\n};\n\nexport default class DataTreeEvaluator {\n  /**\n   * dependencyMap: Maintains map of <PATH, list of paths that re-evaluates on the evaluation of the PATH>\n   */\n  dependencyMap: DependencyMap = {};\n  sortedDependencies: SortedDependencies = [];\n  inverseDependencyMap: DependencyMap = {};\n  widgetConfigMap: WidgetTypeConfigMap = {};\n  evalTree: DataTree = {};\n  /**\n   * This contains raw evaluated value without any validation or parsing.\n   * This is used for revalidation as we do not store the raw validated value.\n   */\n  unParsedEvalTree: DataTree = {};\n  allKeys: Record<string, true> = {};\n  privateWidgets: PrivateWidgets = {};\n  oldUnEvalTree: DataTree = {};\n  errors: EvalError[] = [];\n  resolvedFunctions: Record<string, any> = {};\n  currentJSCollectionState: Record<string, any> = {};\n  logs: unknown[] = [];\n  console = userLogs;\n  allActionValidationConfig?: {\n    [actionId: string]: ActionValidationConfigMap;\n  };\n  triggerFieldDependencyMap: DependencyMap = {};\n  /**  Keeps track of all invalid references in bindings throughout the Application\n   * Eg. For binding {{unknownEntity.name + Api1.name}} in Button1.text, where Api1 is present in dataTree but unknownEntity is not,\n   * the map has a key-value pair of\n   * {\n   *  \"Button1.text\": [unknownEntity.name]\n   * }\n   */\n  invalidReferencesMap: DependencyMap = {};\n  /**\n   * Maintains dependency of paths to re-validate on evaluation of particular property path.\n   */\n  validationDependencyMap: DependencyMap = {};\n  sortedValidationDependencies: SortedDependencies = [];\n  inverseValidationDependencyMap: DependencyMap = {};\n\n  /**\n   * Sanitized eval values and errors\n   */\n  evalProps: EvalProps = {};\n  public hasCyclicalDependency = false;\n  constructor(\n    widgetConfigMap: WidgetTypeConfigMap,\n    allActionValidationConfig?: {\n      [actionId: string]: ActionValidationConfigMap;\n    },\n  ) {\n    this.allActionValidationConfig = allActionValidationConfig;\n    this.widgetConfigMap = widgetConfigMap;\n  }\n\n  getEvalTree() {\n    return this.evalTree;\n  }\n\n  setEvalTree(evalTree: DataTree) {\n    this.evalTree = evalTree;\n  }\n\n  getUnParsedEvalTree() {\n    return this.unParsedEvalTree;\n  }\n\n  setUnParsedEvalTree(unParsedEvalTree: DataTree) {\n    this.unParsedEvalTree = unParsedEvalTree;\n  }\n\n  /**\n   * Method to create all data required for linting and\n   * evaluation of the first tree\n   */\n  setupFirstTree(\n    unEvalTree: DataTree,\n  ): {\n    jsUpdates: Record<string, JSUpdate>;\n    evalOrder: string[];\n    lintOrder: string[];\n  } {\n    const totalFirstTreeSetupStartTime = performance.now();\n    // cloneDeep will make sure not to omit key which has value as undefined.\n    const firstCloneStartTime = performance.now();\n    let localUnEvalTree = klona(unEvalTree);\n    const firstCloneEndTime = performance.now();\n\n    let jsUpdates: Record<string, JSUpdate> = {};\n    //parse js collection to get functions\n    //save current state of js collection action and variables to be added to uneval tree\n    //save functions in resolveFunctions (as functions) to be executed as functions are not allowed in evalTree\n    //and functions are saved in dataTree as strings\n    const parsedCollections = parseJSActions(this, localUnEvalTree);\n    jsUpdates = parsedCollections.jsUpdates;\n    localUnEvalTree = getUpdatedLocalUnEvalTreeAfterJSUpdates(\n      jsUpdates,\n      localUnEvalTree,\n    );\n    const allKeysGenerationStartTime = performance.now();\n    // set All keys\n    this.allKeys = getAllPaths(localUnEvalTree);\n    const allKeysGenerationEndTime = performance.now();\n\n    const createDependencyMapStartTime = performance.now();\n    // Create dependency map\n    const {\n      dependencyMap,\n      invalidReferencesMap,\n      triggerFieldDependencyMap,\n      validationDependencyMap,\n    } = createDependencyMap(this, localUnEvalTree);\n    const createDependencyMapEndTime = performance.now();\n\n    this.dependencyMap = dependencyMap;\n    this.triggerFieldDependencyMap = triggerFieldDependencyMap;\n    this.invalidReferencesMap = invalidReferencesMap;\n    this.validationDependencyMap = validationDependencyMap;\n    const sortDependenciesStartTime = performance.now();\n    // Sort\n    this.sortedDependencies = this.sortDependencies(this.dependencyMap);\n    this.sortedValidationDependencies = this.sortDependencies(\n      validationDependencyMap,\n    );\n    const sortDependenciesEndTime = performance.now();\n\n    const inverseDependencyGenerationStartTime = performance.now();\n    // Inverse\n    this.inverseDependencyMap = this.getInverseDependencyTree({\n      dependencyMap,\n      sortedDependencies: this.sortedDependencies,\n    });\n    this.inverseValidationDependencyMap = this.getInverseDependencyTree({\n      dependencyMap: validationDependencyMap,\n      sortedDependencies: this.sortedValidationDependencies,\n    });\n    const inverseDependencyGenerationEndTime = performance.now();\n\n    const secondCloneStartTime = performance.now();\n    this.oldUnEvalTree = klona(localUnEvalTree);\n    const secondCloneEndTime = performance.now();\n\n    const totalFirstTreeSetupEndTime = performance.now();\n\n    const timeTakenForSetupFirstTree = {\n      total: getFixedTimeDifference(\n        totalFirstTreeSetupEndTime,\n        totalFirstTreeSetupStartTime,\n      ),\n      clone: getFixedTimeDifference(\n        firstCloneEndTime + secondCloneEndTime,\n        firstCloneStartTime + secondCloneStartTime,\n      ),\n      allKeys: getFixedTimeDifference(\n        allKeysGenerationEndTime,\n        allKeysGenerationStartTime,\n      ),\n      createDependencyMap: getFixedTimeDifference(\n        createDependencyMapEndTime,\n        createDependencyMapStartTime,\n      ),\n      sortDependencies: getFixedTimeDifference(\n        sortDependenciesEndTime,\n        sortDependenciesStartTime,\n      ),\n      inverseDependency: getFixedTimeDifference(\n        inverseDependencyGenerationEndTime,\n        inverseDependencyGenerationStartTime,\n      ),\n    };\n    this.logs.push({ timeTakenForSetupFirstTree });\n\n    return {\n      jsUpdates,\n      evalOrder: this.sortedDependencies,\n      lintOrder: this.sortedDependencies,\n    };\n  }\n\n  evalAndValidateFirstTree(): {\n    evalTree: DataTree;\n    evalMetaUpdates: EvalMetaUpdates;\n    staleMetaIds: string[];\n  } {\n    const evaluationStartTime = performance.now();\n    // Evaluate\n    const { evalMetaUpdates, evaluatedTree, staleMetaIds } = this.evaluateTree(\n      this.oldUnEvalTree,\n      this.resolvedFunctions,\n      this.sortedDependencies,\n    );\n    const evaluationEndTime = performance.now();\n\n    const validationStartTime = performance.now();\n    // Validate Widgets\n    this.setEvalTree(\n      getValidatedTree(evaluatedTree, {\n        evalProps: this.evalProps,\n      }),\n    );\n    const validationEndTime = performance.now();\n\n    const timeTakenForEvalAndValidateFirstTree = {\n      evaluation: getFixedTimeDifference(\n        evaluationEndTime,\n        evaluationStartTime,\n      ),\n      validation: getFixedTimeDifference(\n        validationEndTime,\n        validationStartTime,\n      ),\n    };\n    this.logs.push({ timeTakenForEvalAndValidateFirstTree });\n\n    return {\n      evalTree: this.getEvalTree(),\n      evalMetaUpdates,\n      staleMetaIds,\n    };\n  }\n\n  updateLocalUnEvalTree(dataTree: DataTree) {\n    //add functions and variables to unevalTree\n    Object.keys(this.currentJSCollectionState).forEach((update) => {\n      const updates = this.currentJSCollectionState[update];\n      if (!!dataTree[update]) {\n        Object.keys(updates).forEach((key) => {\n          const data = get(dataTree, `${update}.${key}.data`, undefined);\n          if (isJSObjectFunction(dataTree, update, key)) {\n            set(dataTree, `${update}.${key}`, new String(updates[key]));\n            set(dataTree, `${update}.${key}.data`, data);\n          } else {\n            set(dataTree, `${update}.${key}`, updates[key]);\n          }\n        });\n      }\n    });\n  }\n\n  /**\n   * Method to create all data required for linting and\n   * evaluation of the updated tree\n   */\n\n  setupUpdateTree(\n    unEvalTree: DataTree,\n  ): {\n    unEvalUpdates: DataTreeDiff[];\n    evalOrder: string[];\n    lintOrder: string[];\n    jsUpdates: Record<string, JSUpdate>;\n    nonDynamicFieldValidationOrder: string[];\n    pathsToClearErrorsFor: any[];\n  } {\n    const totalUpdateTreeSetupStartTime = performance.now();\n\n    let localUnEvalTree = Object.assign({}, unEvalTree);\n    let jsUpdates: Record<string, JSUpdate> = {};\n    const diffCheckTimeStartTime = performance.now();\n    //update uneval tree from previously saved current state of collection\n    this.updateLocalUnEvalTree(localUnEvalTree);\n    //get difference in js collection body to be parsed\n    const oldUnEvalTreeJSCollections = getJSEntities(this.oldUnEvalTree);\n    const localUnEvalTreeJSCollection = getJSEntities(localUnEvalTree);\n    const jsDifferences: Diff<\n      Record<string, DataTreeJSAction>,\n      Record<string, DataTreeJSAction>\n    >[] = diff(oldUnEvalTreeJSCollections, localUnEvalTreeJSCollection) || [];\n    const jsTranslatedDiffs = flatten(\n      jsDifferences.map((diff) =>\n        translateDiffEventToDataTreeDiffEvent(diff, localUnEvalTree),\n      ),\n    );\n    //save parsed functions in resolveJSFunctions, update current state of js collection\n    const parsedCollections = parseJSActions(\n      this,\n      localUnEvalTree,\n      jsTranslatedDiffs,\n      this.oldUnEvalTree,\n    );\n\n    jsUpdates = parsedCollections.jsUpdates;\n    //update local data tree if js body has updated (remove/update/add js functions or variables)\n    localUnEvalTree = getUpdatedLocalUnEvalTreeAfterJSUpdates(\n      jsUpdates,\n      localUnEvalTree,\n    );\n\n    const stringifiedOldUnEvalTreeJSCollections = convertJSFunctionsToString(\n      oldUnEvalTreeJSCollections,\n    );\n    const stringifiedLocalUnEvalTreeJSCollection = convertJSFunctionsToString(\n      localUnEvalTreeJSCollection,\n    );\n\n    const oldUnEvalTreeWithStrigifiedJSFunctions = Object.assign(\n      {},\n      this.oldUnEvalTree,\n      stringifiedOldUnEvalTreeJSCollections,\n    );\n\n    const localUnEvalTreeWithStrigifiedJSFunctions = Object.assign(\n      {},\n      localUnEvalTree,\n      stringifiedLocalUnEvalTreeJSCollection,\n    );\n\n    const differences: Diff<DataTree, DataTree>[] =\n      diff(\n        oldUnEvalTreeWithStrigifiedJSFunctions,\n        localUnEvalTreeWithStrigifiedJSFunctions,\n      ) || [];\n    // Since eval tree is listening to possible events that don't cause differences\n    // We want to check if no diffs are present and bail out early\n    if (differences.length === 0) {\n      return {\n        pathsToClearErrorsFor: [],\n        unEvalUpdates: [],\n        evalOrder: [],\n        lintOrder: [],\n        jsUpdates: {},\n        nonDynamicFieldValidationOrder: [],\n      };\n    }\n    //find all differences which can lead to updating of dependency map\n    const translatedDiffs = flatten(\n      differences.map((diff) =>\n        translateDiffEventToDataTreeDiffEvent(diff, localUnEvalTree),\n      ),\n    );\n    const diffCheckTimeStopTime = performance.now();\n    this.logs.push({\n      differences,\n      translatedDiffs,\n    });\n    const updateDependencyStartTime = performance.now();\n    // Find all the paths that have changed as part of the difference and update the\n    // global dependency map if an existing dynamic binding has now become legal\n    const {\n      dependenciesOfRemovedPaths,\n      extraPathsToLint,\n      pathsToClearErrorsFor,\n      removedPaths,\n    } = updateDependencyMap({\n      dataTreeEvalRef: this,\n      translatedDiffs,\n      unEvalDataTree: localUnEvalTree,\n    });\n    const updateDependencyEndTime = performance.now();\n\n    this.applyDifferencesToEvalTree({ differences, localUnEvalTree });\n\n    const calculateSortOrderStartTime = performance.now();\n    const subTreeSortOrder: string[] = this.calculateSubTreeSortOrder(\n      differences,\n      dependenciesOfRemovedPaths,\n      removedPaths,\n      localUnEvalTree,\n    );\n    const calculateSortOrderEndTime = performance.now();\n    // Remove anything from the sort order that is not a dynamic leaf since only those need evaluation\n    const evaluationOrder: string[] = [];\n    let nonDynamicFieldValidationOrderSet = new Set<string>();\n\n    subTreeSortOrder.filter((propertyPath) => {\n      // We are setting all values from our uneval tree to the old eval tree we have\n      // So that the actual uneval value can be evaluated\n      if (isDynamicLeaf(localUnEvalTree, propertyPath)) {\n        const unEvalPropValue = get(localUnEvalTree, propertyPath);\n        const evalPropValue = get(this.evalTree, propertyPath);\n        if (!isFunction(evalPropValue)) {\n          set(this.evalTree, propertyPath, unEvalPropValue);\n        }\n        evaluationOrder.push(propertyPath);\n      } else {\n        /**\n         * if the non dynamic value changes that should trigger revalidation like tabs.tabsObj then we store it in nonDynamicFieldValidationOrderSet\n         */\n        if (this.inverseValidationDependencyMap[propertyPath]) {\n          nonDynamicFieldValidationOrderSet = new Set([\n            ...nonDynamicFieldValidationOrderSet,\n            propertyPath,\n          ]);\n        }\n      }\n    });\n\n    this.logs.push({\n      sortedDependencies: this.sortedDependencies,\n      inverse: this.inverseDependencyMap,\n      updatedDependencyMap: this.dependencyMap,\n      evaluationOrder: evaluationOrder,\n    });\n\n    // Remove any deleted paths from the eval tree\n    removedPaths.forEach((removedPath) => {\n      unset(this.evalTree, removedPath);\n    });\n\n    const cloneStartTime = performance.now();\n    // TODO: For some reason we are passing some reference which are getting mutated.\n    // Need to check why big api responses are getting split between two eval runs\n    this.oldUnEvalTree = klona(localUnEvalTree);\n    const cloneEndTime = performance.now();\n\n    const totalUpdateTreeSetupEndTime = performance.now();\n\n    const timeTakenForSetupUpdateTree = {\n      total: getFixedTimeDifference(\n        totalUpdateTreeSetupEndTime,\n        totalUpdateTreeSetupStartTime,\n      ),\n      updateDependencyMap: getFixedTimeDifference(\n        updateDependencyEndTime,\n        updateDependencyStartTime,\n      ),\n      calculateSubTreeSortOrder: getFixedTimeDifference(\n        calculateSortOrderEndTime,\n        calculateSortOrderStartTime,\n      ),\n      findDifferences: getFixedTimeDifference(\n        diffCheckTimeStopTime,\n        diffCheckTimeStartTime,\n      ),\n      clone: getFixedTimeDifference(cloneEndTime, cloneStartTime),\n    };\n\n    this.logs.push({ timeTakenForSetupUpdateTree });\n\n    return {\n      unEvalUpdates: translatedDiffs,\n      evalOrder: evaluationOrder,\n      lintOrder: union(evaluationOrder, extraPathsToLint),\n      jsUpdates,\n      nonDynamicFieldValidationOrder: Array.from(\n        nonDynamicFieldValidationOrderSet,\n      ),\n      pathsToClearErrorsFor,\n    };\n  }\n\n  evalAndValidateSubTree(\n    evaluationOrder: string[],\n    nonDynamicFieldValidationOrder: string[],\n    unevalUpdates: DataTreeDiff[],\n    metaWidgetIds: string[] = [],\n  ): {\n    evalMetaUpdates: EvalMetaUpdates;\n    staleMetaIds: string[];\n  } {\n    const evaluationStartTime = performance.now();\n    const {\n      evalMetaUpdates,\n      evaluatedTree: newEvalTree,\n      staleMetaIds,\n    } = this.evaluateTree(\n      this.evalTree,\n      this.resolvedFunctions,\n      evaluationOrder,\n      {\n        skipRevalidation: false,\n        isFirstTree: false,\n        unevalUpdates,\n        metaWidgets: metaWidgetIds,\n      },\n    );\n    const evaluationEndTime = performance.now();\n    const reValidateStartTime = performance.now();\n    this.reValidateTree(nonDynamicFieldValidationOrder, newEvalTree);\n    const reValidateEndTime = performance.now();\n    this.setEvalTree(newEvalTree);\n    const timeTakenForEvalAndValidateSubTree = {\n      evaluation: getFixedTimeDifference(\n        evaluationEndTime,\n        evaluationStartTime,\n      ),\n      revalidation: getFixedTimeDifference(\n        reValidateEndTime,\n        reValidateStartTime,\n      ),\n    };\n    this.logs.push({ timeTakenForEvalAndValidateSubTree });\n    return {\n      evalMetaUpdates,\n      staleMetaIds,\n    };\n  }\n\n  getCompleteSortOrder(\n    changes: Array<string>,\n    inverseMap: DependencyMap,\n  ): Array<string> {\n    let finalSortOrder: Array<string> = [];\n    let computeSortOrder = true;\n    // Initialize parents with the current sent of property paths that need to be evaluated\n    let parents = changes;\n    let subSortOrderArray: Array<string>;\n    while (computeSortOrder) {\n      // Get all the nodes that would be impacted by the evaluation of the nodes in parents array in sorted order\n      subSortOrderArray = this.getEvaluationSortOrder(parents, inverseMap);\n\n      // Add all the sorted nodes in the final list\n      finalSortOrder = [...finalSortOrder, ...subSortOrderArray];\n\n      parents = getImmediateParentsOfPropertyPaths(subSortOrderArray);\n      // If we find parents of the property paths in the sorted array, we should continue finding all the nodes dependent\n      // on the parents\n      computeSortOrder = parents.length > 0;\n    }\n\n    // Remove duplicates from this list. Since we explicitly walk down the tree and implicitly (by fetching parents) walk\n    // up the tree, there are bound to be many duplicates.\n    const uniqueKeysInSortOrder = new Set(finalSortOrder);\n\n    // if a property path evaluation gets triggered by diff top order changes\n    // this could lead to incorrect sort order in spite of the bfs traversal\n    const sortOrderPropertyPaths: string[] = [];\n    this.sortedDependencies.forEach((path) => {\n      if (uniqueKeysInSortOrder.has(path)) {\n        sortOrderPropertyPaths.push(path);\n        // remove from the uniqueKeysInSortOrder\n        uniqueKeysInSortOrder.delete(path);\n      }\n    });\n    // Add any remaining paths in the uniqueKeysInSortOrder\n    const completeSortOrder = [\n      ...Array.from(uniqueKeysInSortOrder),\n      ...sortOrderPropertyPaths,\n    ];\n\n    //Trim this list to now remove the property paths which are simply entity names\n    const finalSortOrderArray: Array<string> = [];\n    completeSortOrder.forEach((propertyPath) => {\n      const lastIndexOfDot = propertyPath.lastIndexOf(\".\");\n      // Only do this for property paths and not the entity themselves\n      if (lastIndexOfDot !== -1) {\n        finalSortOrderArray.push(propertyPath);\n      }\n    });\n\n    return finalSortOrderArray;\n  }\n\n  getEvaluationSortOrder(\n    changes: Array<string>,\n    inverseMap: DependencyMap,\n  ): Array<string> {\n    const sortOrder: Array<string> = [...changes];\n    let iterator = 0;\n    while (iterator < sortOrder.length) {\n      // Find all the nodes who are to be evaluated when sortOrder[iterator] changes\n      const newNodes = inverseMap[sortOrder[iterator]];\n\n      // If we find more nodes that would be impacted by the evaluation of the node being investigated\n      // we add these to the sort order.\n      if (newNodes) {\n        newNodes.forEach((toBeEvaluatedNode) => {\n          // Only add the nodes if they haven't been already added for evaluation in the list. Since we are doing\n          // breadth first traversal, we should be safe in not changing the evaluation order and adding this now at this\n          // point instead of the previous index found.\n          if (!sortOrder.includes(toBeEvaluatedNode)) {\n            sortOrder.push(toBeEvaluatedNode);\n          }\n        });\n      }\n      iterator++;\n    }\n    return sortOrder;\n  }\n\n  getPrivateWidgets(dataTree: DataTree): PrivateWidgets {\n    let privateWidgets: PrivateWidgets = {};\n    Object.keys(dataTree).forEach((entityName) => {\n      const entity = dataTree[entityName];\n      if (isWidget(entity) && !isEmpty(entity.privateWidgets)) {\n        privateWidgets = {\n          ...privateWidgets,\n          ...entity.privateWidgets,\n        };\n      }\n    });\n    return privateWidgets;\n  }\n\n  evaluateTree(\n    oldUnevalTree: DataTree,\n    resolvedFunctions: Record<string, any>,\n    sortedDependencies: Array<string>,\n    options: {\n      skipRevalidation: boolean;\n      isFirstTree: boolean;\n      unevalUpdates: DataTreeDiff[];\n      metaWidgets: string[];\n    } = {\n      skipRevalidation: true,\n      isFirstTree: true,\n      unevalUpdates: [],\n      metaWidgets: [],\n    },\n  ): {\n    evaluatedTree: DataTree;\n    evalMetaUpdates: EvalMetaUpdates;\n    staleMetaIds: string[];\n  } {\n    const tree = klona(oldUnevalTree);\n    errorModifier.updateAsyncFunctions(tree);\n    const evalMetaUpdates: EvalMetaUpdates = [];\n    const {\n      isFirstTree,\n      metaWidgets,\n      skipRevalidation,\n      unevalUpdates,\n    } = options;\n    let staleMetaIds: string[] = [];\n    try {\n      const evaluatedTree = sortedDependencies.reduce(\n        (currentTree: DataTree, fullPropertyPath: string) => {\n          const { entityName, propertyPath } = getEntityNameAndPropertyPath(\n            fullPropertyPath,\n          );\n          const entity = currentTree[entityName] as\n            | DataTreeWidget\n            | DataTreeAction;\n          const unEvalPropertyValue = get(currentTree as any, fullPropertyPath);\n\n          const isADynamicBindingPath =\n            (isAction(entity) || isWidget(entity) || isJSAction(entity)) &&\n            isPathADynamicBinding(entity, propertyPath);\n          const isATriggerPath =\n            isWidget(entity) && isPathDynamicTrigger(entity, propertyPath);\n          let evalPropertyValue;\n          const requiresEval =\n            isADynamicBindingPath &&\n            !isATriggerPath &&\n            (isDynamicValue(unEvalPropertyValue) || isJSAction(entity));\n          if (propertyPath) {\n            set(this.evalProps, getEvalErrorPath(fullPropertyPath), []);\n          }\n          if (requiresEval) {\n            const evaluationSubstitutionType =\n              entity.reactivePaths[propertyPath] ||\n              EvaluationSubstitutionType.TEMPLATE;\n\n            const contextData: EvaluateContext = {};\n            if (isAction(entity)) {\n              contextData.thisContext = {\n                params: {},\n              };\n            }\n            try {\n              evalPropertyValue = this.getDynamicValue(\n                unEvalPropertyValue,\n                currentTree,\n                resolvedFunctions,\n                evaluationSubstitutionType,\n                contextData,\n                undefined,\n                fullPropertyPath,\n              );\n            } catch (error) {\n              this.errors.push({\n                type: EvalErrorTypes.EVAL_PROPERTY_ERROR,\n                message: (error as Error).message,\n                context: {\n                  propertyPath: fullPropertyPath,\n                },\n              });\n              evalPropertyValue = undefined;\n            }\n          } else {\n            evalPropertyValue = unEvalPropertyValue;\n          }\n          if (isWidget(entity) && !isATriggerPath) {\n            const isNewWidget =\n              isFirstTree || isNewEntity(unevalUpdates, entityName);\n            if (propertyPath) {\n              const parsedValue = validateAndParseWidgetProperty({\n                fullPropertyPath,\n                widget: entity,\n                currentTree,\n                evalPropertyValue,\n                unEvalPropertyValue,\n                evalProps: this.evalProps,\n              });\n\n              this.setParsedValue({\n                currentTree,\n                entity,\n                evalMetaUpdates,\n                fullPropertyPath,\n                parsedValue,\n                propertyPath,\n                evalPropertyValue,\n                isNewWidget,\n              });\n\n              if (!skipRevalidation) {\n                this.reValidateWidgetDependentProperty({\n                  fullPropertyPath,\n                  widget: entity,\n                  currentTree,\n                });\n              }\n              staleMetaIds = staleMetaIds.concat(\n                getStaleMetaStateIds({\n                  entity,\n                  propertyPath,\n                  isNewWidget,\n                  metaWidgets,\n                }),\n              );\n\n              return currentTree;\n            }\n            return set(currentTree, fullPropertyPath, evalPropertyValue);\n          } else if (isATriggerPath) {\n            return currentTree;\n          } else if (isAction(entity)) {\n            if (this.allActionValidationConfig) {\n              const configProperty = propertyPath.replace(\n                \"config\",\n                \"actionConfiguration\",\n              );\n              const validationConfig =\n                !!this.allActionValidationConfig[entity.actionId] &&\n                this.allActionValidationConfig[entity.actionId][configProperty];\n              if (!!validationConfig && !isEmpty(validationConfig)) {\n                this.validateActionProperty(\n                  fullPropertyPath,\n                  entity,\n                  currentTree,\n                  evalPropertyValue,\n                  unEvalPropertyValue,\n                  validationConfig,\n                );\n              }\n            }\n\n            if (!propertyPath) return currentTree;\n            set(\n              this.evalProps,\n              getEvalValuePath(fullPropertyPath),\n              evalPropertyValue,\n            );\n            set(currentTree, fullPropertyPath, evalPropertyValue);\n            return currentTree;\n          } else if (isJSAction(entity)) {\n            const variableList: Array<string> = get(entity, \"variables\") || [];\n            if (variableList.indexOf(propertyPath) > -1) {\n              const currentEvaluatedValue = get(\n                this.evalProps,\n                getEvalValuePath(fullPropertyPath, {\n                  isPopulated: true,\n                  fullPath: true,\n                }),\n              );\n              if (!currentEvaluatedValue) {\n                set(\n                  this.evalProps,\n                  getEvalValuePath(fullPropertyPath, {\n                    isPopulated: true,\n                    fullPath: true,\n                  }),\n                  evalPropertyValue,\n                );\n                set(currentTree, fullPropertyPath, evalPropertyValue);\n              } else {\n                set(currentTree, fullPropertyPath, currentEvaluatedValue);\n              }\n            }\n            return currentTree;\n          } else {\n            return set(currentTree, fullPropertyPath, evalPropertyValue);\n          }\n        },\n        tree,\n      );\n\n      return {\n        evaluatedTree,\n        evalMetaUpdates,\n        staleMetaIds: staleMetaIds,\n      };\n    } catch (error) {\n      this.errors.push({\n        type: EvalErrorTypes.EVAL_TREE_ERROR,\n        message: (error as Error).message,\n      });\n      return { evaluatedTree: tree, evalMetaUpdates, staleMetaIds: [] };\n    }\n  }\n\n  setAllActionValidationConfig(allActionValidationConfig: {\n    [actionId: string]: ActionValidationConfigMap;\n  }): void {\n    this.allActionValidationConfig = allActionValidationConfig;\n  }\n\n  sortDependencies(\n    dependencyMap: DependencyMap,\n    diffs?: (DataTreeDiff | DataTreeDiff[])[],\n  ): Array<string> {\n    /**\n     * dependencyTree : Array<[Node, dependentNode]>\n     */\n    const dependencyTree: Array<[string, string]> = [];\n    Object.keys(dependencyMap).forEach((key: string) => {\n      if (dependencyMap[key].length) {\n        dependencyMap[key].forEach((dep) => dependencyTree.push([key, dep]));\n      } else {\n        // Set no dependency\n        dependencyTree.push([key, \"\"]);\n      }\n    });\n\n    try {\n      return toposort(dependencyTree)\n        .reverse()\n        .filter((d) => !!d);\n    } catch (error) {\n      // Cyclic dependency found. Extract all node and entity type\n      const cyclicNodes = (error as Error).message.match(\n        new RegExp('Cyclic dependency, node was:\"(.*)\"'),\n      );\n\n      const node = cyclicNodes?.length ? cyclicNodes[1] : \"\";\n\n      let entityType = \"UNKNOWN\";\n      const entityName = node.split(\".\")[0];\n      const entity = get(this.oldUnEvalTree, entityName);\n      if (entity && isWidget(entity)) {\n        entityType = entity.type;\n      } else if (entity && isAction(entity)) {\n        entityType = entity.pluginType;\n      } else if (entity && isJSAction(entity)) {\n        entityType = entity.ENTITY_TYPE;\n      }\n      this.errors.push({\n        type: EvalErrorTypes.CYCLICAL_DEPENDENCY_ERROR,\n        message: \"Cyclic dependency found while evaluating.\",\n        context: {\n          node,\n          entityType,\n          dependencyMap,\n          diffs,\n        },\n      });\n      logError(\"CYCLICAL DEPENDENCY MAP\", dependencyMap);\n      this.hasCyclicalDependency = true;\n      throw new CrashingError((error as Error).message);\n    }\n  }\n\n  getDynamicValue(\n    dynamicBinding: string,\n    data: DataTree,\n    resolvedFunctions: Record<string, any>,\n    evaluationSubstitutionType: EvaluationSubstitutionType,\n    contextData?: EvaluateContext,\n    callBackData?: Array<any>,\n    fullPropertyPath?: string,\n  ) {\n    // Get the {{binding}} bound values\n    let entity: DataTreeEntity | undefined = undefined;\n    let propertyPath: string;\n    if (fullPropertyPath) {\n      const entityName = fullPropertyPath.split(\".\")[0];\n      propertyPath = fullPropertyPath.split(\".\")[1];\n      entity = data[entityName];\n    }\n    // Get the {{binding}} bound values\n    const { jsSnippets, stringSegments } = getDynamicBindings(\n      dynamicBinding,\n      entity,\n    );\n    if (stringSegments.length) {\n      // Get the Data Tree value of those \"binding \"paths\n      const values = jsSnippets.map((jsSnippet, index) => {\n        const toBeSentForEval =\n          entity && isJSAction(entity) && propertyPath === \"body\"\n            ? jsSnippet.replace(/export default/g, \"\")\n            : jsSnippet;\n        if (jsSnippet) {\n          if (entity && !propertyPath.includes(\"body\")) {\n            ExecutionMetaData.setExecutionMetaData({\n              source: {\n                id: getEntityId(entity) || \"\",\n                entityType: getEntityType(entity) || ENTITY_TYPE.WIDGET,\n                name: getEntityName(entity) || \"\",\n              },\n              triggerPropertyName: fullPropertyPath?.split(\".\")[1] || \"\",\n            });\n          }\n\n          const result = this.evaluateDynamicBoundValue(\n            toBeSentForEval,\n            data,\n            resolvedFunctions,\n            !!entity && isJSAction(entity),\n            contextData,\n            callBackData,\n          );\n          if (fullPropertyPath && result.errors.length) {\n            addErrorToEntityProperty({\n              errors: result.errors,\n              evalProps: this.evalProps,\n              fullPropertyPath,\n              dataTree: data,\n            });\n          }\n          return result.result;\n        } else {\n          return stringSegments[index];\n        }\n      });\n\n      // We don't need to substitute template of the result if only one binding exists\n      // But it should not be of prepared statements since that does need a string\n      if (\n        stringSegments.length === 1 &&\n        evaluationSubstitutionType !== EvaluationSubstitutionType.PARAMETER\n      ) {\n        return values[0];\n      }\n      try {\n        // else return a combined value according to the evaluation type\n        return substituteDynamicBindingWithValues(\n          dynamicBinding,\n          stringSegments,\n          values,\n          evaluationSubstitutionType,\n        );\n      } catch (error) {\n        if (fullPropertyPath) {\n          addErrorToEntityProperty({\n            errors: [\n              {\n                raw: dynamicBinding,\n                errorType: PropertyEvaluationErrorType.PARSE,\n                errorMessage: {\n                  name: (error as Error).name,\n                  message: (error as Error).message,\n                },\n                severity: Severity.ERROR,\n              },\n            ],\n            evalProps: this.evalProps,\n            fullPropertyPath,\n            dataTree: data,\n          });\n        }\n        return undefined;\n      }\n    }\n    return undefined;\n  }\n\n  async evaluateTriggers(\n    userScript: string,\n    dataTree: DataTree,\n    resolvedFunctions: Record<string, any>,\n    callbackData: Array<unknown>,\n    context?: EvaluateContext,\n  ) {\n    const { jsSnippets } = getDynamicBindings(userScript);\n    return evaluateAsync(\n      jsSnippets[0] || userScript,\n      dataTree,\n      resolvedFunctions,\n      context,\n      callbackData,\n    );\n  }\n\n  // Paths are expected to have \"{name}.{path}\" signature\n  // Also returns any action triggers found after evaluating value\n  evaluateDynamicBoundValue(\n    js: string,\n    data: DataTree,\n    resolvedFunctions: Record<string, any>,\n    isJSObject: boolean,\n    contextData?: EvaluateContext,\n    callbackData?: Array<any>,\n  ): EvalResult {\n    try {\n      return evaluateSync(\n        js,\n        data,\n        resolvedFunctions,\n        isJSObject,\n        contextData,\n        callbackData,\n      );\n    } catch (error) {\n      return {\n        result: undefined,\n        errors: [\n          {\n            errorType: PropertyEvaluationErrorType.PARSE,\n            raw: js,\n            severity: Severity.ERROR,\n            errorMessage: {\n              name: (error as Error).name,\n              message: (error as Error).message,\n            },\n          },\n        ],\n      };\n    }\n  }\n\n  setParsedValue({\n    currentTree,\n    entity,\n    evalMetaUpdates,\n    evalPropertyValue,\n    fullPropertyPath,\n    isNewWidget,\n    parsedValue,\n    propertyPath,\n  }: {\n    currentTree: DataTree;\n    entity: DataTreeWidget;\n    evalMetaUpdates: EvalMetaUpdates;\n    fullPropertyPath: string;\n    isNewWidget: boolean;\n    parsedValue: unknown;\n    propertyPath: string;\n    evalPropertyValue: unknown;\n  }) {\n    const overwriteObj = overrideWidgetProperties({\n      entity,\n      propertyPath,\n      value: parsedValue,\n      currentTree,\n      evalMetaUpdates,\n      isNewWidget,\n    });\n\n    if (overwriteObj && overwriteObj.overwriteParsedValue) {\n      parsedValue = overwriteObj.newValue;\n    }\n    // setting parseValue in dataTree\n    set(currentTree, fullPropertyPath, parsedValue);\n    // setting evalPropertyValue in unParsedEvalTree\n    set(this.getUnParsedEvalTree(), fullPropertyPath, evalPropertyValue);\n  }\n\n  reValidateWidgetDependentProperty({\n    currentTree,\n    fullPropertyPath,\n    widget,\n  }: {\n    fullPropertyPath: string;\n    widget: DataTreeWidget;\n    currentTree: DataTree;\n  }) {\n    if (this.inverseValidationDependencyMap[fullPropertyPath]) {\n      const pathsToRevalidate = this.inverseValidationDependencyMap[\n        fullPropertyPath\n      ];\n      pathsToRevalidate.forEach((fullPath) => {\n        validateAndParseWidgetProperty({\n          fullPropertyPath: fullPath,\n          widget,\n          currentTree,\n          // we supply non-transformed evaluated value\n          evalPropertyValue: get(this.getUnParsedEvalTree(), fullPath),\n          unEvalPropertyValue: (get(\n            this.oldUnEvalTree,\n            fullPath,\n          ) as unknown) as string,\n          evalProps: this.evalProps,\n        });\n      });\n    }\n  }\n\n  reValidateTree(\n    nonDynamicFieldValidationOrder: string[],\n    currentTree: DataTree,\n  ) {\n    nonDynamicFieldValidationOrder.forEach((fullPropertyPath) => {\n      const { entityName, propertyPath } = getEntityNameAndPropertyPath(\n        fullPropertyPath,\n      );\n      const entity = currentTree[entityName];\n      if (isWidget(entity) && !isPathDynamicTrigger(entity, propertyPath)) {\n        this.reValidateWidgetDependentProperty({\n          widget: entity,\n          fullPropertyPath,\n          currentTree,\n        });\n      }\n    });\n  }\n\n  // validates the user input saved as action property based on a validationConfig\n  validateActionProperty(\n    fullPropertyPath: string,\n    action: DataTreeAction,\n    currentTree: DataTree,\n    evalPropertyValue: any,\n    unEvalPropertyValue: string,\n    validationConfig: ValidationConfig,\n  ) {\n    if (evalPropertyValue && validationConfig) {\n      // runs VALIDATOR function and returns errors\n      const { isValid, messages } = validateActionProperty(\n        validationConfig,\n        evalPropertyValue,\n      );\n      if (!isValid) {\n        const evalErrors: EvaluationError[] =\n          messages?.map((message) => {\n            return {\n              raw: unEvalPropertyValue,\n              errorMessage: message || { name: \"\", text: \"\" },\n              errorType: PropertyEvaluationErrorType.VALIDATION,\n              severity: Severity.ERROR,\n            };\n          }) ?? [];\n        // saves error in dataTree at fullPropertyPath\n        // Later errors can consumed by the forms and debugger\n        addErrorToEntityProperty({\n          errors: evalErrors,\n          evalProps: this.evalProps,\n          fullPropertyPath,\n          dataTree: currentTree,\n        });\n      }\n    }\n  }\n\n  /**\n   * Update the entity config set as prototype according to latest unEvalTree changes else code would consume stale configs.\n   *\n   * Example scenario: On addition of a JS binding to widget, it's dynamicBindingPathList changes and needs to be updated.\n   */\n  updateConfigForModifiedEntity(unEvalTree: DataTree, entityName: string) {\n    const unEvalEntity = unEvalTree[entityName];\n    // skip entity if entity is not present in the evalTree or is not a valid entity\n    if (!this.evalTree[entityName] || !isValidEntity(this.evalTree[entityName]))\n      return;\n    const entityConfig = Object.getPrototypeOf(unEvalEntity);\n    const newEntityObject = Object.create(entityConfig);\n    this.evalTree[entityName] = Object.assign(newEntityObject, {\n      ...this.evalTree[entityName],\n    });\n  }\n\n  applyDifferencesToEvalTree({\n    differences,\n    localUnEvalTree,\n  }: {\n    differences: Diff<any, any>[];\n    localUnEvalTree: DataTree;\n  }) {\n    for (const d of differences) {\n      if (!Array.isArray(d.path) || d.path.length === 0) continue; // Null check for typescript\n      // Apply the changes into the evalTree so that it gets the latest changes\n      applyChange(this.evalTree, undefined, d);\n      const { entityName } = getEntityNameAndPropertyPath(d.path.join(\".\"));\n      this.updateConfigForModifiedEntity(localUnEvalTree, entityName);\n    }\n  }\n\n  calculateSubTreeSortOrder(\n    differences: Diff<any, any>[],\n    dependenciesOfRemovedPaths: Array<string>,\n    removedPaths: Array<string>,\n    unEvalTree: DataTree,\n  ) {\n    const changePaths: Set<string> = new Set(dependenciesOfRemovedPaths);\n    for (const d of differences) {\n      if (!Array.isArray(d.path) || d.path.length === 0) continue; // Null check for typescript\n      changePaths.add(convertPathToString(d.path));\n      // If this is a property path change, simply add for evaluation and move on\n      if (!isDynamicLeaf(unEvalTree, convertPathToString(d.path))) {\n        // A parent level property has been added or deleted\n        /**\n         * We want to add all pre-existing dynamic and static bindings in dynamic paths of this entity to get evaluated and validated.\n         * Example:\n         * - Table1.tableData = {{Api1.data}}\n         * - Api1 gets created.\n         * - This function gets called with a diff {path:[\"Api1\"]}\n         * We want to add `Api.data` to changedPaths so that `Table1.tableData` can be discovered below.\n         */\n        const entityName = d.path[0];\n        const entity = unEvalTree[entityName];\n        if (!entity) {\n          continue;\n        }\n        if (!isAction(entity) && !isWidget(entity) && !isJSAction(entity)) {\n          continue;\n        }\n        let entityDynamicBindingPaths: string[] = [];\n        if (isAction(entity)) {\n          const entityDynamicBindingPathList = getEntityDynamicBindingPathList(\n            entity,\n          );\n          entityDynamicBindingPaths = entityDynamicBindingPathList.map(\n            (path) => {\n              return path.key;\n            },\n          );\n        }\n        const parentPropertyPath = convertPathToString(d.path);\n        Object.keys(entity.reactivePaths).forEach((relativePath) => {\n          const childPropertyPath = `${entityName}.${relativePath}`;\n          // Check if relative path has dynamic binding\n          if (\n            entityDynamicBindingPaths &&\n            entityDynamicBindingPaths.length &&\n            entityDynamicBindingPaths.includes(relativePath)\n          ) {\n            changePaths.add(childPropertyPath);\n          }\n          if (isChildPropertyPath(parentPropertyPath, childPropertyPath)) {\n            changePaths.add(childPropertyPath);\n          }\n        });\n      }\n    }\n\n    // If a nested property path has changed and someone (say x) is dependent on the parent of the said property,\n    // x must also be evaluated. For example, the following relationship exists in dependency map:\n    // <  \"Input1.defaultText\" : [\"Table1.selectedRow.email\"] >\n    // If Table1.selectedRow has changed, then Input1.defaultText must also be evaluated because Table1.selectedRow.email\n    // is a nested property of Table1.selectedRow\n    const changePathsWithNestedDependants = addDependantsOfNestedPropertyPaths(\n      Array.from(changePaths),\n      this.inverseDependencyMap,\n    );\n\n    const trimmedChangedPaths = trimDependantChangePaths(\n      changePathsWithNestedDependants,\n      this.dependencyMap,\n    );\n\n    // Now that we have all the root nodes which have to be evaluated, recursively find all the other paths which\n    // would get impacted because they are dependent on the said root nodes and add them in order\n    const completeSortOrder = this.getCompleteSortOrder(\n      trimmedChangedPaths,\n      this.inverseDependencyMap,\n    );\n    // Remove any paths that do not exist in the data tree anymore\n    return difference(completeSortOrder, removedPaths);\n  }\n\n  getInverseDependencyTree(\n    params = {\n      dependencyMap: this.dependencyMap,\n      sortedDependencies: this.sortedDependencies,\n    },\n  ): DependencyMap {\n    const { dependencyMap, sortedDependencies } = params;\n    const inverseDependencyMap: DependencyMap = {};\n    sortedDependencies.forEach((propertyPath) => {\n      const incomingEdges: Array<string> = dependencyMap[propertyPath];\n      if (incomingEdges) {\n        incomingEdges.forEach((edge) => {\n          const node = inverseDependencyMap[edge];\n          if (node) {\n            node.push(propertyPath);\n          } else {\n            inverseDependencyMap[edge] = [propertyPath];\n          }\n        });\n      }\n    });\n    return inverseDependencyMap;\n  }\n\n  evaluateActionBindings(\n    bindings: string[],\n    executionParams?: Record<string, unknown> | string,\n  ) {\n    // We might get execution params as an object or as a string.\n    // If the user has added a proper object (valid case) it will be an object\n    // If they have not added any execution params or not an object\n    // it would be a string (invalid case)\n    let evaluatedExecutionParams: Record<string, any> = {};\n    if (executionParams && isObject(executionParams)) {\n      evaluatedExecutionParams = this.getDynamicValue(\n        `{{${JSON.stringify(executionParams)}}}`,\n        this.evalTree,\n        this.resolvedFunctions,\n        EvaluationSubstitutionType.TEMPLATE,\n      );\n    }\n\n    return bindings.map((binding) => {\n      // Replace any reference of 'this.params' to 'executionParams' (backwards compatibility)\n      // also helps with dealing with IIFE which are normal functions (not arrow)\n      // because normal functions won't retain 'this' context (when executed elsewhere)\n      const replacedBinding = binding.replace(\n        EXECUTION_PARAM_REFERENCE_REGEX,\n        EXECUTION_PARAM_KEY,\n      );\n      return this.getDynamicValue(\n        `{{${replacedBinding}}}`,\n        this.evalTree,\n        this.resolvedFunctions,\n        EvaluationSubstitutionType.TEMPLATE,\n        // params can be accessed via \"this.params\" or \"executionParams\"\n        {\n          thisContext: {\n            [THIS_DOT_PARAMS_KEY]: evaluatedExecutionParams,\n          },\n          globalContext: {\n            [EXECUTION_PARAM_KEY]: evaluatedExecutionParams,\n          },\n        },\n      );\n    });\n  }\n\n  clearErrors() {\n    this.errors = [];\n  }\n  clearLogs() {\n    this.logs = [];\n  }\n}\n\n// TODO cryptic comment below. Dont know if we still need this. Duplicate function\n// referencing DATA_BIND_REGEX fails for the value \"{{Table1.tableData[Table1.selectedRowIndex]}}\" if you run it multiple times and don't recreate\nconst isDynamicValue = (value: string): boolean => DATA_BIND_REGEX.test(value);\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport {\n  ValidationTypes,\n  ValidationResponse,\n  Validator,\n} from \"constants/WidgetValidation\";\nimport _, {\n  compact,\n  get,\n  isArray,\n  isObject,\n  isPlainObject,\n  isRegExp,\n  isString,\n  toString,\n  uniq,\n  __,\n} from \"lodash\";\n\nimport moment from \"moment\";\nimport { ValidationConfig } from \"constants/PropertyControlConstants\";\nimport evaluate from \"./evaluate\";\n\nimport getIsSafeURL from \"utils/validation/getIsSafeURL\";\nimport * as log from \"loglevel\";\nimport { countOccurrences, findDuplicateIndex } from \"./helpers\";\n\nexport const UNDEFINED_VALIDATION = \"UNDEFINED_VALIDATION\";\nexport const VALIDATION_ERROR_COUNT_THRESHOLD = 10;\nconst MAX_ALLOWED_LINE_BREAKS = 1000; // Rendering performance deteriorates beyond this number.\nconst LINE_BREAKS_ERROR_MESSAGE = `Warning: New lines in the text exceed ${MAX_ALLOWED_LINE_BREAKS}. The text displayed will not contain any new lines.`;\n\nconst flat = (array: Record<string, any>[], uniqueParam: string) => {\n  let result: { value: string }[] = [];\n  array.forEach((a) => {\n    result.push({ value: a[uniqueParam] });\n    if (Array.isArray(a.children)) {\n      result = result.concat(flat(a.children, uniqueParam));\n    }\n  });\n  return result;\n};\n\nfunction getPropertyEntry(\n  obj: Record<string, unknown>,\n  name: string,\n  ignoreCase = false,\n) {\n  if (!ignoreCase) {\n    return name;\n  } else {\n    const keys = Object.getOwnPropertyNames(obj);\n    return keys.find((key) => key.toLowerCase() === name.toLowerCase()) || name;\n  }\n}\n\nfunction validatePlainObject(\n  config: ValidationConfig,\n  value: Record<string, unknown>,\n  props: Record<string, unknown>,\n  propertyPath: string,\n) {\n  if (config.params?.allowedKeys) {\n    let _valid = true;\n    const _messages: Error[] = [];\n    config.params.allowedKeys.forEach((entry) => {\n      const ignoreCase = !!entry.params?.ignoreCase;\n      const entryName = getPropertyEntry(value, entry.name, ignoreCase);\n\n      if (value.hasOwnProperty(entryName)) {\n        const { isValid, messages, parsed } = validate(\n          entry,\n          value[entryName],\n          props,\n          propertyPath,\n        );\n        if (!isValid) {\n          value[entryName] = parsed;\n          _valid = isValid;\n          messages &&\n            messages.map((message) => {\n              _messages.push({\n                name: message.name,\n                message: `Value of key: ${entryName} is invalid: ${message.message}`,\n              });\n            });\n        }\n      } else if (entry.params?.required || entry.params?.requiredKey) {\n        _valid = false;\n        _messages.push({\n          name: \"ValidationError\",\n          message: `Missing required key: ${entryName}`,\n        });\n      }\n    });\n    if (_valid) {\n      return {\n        isValid: true,\n        parsed: value,\n      };\n    }\n    return {\n      isValid: false,\n      parsed: config.params?.default || value,\n      messages: _messages,\n    };\n  }\n  return {\n    isValid: true,\n    parsed: value,\n  };\n}\n\nfunction validateArray(\n  config: ValidationConfig,\n  value: unknown[],\n  props: Record<string, unknown>,\n  propertyPath: string,\n) {\n  let _isValid = true; // Let's first assume that this is valid\n  const _messages: Error[] = []; // Initialise messages array\n\n  // Values allowed in the array, converted into a set of unique values\n  // or an empty set\n  const allowedValues = new Set(config.params?.allowedValues || []);\n\n  // Keys whose values are supposed to be unique across all values in all objects in the array\n  let uniqueKeys: Array<string> = [];\n  const allowedKeyConfigs = config.params?.children?.params?.allowedKeys;\n  if (\n    config.params?.children?.type === ValidationTypes.OBJECT &&\n    Array.isArray(allowedKeyConfigs) &&\n    allowedKeyConfigs.length\n  ) {\n    uniqueKeys = compact(\n      allowedKeyConfigs.map((allowedKeyConfig) => {\n        // TODO(abhinav): This is concerning, we now have two ways,\n        // in which we can define unique keys in an array of objects\n        // We need to disable one option.\n\n        // If this key is supposed to be unique across all objects in the value array\n        // We include it in the uniqueKeys list\n        if (allowedKeyConfig.params?.unique) return allowedKeyConfig.name;\n      }),\n    );\n  }\n\n  // Concatenate unique keys from config.params?.unique\n  uniqueKeys = Array.isArray(config.params?.unique)\n    ? uniqueKeys.concat(config.params?.unique as Array<string>)\n    : uniqueKeys;\n\n  // Validation configuration for children\n  const childrenValidationConfig = config.params?.children;\n\n  // Should we validate against disallowed values in the value array?\n  const shouldVerifyAllowedValues = !!allowedValues.size; // allowedValues is a set\n\n  // Do we have validation config for array children?\n  const shouldValidateChildren = !!childrenValidationConfig;\n\n  // Should array values be unique? This should applies only to primitive values in array children\n  // If we have to validate children with their own validation config, this should be false (Needs verification)\n  // If this option is true, shouldArrayValuesHaveUniqueValuesForKeys will become false\n  const shouldArrayHaveUniqueEntries = config.params?.unique === true;\n\n  // Should we validate for unique values for properties in the array entries?\n  const shouldArrayValuesHaveUniqueValuesForKeys =\n    !!uniqueKeys.length && !shouldArrayHaveUniqueEntries;\n\n  // Verify if all values are unique\n  if (shouldArrayHaveUniqueEntries) {\n    // Find the index of a duplicate value in array\n    const duplicateIndex = findDuplicateIndex(value);\n    if (duplicateIndex !== -1) {\n      // Bail out early\n      // Because, we don't want to re-iterate, if this validation fails\n      return {\n        isValid: false,\n        parsed: config.params?.default || [],\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: `Array must be unique. Duplicate values found at index: ${duplicateIndex}`,\n          },\n        ],\n      };\n    }\n  }\n\n  if (shouldArrayValuesHaveUniqueValuesForKeys) {\n    // Loop\n    // Get only unique entries from the value array\n    const uniqueEntries = _.uniqWith(\n      value as Array<Record<string, unknown>>,\n      (a: Record<string, unknown>, b: Record<string, unknown>) => {\n        // If any of the keys are the same, we fail the uniqueness test\n        return uniqueKeys.some((key) => a[key] === b[key]);\n      },\n    );\n\n    if (uniqueEntries.length !== value.length) {\n      // Bail out early\n      // Because, we don't want to re-iterate, if this validation fails\n      return {\n        isValid: false,\n        parsed: config.params?.default || [],\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: `Duplicate values found for the following properties, in the array entries, that must be unique -- ${uniqueKeys.join(\n              \",\",\n            )}.`,\n          },\n        ],\n      };\n    }\n  }\n\n  // Loop\n  value.every((entry, index) => {\n    // Validate for allowed values\n    if (shouldVerifyAllowedValues && !allowedValues.has(entry)) {\n      _messages.push({\n        name: \"ValidationError\",\n        message: `Value is not allowed in this array: ${entry}`,\n      });\n      _isValid = false;\n    }\n\n    // validate using validation config\n    if (shouldValidateChildren && childrenValidationConfig) {\n      // Validate this entry\n      const childValidationResult = validate(\n        childrenValidationConfig,\n        entry,\n        props,\n        `${propertyPath}[${index}]`,\n      );\n\n      // If invalid, append to messages\n      if (!childValidationResult.isValid) {\n        _isValid = false;\n        childValidationResult.messages?.forEach((message) =>\n          _messages.push({\n            name: message.name,\n            message: `Invalid entry at index: ${index}. ${message.message}`,\n          }),\n        );\n      }\n    }\n\n    // Bail out, if the error count threshold has been overcome\n    // This way, debugger will not have to render too many errors\n    if (_messages.length >= VALIDATION_ERROR_COUNT_THRESHOLD && !_isValid) {\n      return false;\n    }\n    return true;\n  });\n\n  return {\n    isValid: _isValid,\n    parsed: _isValid ? value : config.params?.default || [],\n    messages: _messages,\n  };\n}\n\nfunction validateExcessLineBreaks(value: any): boolean {\n  /**\n   * Check if the value exceeds a threshold number of line breaks;\n   * beyond which the rendering performance starts deteriorating.\n   */\n  const str: string = isObject(value) ? JSON.stringify(value, null, 2) : value;\n  const lineBreakCount: number = countOccurrences(\n    str,\n    \"\\n\",\n    false,\n    MAX_ALLOWED_LINE_BREAKS,\n  );\n  return lineBreakCount > MAX_ALLOWED_LINE_BREAKS;\n}\n\nfunction validateExcessLength(text: string, maxLength: number): boolean {\n  /**\n   * Check if text is too long and without any line breaks.\n   */\n  const lineBreakCount = countOccurrences(text, \"\\n\", false, 0);\n  return lineBreakCount === 0 && text.length > maxLength;\n}\n\n/**\n * Iterate through an object,\n * Check for length of string values\n * and trim them in case they are too long.\n */\nfunction validateObjectValues(obj: any): any {\n  if (!obj) return;\n  Object.keys(obj).forEach((key) => {\n    if (typeof obj[key] === \"string\" && obj[key].length > 100000) {\n      obj[key] = obj[key].substring(0, 100000);\n    } else if (isObject(obj[key])) {\n      obj[key] = validateObjectValues(obj[key]);\n    } else if (isArray(obj[key])) {\n      obj[key] = obj[key].map((item: any) => validateObjectValues(item));\n    }\n  });\n  return obj;\n}\n\n//TODO: parameter props may not be in use\nexport const validate = (\n  config: ValidationConfig,\n  value: unknown,\n  props: Record<string, unknown>,\n  propertyPath = \"\",\n): ValidationResponse => {\n  const validateFn = VALIDATORS[config.type];\n  const staticValue = {\n    isValid: true,\n    parsed: value,\n  };\n  if (!validateFn) return staticValue;\n\n  return validateFn(config, value, props, propertyPath) || staticValue;\n};\n\nexport const WIDGET_TYPE_VALIDATION_ERROR =\n  \"This value does not evaluate to type\"; // TODO: Lot's of changes in validations.ts file\n\nexport function getExpectedType(config?: ValidationConfig): string | undefined {\n  if (!config) return UNDEFINED_VALIDATION; // basic fallback\n  switch (config.type) {\n    case ValidationTypes.FUNCTION:\n      return config.params?.expected?.type || \"unknown\";\n    case ValidationTypes.TEXT:\n      let result = \"string\";\n      if (config.params?.allowedValues) {\n        const allowed = config.params.allowedValues.join(\" | \");\n        result = result + ` ( ${allowed} )`;\n      }\n      if (config.params?.regex) {\n        result = config.params?.regex.source;\n      }\n      if (config.params?.expected?.type) result = config.params?.expected.type;\n      return result;\n    case ValidationTypes.REGEX:\n      return \"regExp\";\n    case ValidationTypes.DATE_ISO_STRING:\n      return \"ISO 8601 date string\";\n    case ValidationTypes.BOOLEAN:\n      return \"boolean\";\n    case ValidationTypes.NUMBER:\n      let validationType = \"number\";\n      if (config.params?.min) {\n        validationType = `${validationType} Min: ${config.params?.min}`;\n      }\n      if (config.params?.max) {\n        validationType = `${validationType} Max: ${config.params?.max}`;\n      }\n      if (config.params?.required) {\n        validationType = `${validationType} Required`;\n      }\n\n      return validationType;\n    case ValidationTypes.OBJECT:\n      let objectType = \"Object\";\n      if (config.params?.allowedKeys) {\n        objectType = \"{\";\n        config.params?.allowedKeys.forEach((allowedKeyConfig) => {\n          const _expected = getExpectedType(allowedKeyConfig);\n          objectType = `${objectType} \"${allowedKeyConfig.name}\": \"${_expected}\",`;\n        });\n        objectType = `${objectType.substring(0, objectType.length - 1)} }`;\n        return objectType;\n      }\n      return objectType;\n    case ValidationTypes.ARRAY:\n    case ValidationTypes.NESTED_OBJECT_ARRAY:\n      if (config.params?.allowedValues) {\n        const allowed = config.params?.allowedValues.join(\"' | '\");\n        return `Array<'${allowed}'>`;\n      }\n      if (config.params?.children) {\n        const children = getExpectedType(config.params.children);\n        return `Array<${children}>`;\n      }\n      return \"Array\";\n    case ValidationTypes.OBJECT_ARRAY:\n      return `Array<Object>`;\n    case ValidationTypes.IMAGE_URL:\n      return `base64 encoded image | data uri | image url`;\n    case ValidationTypes.SAFE_URL:\n      return \"URL\";\n  }\n}\n\nexport const VALIDATORS: Record<ValidationTypes, Validator> = {\n  [ValidationTypes.TEXT]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    if (value === undefined || value === null || value === \"\") {\n      if (config.params && config.params.required) {\n        return {\n          isValid: false,\n          parsed: config.params?.default || \"\",\n          messages: [\n            {\n              name: \"TypeError\",\n              message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n                config,\n              )}`,\n            },\n          ],\n        };\n      }\n\n      return {\n        isValid: true,\n        parsed: config.params?.default || \"\",\n      };\n    }\n    let parsed = value;\n\n    if (isObject(value)) {\n      if (\n        config.params &&\n        config.params.limitLineBreaks &&\n        validateExcessLineBreaks(value)\n      ) {\n        return {\n          isValid: false,\n          parsed: JSON.stringify(validateObjectValues(value)), // Parse without line breaks\n          messages: [\n            {\n              name: \"ValidationError\",\n              message: LINE_BREAKS_ERROR_MESSAGE,\n            },\n          ],\n        };\n      }\n      return {\n        isValid: false,\n        parsed: JSON.stringify(validateObjectValues(value), null, 2),\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n\n    const isValid = isString(parsed);\n    const stringValidationError = {\n      isValid: false,\n      parsed: config.params?.default || \"\",\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(config)}`,\n        },\n      ],\n    };\n    if (!isValid) {\n      try {\n        if (!config.params?.strict) parsed = toString(parsed);\n        else return stringValidationError;\n      } catch (e) {\n        return stringValidationError;\n      }\n    }\n    if (\n      config.params &&\n      config.params.limitLineBreaks &&\n      validateExcessLineBreaks(value)\n    ) {\n      return {\n        isValid: false,\n        parsed: JSON.stringify(value), // Parse without line breaks\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: LINE_BREAKS_ERROR_MESSAGE,\n          },\n        ],\n      };\n    }\n    if (config.params?.allowedValues) {\n      if (!config.params?.allowedValues.includes((parsed as string).trim())) {\n        return {\n          parsed: config.params?.default || \"\",\n          messages: [\n            {\n              name: \"ValidationError\",\n              message: `Disallowed value: ${parsed}`,\n            },\n          ],\n          isValid: false,\n        };\n      }\n    }\n\n    if (validateExcessLength(parsed as string, 200000)) {\n      return {\n        parsed: (parsed as string)?.substring(0, 200000),\n        isValid: false,\n        messages: [\n          {\n            name: \"ValidationError\",\n            message:\n              \"Excessive text length without a line break. Rendering a substring to avoid app crash.\",\n          },\n        ],\n      };\n    }\n\n    if (\n      config.params?.regex &&\n      isRegExp(config.params?.regex) &&\n      !config.params?.regex.test(parsed as string)\n    ) {\n      return {\n        parsed: config.params?.default || \"\",\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n        isValid: false,\n      };\n    }\n\n    return {\n      isValid: true,\n      parsed,\n    };\n  },\n  // TODO(abhinav): The original validation does not make sense fix this.\n  [ValidationTypes.REGEX]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    const { isValid, messages, parsed } = VALIDATORS[ValidationTypes.TEXT](\n      config,\n      value,\n      props,\n      propertyPath,\n    );\n\n    if (!isValid) {\n      return {\n        isValid: false,\n        parsed: new RegExp(parsed),\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n\n    return { isValid, parsed, messages };\n  },\n  [ValidationTypes.NUMBER]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    if (value === undefined || value === null || value === \"\") {\n      if (config.params?.required) {\n        return {\n          isValid: false,\n          parsed: config.params?.default || 0,\n          messages: [\n            {\n              name: \"ValidationError\",\n              message: \"This value is required\",\n            },\n          ],\n        };\n      }\n\n      if (value === \"\") {\n        return {\n          isValid: true,\n          parsed: config.params?.default || 0,\n        };\n      }\n\n      return {\n        isValid: true,\n        parsed: value,\n      };\n    }\n    if (!Number.isFinite(value) && !isString(value)) {\n      return {\n        isValid: false,\n        parsed: config.params?.default || 0,\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n\n    // check for min and max limits\n    let parsed: number = value as number;\n    if (isString(value)) {\n      if (/^-?\\d+\\.?\\d*$/.test(value)) {\n        parsed = Number(value);\n      } else {\n        return {\n          isValid: false,\n          parsed: value || config.params?.default || 0,\n          messages: [\n            {\n              name: \"TypeError\",\n              message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n                config,\n              )}`,\n            },\n          ],\n        };\n      }\n    }\n\n    if (\n      config.params?.min !== undefined &&\n      Number.isFinite(config.params.min)\n    ) {\n      if (parsed < Number(config.params.min)) {\n        return {\n          isValid: false,\n          parsed:\n            // passThroughOnZero is introduced to resolve a bug and to not break existing apps\n            // Refer: https://github.com/appsmithorg/appsmith/issues/17472#issuecomment-1281818238\n            config.params.passThroughOnZero === false\n              ? parsed || config.params.min || 0\n              : parsed ?? config.params.min ?? 0,\n          messages: [\n            {\n              name: \"RangeError\",\n              message: `Minimum allowed value: ${config.params.min}`,\n            },\n          ],\n        };\n      }\n    }\n\n    if (\n      config.params?.max !== undefined &&\n      Number.isFinite(config.params.max)\n    ) {\n      if (parsed > Number(config.params.max)) {\n        return {\n          isValid: false,\n          parsed: config.params.max || parsed || 0,\n          messages: [\n            {\n              name: \"RangeError\",\n              message: `Maximum allowed value: ${config.params.max}`,\n            },\n          ],\n        };\n      }\n    }\n    if (config.params?.natural && (parsed < 0 || !Number.isInteger(parsed))) {\n      return {\n        isValid: false,\n        parsed: config.params.default || parsed || 0,\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: `Value should be a positive integer`,\n          },\n        ],\n      };\n    }\n\n    return {\n      isValid: true,\n      parsed,\n    };\n  },\n  [ValidationTypes.BOOLEAN]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    if (value === undefined || value === null || value === \"\") {\n      if (config.params && config.params.required) {\n        return {\n          isValid: false,\n          parsed: !!config.params?.default,\n          messages: [\n            {\n              name: \"TypeError\",\n              message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n                config,\n              )}`,\n            },\n          ],\n        };\n      }\n\n      if (value === \"\") {\n        return {\n          isValid: true,\n          parsed: config.params?.default || false,\n        };\n      }\n\n      return { isValid: true, parsed: config.params?.default || value };\n    }\n    const isABoolean = value === true || value === false;\n    const isStringTrueFalse = value === \"true\" || value === \"false\";\n    const isValid = isABoolean || isStringTrueFalse;\n\n    let parsed = value;\n    if (isStringTrueFalse) parsed = value !== \"false\";\n\n    if (!isValid) {\n      return {\n        isValid: false,\n        parsed: config.params?.default || false,\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n\n    return { isValid, parsed };\n  },\n  [ValidationTypes.OBJECT]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    if (\n      value === undefined ||\n      value === null ||\n      (isString(value) && value.trim().length === 0)\n    ) {\n      if (config.params && config.params.required) {\n        return {\n          isValid: false,\n          parsed: config.params?.default || {},\n          messages: [\n            {\n              name: \"TypeError\",\n              message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n                config,\n              )}`,\n            },\n          ],\n        };\n      }\n      return {\n        isValid: true,\n        parsed: config.params?.default || value,\n      };\n    }\n\n    if (isPlainObject(value)) {\n      return validatePlainObject(\n        config,\n        value as Record<string, unknown>,\n        props,\n        propertyPath,\n      );\n    }\n\n    try {\n      const result = { parsed: JSON.parse(value as string), isValid: true };\n      if (isPlainObject(result.parsed)) {\n        return validatePlainObject(config, result.parsed, props, propertyPath);\n      }\n      return {\n        isValid: false,\n        parsed: config.params?.default || {},\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    } catch (e) {\n      return {\n        isValid: false,\n        parsed: config.params?.default || {},\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n  },\n  [ValidationTypes.ARRAY]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: config.params?.default || [],\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(config)}`,\n        },\n      ],\n    };\n    if (value === undefined || value === null || value === \"\") {\n      if (\n        config.params &&\n        config.params.required &&\n        !isArray(config.params.default)\n      ) {\n        invalidResponse.messages = [\n          {\n            name: \"ValidationError\",\n            message:\n              \"This property is required for the widget to function correctly\",\n          },\n        ];\n        return invalidResponse;\n      }\n      if (value === \"\") {\n        return {\n          isValid: true,\n          parsed: config.params?.default || [],\n        };\n      }\n      if (config.params && isArray(config.params.default)) {\n        return {\n          isValid: true,\n          parsed: config.params?.default,\n        };\n      }\n\n      return {\n        isValid: true,\n        parsed: value,\n      };\n    }\n\n    if (isString(value)) {\n      try {\n        const _value = JSON.parse(value);\n        if (Array.isArray(_value)) {\n          const result = validateArray(config, _value, props, propertyPath);\n          return result;\n        }\n      } catch (e) {\n        return invalidResponse;\n      }\n    }\n\n    if (Array.isArray(value)) {\n      return validateArray(config, value, props, propertyPath);\n    }\n\n    return invalidResponse;\n  },\n  [ValidationTypes.OBJECT_ARRAY]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: config.params?.default || [{}],\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(config)}`,\n        },\n      ],\n    };\n    if (value === undefined || value === null || value === \"\") {\n      if (config.params?.required) return invalidResponse;\n\n      if (value === \"\") {\n        return {\n          isValid: true,\n          parsed: config.params?.default || [{}],\n        };\n      }\n\n      return { isValid: true, parsed: value };\n    }\n    if (!isString(value) && !Array.isArray(value)) {\n      return invalidResponse;\n    }\n\n    let parsed = value;\n\n    if (isString(value)) {\n      try {\n        parsed = JSON.parse(value);\n      } catch (e) {\n        return invalidResponse;\n      }\n    }\n\n    if (Array.isArray(parsed)) {\n      if (parsed.length === 0) {\n        if (config.params?.required) {\n          return invalidResponse;\n        } else {\n          return {\n            isValid: true,\n            parsed: config.params?.default || [{}],\n          };\n        }\n      }\n\n      for (const [index, parsedEntry] of parsed.entries()) {\n        if (!isPlainObject(parsedEntry)) {\n          return {\n            ...invalidResponse,\n            messages: [\n              {\n                name: \"ValidationError\",\n                message: `Invalid object at index ${index}`,\n              },\n            ],\n          };\n        }\n      }\n      return { isValid: true, parsed };\n    }\n    return invalidResponse;\n  },\n\n  [ValidationTypes.NESTED_OBJECT_ARRAY]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    let response: ValidationResponse = {\n      isValid: false,\n      parsed: config.params?.default || [],\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(config)}`,\n        },\n      ],\n    };\n    response = VALIDATORS.ARRAY(config, value, props, propertyPath);\n\n    if (!response.isValid) {\n      return response;\n    }\n    // Check if all values and children values are unique\n    if (config.params?.unique && response.parsed.length) {\n      if (isArray(config.params?.unique)) {\n        for (const param of config.params?.unique) {\n          const flattenedArray = flat(response.parsed, param);\n          const shouldBeUnique = flattenedArray.map((entry) =>\n            get(entry, param, \"\"),\n          );\n          if (uniq(shouldBeUnique).length !== flattenedArray.length) {\n            response = {\n              ...response,\n              isValid: false,\n              messages: [\n                {\n                  name: \"ValidationError\",\n                  message: `path:${param} must be unique. Duplicate values found`,\n                },\n              ],\n            };\n          }\n        }\n      }\n    }\n    return response;\n  },\n  [ValidationTypes.DATE_ISO_STRING]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    let isValid = false;\n    let parsed = value;\n    let message = { name: \"\", message: \"\" };\n\n    if (_.isNil(value) || value === \"\") {\n      parsed = config.params?.default;\n\n      if (config.params?.required) {\n        isValid = false;\n        message = {\n          name: \"TypeError\",\n          message: `Value does not match: ${getExpectedType(config)}`,\n        };\n      } else {\n        isValid = true;\n      }\n    } else if (typeof value === \"object\" && moment(value).isValid()) {\n      //Date and moment object\n      isValid = true;\n      parsed = moment(value).toISOString(true);\n    } else if (isString(value)) {\n      //Date string\n      if (\n        value === moment(value).toISOString() ||\n        value === moment(value).toISOString(true)\n      ) {\n        return {\n          isValid: true,\n          parsed: value,\n        };\n      } else if (moment(value).isValid()) {\n        isValid = true;\n        parsed = moment(value).toISOString(true);\n      } else {\n        isValid = false;\n        message = {\n          name: \"TypeError\",\n          message: `Value does not match: ${getExpectedType(config)}`,\n        };\n        parsed = config.params?.default;\n      }\n    } else {\n      isValid = false;\n      message = {\n        name: \"TypeError\",\n        message: `Value does not match: ${getExpectedType(config)}`,\n      };\n    }\n\n    const result: ValidationResponse = {\n      isValid,\n      parsed,\n    };\n\n    if (message) {\n      result.messages = [message];\n    }\n\n    return result;\n  },\n  [ValidationTypes.FUNCTION]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: undefined,\n      messages: [\n        {\n          name: \"ValidationError\",\n          message: \"Failed to validate\",\n        },\n      ],\n    };\n    if (config.params?.fnString && isString(config.params?.fnString)) {\n      try {\n        const { result } = evaluate(\n          config.params.fnString,\n          {},\n          {},\n          false,\n          undefined,\n          [value, props, _, moment, propertyPath, config],\n        );\n        return result;\n      } catch (e) {\n        log.error(\"Validation function error: \", { e });\n      }\n    }\n    return invalidResponse;\n  },\n  [ValidationTypes.IMAGE_URL]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: config.params?.default || \"\",\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n            config,\n          )}`,\n        },\n      ],\n    };\n    const base64Regex = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\n    const base64ImageRegex = /^data:image\\/.*;base64/;\n    const imageUrlRegex = /(http(s?):)([/|.|\\w|\\s|-])*\\.(?:jpeg|jpg|gif|png)??(?:&?[^=&]*=[^=&]*)*/;\n    if (\n      value === undefined ||\n      value === null ||\n      (isString(value) && value.trim().length === 0)\n    ) {\n      if (config.params && config.params.required) return invalidResponse;\n      return { isValid: true, parsed: value };\n    }\n    if (isString(value)) {\n      if (imageUrlRegex.test(value.trim())) {\n        return { isValid: true, parsed: value.trim() };\n      }\n      if (base64ImageRegex.test(value)) {\n        return {\n          isValid: true,\n          parsed: value,\n        };\n      }\n      if (base64Regex.test(value) && btoa(atob(value)) === value) {\n        return { isValid: true, parsed: `data:image/png;base64,${value}` };\n      }\n    }\n    return invalidResponse;\n  },\n  [ValidationTypes.SAFE_URL]: (\n    config: ValidationConfig,\n    value: unknown,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: config?.params?.default || \"\",\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n            config,\n          )}`,\n        },\n      ],\n    };\n\n    if (typeof value === \"string\" && getIsSafeURL(value)) {\n      return {\n        isValid: true,\n        parsed: value,\n      };\n    } else {\n      return invalidResponse;\n    }\n  },\n\n  /**\n   *\n   * ARRAY_OF_TYPE_OR_TYPE can be used in scenarios where we wanted to validate\n   * using ValidationTypes.ARRAY or ValidationTypes.* at the same time.\n   *\n   * This is needed in case of properties inside\n   * 1. Table widget where we use COMPUTE_VALUE\n   * 2. Menu button widget where we use MENU_BUTTON_DYNAMIC_ITEMS\n   *\n   * For more info: https://github.com/appsmithorg/appsmith/pull/9396\n   */\n  [ValidationTypes.ARRAY_OF_TYPE_OR_TYPE]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    if (!config.params?.type)\n      return {\n        isValid: false,\n        parsed: undefined,\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: \"Invalid validation\",\n          },\n        ],\n      };\n\n    // Validate when JS mode is disabled\n    const result = VALIDATORS[config.params.type as ValidationTypes](\n      config.params as ValidationConfig,\n      value,\n      props,\n      propertyPath,\n    );\n    if (result.isValid) return result;\n\n    // Validate when JS mode is enabled\n    const resultValue = [];\n    if (_.isArray(value)) {\n      for (const item of value) {\n        const result = VALIDATORS[config.params.type](\n          config.params as ValidationConfig,\n          item,\n          props,\n          propertyPath,\n        );\n        if (!result.isValid) return result;\n        resultValue.push(result.parsed);\n      }\n    } else {\n      return {\n        isValid: false,\n        parsed: config.params?.params?.default,\n        messages: result.messages,\n      };\n    }\n\n    return {\n      isValid: true,\n      parsed: resultValue,\n    };\n  },\n};\n","import { DataTree, DataTreeEntity } from \"entities/DataTree/dataTreeFactory\";\n\nimport { Position } from \"codemirror\";\nimport {\n  isDynamicValue,\n  isPathADynamicBinding,\n  LintError,\n  PropertyEvaluationErrorType,\n} from \"utils/DynamicBindingUtils\";\nimport { MAIN_THREAD_ACTION } from \"@appsmith/workers/Evaluation/evalWorkerActions\";\nimport {\n  JSHINT as jshint,\n  LintError as JSHintError,\n  LintOptions,\n} from \"jshint\";\nimport { get, isEmpty, isNumber, keys, last, set } from \"lodash\";\nimport {\n  getLintErrorMessage,\n  getLintSeverity,\n} from \"components/editorComponents/CodeEditor/lintHelpers\";\nimport {\n  CustomLintErrorCode,\n  CUSTOM_LINT_ERRORS,\n  IGNORED_LINT_ERRORS,\n  INVALID_JSOBJECT_START_STATEMENT,\n  JS_OBJECT_START_STATEMENT,\n  SUPPORTED_WEB_APIS,\n} from \"components/editorComponents/CodeEditor/constants\";\nimport {\n  extractInvalidTopLevelMemberExpressionsFromCode,\n  isLiteralNode,\n  ECMA_VERSION,\n  MemberExpressionData,\n} from \"@shared/ast\";\nimport { getDynamicBindings } from \"utils/DynamicBindingUtils\";\n\nimport {\n  createEvaluationContext,\n  EvaluationScripts,\n  EvaluationScriptType,\n  getScriptToEval,\n  getScriptType,\n  ScriptTemplate,\n} from \"workers/Evaluation/evaluate\";\nimport {\n  getEntityNameAndPropertyPath,\n  isAction,\n  isATriggerPath,\n  isJSAction,\n  isWidget,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport { LintErrors } from \"reducers/lintingReducers/lintErrorsReducers\";\nimport { Severity } from \"entities/AppsmithConsole\";\nimport { JSLibraries } from \"workers/common/JSLibrary\";\nimport { getActionTriggerFunctionNames } from \"@appsmith/workers/Evaluation/fns/index\";\nimport { WorkerMessenger } from \"workers/Evaluation/fns/utils/Messenger\";\n\nexport function getlintErrorsFromTree(\n  pathsToLint: string[],\n  unEvalTree: DataTree,\n  cloudHosting: boolean,\n): LintErrors {\n  const lintTreeErrors: LintErrors = {};\n\n  const evalContext = createEvaluationContext({\n    dataTree: unEvalTree,\n    resolvedFunctions: {},\n    isTriggerBased: false,\n    skipEntityFunctions: true,\n  });\n\n  const platformFnNamesMap = Object.values(\n    getActionTriggerFunctionNames(cloudHosting),\n  ).reduce(\n    (acc, name) => ({ ...acc, [name]: true }),\n    {} as { [x: string]: boolean },\n  );\n  Object.assign(evalContext, platformFnNamesMap);\n\n  const evalContextWithOutFunctions = createEvaluationContext({\n    dataTree: unEvalTree,\n    resolvedFunctions: {},\n    isTriggerBased: true,\n    skipEntityFunctions: true,\n  });\n\n  // trigger paths\n  const triggerPaths = new Set<string>();\n  // Certain paths, like JS Object's body are binding paths where appsmith functions are needed in the global data\n  const bindingPathsRequiringFunctions = new Set<string>();\n\n  pathsToLint.forEach((fullPropertyPath) => {\n    const { entityName, propertyPath } = getEntityNameAndPropertyPath(\n      fullPropertyPath,\n    );\n    const entity = unEvalTree[entityName];\n    const unEvalPropertyValue = (get(\n      unEvalTree,\n      fullPropertyPath,\n    ) as unknown) as string;\n    // remove all lint errors from path\n    set(lintTreeErrors, `[\"${fullPropertyPath}\"]`, []);\n\n    // We are only interested in paths that require linting\n    if (!pathRequiresLinting(unEvalTree, entity, fullPropertyPath)) return;\n    if (isATriggerPath(entity, propertyPath))\n      return triggerPaths.add(fullPropertyPath);\n    if (isJSAction(entity))\n      return bindingPathsRequiringFunctions.add(`${entityName}.body`);\n    const lintErrors = lintBindingPath(\n      unEvalPropertyValue,\n      entity,\n      fullPropertyPath,\n      evalContextWithOutFunctions,\n    );\n    set(lintTreeErrors, `[\"${fullPropertyPath}\"]`, lintErrors);\n  });\n\n  if (triggerPaths.size || bindingPathsRequiringFunctions.size) {\n    // we only create GLOBAL_DATA_WITH_FUNCTIONS if there are paths requiring it\n    // In trigger based fields, functions such as showAlert, storeValue, etc need to be added to the global data\n\n    // lint binding paths that need GLOBAL_DATA_WITH_FUNCTIONS\n    if (bindingPathsRequiringFunctions.size) {\n      bindingPathsRequiringFunctions.forEach((fullPropertyPath) => {\n        const { entityName } = getEntityNameAndPropertyPath(fullPropertyPath);\n        const entity = unEvalTree[entityName];\n        const unEvalPropertyValue = (get(\n          unEvalTree,\n          fullPropertyPath,\n        ) as unknown) as string;\n        // remove all lint errors from path\n        set(lintTreeErrors, `[\"${fullPropertyPath}\"]`, []);\n        const lintErrors = lintBindingPath(\n          unEvalPropertyValue,\n          entity,\n          fullPropertyPath,\n          evalContext,\n        );\n        set(lintTreeErrors, `[\"${fullPropertyPath}\"]`, lintErrors);\n      });\n    }\n\n    // Lint triggerPaths\n    if (triggerPaths.size) {\n      triggerPaths.forEach((triggerPath) => {\n        const { entityName } = getEntityNameAndPropertyPath(triggerPath);\n        const entity = unEvalTree[entityName];\n        const unEvalPropertyValue = (get(\n          unEvalTree,\n          triggerPath,\n        ) as unknown) as string;\n        // remove all lint errors from path\n        set(lintTreeErrors, `[\"${triggerPath}\"]`, []);\n        const lintErrors = lintTriggerPath(\n          unEvalPropertyValue,\n          entity,\n          evalContext,\n        );\n        set(lintTreeErrors, `[\"${triggerPath}\"]`, lintErrors);\n      });\n    }\n  }\n\n  return lintTreeErrors;\n}\n\nfunction lintBindingPath(\n  dynamicBinding: string,\n  entity: DataTreeEntity,\n  fullPropertyPath: string,\n  globalData: ReturnType<typeof createEvaluationContext>,\n) {\n  let lintErrors: LintError[] = [];\n\n  if (isJSAction(entity)) {\n    if (!entity.body) return lintErrors;\n    if (!entity.body.startsWith(JS_OBJECT_START_STATEMENT)) {\n      return lintErrors.concat([\n        {\n          errorType: PropertyEvaluationErrorType.LINT,\n          errorSegment: \"\",\n          originalBinding: entity.body,\n          line: 0,\n          ch: 0,\n          code: entity.body,\n          variables: [],\n          raw: entity.body,\n          errorMessage: {\n            name: \"LintingError\",\n            message: INVALID_JSOBJECT_START_STATEMENT,\n          },\n          severity: Severity.ERROR,\n        },\n      ]);\n    }\n  }\n\n  const { propertyPath } = getEntityNameAndPropertyPath(fullPropertyPath);\n  // Get the {{binding}} bound values\n  const { jsSnippets, stringSegments } = getDynamicBindings(\n    dynamicBinding,\n    entity,\n  );\n\n  if (stringSegments) {\n    jsSnippets.forEach((jsSnippet, index) => {\n      if (jsSnippet) {\n        const jsSnippetToLint = getJSToLint(entity, jsSnippet, propertyPath);\n        // {{user's code}}\n        const originalBinding = getJSToLint(\n          entity,\n          stringSegments[index],\n          propertyPath,\n        );\n        const scriptType = getScriptType(false, false);\n        const scriptToLint = getScriptToEval(jsSnippetToLint, scriptType);\n        const lintErrorsFromSnippet = getLintingErrors(\n          scriptToLint,\n          globalData,\n          originalBinding,\n          scriptType,\n        );\n        lintErrors = lintErrors.concat(lintErrorsFromSnippet);\n      }\n    });\n  }\n  return lintErrors;\n}\n\nfunction lintTriggerPath(\n  userScript: string,\n  entity: DataTreeEntity,\n  globalData: ReturnType<typeof createEvaluationContext>,\n) {\n  const { jsSnippets } = getDynamicBindings(userScript, entity);\n  const script = getScriptToEval(jsSnippets[0], EvaluationScriptType.TRIGGERS);\n\n  return getLintingErrors(\n    script,\n    globalData,\n    jsSnippets[0],\n    EvaluationScriptType.TRIGGERS,\n  );\n}\n\nexport function pathRequiresLinting(\n  dataTree: DataTree,\n  entity: DataTreeEntity,\n  fullPropertyPath: string,\n): boolean {\n  const { propertyPath } = getEntityNameAndPropertyPath(fullPropertyPath);\n  const unEvalPropertyValue = (get(\n    dataTree,\n    fullPropertyPath,\n  ) as unknown) as string;\n\n  if (isATriggerPath(entity, propertyPath)) {\n    return isDynamicValue(unEvalPropertyValue);\n  }\n  const isADynamicBindingPath =\n    (isAction(entity) || isWidget(entity) || isJSAction(entity)) &&\n    isPathADynamicBinding(entity, propertyPath);\n  const requiresLinting =\n    (isADynamicBindingPath && isDynamicValue(unEvalPropertyValue)) ||\n    isJSAction(entity);\n  return requiresLinting;\n}\n\n// Removes \"export default\" statement from js Object\nexport function getJSToLint(\n  entity: DataTreeEntity,\n  snippet: string,\n  propertyPath: string,\n): string {\n  return entity && isJSAction(entity) && propertyPath === \"body\"\n    ? snippet.replace(/export default/g, \"\")\n    : snippet;\n}\n\nexport function getPositionInEvaluationScript(\n  type: EvaluationScriptType,\n): Position {\n  const script = EvaluationScripts[type];\n\n  const index = script.indexOf(ScriptTemplate);\n  const substr = script.slice(0, index !== -1 ? index : 0);\n  const lines = substr.split(\"\\n\");\n  const lastLine = last(lines) || \"\";\n\n  return { line: lines.length, ch: lastLine.length };\n}\n\nconst EvaluationScriptPositions: Record<string, Position> = {};\n\nfunction getEvaluationScriptPosition(scriptType: EvaluationScriptType) {\n  if (isEmpty(EvaluationScriptPositions)) {\n    // We are computing position of <<script>> in our templates.\n    // This will be used to get the exact location of error in linting\n    keys(EvaluationScripts).forEach((type) => {\n      EvaluationScriptPositions[type] = getPositionInEvaluationScript(\n        type as EvaluationScriptType,\n      );\n    });\n  }\n\n  return EvaluationScriptPositions[scriptType];\n}\n\nexport function getLintingErrors(\n  script: string,\n  data: Record<string, unknown>,\n  // {{user's code}}\n  originalBinding: string,\n  scriptType: EvaluationScriptType,\n): LintError[] {\n  const scriptPos = getEvaluationScriptPosition(scriptType);\n  const globalData: Record<string, boolean> = {};\n  for (const dataKey in data) {\n    globalData[dataKey] = true;\n  }\n  // Jshint shouldn't throw errors for additional libraries\n  const libAccessors = ([] as string[]).concat(\n    ...JSLibraries.map((lib) => lib.accessor),\n  );\n  libAccessors.forEach((accessor) => (globalData[accessor] = true));\n\n  // JSHint shouldn't throw errors for supported web apis\n  Object.keys(SUPPORTED_WEB_APIS).forEach(\n    (apiName) => (globalData[apiName] = true),\n  );\n\n  const options: LintOptions = {\n    indent: 2,\n    esversion: ECMA_VERSION,\n    eqeqeq: false, // Not necessary to use ===\n    curly: false, // Blocks can be added without {}, eg if (x) return true\n    freeze: true, // Overriding inbuilt classes like Array is not allowed\n    undef: true, // Undefined variables should be reported as error\n    forin: false, // Doesn't require filtering for..in loops with obj.hasOwnProperty()\n    noempty: false, // Empty blocks are allowed\n    strict: false, // We won't force strict mode\n    unused: \"strict\", // Unused variables are not allowed\n    asi: true, // Tolerate Automatic Semicolon Insertion (no semicolons)\n    boss: true, // Tolerate assignments where comparisons would be expected\n    evil: false, // Use of eval not allowed\n    funcscope: true, // Tolerate variable definition inside control statements\n    sub: true, // Don't force dot notation\n    expr: true, // suppresses warnings about the use of expressions where normally you would expect to see assignments or function calls\n    // environments\n    browser: true,\n    worker: true,\n    mocha: false,\n    // global values\n    globals: globalData,\n    loopfunc: true,\n  };\n\n  jshint(script, options);\n\n  const jshintErrors: LintError[] = getValidLintErrors(\n    jshint.errors,\n    scriptPos,\n  ).map((lintError) => {\n    const ch = lintError.character;\n    return {\n      errorType: PropertyEvaluationErrorType.LINT,\n      raw: script,\n      severity: getLintSeverity(lintError.code),\n      errorMessage: {\n        name: \"LintingError\",\n        message: getLintErrorMessage(lintError.reason),\n      },\n      errorSegment: lintError.evidence,\n      originalBinding,\n      // By keeping track of these variables we can highlight the exact text that caused the error.\n      variables: [lintError.a, lintError.b, lintError.c, lintError.d],\n      code: lintError.code,\n      line: lintError.line - scriptPos.line,\n      ch: lintError.line === scriptPos.line ? ch - scriptPos.ch : ch,\n    };\n  });\n  const invalidPropertyErrors = getInvalidPropertyErrorsFromScript(\n    script,\n    data,\n    scriptPos,\n    originalBinding,\n  );\n  return jshintErrors.concat(invalidPropertyErrors);\n}\n\nfunction getValidLintErrors(\n  lintErrors: JSHintError[],\n  scriptPos: Position,\n): JSHintError[] {\n  return lintErrors.reduce((result: JSHintError[], lintError) => {\n    // Ignored errors should not be reported\n    if (IGNORED_LINT_ERRORS.includes(lintError.code)) return result;\n    /** Some error messages reference line numbers,\n     * Eg. Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'\n     * these line numbers need to be re-calculated based on the binding location.\n     * Errors referencing line numbers outside the user's script should also be ignored\n     * */\n    let message = lintError.reason;\n    const matchedLines = message.match(/line \\d/gi);\n    const lineNumbersInErrorMessage = new Set<number>();\n    let isInvalidErrorMessage = false;\n    if (matchedLines) {\n      matchedLines.forEach((lineStatement) => {\n        const digitString = lineStatement.split(\" \")[1];\n        const digit = Number(digitString);\n        if (isNumber(digit)) {\n          if (digit < scriptPos.line) {\n            // referenced line number is outside the scope of user's script\n            isInvalidErrorMessage = true;\n          } else {\n            lineNumbersInErrorMessage.add(digit);\n          }\n        }\n      });\n    }\n    if (isInvalidErrorMessage) return result;\n    if (lineNumbersInErrorMessage.size) {\n      Array.from(lineNumbersInErrorMessage).forEach((lineNumber) => {\n        message = message.replaceAll(\n          `line ${lineNumber}`,\n          `line ${lineNumber - scriptPos.line + 1}`,\n        );\n      });\n    }\n    result.push({\n      ...lintError,\n      reason: message,\n    });\n    return result;\n  }, []);\n}\n\nfunction getInvalidPropertyErrorsFromScript(\n  script: string,\n  data: Record<string, unknown>,\n  scriptPos: Position,\n  originalBinding: string,\n): LintError[] {\n  let invalidTopLevelMemberExpressions: MemberExpressionData[] = [];\n  try {\n    invalidTopLevelMemberExpressions = extractInvalidTopLevelMemberExpressionsFromCode(\n      script,\n      data,\n      self.evaluationVersion,\n    );\n  } catch (e) {}\n\n  const invalidPropertyErrors = invalidTopLevelMemberExpressions.map(\n    ({ object, property }): LintError => {\n      const propertyName = isLiteralNode(property)\n        ? (property.value as string)\n        : property.name;\n      const objectStartLine = object.loc.start.line - 1;\n      // For computed member expressions (entity[\"property\"]), add an extra 1 to the start column to account for \"[\".\n      const propertyStartColumn = !isLiteralNode(property)\n        ? property.loc.start.column + 1\n        : property.loc.start.column + 2;\n      return {\n        errorType: PropertyEvaluationErrorType.LINT,\n        raw: script,\n        severity: getLintSeverity(CustomLintErrorCode.INVALID_ENTITY_PROPERTY),\n        errorMessage: {\n          name: \"LintingError\",\n          message: CUSTOM_LINT_ERRORS[\n            CustomLintErrorCode.INVALID_ENTITY_PROPERTY\n          ](object.name, propertyName),\n        },\n        errorSegment: `${object.name}.${propertyName}`,\n        originalBinding,\n        variables: [propertyName, null, null, null],\n        code: CustomLintErrorCode.INVALID_ENTITY_PROPERTY,\n        line: objectStartLine - scriptPos.line,\n        ch:\n          objectStartLine === scriptPos.line\n            ? propertyStartColumn - scriptPos.ch\n            : propertyStartColumn,\n      };\n    },\n  );\n  return invalidPropertyErrors;\n}\n\nexport function initiateLinting(\n  lintOrder: string[],\n  unevalTree: DataTree,\n  requiresLinting: boolean,\n) {\n  if (!requiresLinting) return;\n  WorkerMessenger.ping({\n    data: {\n      lintOrder,\n      unevalTree,\n    },\n    method: MAIN_THREAD_ACTION.LINT_TREE,\n  });\n}\n","export function getFixedTimeDifference(endTime: number, startTime: number) {\n  return (endTime - startTime).toFixed(2) + \" ms\";\n}\n","import { ValidationConfig } from \"constants/PropertyControlConstants\";\nimport { Severity } from \"entities/AppsmithConsole\";\nimport { DataTree, DataTreeWidget } from \"entities/DataTree/dataTreeFactory\";\nimport { get, isUndefined, set } from \"lodash\";\nimport {\n  EvaluationError,\n  getEvalErrorPath,\n  getEvalValuePath,\n  isPathDynamicTrigger,\n  PropertyEvaluationErrorType,\n} from \"utils/DynamicBindingUtils\";\nimport {\n  addErrorToEntityProperty,\n  getEntityNameAndPropertyPath,\n  isWidget,\n  resetValidationErrorsForEntityProperty,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport { validate } from \"workers/Evaluation/validations\";\nimport { EvalProps } from \".\";\n\nexport function validateAndParseWidgetProperty({\n  currentTree,\n  evalPropertyValue,\n  evalProps,\n  fullPropertyPath,\n  unEvalPropertyValue,\n  widget,\n}: {\n  fullPropertyPath: string;\n  widget: DataTreeWidget;\n  currentTree: DataTree;\n  evalPropertyValue: unknown;\n  unEvalPropertyValue: string;\n  evalProps: EvalProps;\n}): unknown {\n  const { propertyPath } = getEntityNameAndPropertyPath(fullPropertyPath);\n  if (isPathDynamicTrigger(widget, propertyPath)) {\n    // TODO find a way to validate triggers\n    return unEvalPropertyValue;\n  }\n  const validation = widget.validationPaths[propertyPath];\n\n  const { isValid, messages, parsed, transformed } = validateWidgetProperty(\n    validation,\n    evalPropertyValue,\n    widget,\n    propertyPath,\n  );\n\n  let evaluatedValue;\n  if (isValid) {\n    evaluatedValue = parsed;\n    // remove validation errors is already present\n    resetValidationErrorsForEntityProperty({\n      evalProps,\n      fullPropertyPath,\n    });\n  } else {\n    evaluatedValue = isUndefined(transformed) ? evalPropertyValue : transformed;\n\n    const evalErrors: EvaluationError[] =\n      messages?.map((message) => {\n        return {\n          raw: unEvalPropertyValue,\n          errorMessage: message || \"\",\n          errorType: PropertyEvaluationErrorType.VALIDATION,\n          severity: Severity.ERROR,\n        };\n      }) ?? [];\n    // Add validation errors\n    addErrorToEntityProperty({\n      errors: evalErrors,\n      evalProps,\n      fullPropertyPath,\n      dataTree: currentTree,\n    });\n  }\n  set(\n    evalProps,\n    getEvalValuePath(fullPropertyPath, {\n      isPopulated: false,\n      fullPath: true,\n    }),\n    evaluatedValue,\n  );\n\n  return parsed;\n}\n\nexport function validateWidgetProperty(\n  config: ValidationConfig,\n  value: unknown,\n  props: Record<string, unknown>,\n  propertyPath: string,\n) {\n  if (!config) {\n    return {\n      isValid: true,\n      parsed: value,\n    };\n  }\n  return validate(config, value, props, propertyPath);\n}\n\nexport function validateActionProperty(\n  config: ValidationConfig,\n  value: unknown,\n) {\n  if (!config) {\n    return {\n      isValid: true,\n      parsed: value,\n    };\n  }\n  return validate(config, value, {}, \"\");\n}\n\nexport function getValidatedTree(\n  tree: DataTree,\n  option: { evalProps: EvalProps },\n) {\n  const { evalProps } = option;\n  return Object.keys(tree).reduce((tree, entityKey: string) => {\n    const parsedEntity = tree[entityKey];\n    if (!isWidget(parsedEntity)) {\n      return tree;\n    }\n\n    Object.entries(parsedEntity.validationPaths).forEach(\n      ([property, validation]) => {\n        const value = get(parsedEntity, property);\n        // Pass it through parse\n        const {\n          isValid,\n          messages,\n          parsed,\n          transformed,\n        } = validateWidgetProperty(validation, value, parsedEntity, property);\n        set(parsedEntity, property, parsed);\n        const evaluatedValue = isValid\n          ? parsed\n          : isUndefined(transformed)\n          ? value\n          : transformed;\n        set(\n          evalProps,\n          getEvalValuePath(`${entityKey}.${property}`, {\n            isPopulated: false,\n            fullPath: true,\n          }),\n          evaluatedValue,\n        );\n        if (!isValid) {\n          const evalErrors: EvaluationError[] =\n            messages?.map((message) => ({\n              errorType: PropertyEvaluationErrorType.VALIDATION,\n              errorMessage: message,\n              severity: Severity.ERROR,\n              raw: value,\n            })) ?? [];\n          addErrorToEntityProperty({\n            errors: evalErrors,\n            evalProps,\n            fullPropertyPath: getEvalErrorPath(`${entityKey}.${property}`, {\n              isPopulated: false,\n              fullPath: true,\n            }),\n            dataTree: tree,\n          });\n        }\n      },\n    );\n    return { ...tree, [entityKey]: parsedEntity };\n  }, tree);\n}\n","export const ECMA_VERSION = 11;\n\n/* Indicates the mode the code should be parsed in. \nThis influences global strict mode and parsing of import and export declarations.\n*/\nexport enum SourceType {\n  script = 'script',\n  module = 'module',\n}\n\n// Each node has an attached type property which further defines\n// what all properties can the node have.\n// We will just define the ones we are working with\nexport enum NodeTypes {\n  Identifier = 'Identifier',\n  AssignmentPattern = 'AssignmentPattern',\n  Literal = 'Literal',\n  Property = 'Property',\n  // Declaration - https://github.com/estree/estree/blob/master/es5.md#declarations\n  FunctionDeclaration = 'FunctionDeclaration',\n  ExportDefaultDeclaration = 'ExportDefaultDeclaration',\n  VariableDeclarator = 'VariableDeclarator',\n  // Expression - https://github.com/estree/estree/blob/master/es5.md#expressions\n  MemberExpression = 'MemberExpression',\n  FunctionExpression = 'FunctionExpression',\n  ArrowFunctionExpression = 'ArrowFunctionExpression',\n  ObjectExpression = 'ObjectExpression',\n  ArrayExpression = 'ArrayExpression',\n  ThisExpression = 'ThisExpression',\n}\n","/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */\nif (!String.fromCodePoint) {\n\t(function() {\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\ttry {\n\t\t\t\tvar object = {};\n\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tvar stringFromCharCode = String.fromCharCode;\n\t\tvar floor = Math.floor;\n\t\tvar fromCodePoint = function(_) {\n\t\t\tvar MAX_SIZE = 0x4000;\n\t\t\tvar codeUnits = [];\n\t\t\tvar highSurrogate;\n\t\t\tvar lowSurrogate;\n\t\t\tvar index = -1;\n\t\t\tvar length = arguments.length;\n\t\t\tif (!length) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tvar result = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tvar codePoint = Number(arguments[index]);\n\t\t\t\tif (\n\t\t\t\t\t!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n\t\t\t\t\tcodePoint < 0 || // not a valid Unicode code point\n\t\t\t\t\tcodePoint > 0x10FFFF || // not a valid Unicode code point\n\t\t\t\t\tfloor(codePoint) != codePoint // not an integer\n\t\t\t\t) {\n\t\t\t\t\tthrow RangeError('Invalid code point: ' + codePoint);\n\t\t\t\t}\n\t\t\t\tif (codePoint <= 0xFFFF) { // BMP code point\n\t\t\t\t\tcodeUnits.push(codePoint);\n\t\t\t\t} else { // Astral code point; split in surrogate halves\n\t\t\t\t\t// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\t\thighSurrogate = (codePoint >> 10) + 0xD800;\n\t\t\t\t\tlowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t\t\t\t\tcodeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t\t}\n\t\t\t\tif (index + 1 == length || codeUnits.length > MAX_SIZE) {\n\t\t\t\t\tresult += stringFromCharCode.apply(null, codeUnits);\n\t\t\t\t\tcodeUnits.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String, 'fromCodePoint', {\n\t\t\t\t'value': fromCodePoint,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.fromCodePoint = fromCodePoint;\n\t\t}\n\t}());\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nrequire(\"string.fromcodepoint\");\n\n/**\n * \\\\ - matches the backslash which indicates the beginning of an escape sequence\n * (\n *   u\\{([0-9A-Fa-f]+)\\} - first alternative; matches the variable-length hexadecimal escape sequence (\\u{ABCD0})\n * |\n *   u([0-9A-Fa-f]{4}) - second alternative; matches the 4-digit hexadecimal escape sequence (\\uABCD)\n * |\n *   x([0-9A-Fa-f]{2}) - third alternative; matches the 2-digit hexadecimal escape sequence (\\xA5)\n * |\n *   ([1-7][0-7]{0,2}|[0-7]{2,3}) - fourth alternative; matches the up-to-3-digit octal escape sequence (\\5 or \\512)\n * |\n *   (['\"tbrnfv0\\\\]) - fifth alternative; matches the special escape characters (\\t, \\n and so on)\n * |\n *   \\U([0-9A-Fa-f]+) - sixth alternative; matches the 8-digit hexadecimal escape sequence used by python (\\U0001F3B5)\n * )\n */\nvar jsEscapeRegex = /\\\\(u\\{([0-9A-Fa-f]+)\\}|u([0-9A-Fa-f]{4})|x([0-9A-Fa-f]{2})|([1-7][0-7]{0,2}|[0-7]{2,3})|(['\"tbrnfv0\\\\]))|\\\\U([0-9A-Fa-f]{8})/g;\nvar usualEscapeSequences = {\n  '0': '\\0',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n  'v': '\\v',\n  '\\'': '\\'',\n  '\"': '\"',\n  '\\\\': '\\\\'\n};\n\nvar fromHex = function fromHex(str) {\n  return String.fromCodePoint(parseInt(str, 16));\n};\n\nvar fromOct = function fromOct(str) {\n  return String.fromCodePoint(parseInt(str, 8));\n};\n\nvar _default = function _default(string) {\n  return string.replace(jsEscapeRegex, function (_, __, varHex, longHex, shortHex, octal, specialCharacter, python) {\n    if (varHex !== undefined) {\n      return fromHex(varHex);\n    } else if (longHex !== undefined) {\n      return fromHex(longHex);\n    } else if (shortHex !== undefined) {\n      return fromHex(shortHex);\n    } else if (octal !== undefined) {\n      return fromOct(octal);\n    } else if (python !== undefined) {\n      return fromHex(python);\n    } else {\n      return usualEscapeSequences[specialCharacter];\n    }\n  });\n};\n\nexports.default = _default;\nmodule.exports = exports.default;","import unescapeJS from 'unescape-js';\n\nconst beginsWithLineBreakRegex = /^\\s+|\\s+$/;\n\nexport function sanitizeScript(js: string, evaluationVersion: number) {\n  // We remove any line breaks from the beginning of the script because that\n  // makes the final function invalid. We also unescape any escaped characters\n  // so that eval can happen\n  //default value of evalutaion version is 2\n  evaluationVersion = evaluationVersion ? evaluationVersion : 2;\n  const trimmedJS = js.replace(beginsWithLineBreakRegex, '');\n  return evaluationVersion > 1 ? trimmedJS : unescapeJS(trimmedJS);\n}\n\n// For the times when you need to know if something truly an object like { a: 1, b: 2}\n// typeof, lodash.isObject and others will return false positives for things like array, null, etc\nexport const isTrueObject = (\n  item: unknown\n): item is Record<string, unknown> => {\n  return Object.prototype.toString.call(item) === '[object Object]';\n};\n","import { Node } from \"acorn\";\nimport { getAST } from \"../index\";\nimport { generate } from \"astring\";\nimport { simple } from \"acorn-walk\";\nimport {\n  getFunctionalParamsFromNode,\n  isPropertyAFunctionNode,\n  isVariableDeclarator,\n  isObjectExpression,\n  PropertyNode,\n  functionParam,\n} from \"../index\";\n\ntype JsObjectProperty = {\n  key: string;\n  value: string;\n  type: string;\n  arguments?: Array<functionParam>;\n};\n\nconst jsObjectVariableName =\n  \"____INTERNAL_JS_OBJECT_NAME_USED_FOR_PARSING_____\";\n\nexport const jsObjectDeclaration = `var ${jsObjectVariableName} =`;\n\nexport const parseJSObjectWithAST = (\n  jsObjectBody: string\n): Array<JsObjectProperty> => {\n  /* \n      jsObjectVariableName value is added such actual js code would never name same variable name. \n      if the variable name will be same then also we won't have problem here as jsObjectVariableName will be last node in VariableDeclarator hence overriding the previous JSObjectProperties.\n      Keeping this just for sanity check if any caveat was missed.\n    */\n  const jsCode = `${jsObjectDeclaration} ${jsObjectBody}`;\n\n  const ast = getAST(jsCode);\n\n  const parsedObjectProperties = new Set<JsObjectProperty>();\n  let JSObjectProperties: Array<PropertyNode> = [];\n\n  simple(ast, {\n    VariableDeclarator(node: Node) {\n      if (\n        isVariableDeclarator(node) &&\n        node.id.name === jsObjectVariableName &&\n        node.init &&\n        isObjectExpression(node.init)\n      ) {\n        JSObjectProperties = node.init.properties;\n      }\n    },\n  });\n\n  JSObjectProperties.forEach((node) => {\n    let params = new Set<functionParam>();\n    const propertyNode = node;\n    let property: JsObjectProperty = {\n      key: generate(propertyNode.key),\n      value: generate(propertyNode.value),\n      type: propertyNode.value.type,\n    };\n\n    if (isPropertyAFunctionNode(propertyNode.value)) {\n      // if in future we need default values of each param, we could implement that in getFunctionalParamsFromNode\n      // currently we don't consume it anywhere hence avoiding to calculate that.\n      params = getFunctionalParamsFromNode(propertyNode.value);\n      property = {\n        ...property,\n        arguments: [...params],\n      };\n    }\n\n    // here we use `generate` function to convert our AST Node to JSCode\n    parsedObjectProperties.add(property);\n  });\n\n  return [...parsedObjectProperties];\n};\n","import { parse, Node, SourceLocation, Options, Comment } from \"acorn\";\nimport { ancestor, simple } from \"acorn-walk\";\nimport { ECMA_VERSION, NodeTypes } from \"./constants/ast\";\nimport { has, isFinite, isString, memoize, toPath } from \"lodash\";\nimport { isTrueObject, sanitizeScript } from \"./utils\";\nimport { jsObjectDeclaration } from \"./jsObject/index\";\n/*\n * Valuable links:\n *\n * * ESTree spec: Javascript AST is called ESTree.\n * Each es version has its md file in the repo to find features\n * implemented and their node type\n * https://github.com/estree/estree\n *\n * * Acorn: The parser we use to get the AST\n * https://github.com/acornjs/acorn\n *\n * * Acorn walk: The walker we use to traverse the AST\n * https://github.com/acornjs/acorn/tree/master/acorn-walk\n *\n * * AST Explorer: Helpful web tool to see ASTs and its parts\n * https://astexplorer.net/\n *\n */\n\ntype Pattern = IdentifierNode | AssignmentPatternNode;\ntype Expression = Node;\n// doc: https://github.com/estree/estree/blob/master/es5.md#memberexpression\ninterface MemberExpressionNode extends Node {\n  type: NodeTypes.MemberExpression;\n  object: MemberExpressionNode | IdentifierNode;\n  property: IdentifierNode | LiteralNode;\n  computed: boolean;\n  // doc: https://github.com/estree/estree/blob/master/es2020.md#chainexpression\n  optional?: boolean;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#identifier\ninterface IdentifierNode extends Node {\n  type: NodeTypes.Identifier;\n  name: string;\n}\n\n//Using this to handle the Variable property refactor\ninterface RefactorIdentifierNode extends Node {\n  type: NodeTypes.Identifier;\n  name: string;\n  property?: IdentifierNode;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#variabledeclarator\ninterface VariableDeclaratorNode extends Node {\n  type: NodeTypes.VariableDeclarator;\n  id: IdentifierNode;\n  init: Expression | null;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#functions\ninterface Function extends Node {\n  id: IdentifierNode | null;\n  params: Pattern[];\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#functiondeclaration\ninterface FunctionDeclarationNode extends Node, Function {\n  type: NodeTypes.FunctionDeclaration;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#functionexpression\ninterface FunctionExpressionNode extends Expression, Function {\n  type: NodeTypes.FunctionExpression;\n}\n\ninterface ArrowFunctionExpressionNode extends Expression, Function {\n  type: NodeTypes.ArrowFunctionExpression;\n}\n\nexport interface ObjectExpression extends Expression {\n  type: NodeTypes.ObjectExpression;\n  properties: Array<PropertyNode>;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es2015.md#assignmentpattern\ninterface AssignmentPatternNode extends Node {\n  type: NodeTypes.AssignmentPattern;\n  left: Pattern;\n}\n\n// doc: https://github.com/estree/estree/blob/master/es5.md#literal\ninterface LiteralNode extends Node {\n  type: NodeTypes.Literal;\n  value: string | boolean | null | number | RegExp;\n}\n\ntype NodeList = {\n  references: Set<string>;\n  functionalParams: Set<string>;\n  variableDeclarations: Set<string>;\n  identifierList: Array<IdentifierNode>;\n};\n\n// https://github.com/estree/estree/blob/master/es5.md#property\nexport interface PropertyNode extends Node {\n  type: NodeTypes.Property;\n  key: LiteralNode | IdentifierNode;\n  value: Node;\n  kind: \"init\" | \"get\" | \"set\";\n}\n\n// Node with location details\ntype NodeWithLocation<NodeType> = NodeType & {\n  loc: SourceLocation;\n};\n\ntype AstOptions = Omit<Options, \"ecmaVersion\">;\n\ntype EntityRefactorResponse = {\n  isSuccess: boolean;\n  body: { script: string; refactorCount: number } | { error: string };\n};\n\n/* We need these functions to typescript casts the nodes with the correct types */\nexport const isIdentifierNode = (node: Node): node is IdentifierNode => {\n  return node.type === NodeTypes.Identifier;\n};\n\nconst isMemberExpressionNode = (node: Node): node is MemberExpressionNode => {\n  return node.type === NodeTypes.MemberExpression;\n};\n\nexport const isVariableDeclarator = (\n  node: Node,\n): node is VariableDeclaratorNode => {\n  return node.type === NodeTypes.VariableDeclarator;\n};\n\nconst isFunctionDeclaration = (node: Node): node is FunctionDeclarationNode => {\n  return node.type === NodeTypes.FunctionDeclaration;\n};\n\nconst isFunctionExpression = (node: Node): node is FunctionExpressionNode => {\n  return node.type === NodeTypes.FunctionExpression;\n};\nconst isArrowFunctionExpression = (\n  node: Node,\n): node is ArrowFunctionExpressionNode => {\n  return node.type === NodeTypes.ArrowFunctionExpression;\n};\n\nexport const isObjectExpression = (node: Node): node is ObjectExpression => {\n  return node.type === NodeTypes.ObjectExpression;\n};\n\nconst isAssignmentPatternNode = (node: Node): node is AssignmentPatternNode => {\n  return node.type === NodeTypes.AssignmentPattern;\n};\n\nexport const isLiteralNode = (node: Node): node is LiteralNode => {\n  return node.type === NodeTypes.Literal;\n};\n\nexport const isPropertyNode = (node: Node): node is PropertyNode => {\n  return node.type === NodeTypes.Property;\n};\n\nexport const isPropertyAFunctionNode = (\n  node: Node,\n): node is ArrowFunctionExpressionNode | FunctionExpressionNode => {\n  return (\n    node.type === NodeTypes.ArrowFunctionExpression ||\n    node.type === NodeTypes.FunctionExpression\n  );\n};\n\nconst isArrayAccessorNode = (node: Node): node is MemberExpressionNode => {\n  return (\n    isMemberExpressionNode(node) &&\n    node.computed &&\n    isLiteralNode(node.property) &&\n    isFinite(node.property.value)\n  );\n};\n\nconst wrapCode = (code: string) => {\n  return `\n    (function() {\n      return ${code}\n    })\n  `;\n};\n\n//Tech-debt: should upgrade this to better logic\n//Used slice for a quick resolve of critical bug\nconst unwrapCode = (code: string) => {\n  let unwrapedCode = code.slice(32);\n  return unwrapedCode.slice(0, -10);\n};\n\nconst getFunctionalParamNamesFromNode = (\n  node:\n    | FunctionDeclarationNode\n    | FunctionExpressionNode\n    | ArrowFunctionExpressionNode,\n) => {\n  return Array.from(getFunctionalParamsFromNode(node)).map(\n    (functionalParam) => functionalParam.paramName,\n  );\n};\n\n// Memoize the ast generation code to improve performance.\n// Since this will be used by both the server and the client, we want to prevent regeneration of ast\n// for the the same code snippet\nexport const getAST = memoize((code: string, options?: AstOptions) =>\n  parse(code, { ...options, ecmaVersion: ECMA_VERSION }),\n);\n\n/**\n * An AST based extractor that fetches all possible references in a given\n * piece of code. We use this to get any references to the global entities in Appsmith\n * and create dependencies on them. If the reference was updated, the given piece of code\n * should run again.\n * @param code: The piece of script where references need to be extracted from\n */\n\nexport interface IdentifierInfo {\n  references: string[];\n  functionalParams: string[];\n  variables: string[];\n}\nexport const extractIdentifierInfoFromCode = (\n  code: string,\n  evaluationVersion: number,\n  invalidIdentifiers?: Record<string, unknown>,\n): IdentifierInfo => {\n  let ast: Node = { end: 0, start: 0, type: \"\" };\n  try {\n    const sanitizedScript = sanitizeScript(code, evaluationVersion);\n    /* wrapCode - Wrapping code in a function, since all code/script get wrapped with a function during evaluation.\n       Some syntax won't be valid unless they're at the RHS of a statement.\n       Since we're assigning all code/script to RHS during evaluation, we do the same here.\n       So that during ast parse, those errors are neglected.\n    */\n    /* e.g. IIFE without braces\n      function() { return 123; }() -> is invalid\n      let result = function() { return 123; }() -> is valid\n    */\n    const wrappedCode = wrapCode(sanitizedScript);\n    ast = getAST(wrappedCode);\n    let { references, functionalParams, variableDeclarations }: NodeList =\n      ancestorWalk(ast);\n    const referencesArr = Array.from(references).filter((reference) => {\n      // To remove references derived from declared variables and function params,\n      // We extract the topLevelIdentifier Eg. Api1.name => Api1\n      const topLevelIdentifier = toPath(reference)[0];\n      return !(\n        functionalParams.has(topLevelIdentifier) ||\n        variableDeclarations.has(topLevelIdentifier) ||\n        has(invalidIdentifiers, topLevelIdentifier)\n      );\n    });\n    return {\n      references: referencesArr,\n      functionalParams: Array.from(functionalParams),\n      variables: Array.from(variableDeclarations),\n    };\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      // Syntax error. Ignore and return empty list\n      return {\n        references: [],\n        functionalParams: [],\n        variables: [],\n      };\n    }\n    throw e;\n  }\n};\n\nexport const entityRefactorFromCode = (\n  script: string,\n  oldName: string,\n  newName: string,\n  isJSObject: boolean,\n  evaluationVersion: number,\n  invalidIdentifiers?: Record<string, unknown>,\n): EntityRefactorResponse => {\n  //Sanitizing leads to removal of special charater.\n  //Hence we are not sanatizing the script. Fix(#18492)\n  //If script is a JSObject then replace export default to decalartion.\n  if (isJSObject) script = jsObjectToCode(script);\n  else script = wrapCode(script);\n  let ast: Node = { end: 0, start: 0, type: \"\" };\n  //Copy of script to refactor\n  let refactorScript = script;\n  //Difference in length of oldName and newName\n  const nameLengthDiff: number = newName.length - oldName.length;\n  //Offset index used for deciding location of oldName.\n  let refactorOffset: number = 0;\n  //Count of refactors on the script\n  let refactorCount: number = 0;\n  try {\n    ast = getAST(script);\n    let {\n      references,\n      functionalParams,\n      variableDeclarations,\n      identifierList,\n    }: NodeList = ancestorWalk(ast);\n    const identifierArray = Array.from(\n      identifierList,\n    ) as Array<RefactorIdentifierNode>;\n    //To handle if oldName has property (\"JSObject.myfunc\")\n    const oldNameArr = oldName.split(\".\");\n    const referencesArr = Array.from(references).filter((reference) => {\n      // To remove references derived from declared variables and function params,\n      // We extract the topLevelIdentifier Eg. Api1.name => Api1\n      const topLevelIdentifier = toPath(reference)[0];\n      return !(\n        functionalParams.has(topLevelIdentifier) ||\n        variableDeclarations.has(topLevelIdentifier) ||\n        has(invalidIdentifiers, topLevelIdentifier)\n      );\n    });\n    //Traverse through all identifiers in the script\n    identifierArray.forEach((identifier) => {\n      if (identifier.name === oldNameArr[0]) {\n        let index = 0;\n        while (index < referencesArr.length) {\n          if (identifier.name === referencesArr[index].split(\".\")[0]) {\n            //Replace the oldName by newName\n            //Get start index from node and get subarray from index 0 till start\n            //Append above with new name\n            //Append substring from end index from the node till end of string\n            //Offset variable is used to alter the position based on `refactorOffset`\n            //In case of nested JS action get end postion fro the property.\n            ///Default end index\n            let endIndex = identifier.end;\n            const propertyNode = identifier.property;\n            //Flag variable : true if property should be updated\n            //false if property should not be updated\n            let propertyCondFlag =\n              oldNameArr.length > 1 &&\n              propertyNode &&\n              oldNameArr[1] === propertyNode.name;\n            //Condition to validate if Identifier || Property should be updated??\n            if (oldNameArr.length === 1 || propertyCondFlag) {\n              //Condition to extend end index in case of property match\n              if (propertyCondFlag && propertyNode) {\n                endIndex = propertyNode.end;\n              }\n              refactorScript =\n                refactorScript.substring(0, identifier.start + refactorOffset) +\n                newName +\n                refactorScript.substring(endIndex + refactorOffset);\n              refactorOffset += nameLengthDiff;\n              ++refactorCount;\n              //We are only looking for one match in refrence for the identifier name.\n              break;\n            }\n          }\n          index++;\n        }\n      }\n    });\n    //If script is a JSObject then revert decalartion to export default.\n    if (isJSObject) refactorScript = jsCodeToObject(refactorScript);\n    else refactorScript = unwrapCode(refactorScript);\n    return {\n      isSuccess: true,\n      body: { script: refactorScript, refactorCount },\n    };\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      // Syntax error. Ignore and return empty list\n      return { isSuccess: false, body: { error: \"Syntax Error\" } };\n    }\n    throw e;\n  }\n};\n\nexport type functionParam = { paramName: string; defaultValue: unknown };\n\nexport const getFunctionalParamsFromNode = (\n  node:\n    | FunctionDeclarationNode\n    | FunctionExpressionNode\n    | ArrowFunctionExpressionNode,\n  needValue = false,\n): Set<functionParam> => {\n  const functionalParams = new Set<functionParam>();\n  node.params.forEach((paramNode) => {\n    if (isIdentifierNode(paramNode)) {\n      functionalParams.add({\n        paramName: paramNode.name,\n        defaultValue: undefined,\n      });\n    } else if (isAssignmentPatternNode(paramNode)) {\n      if (isIdentifierNode(paramNode.left)) {\n        const paramName = paramNode.left.name;\n        if (!needValue) {\n          functionalParams.add({ paramName, defaultValue: undefined });\n        } else {\n          // figure out how to get value of paramNode.right for each node type\n          // currently we don't use params value, hence skipping it\n          // functionalParams.add({\n          //   defaultValue: paramNode.right.value,\n          // });\n        }\n      }\n    }\n  });\n  return functionalParams;\n};\n\nconst constructFinalMemberExpIdentifier = (\n  node: MemberExpressionNode,\n  child = \"\",\n): string => {\n  const propertyAccessor = getPropertyAccessor(node.property);\n  if (isIdentifierNode(node.object)) {\n    return `${node.object.name}${propertyAccessor}${child}`;\n  } else {\n    const propertyAccessor = getPropertyAccessor(node.property);\n    const nestedChild = `${propertyAccessor}${child}`;\n    return constructFinalMemberExpIdentifier(node.object, nestedChild);\n  }\n};\n\nconst getPropertyAccessor = (propertyNode: IdentifierNode | LiteralNode) => {\n  if (isIdentifierNode(propertyNode)) {\n    return `.${propertyNode.name}`;\n  } else if (isLiteralNode(propertyNode) && isString(propertyNode.value)) {\n    // is string literal search a['b']\n    return `.${propertyNode.value}`;\n  } else if (isLiteralNode(propertyNode) && isFinite(propertyNode.value)) {\n    // is array index search - a[9]\n    return `[${propertyNode.value}]`;\n  }\n};\n\nexport const isTypeOfFunction = (type: string) => {\n  return (\n    type === NodeTypes.ArrowFunctionExpression ||\n    type === NodeTypes.FunctionExpression\n  );\n};\n\nexport interface MemberExpressionData {\n  property: NodeWithLocation<IdentifierNode | LiteralNode>;\n  object: NodeWithLocation<IdentifierNode>;\n}\n\n/** Function returns Invalid top-level member expressions from code\n * @param code\n * @param data\n * @param evaluationVersion\n * @returns information about all invalid property/method assessment in code\n * @example Given data {\n * JSObject1: {\n * name:\"JSObject\",\n * data:[]\n * },\n * Api1:{\n * name: \"Api1\",\n * data: []\n * }\n * },\n * For code {{Api1.name + JSObject.unknownProperty}}, function returns information about \"JSObject.unknownProperty\" node.\n */\nexport const extractInvalidTopLevelMemberExpressionsFromCode = (\n  code: string,\n  data: Record<string, any>,\n  evaluationVersion: number,\n): MemberExpressionData[] => {\n  const invalidTopLevelMemberExpressions = new Set<MemberExpressionData>();\n  const variableDeclarations = new Set<string>();\n  let functionalParams = new Set<string>();\n  let ast: Node = { end: 0, start: 0, type: \"\" };\n  try {\n    const sanitizedScript = sanitizeScript(code, evaluationVersion);\n    const wrappedCode = wrapCode(sanitizedScript);\n    ast = getAST(wrappedCode, { locations: true });\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      // Syntax error. Ignore and return empty list\n      return [];\n    }\n    throw e;\n  }\n  simple(ast, {\n    MemberExpression(node: Node) {\n      const { object, property, computed } = node as MemberExpressionNode;\n      // We are only interested in top-level MemberExpression nodes\n      // Eg. for Api1.data.name, we are only interested in Api1.data\n      if (!isIdentifierNode(object)) return;\n      if (!(object.name in data) || !isTrueObject(data[object.name])) return;\n      // For computed member expressions (assessed via [], eg. JSObject1[\"name\"] ),\n      // We are only interested in strings\n      if (\n        isLiteralNode(property) &&\n        isString(property.value) &&\n        !(property.value in data[object.name])\n      ) {\n        invalidTopLevelMemberExpressions.add({\n          object,\n          property,\n        } as MemberExpressionData);\n      }\n      // We ignore computed member expressions if property is an identifier (JSObject[name])\n      // This is because we can't statically determine what the value of the identifier might be.\n      if (\n        isIdentifierNode(property) &&\n        !computed &&\n        !(property.name in data[object.name])\n      ) {\n        invalidTopLevelMemberExpressions.add({\n          object,\n          property,\n        } as MemberExpressionData);\n      }\n    },\n    VariableDeclarator(node: Node) {\n      if (isVariableDeclarator(node)) {\n        variableDeclarations.add(node.id.name);\n      }\n    },\n    FunctionDeclaration(node: Node) {\n      if (!isFunctionDeclaration(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n    FunctionExpression(node: Node) {\n      if (!isFunctionExpression(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n    ArrowFunctionExpression(node: Node) {\n      if (!isArrowFunctionExpression(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n  });\n\n  const invalidTopLevelMemberExpressionsArray = Array.from(\n    invalidTopLevelMemberExpressions,\n  ).filter((MemberExpression) => {\n    return !(\n      variableDeclarations.has(MemberExpression.object.name) ||\n      functionalParams.has(MemberExpression.object.name)\n    );\n  });\n\n  return invalidTopLevelMemberExpressionsArray;\n};\n\nconst ancestorWalk = (ast: Node): NodeList => {\n  //List of all Identifier nodes with their property(if exists).\n  const identifierList = new Array<RefactorIdentifierNode>();\n  // List of all references found\n  const references = new Set<string>();\n  // List of variables declared within the script. All identifiers and member expressions derived from declared variables will be removed\n  const variableDeclarations = new Set<string>();\n  // List of functional params declared within the script. All identifiers and member expressions derived from functional params will be removed\n  let functionalParams = new Set<string>();\n\n  /*\n   * We do an ancestor walk on the AST in order to extract all references. For example, for member expressions and identifiers, we need to know\n   * what surrounds the identifier (its parent and ancestors), ancestor walk will give that information in the callback\n   * doc: https://github.com/acornjs/acorn/tree/master/acorn-walk\n   */\n  ancestor(ast, {\n    Identifier(node: Node, ancestors: Node[]) {\n      /*\n       * We are interested in identifiers. Due to the nature of AST, Identifier nodes can\n       * also be nested inside MemberExpressions. For deeply nested object references, there\n       * could be nesting of many MemberExpressions. To find the final reference, we will\n       * try to find the top level MemberExpression that does not have a MemberExpression parent.\n       * */\n      let candidateTopLevelNode: IdentifierNode | MemberExpressionNode =\n        node as IdentifierNode;\n      let depth = ancestors.length - 2; // start \"depth\" with first parent\n      while (depth > 0) {\n        const parent = ancestors[depth];\n        if (\n          isMemberExpressionNode(parent) &&\n          /* Member expressions that are \"computed\" (with [ ] search)\n             and the ones that have optional chaining ( a.b?.c )\n             will be considered top level node.\n             We will stop looking for further parents */\n          /* \"computed\" exception - isArrayAccessorNode\n             Member expressions that are array accessors with static index - [9]\n             will not be considered top level.\n             We will continue looking further. */\n          (!parent.computed || isArrayAccessorNode(parent)) &&\n          !parent.optional\n        ) {\n          candidateTopLevelNode = parent;\n          depth = depth - 1;\n        } else {\n          // Top level found\n          break;\n        }\n      }\n      //If parent is a Member expression then attach property to the Node.\n      //else push Identifier Node.\n      const parentNode = ancestors[ancestors.length - 2];\n      if (isMemberExpressionNode(parentNode)) {\n        identifierList.push({\n          ...(node as IdentifierNode),\n          property: parentNode.property as IdentifierNode,\n        });\n      } else identifierList.push(node as RefactorIdentifierNode);\n      if (isIdentifierNode(candidateTopLevelNode)) {\n        // If the node is an Identifier, just save that\n        references.add(candidateTopLevelNode.name);\n      } else {\n        // For MemberExpression Nodes, we will construct a final reference string and then add\n        // it to the references list\n        const memberExpIdentifier = constructFinalMemberExpIdentifier(\n          candidateTopLevelNode,\n        );\n        references.add(memberExpIdentifier);\n      }\n    },\n    VariableDeclarator(node: Node) {\n      // keep a track of declared variables so they can be\n      // removed from the final list of references\n      if (isVariableDeclarator(node)) {\n        variableDeclarations.add(node.id.name);\n      }\n    },\n    FunctionDeclaration(node: Node) {\n      // params in function declarations are also counted as references so we keep\n      // track of them and remove them from the final list of references\n      if (!isFunctionDeclaration(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n    FunctionExpression(node: Node) {\n      // params in function expressions are also counted as references so we keep\n      // track of them and remove them from the final list of references\n      if (!isFunctionExpression(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n    ArrowFunctionExpression(node: Node) {\n      // params in arrow function expressions are also counted as references so we keep\n      // track of them and remove them from the final list of references\n      if (!isArrowFunctionExpression(node)) return;\n      functionalParams = new Set([\n        ...functionalParams,\n        ...getFunctionalParamNamesFromNode(node),\n      ]);\n    },\n  });\n  return {\n    references,\n    functionalParams,\n    variableDeclarations,\n    identifierList,\n  };\n};\n\n//Replace export default by a variable declaration.\n//This is required for acorn to parse code into AST.\nconst jsObjectToCode = (script: string) => {\n  return script.replace(/export default/g, jsObjectDeclaration);\n};\n\n//Revert the string replacement from 'jsObjectToCode'.\n//variable declaration is replaced back by export default.\nconst jsCodeToObject = (script: string) => {\n  return script.replace(jsObjectDeclaration, \"export default\");\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [72,429,998], function() { return __webpack_require__(86043); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"72\":\"1f61a85c\",\"429\":\"f13b5ef6\",\"998\":\"c73b6c4d\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.hmd = function(module) {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: function() {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","(function () {\n  if (typeof __webpack_require__ !== 'undefined') {\n    var oldGetScript = __webpack_require__.u;\n    var oldLoadScript = __webpack_require__.e;\n    var queryMap = {};\n    var countMap = {};\n    var getRetryDelay = function () {\n      return 3000;\n    };\n    __webpack_require__.u = function (chunkId) {\n      var result = oldGetScript(chunkId);\n      return (\n        result +\n        (queryMap.hasOwnProperty(chunkId) ? '?' + queryMap[chunkId] : '')\n      );\n    };\n    __webpack_require__.e = function (chunkId) {\n      var result = oldLoadScript(chunkId);\n      return result.catch(function (error) {\n        var retries = countMap.hasOwnProperty(chunkId) ? countMap[chunkId] : 2;\n        if (retries < 1) {\n          var realSrc = oldGetScript(chunkId);\n          error.message =\n            'Loading chunk ' +\n            chunkId +\n            ' failed after 2 retries.\\n(' +\n            realSrc +\n            ')';\n          error.request = realSrc;\n          window.location.href = '/404.html';\n          throw error;\n        }\n        return new Promise(function (resolve) {\n          var retryAttempt = 2 - retries + 1;\n          setTimeout(function () {\n            var retryAttemptString = '&retry-attempt=' + retryAttempt;\n            var cacheBust = 'cache-bust=true' + retryAttemptString;\n            queryMap[chunkId] = cacheBust;\n            countMap[chunkId] = retries - 1;\n            resolve(__webpack_require__.e(chunkId));\n          }, getRetryDelay(retryAttempt));\n        });\n      });\n    };\n  }\n})();\n","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t101: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkappsmith\"] = self[\"webpackChunkappsmith\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([72,429,998].map(__webpack_require__.e, __webpack_require__)).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["DataTreeDiffEvent","IMMEDIATE_PARENT_REGEX","CrashingError","_Error","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","_wrapNativeSuper","Error","convertPathToString","arrPath","string","forEach","segment","val","Number","isInteger","_","test","length","getEntityNameAndPropertyPath","fullPath","indexOfFirstDot","indexOf","entityName","propertyPath","substring","translateCollectionDiffs","data","event","dataTreeDiffs","Array","isArray","diff","idx","push","payload","concat","isTrueObject","Object","keys","diffKey","path","translateDiffEventToDataTreeDiffEvent","difference","unEvalDataTree","result","value","NOOP","match","isJsAction","isJSAction","kind","NEW","DELETE","rhsChange","rhs","isDynamicValue","lhsChange","lhs","EDIT","dataTreeDeleteDiffs","undefined","_objectSpread","item","_toConsumableArray","index","addDependantsOfNestedPropertyPaths","parentPaths","inverseMap","withNestedPaths","Set","dependantNodes","add","filter","dependantNodePath","isChildPropertyPath","isWidget","entity","ENTITY_TYPE","WIDGET","isAction","ACTION","isAppsmithEntity","APPSMITH","JSACTION","removeFunctions","JSON","parse","stringify","v","toString","makeParentsDependOnChildren","depMap","allkeys","key","makeParentsDependOnChild","child","matches","curKey","logWarn","parentKey","existing","from","getImmediateParentsOfPropertyPaths","propertyPaths","parents","getAllPaths","records","i","tempKey","_i","_Object$keys","trimDependantChangePaths","changePaths","dependencyMap","_step","trimmedPaths","_iterator","_createForOfIteratorHelper","s","n","done","foundADependant","_step2","dependants","_iterator2","dependantPath","has","err","e","f","getSafeToRenderDataTree","tree","widgetTypeConfigMap","reduce","entityKey","safeToRenderEntity","entries","validationPaths","_ref","_ref2","_slicedToArray","property","validation","parsed","validateWidgetProperty","type","derivedProperties","_defineProperty","addErrorToEntityProperty","_ref3","dataTree","errors","evalProps","_getEntityNameAndProp2","fullPropertyPath","isPrivateEntityPath","getAllPrivateWidgetsInDataTree","logBlackList","get","errorPath","EVAL_ERROR_PATH","existingErrors","set","resetValidationErrorsForEntityProperty","_ref4","_getEntityNameAndProp3","existingErrorsExceptValidation","error","errorType","PropertyEvaluationErrorType","VALIDATION","prototype","call","isDynamicLeaf","unEvalTree","_$toPath","_$toPath2","_toArray","propPathEls","slice","hasOwnProperty","relativePropertyPath","reactivePaths","triggerPaths","addWidgetPropertyDependencies","_ref5","dependencies","propertyOverrideDependency","_ref6","_ref7","overriddenPropertyKey","overridingPropertyKeyMap","existingDependenciesSet","META","DEFAULT","privateWidgets","overrideWidgetProperties","params","currentTree","evalMetaUpdates","isNewWidget","clonedValue","klona","overridingPropertyPaths","pathsNotToOverride","widgetPathsNotToOverride","overriddenPropertyPath","overriddenPropertyPathArray","split","includes","widgetName","metaPropertyPath","widgetId","propertyOverridingKeyMap","defaultValue","clonedDefaultValue","propertyPathArray","overwriteParsedValue","newValue","isValidEntity","isObject","isNewEntity","updates","find","overriddenPropertyPaths","isMetaPropDirty","overriddenMetaPaths","getStaleMetaStateIds","args","metaWidgets","widget","_i2","_Object$keys2","isWidgetDefaultPropertyPath","siblingMetaWidgets","convertJSFunctionsToString","jscollections","collections","collectionName","jsCollection","jsFunctions","meta","funcName","String","AppsmithWorkers","WorkerErrorTypes","LintTooltipDirection","CustomLintErrorCode","JS_OBJECT_START_STATEMENT","INVALID_ENTITY_PROPERTY","propertyName","ViewTypes","PaginationSubComponent","SortingSubComponent","WhereClauseSubComponent","extractExpressionObject","config","parentPath","bindingPaths","expressions","DATA_BIND_REGEX_GLOBAL","completePath","exp","expression","output","extractEvalConfigFromFormConfig","formConfig","paths","bindingsFound","EventType","EXECUTION_PARAM_KEY","EXECUTION_PARAM_REFERENCE_REGEX","THIS_DOT_PARAMS_KEY","_defaultActionSetting","PluginType","API","apiActionSettingsConfig","DB","queryActionSettingsConfig","SAAS","saasActionSettingsConfig","REMOTE","JS","_defaultActionEditorC","apiActionEditorConfig","_defaultActionDepende","apiActionDependencyConfig","_defaultDatasourceFor","apiActionDatasourceFormButtonConfig","DATA_BIND_REGEX","QUOTED_BINDING_REGEX","ExecutionType","addDataTreeToContext","EVAL_CONTEXT","isTriggerBased","_args$skipEntityFunct","skipEntityFunctions","entityFunctionCollection","_dataTreeEntries","_dataTreeEntries$_i","entityFns","entityFn","qualifier","func","fn","name","_Object$entries","_Object$entries$_i","funcObj","assign","addPlatformFunctionsToEvalContext","context","getPlatformFunctions","self","$cloudHosting","fnDef","addFn","bind","getAllAsyncFunctions","asyncFunctionNameMap","_i3","_dataTreeEntries2","_step3","_dataTreeEntries2$_i","_iterator3","_step4","_iterator4","createNewEntity","__config__","rest","_objectWithoutProperties","_excluded","newObj","create","createUnEvalTreeForEval","unevalTree","newUnEvalTree","makeEntityConfigsAsObjProperties","option","_option$sanitizeDataT","sanitizeDataTree","newDataTree","entityConfig","getPrototypeOf","dataTreeToReturn","sanitizedEvalProps","entityEvalProps","__evaluation__","EVAL_WORKER_SYNC_ACTION","EVAL_WORKER_ASYNC_ACTION","MAIN_THREAD_ACTION","EVAL_WORKER_ACTIONS","CE_MAIN_THREAD_ACTION","LOG_JS_FUNCTION_EXECUTION","cloudHosting","platformFns","navigateTo","showAlert","showModal","closeModal","download","postWindowMessage","copyToClipboard","resetWidget","storeValue","removeValue","clearStore","isAsyncGuard","run","clear","getGeoLocation","watchGeoLocation","stopWatchGeoLocation","EvaluationSubstitutionType","OverridingPropertyType","_DIFF_","ReplayEntity","replayEntityType","diffMap","undoManager","logs","doc","Doc","this","Map","UndoManager","captureTimeout","replayType","undoStack","redoStack","start","performance","now","canReplay","diffs","getDiffs","undo","redo","replay","applyDiffs","stop","log","undoTime","replayEntity","timeTaken","getPathsFromDiff","startTime","deepDiff","endTime","updateTime","isUndo","applyDiff","revertChange","applyChange","processDiff","captureException","extra","updateLength","UPDATES","TOASTS","FOCUSES","WIDGETS","setPropertyUpdate","existingPathValue","addToArray","obj","join","pathArrayToString","stringPath","isNaN","parseInt","getDynamicStringSegments","dynamicString","stringSegments","indexOfDoubleParanStart","firstString","sum","char","prevChar","EvalErrorTypes","getDynamicBindings","jsSnippets","sanitisedString","trim","map","getEntityDynamicBindingPathList","dynamicBindingPathList","isPathADynamicBinding","getPropertyPath","isPathDynamicTrigger","dynamicTriggerPathList","unsafeFunctionForEval","parentPropertyPath","childPropertyPath","startsWith","EVALUATION_PATH","EVAL_VALUE_PATH","getNestedEvalPath","pathType","isPopulated","_getEntityNameAndProp","nestedPath","getEvalErrorPath","options","getEvalValuePath","_PropertyEvalErrorTyp","PARSE","LINT","getEntityType","getEntityId","actionId","getEntityName","MessageType","sendMessage","message","postMessage","Types","getType","STRING","NUMBER","BOOLEAN","ARRAY","FUNCTION","OBJECT","UNDEFINED","NULL","UNKNOWN","updateJSCollectionInUnEvalTree","parsedBody","modifiedUnEvalTree","functionsList","varList","variables","action","oldConfig","actions","body","SMART_SUBSTITUTE","TEMPLATE","isAsync","confirmBeforeExecute","_loop","oldActionName","js","unset","newVar","existedVarVal","newVarList","_loop2","varListItem","removeFunctionsAndVariableJSCollection","jsEntityName","modifiedDataTree","varName","_loop3","actionName","isJSObjectFunction","jsObjectName","isPromise","Boolean","then","DOM_APIS","documentMock","acc","dom","window","document","UNDEFINED_ACTION_IN_SYNC_EVAL_ERROR","errorModifier","ErrorModifier","errorNamesToScan","asyncFunctionsNameMap","errorMessage","getErrorMessage","asyncFunctionFullPath","functionNameWithWhiteSpace","getErrorMessageWithType","replaceAll","FoundPromiseInSyncEvalError","_this","ActionCalledInSyncFieldError","_Error2","_super2","_this2","_possibleConstructorReturn","EvaluationScriptType","ScriptTemplate","EvaluationScripts","_EvaluationScripts","EXPRESSION","ANONYMOUS_FUNCTION","ASYNC_ANONYMOUS_FUNCTION","TRIGGERS","topLevelWorkerAPIs","resetWorkerGlobalScope","$isDataField","JSLibraries","lib","accessor","libraryReservedIdentifiers","beginsWithLineBreakRegex","createEvaluationContext","evalArguments","resolvedFunctions","ARGUMENTS","THIS_CONTEXT","thisContext","globalContext","assignJSFunctionsToContext","_jsObjectNames","resolvedObject","jsObject","jsObjectFunction","_jsObject$fnName","fnName","jsObjectFunctionFactory","getUserScriptToEvaluate","userScript","unescapedJS","trimmedJS","replace","evaluationVersion","unescapeJS","sanitizeScript","script","scriptType","evalArgumentsExist","getScriptType","buffer","getScriptToEval","evaluateSync","isJSCollection","evalContext","triggers","indirectEval","Promise","severity","Severity","ERROR","raw","originalBinding","evaluateAsync","_x","_x2","_x3","_x4","_x5","_evaluateAsync","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","wrap","_context2","prev","next","abrupt","_callee","_getUserScriptToEvalu2","_context","sent","t0","request","callbackData","dynamicTrigger","eventType","triggerMeta","__unEvalTree__","_dataTreeEvaluator$se","evalOrder","nonDynamicFieldValidationOrder","unEvalUpdates","evalTree","dataTreeEvaluator","ExecutionMetaData","setExecutionMetaData","setupUpdateTree","evalAndValidateSubTree","evaluateTriggers","createMessage","format","_len","_key","ONBOARDING_CHECKLIST_ACTIONS","customJSLibraryMessages","url","accessors","LibraryInstallError","ignoredKeys","makeTernDefs","defs","cachedDefs","visitedReferences","iteration_count","baseObjPrototype","queue","shift","src","target","getTernDocType","getOwnPropertyNames","NameCollisionError","code","ImportError","TernDefinitionError","_Error3","_super3","_this3","LibraryOverrideError","_Error4","_super4","_this4","ReplayEditor","_ReplayEntity","entityType","getChanges","isEmpty","modifiedProperty","update","_internalSetTimeout","setTimeout","_internalClearTimeout","clearTimeout","cb","delay","metaData","getExecutionMetaData","timerId","_originalFetch","fetch","Request","initLocalStorage","localStorage","getItem","appsmith","store","setItem","removeItem","defineProperty","enumerable","overrideWebAPIs","ctx","userLogs","overrideConsoleAPI","setInterval","clearAllIntervals","syncHandlerMap","_syncHandlerMap","EVAL_ACTION_BINDINGS","bindings","executionParams","values","evaluateActionBindings","cleanValues","clearErrors","EVAL_TREE","EXECUTE_SYNC_JS","functionCall","UNDO","entityId","replayMap","CANVAS","replayResult","clearLogs","REDO","UPDATE_REPLAY_OBJECT","replayObject","VALIDATE_PROPERTY","props","INSTALL_LIBRARY","takenAccessors","takenNamesMap","currentEnvKeys","unsetKeys","existingLibraries","importScripts","collidingNames","_step7","_iterator7","checkForNameCollision","_step8","_iterator8","checkIfUninstalledEarlier","_step9","overriddenAccessors","_iterator9","checkForOverrides","status","success","UNINSTALL_LIBRARY","_step5","_iterator5","LOAD_LIBRARIES","resetJSLibraries","urls","keysBefore","_self","_step6","keysAfter","newKeys","_iterator6","LINT_TREE","noop","SETUP","setupDOM","CLEAR_CACHE","clearCache","SET_EVALUATION_VERSION","version","INIT_FORM_EVAL","currentEvalState","setFormEvaluationSaga","asyncHandlerMap","_asyncHandlerMap","EVAL_TRIGGER","EVAL_EXPRESSION","_asyncRequestMessageListener","_e$data2","messageId","method","messageHandler","end","messageType","REQUEST","WorkerMessenger","respond","addEventListener","_e$data","responseData","UserLog","isEnabled","emitter","getSource","_triggerMeta$source","_triggerMeta$source2","_triggerMeta$source3","source","triggerPropertyName","id","_this$emitter","parseLogs","emit","TriggerEmitter","_console","console","debug","info","table","warn","saveLog","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","replaceFunctionWithNamesFromObjects","uuid4","timestamp","moment","INFO","stack","WARNING","sanitizeData","_internalSetInterval","_internalClearInterval","clearInterval","intervalIdMap","intervalId","callback","runningIntervalId","delete","_internalIntervalId","customIntervalId","responseHandler","requestId","resolve","listener","_event$data","RESPONSE","removeEventListener","_request","response","uniqueId","toFixed","CLONE_ERROR","fnGuards","guard","writable","configurable","ConditionType","FormDataPaths","finalEvalObj","evalConfigPaths","MATCH_ACTION_CONFIG_PROPERTY","matchExact","r","str","generateInitialEvalState","configPropertyPath","staticDependencyPathList","conditionals","conditionTypes","dependencyPaths","configProperty","identifier","allConditionTypes","HIDE","SHOW","_formConfig$condition","_formConfig$condition2","visible","merge","showOrHideDependencies","show","hide","ENABLE","DISABLE","_formConfig$condition3","_formConfig$condition4","enabled","enableOrDisableDependencies","enable","disable","FETCH_DYNAMIC_VALUES","_formConfig$condition5","_formConfig$condition6","dynamicDependencyPathList","fetchDynamicValuesDependencies","fetchDynamicValues","condition","dynamicValues","allowedToFetch","isLoading","hasStarted","hasFetchFailed","evaluatedConfig","generateEvalFormConfigPaths","uniq","evaluateFormConfig","updateEvaluatedConfig","evaluateFormConfigObject","children","schema","configToBeChecked","placeholderText","placeHolderText","isString","evaluateDynamicValuesConfig","actionConfiguration","configArray","evaluatedValue","eval","evaluateFormConfigElements","evaluatedVal","evaluate","actionDiffPath","hasRouteChanged","conditionBlock","conditionType","_currentEvalState$key","_currentEvalState$key2","_currentEvalState$key3","_currentEvalState$key4","_currentEvalState$key5","_currentEvalState$key6","_currentEvalState$key7","isActionDiffADependency","EVALUATE_FORM_CONFIG","getFormEvaluation","formId","currentFormIdEvalState","conditionToBeEvaluated","dynamicConditionsToBeFetched","_value$staticDependen","COMMAND","ReduxActionTypes","INIT_FORM_EVALUATION","editorConfig","settingConfig","formData","positionProps","ReplayCanvas","processDiffForWidgets","processDiffForTheme","widgetProperty","toast","createToast","widgets","diffWidget","dslWidget","isCreated","filterBindingSegmentsAndRemoveQuotes","binding","subSegments","subSegmentValues","bindingStrippedQuotes","original","firstGroup","subBindings","subValues","substituteDynamicBindingWithValues","evaluationSubstitutionType","finalValue","b","templateSubstituteDynamicValues","_filterBindingSegment","finalBinding","smartSubstituteDynamicValues","PARAMETER","_filterBindingSegment2","parameters","parameterSubstituteDynamicValues","extractInfoFromReferences","references","allPaths","validReferences","invalidReferences","reference","subpaths","toPath","current","pop","extractInfoFromBindings","bindingsInfo","_extractInfoFromBindi","extractIdentifierInfoFromCode","invalidEntityIdentifiers","extractInfoFromBinding","union","newEvalError","EXTRACT_DEPENDENCY_ERROR","listTriggerFieldDependencies","triggerFieldDependency","dynamicTriggerPathlist","dynamicPath","unevalPropValue","existingDeps","jsSnippet","listValidationDependencies","validationDependency","validationConfig","dependentPaths","dependencyArray","mergeArrays","currentArr","updateArr","JAVASCRIPT_KEYWORDS","APPSMITH_GLOBAL_FUNCTIONS","DEDICATED_WORKER_GLOBAL_SCOPE_IDENTIFIERS","listEntityDependencies","widgetDependencies","entityDependencies","actionDependentPaths","mainPath","dependentPath","unevalPropValueString","listEntityPathDependencies","isATriggerPath","isTrigger","listEntityPathTriggerFieldDependencies","triggerFieldDependencies","isADynamicTriggerPath","updateMap","deleteOnEmpty","replaceValue","oldValue","updatedEntries","FunctionDeterminer","$isAsync","userFunction","constructor","returnValue","functionDeterminer","getUpdatedLocalUnEvalTreeAfterJSUpdates","jsUpdates","localUnEvalTree","regex","RegExp","saveResolvedFunctionsAndJSUpdates","dataTreeEvalRef","currentJSCollectionState","parseStartTime","parsedObject","parseJSObjectWithAST","JSObjectASTParseTime","JSObjectName","parsedElement","isTypeOfFunction","paramName","functionString","parsedFunction","_unused","PARSE_JS_ERROR","parseJSActions","differences","oldUnEvalTree","setupEval","isFunctionAsync","close","getJSEntities","jsCollections","DataTreeEvaluator","widgetConfigMap","allActionValidationConfig","sortedDependencies","inverseDependencyMap","unParsedEvalTree","allKeys","triggerFieldDependencyMap","invalidReferencesMap","validationDependencyMap","sortedValidationDependencies","inverseValidationDependencyMap","hasCyclicalDependency","totalFirstTreeSetupStartTime","firstCloneStartTime","firstCloneEndTime","allKeysGenerationStartTime","allKeysGenerationEndTime","createDependencyMapStartTime","_createDependencyMap","entityListedDependencies","_extractInfoFromBindi2","createDependencyMap","createDependencyMapEndTime","sortDependenciesStartTime","sortDependencies","sortDependenciesEndTime","inverseDependencyGenerationStartTime","getInverseDependencyTree","inverseDependencyGenerationEndTime","secondCloneStartTime","secondCloneEndTime","totalFirstTreeSetupEndTime","timeTakenForSetupFirstTree","total","getFixedTimeDifference","clone","inverseDependency","lintOrder","evaluationStartTime","_this$evaluateTree","evaluateTree","evaluatedTree","staleMetaIds","evaluationEndTime","validationStartTime","setEvalTree","getValidatedTree","validationEndTime","timeTakenForEvalAndValidateFirstTree","evaluation","getEvalTree","totalUpdateTreeSetupStartTime","diffCheckTimeStartTime","updateLocalUnEvalTree","oldUnEvalTreeJSCollections","localUnEvalTreeJSCollection","jsDifferences","jsTranslatedDiffs","flatten","stringifiedOldUnEvalTreeJSCollections","stringifiedLocalUnEvalTreeJSCollection","oldUnEvalTreeWithStrigifiedJSFunctions","localUnEvalTreeWithStrigifiedJSFunctions","pathsToClearErrorsFor","translatedDiffs","diffCheckTimeStopTime","updateDependencyStartTime","_updateDependencyMap","diffCalcStart","didUpdateDependencyMap","didUpdateValidationDependencyMap","dependenciesOfRemovedPaths","removedPaths","extraPathsToLint","dataTreeEvalErrors","dataTreeDiff","_dataTreeDiff$payload","_listEntityPathDepend","entityPathDependencies","_extractInfoFromBindi5","extractDependencyErrors","_extractInfoFromBindi6","entityDependencyMap","entityDependent","_extractInfoFromBindi3","triggerFieldDependent","_extractInfoFromBindi4","newlyValidReferencesMap","invalidReference","newlyValidReference","newInvalidReferences","triggerPath","triggerPathDependency","widgetDep","triggerDep","validationDependencies","validationDep","dependencyPath","toRemove","entityPropertyPath","correctSnippets","_extractInfoFromBindi7","entityDependenciesName","dep","_extractInfoFromBindi8","_extractInfoFromBindi9","diffCalcEnd","subDepCalcStart","subDepCalcEnd","updateChangedDependenciesStart","updateChangedDependenciesStop","diffCalcDeps","subDepCalc","updateChangedDependencies","updateDependencyMap","updateDependencyEndTime","applyDifferencesToEvalTree","calculateSortOrderStartTime","subTreeSortOrder","calculateSubTreeSortOrder","calculateSortOrderEndTime","evaluationOrder","nonDynamicFieldValidationOrderSet","unEvalPropValue","evalPropValue","isFunction","inverse","updatedDependencyMap","removedPath","cloneStartTime","cloneEndTime","totalUpdateTreeSetupEndTime","timeTakenForSetupUpdateTree","findDifferences","unevalUpdates","metaWidgetIds","_this$evaluateTree2","skipRevalidation","isFirstTree","newEvalTree","reValidateStartTime","reValidateTree","reValidateEndTime","timeTakenForEvalAndValidateSubTree","revalidation","changes","subSortOrderArray","finalSortOrder","computeSortOrder","getEvaluationSortOrder","uniqueKeysInSortOrder","sortOrderPropertyPaths","completeSortOrder","finalSortOrderArray","lastIndexOf","sortOrder","iterator","newNodes","toBeEvaluatedNode","oldUnevalTree","updateAsyncFunctions","evalPropertyValue","unEvalPropertyValue","isADynamicBindingPath","requiresEval","contextData","getDynamicValue","EVAL_PROPERTY_ERROR","parsedValue","validateAndParseWidgetProperty","setParsedValue","reValidateWidgetDependentProperty","validateActionProperty","currentEvaluatedValue","EVAL_TREE_ERROR","dependencyTree","toposort","reverse","d","cyclicNodes","node","pluginType","CYCLICAL_DEPENDENCY_ERROR","logError","dynamicBinding","callBackData","_getDynamicBindings","toBeSentForEval","evaluateDynamicBoundValue","_evaluateTriggers","_getDynamicBindings2","isJSObject","overwriteObj","getUnParsedEvalTree","_this5","_this6","_validateActionProper","isValid","messages","_messages$map","evalErrors","text","unEvalEntity","newEntityObject","updateConfigForModifiedEntity","entityDynamicBindingPaths","entityDynamicBindingPathList","relativePath","changePathsWithNestedDependants","trimmedChangedPaths","getCompleteSortOrder","incomingEdges","edge","_this7","evaluatedExecutionParams","replacedBinding","isCreateFirstTree","forceEvaluation","requiresLinting","shouldReplay","theme","__unevalTree__","_replayMap$CANVAS","setAllActionValidationConfig","setupFirstTreeResponse","setupFirstTree","initiateLinting","dataTreeResponse","evalAndValidateFirstTree","_replayMap$CANVAS2","setupUpdateTreeResponse","updateResponse","_replayMap$CANVAS3","_replayMap$CANVAS4","_replayMap$CANVAS5","_dataTreeEvaluator","UNKNOWN_ERROR","MAX_ALLOWED_LINE_BREAKS","LINE_BREAKS_ERROR_MESSAGE","flat","array","uniqueParam","a","validatePlainObject","_config$params","allowedKeys","_config$params2","_valid","_messages","entry","_entry$params","_entry$params2","_entry$params3","ignoreCase","entryName","toLowerCase","getPropertyEntry","_validate","validate","required","requiredKey","default","validateArray","_config$params3","_config$params4","_config$params4$child","_config$params4$child2","_config$params5","_config$params5$child","_config$params6","_config$params7","_config$params8","_config$params9","_config$params12","_isValid","allowedValues","uniqueKeys","allowedKeyConfigs","ValidationTypes","compact","allowedKeyConfig","_allowedKeyConfig$par","unique","_config$params11","childrenValidationConfig","shouldVerifyAllowedValues","size","shouldValidateChildren","shouldArrayHaveUniqueEntries","shouldArrayValuesHaveUniqueValuesForKeys","_config$params10","duplicateIndex","findDuplicateIndex","some","every","_childValidationResul","childValidationResult","validateExcessLineBreaks","countOccurrences","validateObjectValues","validateFn","VALIDATORS","staticValue","WIDGET_TYPE_VALIDATION_ERROR","getExpectedType","_config$params13","_config$params13$expe","_config$params14","_config$params15","_config$params17","_config$params17$expe","_config$params18","_config$params19","_config$params21","_config$params23","_config$params24","_config$params26","_config$params28","expected","TEXT","_config$params16","allowed","REGEX","DATE_ISO_STRING","_config$params20","_config$params22","validationType","min","max","_config$params25","objectType","_expected","NESTED_OBJECT_ARRAY","_config$params27","OBJECT_ARRAY","IMAGE_URL","SAFE_URL","_VALIDATORS","_config$params31","_config$params33","_config$params36","_config$params37","_config$params38","_config$params30","_config$params29","limitLineBreaks","_config$params34","_config$params35","_parsed","maxLength","_config$params39","stringValidationError","_config$params32","strict","isRegExp","_VALIDATORS$Validatio","_config$params45","_config$params46","_config$params47","_config$params40","_config$params41","_config$params42","_config$params43","isFinite","_parsed2","_config$params44","passThroughOnZero","natural","_config$params50","_config$params48","_config$params49","_config$params51","isStringTrueFalse","_config$params53","_config$params52","isPlainObject","_config$params54","_config$params55","_config$params56","_config$params57","_config$params58","invalidResponse","_value","_config$params59","_config$params60","_config$params61","_config$params62","_config$params63","_step$value","parsedEntry","_config$params64","_config$params65","_config$params66","_config$params67","param","flattenedArray","shouldBeUnique","_config$params68","_config$params69","toISOString","_config$params70","_config$params71","_config$params72","fnString","_config$params73","btoa","atob","_config$params74","getIsSafeURL","ARRAY_OF_TYPE_OR_TYPE","_config$params75","_config$params76","_config$params76$para","resultValue","ping","_validateWidgetProper","transformed","isUndefined","parsedEntity","_validateWidgetProper2","_messages$map2","SourceType","NodeTypes","exports","fromCodePoint","object","$defineProperty","stringFromCharCode","fromCharCode","floor","Math","highSurrogate","lowSurrogate","MAX_SIZE","codeUnits","codePoint","RangeError","jsEscapeRegex","usualEscapeSequences","fromHex","__","varHex","longHex","shortHex","octal","specialCharacter","python","module","jsObjectVariableName","jsObjectDeclaration","isIdentifierNode","isMemberExpressionNode","isVariableDeclarator","isFunctionDeclaration","isFunctionExpression","isArrowFunctionExpression","isObjectExpression","isAssignmentPatternNode","isLiteralNode","isPropertyAFunctionNode","isArrayAccessorNode","computed","lodash","wrapCode","getFunctionalParamNamesFromNode","getFunctionalParamsFromNode","functionalParam","getAST","memoize","acorn","ecmaVersion","needValue","functionalParams","paramNode","left","constructFinalMemberExpIdentifier","propertyAccessor","getPropertyAccessor","nestedChild","propertyNode","ancestorWalk","ast","identifierList","variableDeclarations","acornWalk","ancestor","Identifier","ancestors","candidateTopLevelNode","depth","parent","optional","parentNode","memberExpIdentifier","VariableDeclarator","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","jsObjectToCode","jsCodeToObject","invalidIdentifiers","sanitizedScript","wrappedCode","_ancestorWalk","topLevelIdentifier","SyntaxError","jsObjectBody","jsCode","parsedObjectProperties","JSObjectProperties","simple","init","properties","astring","generate","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","loaded","__webpack_modules__","m","x","__webpack_exports__","O","deferred","chunkIds","priority","notFulfilled","Infinity","fulfilled","j","splice","getter","__esModule","definition","o","chunkId","all","promises","u","miniCssF","g","globalThis","Function","hmd","prop","Symbol","toStringTag","nmd","p","oldGetScript","oldLoadScript","queryMap","countMap","catch","retries","realSrc","location","href","retryAttempt","cacheBust","installedChunks","chunkLoadingGlobal","parentChunkLoadingFunction","moreModules","runtime"],"sourceRoot":""}